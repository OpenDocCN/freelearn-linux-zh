- en: Virtual Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Coming back to this chapter, we will look at the meaning and purpose of **virtual
    memory** (**VM**) and, importantly, why it is a key concept and required one.
    We will cover the meaning and importance of VM, paging and address-translation,
    the benefits of using VM, the memory layout of a process in execution, and the
    internal layout of a process as seen by the kernel. We shall also delve into what
    segments make up the process virtual address space. This knowledge is indispensable
    in difficult-to-debug situations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这一章，我们将探讨**虚拟内存**（**VM**）的含义和目的，以及为什么它是一个关键概念和必需的概念。我们将涵盖VM、分页和地址转换的含义和重要性，使用VM的好处，进程在执行中的内存布局，以及内核所看到的进程的内部布局。我们还将深入探讨构成进程虚拟地址空间的各个段。在难以调试的情况下，这些知识是不可或缺的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Virtual memory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Process virtual address space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程虚拟地址空间
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A modern desktop PC or laptop is required; Ubuntu Desktop specifies the following as recommended
    system requirements for installation and usage of the distribution:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要现代台式机或笔记本电脑；Ubuntu桌面指定以下作为安装和使用发行版的推荐系统要求：
- en: 2 GHz dual core processor or better
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 GHz双核处理器或更好
- en: RAM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM
- en: '**Running on a physical host**: 2 GB or more system memory'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在物理主机上运行**：2 GB或更多系统内存'
- en: '**Running as a guest**: The host system should have at least 4 GB RAM (the
    more, the better and smoother the experience)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为客人运行**：主机系统应至少具有4 GB RAM（越多越好，体验越流畅）'
- en: 25 GB of free hard drive space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 25 GB的空闲硬盘空间
- en: Either a DVD drive or a USB port for the installer media
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装介质需要DVD驱动器或USB端口
- en: Internet access is definitely helpful
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网访问肯定是有帮助的
- en: 'We recommend the reader use one of the following Linux distributions (can be
    installed as a guest OSon a Windows or Linux host system, as mentioned):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议读者使用以下Linux发行版之一（可以安装为Windows或Linux主机系统上的客户操作系统，如前所述）：
- en: Ubuntu 18.04 LTS Desktop (Ubuntu 16.04 LTS Desktop is a good choice too as it
    has long term support as well, and pretty much everything should work)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04 LTS桌面（Ubuntu 16.04 LTS桌面也是一个不错的选择，因为它也有长期支持，并且几乎所有功能都应该可以使用）
- en: Ubuntu Desktop download link: [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu桌面下载链接：[https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)
- en: Fedora 27 (Workstation)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora 27（工作站）
- en: Download link: [https://getfedora.org/en_GB/workstation/download/](https://getfedora.org/en_GB/workstation/download/)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载链接：[https://getfedora.org/en_GB/workstation/download/](https://getfedora.org/en_GB/workstation/download/)
- en: Note that these distributions are, in their default form, OSS and non-proprietary,
    and free to use as an end user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些发行版在其默认形式下是开源的，非专有的，并且作为最终用户可以免费使用。
- en: There are instances where the entire code snippet isn't included in the book
    . Thus the GitHub URL to refer the codes: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时整个代码片段并未包含在书中。因此，GitHub URL 可以参考代码：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: Also, for the further reading section, refer to the preceding GitHub link.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，关于进一步阅读的部分，请参考前面的GitHub链接。
- en: Virtual memory
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Modern operating systems are based on a memory model called VM. This includes
    Linux, Unixes, MS Windows, and macOS. Truly understanding how a modern OS works
    under the hood requires a deep understanding of VM and memory management – not
    topics we delve into in intricate detail in this book; nevertheless, a solid grasp
    of VM concepts is critical for Linux system developers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统基于称为VM的内存模型。这包括Linux、Unix、MS Windows和macOS。要真正理解现代操作系统在底层是如何工作的，需要对VM和内存管理有深入的理解
    - 这些并不是我们在本书中深入讨论的主题；然而，对VM概念的扎实掌握对于Linux系统开发人员至关重要。
- en: No VM – the problem
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有VM - 问题
- en: 'Let''s imagine for a moment that VM, and all the complex baggage it lugs around,
    does not exist. So, we''re working on a (fictional) pure flat physical memory
    platform with, say, 64 MB RAM. This is actually not that unusual – most old OSes
    (think DOS) and even modern **Real-Time Operating Systems** (RTOSes) operate this
    way:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，如果VM以及它携带的所有复杂负担不存在。因此，我们正在使用一个（虚构的）纯平面物理内存平台，比如说，64 MB RAM。这实际上并不那么不寻常
    - 大多数旧的操作系统（比如DOS）甚至现代的**实时操作系统**（RTOS）都是这样运行的：
- en: '![](img/3c80c1e0-d9e3-4f87-8f4a-e887fa0a5ed2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c80c1e0-d9e3-4f87-8f4a-e887fa0a5ed2.png)'
- en: 'Figure 1: Flat physical address space of 64 MB'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：64 MB的平面物理地址空间
- en: 'Obviously, everything that runs on this machine must share this physical memory
    space: the OS, device drivers, libraries, and applications. We might visualize
    it this way (of course, this is not intended to reflect an actual system – it''s
    just a highly simplified example to help you understand things): one OS, several
    device drivers (to drive the hardware peripherals), a set of libraries, and two
    applications. The physical memory map (not drawn to scale) of this fictional (64
    MB system) platform might look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，运行在这台机器上的所有东西都必须共享这个物理内存空间：操作系统、设备驱动程序、库和应用程序。我们可以这样想象（当然，这并不是要反映一个实际的系统
    - 这只是一个极为简化的例子，帮助你理解事情）：一个操作系统，几个设备驱动程序（驱动硬件外围设备），一组库和两个应用程序。这个虚构的（64 MB系统）平台的物理内存映射（比例不准确）可能是这样的：
- en: '| **Object** | **Space taken** | **Address range** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **占用空间** | **地址范围** |'
- en: '| Operating system (OS) | 3 MB | 0x03d0 0000 - 0x0400 0000 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统（OS） | 3 MB | 0x03d0 0000 - 0x0400 0000 |'
- en: '| Device Drivers | 5 MB | 0x02d0 0000 – 0x0320 0000 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 设备驱动程序 | 5 MB | 0x02d0 0000 – 0x0320 0000 |'
- en: '| Libraries | 10 MB | 0x00a0 0000 – 0x0140 0000 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 10 MB | 0x00a0 0000 – 0x0140 0000 |'
- en: '| Application 2 | 1 MB | 0x0010 0000 – 0x0020 0000 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序2 | 1 MB | 0x0010 0000 – 0x0020 0000 |'
- en: '| Application 1 | 0.5 MB | 0x0000 0000 – 0x0008 0000 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序1 | 0.5 MB | 0x0000 0000 – 0x0008 0000 |'
- en: '| Overall Free Memory | 44.5 MB | <various> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 总体空闲内存 | 44.5 MB | <各种> |'
- en: 'Table 1: The physical memory map'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：物理内存映射
- en: 'The same fictional system is represented in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的虚构系统在下图中表示：
- en: '![](img/c2247e5e-1f97-4fd0-8ef7-410a2ccf8b62.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2247e5e-1f97-4fd0-8ef7-410a2ccf8b62.png)'
- en: 'Fig 2: The physical memory map of our fictional 64 MB system'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：我们虚构的64MB系统的物理内存映射
- en: Normally, of course, the system will undergo rigorous testing before release
    and will perform as expected; except, there's this thing you might have heard
    of in our industry called bugs. Yes, indeed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，系统在发布之前会经过严格的测试，并且会按预期运行；除了，我们行业中可能会出现的问题，你可能听说过，叫做bug。是的，确实。
- en: 'But let''s imagine a dangerous bug creeps into Application 1, say, within the
    use of the ubiquitous `memcpy(3)` glibc API, due to either of the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们想象一下，一个危险的bug潜入了Application 1，比如说在使用普遍的`memcpy(3)` glibc API时，由于以下原因之一：
- en: Inadvertent programming errors
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无意的编程错误
- en: Deliberate malicious intent
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故意的恶意意图
- en: 'As a quick reminder, the usage of the `memcpy` library API is shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速提醒，`memcpy`库API的使用如下所示：
- en: '`void *memcpy(void *dest, const void *src, size_t n).`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`void *memcpy(void *dest, const void *src, size_t n).`'
- en: Objective
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: This C program snippet as follows intends to copy some memory, say 1,024 bytes,
    using the usual `memcpy(3)` glibc API, from a source location 300 KB into the
    program to a destination location 400 KB into the program. As Application 1 is
    the program at the low end of physical memory (see the preceding memory map),
    it starts at the `0x0` physical offset.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C程序片段意图使用通常的`memcpy(3)` glibc API复制一些内存，比如说1,024字节，从程序中的源位置300KB到程序中的目标位置400KB。由于Application
    1是物理内存低端的程序（参见前面的内存映射），它从`0x0`物理偏移开始。
- en: We understand that on a modern OS nothing will start at address `0x0`; that's
    the canonical NULL memory location! Keep in mind that this is just a fictional
    example for learning purposes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在现代操作系统上，没有什么会从地址`0x0`开始；那是经典的NULL内存位置！请记住，这只是一个用于学习目的的虚构示例
- en: First, let's see the correct usage case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看正确的使用情况。
- en: 'Refer to the following pseudocode:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下伪代码：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The effect of the preceding code is shown in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的效果如下图所示：
- en: '![](img/abe5252f-75e7-4d7c-bf4a-0aeab82fb356.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abe5252f-75e7-4d7c-bf4a-0aeab82fb356.png)'
- en: 'Fig 3: Zoomed into App 1: the correct memcpy()'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：放大到App 1：正确的memcpy()
- en: As can be seen in the preceding diagram, this works! The (big) arrow shows the
    copy path from source to destination, for 1,024 bytes. Great.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这是有效的！（大）箭头显示了从源到目的地的复制路径，共1,024字节。很好。
- en: Now for the buggy case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看有bug的情况。
- en: 'All remains the same, except that this time, due to a bug (or malicious intent),
    the `dest`pointer is modified as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都一样，只是这一次，由于一个bug（或者恶意意图），`dest`指针被修改如下：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The destination location is now around 64 KB (0x03cf0000 – 0x03d00000) into
    the operating system! The best part: the code itself does not fail*.* `memcpy()`
    does its job. Of course, now the OS is probably corrupted and the entire system
    will (eventually) crash.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目标位置现在大约在64KB（0x03cf0000 - 0x03d00000）进入操作系统！最好的部分是：代码本身并没有失败*。* `memcpy()`完成了它的工作。当然，现在操作系统可能已经损坏，整个系统将（最终）崩溃。
- en: Note that the intent here is not to debug the cause (we know); the intent here
    is to clearly realize that, in spite of this bug, memcpy succeeds.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的意图不是为了调试原因（我们知道）；这里的意图是要清楚地意识到，尽管有这个bug，memcpy仍然成功。
- en: How come? This is because we are programming in C – we are free to read and
    write physical memory as we wish; inadvertent bugs are our problem, not the language's!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这是因为我们在用C语言编程 - 我们可以自由地读写物理内存，任何意外的错误都是我们的问题，而不是语言的问题！
- en: So what now? Ah, this is one of the key reasons why VMsystems came into existence.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那现在呢？啊，这就是VM系统出现的一个关键原因之一。
- en: Virtual memory
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Unfortunately, the term **virtual memory** (**VM**) is often misunderstood or
    hazily understood, at best, by a large proportion of engineers. In this section,
    we attempt to clarify what this term and its associated terminologies (such as
    memory pyramid, addressing, and paging) really mean; it's important for developers
    to clearly understand this key area.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，**虚拟内存**（**VM**）这个术语经常被工程师大部分人误解或模糊地理解。在本节中，我们试图澄清这个术语及其相关术语（如内存金字塔、寻址和分页）的真正含义；开发人员清楚地理解这一关键领域是很重要的。
- en: First, what is a process?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是进程？
- en: A process is an instance of a program in execution*.*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是正在执行的程序的一个实例*。*
- en: 'A program is a binary executable file: a dead, disk object. For example, take
    the `cat` program*:* `$ ls -l /bin/cat`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是一个二进制可执行文件：一个死的、磁盘上的对象。例如，拿`cat`程序来说：`$ ls -l /bin/cat`
- en: '`-rwxr-xr-x 1 root root 36784 Nov 10 23:26 /bin/cat`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`-rwxr-xr-x 1 root root 36784 Nov 10 23:26 /bin/cat`'
- en: '`$`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: When we run `cat` it becomes a live runtime schedulable entity, which, in the
    Unix universe, we call a process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`cat`时，它变成了一个可以运行的实体，我们在Unix宇宙中称之为进程。
- en: 'In order to understand deeper concepts clearly, we start with a small, simple,
    and fictional machine. Imagine it has a microprocessor with 16 address lines.
    Thus, it''s easy to see, it will have access to a total potential memory space
    (or address space) of 2^(16) = 65,536 bytes = 64 KB:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解更深层次的概念，我们从一个小的、简单的、虚构的机器开始。想象一下，它有一个带有16个地址线的微处理器。因此，很容易看出，它将可以访问总共潜在的内存空间（或地址空间）为2^(16)
    = 65,536字节 = 64KB：
- en: '![](img/a8c1b992-8b5e-4242-a6d8-849724f94961.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8c1b992-8b5e-4242-a6d8-849724f94961.png)'
- en: 'Fig 4: Virtual memory of 64 KB'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：64KB的虚拟内存
- en: But what if the physical memory (RAM) on the machine is a lot less, say, 32
    KB?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果机器上的物理内存（RAM）少得多，比如32KB呢？
- en: Clearly, the preceding diagram depicts virtual memory, not physical.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前图描述的是虚拟内存，而不是物理内存。
- en: 'Meanwhile, physical memory (RAM) looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，物理内存（RAM）如下所示：
- en: '![](img/01122e43-c0aa-442b-861e-5f31ad13a0e0.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01122e43-c0aa-442b-861e-5f31ad13a0e0.png)'
- en: 'Fig 5: Physical memory of 32 KB'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：32KB的物理内存
- en: 'Still, the promise made by the system to every process alive: every single
    process will have available to it the entire virtual address space, that is, 64
    KB. Sounds absurd, right? Yes, until one realizes that memory is more than just
    RAM; in fact, memory is viewed as a hierarchy – what''s commonly referred to as
    the memory pyramid:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管系统向每个活动的进程做出了承诺：每个进程都将有整个64KB的虚拟地址空间可用。听起来很荒谬，对吧？是的，直到人们意识到内存不仅仅是RAM；事实上，内存被视为一个层次结构
    - 通常被称为存储金字塔：
- en: '![](img/2ae13549-17b9-41bf-97c9-ec81c261fa88.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae13549-17b9-41bf-97c9-ec81c261fa88.png)'
- en: 'Fig 6: The Memory pyramid'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：存储金字塔
- en: 'As with life, everything''s a trade-off. Toward the apex of the pyramid, we
    gain in **Speed** at the cost of size; toward the bottom of the pyramid, it''s
    inverted: **Size** at the cost of speed. One could also consider CPU registers
    to be at the very apex of the pyramid; as its size is almost insignificant, it
    has not been shown.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活一样，一切都是一种权衡。在金字塔的顶端，我们在**速度**方面获得了优势，但代价是尺寸；在金字塔的底部，情况正好相反：**尺寸**以牺牲速度为代价。人们也可以认为CPU寄存器位于金字塔的顶端；由于其尺寸几乎微不足道，因此没有显示。
- en: '*Swap* is a filesystem type – a raw disk partition is formatted as swap upon
    system installation. It''s treated as second-level RAM by the OS. When the OS
    runs out of RAM, it uses swap. As a rough heuristic, system administrators sometimes
    configure the size of the swap partition to be twice that of available RAM.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*交换*是一种文件系统类型 - 系统安装时，原始磁盘分区被格式化为交换。它被操作系统视为第二级RAM。当操作系统的RAM用完时，它使用交换。作为一个粗略的启发式方法，系统管理员有时会将交换分区的大小配置为可用RAM的两倍。'
- en: 'To help quantify this, according to *Computer Architecture*, *A Quantitative
    Approach*, *5th Ed*, by Hennessy & Patterson, fairly typical numbers follow:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助量化这一点，根据《计算机体系结构，定量方法，第5版》（Hennessy & Patterson）提供了相当典型的数字：
- en: '| **Type** | **CPU registers** | **CPU caches** | **RAM** | **Swap/storage**
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **CPU寄存器** | **CPU缓存** | **RAM** | **交换/存储** |'
- en: '| L1 | L2 | L3 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| L1 | L2 | L3 |'
- en: '| Server | 1000 bytes | 64 KB | 256 KB | 2 - 4 MB | 4 - 16 GB | 4 - 16 TB |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 服务器 | 1000字节 | 64KB | 256KB | 2-4MB | 4-16GB | 4-16TB |'
- en: '| 300 ps | 1 ns | 3 - 10 ns | 10 - 20 ns | 50 - 100 ns | 5 - 10 ms |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 300ps | 1ns | 3-10ns | 10-20ns | 50-100ns | 5-10ms |'
- en: '| Embedded | 500 bytes | 64 KB | 256 KB | - | 256 - 512 MB | 4 - 8 GB Flash
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 嵌入式 | 500字节 | 64KB | 256KB | - | 256-512MB | 4-8GB闪存 |'
- en: '| 500 ps | 2 ns | 10 - 20 ns | - | 50 - 100 ns | 25 - 50 us |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 500ps | 2ns | 10-20ns | - | 50-100ns | 25-50us |'
- en: 'Table 2: Memory hierarchy numbers'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：存储器层次结构数字
- en: 'Many (if not most) embedded Linux systems do not support a swap partition;
    the reason is straightforward: embedded systems mostly use flash memory as the
    secondary storage medium (not a traditional SCSI disk as do laptops, desktops,
    and servers). Writing to a flash chip wears it out (it has limited erase-write
    cycles); hence, embedded-system designers would rather sacrifice swap and just
    use RAM. (Please note that the embedded system can still be VM-based, which is
    the usual case with Linux and Win-CE, for example).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（如果不是大多数）嵌入式Linux系统不支持交换分区；原因很简单：嵌入式系统主要使用闪存作为辅助存储介质（而不是像笔记本电脑、台式机和服务器那样使用传统的SCSI磁盘）。写入闪存芯片会使其磨损（它有限制的擦写周期）；因此，嵌入式系统设计者宁愿牺牲交换，只使用RAM。（请注意，嵌入式系统仍然可以是基于虚拟内存的，这在Linux和Win-CE等系统中是常见情况）。
- en: The OS will do its best to keep the working set of pages as high up the pyramid
    as is possible, optimizing performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将尽最大努力将页面的工作集保持在尽可能高的金字塔位置，以优化性能。
- en: It's important for the reader to note that, in the sections that follow, while
    this book attempts to explain some of the inner workings of advanced topics such
    as VM and addressing (paging), we quite deliberately do not paint a complete,
    realistic, real-world view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 读者需要注意，在接下来的章节中，虽然本书试图解释一些高级主题的内部工作，比如虚拟内存和寻址（分页），但我们故意没有描绘完整、真实世界的视图。
- en: 'The reason is straightforward: the deep and gory technical details are well
    beyond the scope of this book. So, the reader should keep in mind that several
    of the following areas are explained in concept and not in actuality. The *Further
    reading* section provides references for readers who are interested in going deeper
    into these matters. Refer it on the GitHub repository.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：深入和血腥的技术细节远远超出了本书的范围。因此，读者应该记住，以下几个领域中的一些是以概念而不是实际情况来解释的。*进一步阅读*部分提供了对这些问题感兴趣的读者的参考资料。请在GitHub存储库上查看。
- en: Addressing 1 – the simplistic flawed approach
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻址1 - 简单的有缺陷的方法
- en: 'Okay, now to the memory pyramid; even if we agree that virtual memory is now
    a possibility, a key and difficult hurdle to overcome remains. To explain this,
    note that every single process that is alive will occupy the entire available
    **virtual address space** (**VAS**). Thus, each process overlaps with every other
    process in terms of VAS. But how would this work? It wouldn''t, by itself. In
    order for this elaborate scheme to work, the system has to somehow map every virtual
    address in every process to a physical address! Refer to the following mapping
    of virtual address to physical address:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在来看看存储金字塔；即使我们同意虚拟内存现在是可能的，一个关键且困难的障碍仍然存在。要解释这一点，请注意，每个活动的进程都将占用整个可用的虚拟地址空间（VAS）。因此，每个进程在VAS方面与其他每个进程重叠。但这会怎么样？它本身不会。为了使这个复杂的方案工作，系统必须以某种方式将每个进程中的每个虚拟地址映射到物理地址！参考以下虚拟地址到物理地址的映射：
- en: '**Process P:virtual address (va) → RAM:physical address (pa)**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程P：虚拟地址（va）→ RAM：物理地址（pa）**'
- en: 'So, the situation is something like this now:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在的情况是这样的：
- en: '![](img/22cf8ed4-3660-4494-9bb3-cbb3b2281b94.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22cf8ed4-3660-4494-9bb3-cbb3b2281b94.png)'
- en: 'Fig 7: Processes containing virtual addresses'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：包含虚拟地址的进程
- en: Processes **P1**, **P2**, and **Pn**, are alive and well in VM. Their virtual
    address spaces cover 0 to 64 KB and overlap each other. Physical memory, RAM,
    of 32 KB is present on this (fictional) system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进程P1、P2和Pn在虚拟内存中活跃。它们的虚拟地址空间覆盖0到64KB，并相互重叠。在这个（虚构的）系统上存在32KB的物理内存RAM。
- en: 'As an example, two virtual addresses for each process are shown in the following
    format:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个进程的两个虚拟地址以以下格式显示：
- en: '**`P''r'':va''n''`**; where `r` is the process number and `n` is 1 and 2.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`P''r'':va''n''`；其中`r`是进程编号，`n`是1和2。'
- en: 'As mentioned earlier, the key now is to map each process''s virtual addresses
    to physical addresses. So, we need to map the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，现在的关键是将每个进程的虚拟地址映射到物理地址。因此，我们需要映射以下内容：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could have the OS perform this mapping; the OS would then maintain a mapping
    table per process to do so. Diagrammatically and conceptually it looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让操作系统执行这种映射；然后操作系统将维护每个进程的映射表来执行此操作。从图解和概念上看，它如下所示：
- en: '![](img/a7af066e-5f21-4d90-8aee-d155b5ed2b09.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7af066e-5f21-4d90-8aee-d155b5ed2b09.png)'
- en: 'Fig 8: Direct mapping virtual addresses to physical RAM addresses'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：将虚拟地址直接映射到物理RAM地址
- en: 'So that''s it, then? Seems quite simple, actually. Well, no, it won''t work
    in reality: to map all the possible virtual addresses per process to physical
    addresses in RAM, the OS would need to maintain a **va**-to-**pa** translation
    entry per address per process! That''s too expensive, as each table would possibly
    exceed the size of physical memory, rendering the scheme useless.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那就这样了？实际上似乎相当简单。嗯，不，实际上不会这样：要将每个进程的所有可能的虚拟地址映射到RAM中的物理地址，操作系统需要维护每个地址每个进程的va-to-pa翻译条目！这太昂贵了，因为每个表可能会超过物理内存的大小，使该方案无用。
- en: 'A quick calculation reveals that we have 64KB virtual memory, that is, 65,536
    bytes or addresses. Each of these virtual addresses need to be mapped to a physical
    address. So each process would require:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 快速计算表明，我们有64KB的虚拟内存，即65,536字节或地址。这些虚拟地址中的每一个都需要映射到一个物理地址。因此，每个进程都需要：
- en: 65536 * 2 = 131072 = 128 KB, for a mapping table. per process.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 65536 * 2 = 131072 = 128 KB，用于每个进程的映射表。
- en: 'It gets worse in reality; the OS would need to store some metadata along with
    each address-translation entry; let''s say 8 bytes of metadata. So now, each process
    would require:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况更糟糕；操作系统需要存储一些元数据以及每个地址转换条目；假设8字节的元数据。所以现在，每个进程都需要：
- en: 65536 * 2 * 8 = 1048576 = 1 MB, for a mapping table. per process.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 65536 * 2 * 8 = 1048576 = 1 MB，用于每个进程的映射表。
- en: Wow, 1 megabyte of RAM per process! That's far too much (think of an embedded
    system); also, on our fictional system, there's a total of 32 KB of RAM. Whoops.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，每个进程需要1兆字节的RAM！这太多了（想象一下嵌入式系统）；而且在我们的虚构系统中，总共只有32KB的RAM。哎呀。
- en: 'Okay, we can reduce this overhead by not mapping each byte but mapping each
    word; say, 4 bytes to a word. So now, each process would require:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以通过不映射每个字节而映射每个字来减少这种开销；比如，将4个字节映射到一个字。所以现在，每个进程都需要：
- en: (65536 * 2 * 8) / 4 = 262144 = 256 KB, for a mapping table. per process.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （65536 * 2 * 8）/ 4 = 262144 = 256 KB，用于每个进程的映射表。
- en: Better, but not good enough. If there are just 20 processes alive, we'd require
    5 MB of physical memory to store just the mapping metadata. With 32 KB of RAM,
    we can't do that.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更好，但还不够好。如果只有20个进程在运行，我们需要5MB的物理内存来存储映射元数据。在32KB的RAM中，我们做不到这一点。
- en: Addressing 2 – paging in brief
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址2-简要分页
- en: 'To address (pun intended) this tricky issue, computer scientists came up with
    a solution: do not attempt to map individual virtual bytes (or even words) to
    their physical counterpart; it''s far too expensive. Instead, carve up both physical
    and virtual memory space into blocks and map them.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个棘手的问题，计算机科学家提出了一个解决方案：不要试图将单个虚拟字节（甚至单词）映射到它们的物理对应物；这太昂贵了。相反，将物理和虚拟内存空间分割成块并进行映射。
- en: 'A bit simplistically, there are broadly two ways to do this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种广义的方法来做到这一点：
- en: Hardware-segmentation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件分段
- en: Hardware-paging
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件分页
- en: '**Hardware-segmentation:** Carves up the virtual and physical address space
    into arbitrary-sized chunks called **segments**. The best example is Intel 32-bit
    processors.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件分段：将虚拟和物理地址空间分割成称为段的任意大小块。最好的例子是英特尔32位处理器。
- en: '**Hardware-paging:** Carves up the virtual and physical address space into
    equal-sized chunks called **pages**. Most real-world processors support hardware-paging,
    including Intel, ARM, PPC, and MIPS.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件分页：将虚拟和物理地址空间分割成称为页面的等大小块。大多数现实世界的处理器都支持硬件分页，包括英特尔、ARM、PPC和MIPS。
- en: 'Actually it''s not even up to the OS developer to select which scheme to use:
    the choice is dictated by the hardware MMU.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，甚至不是由操作系统开发人员选择使用哪种方案：选择由硬件MMU决定。
- en: 'Again, we remind the reader: the intricate details are beyond the scope of
    this book. See the *Further reading* section on the GitHub repository.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒读者：这本书的复杂细节超出了范围。请参阅GitHub存储库上的“进一步阅读”部分。
- en: Let's assume we go with the paging technique. The key takeaway is that we stop
    attempting to map all possible virtual addresses per process to physical addresses
    in RAM, instead, we map virtual pages (just called pages) to physical pages (called
    page frames).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们采用分页技术。关键要点是，我们停止尝试将每个进程的所有可能的虚拟地址映射到RAM中的物理地址，而是将虚拟页（称为页）映射到物理页（称为页框）。
- en: Common Terminology
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 常见术语
- en: '**virtual address space** : **VAS**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址空间：VAS
- en: 'Virtual page within the process VAS : page'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 进程VAS中的虚拟页：页
- en: 'Physical page in RAM : **page frame** (**pf**)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: RAM中的物理页：页框（pf）
- en: 'Does NOT work: **virtual address** (**va**) → **physical address** (**pa**)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不起作用：虚拟地址（va）→物理地址（pa）
- en: 'Does work: (virtual) page → page frame'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 起作用：（虚拟）页→页框
- en: The left-to-right arrow represents the mapping.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 左到右的箭头表示映射。
- en: As a rule of thumb (and the generally accepted norm), the size of a page is
    4 kilobytes (4,096 bytes). Again, it's the processor **Memory Management Unit**
    (**MMU**) that dictates the page size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则（和通常被接受的规范），页面的大小为4千字节（4,096字节）。再次强调，是处理器的内存管理单元（MMU）决定页面的大小。
- en: So how and why does this scheme help?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这种方案如何以及为什么有帮助呢？
- en: 'Think about it for a moment; in our fictional machine, we''ve got: 64 KB of
    VM, that is, 64K/4K =  16 pages, and 32 KB of RAM, that is, 32K/4K = 8 page frames.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想；在我们的虚构机器中，我们有：64 KB的虚拟内存，即64K/4K =  16页，和32 KB的RAM，即 32K/4K = 8页帧。
- en: Mapping 16 pages to corresponding page frames requires a table of only 16 entries
    per process; this is viable!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将16页映射到相应的页面帧需要每个进程只有16个条目的表；这是可行的！
- en: 'As in our earlier calculations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的计算一样：
- en: 16 * 2 * 8 = 256 bytes, for a mapping table per process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 16 * 2 * 8 = 256字节，每个进程的映射表。
- en: The very important thing, it bears repeating: we map (virtual) pages to (physical)
    page frames!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点，值得重复：我们将（虚拟）页映射到（物理）页面帧！
- en: 'This is done by the OS on a per-process basis. Thus, each process has its own
    mapping table that translates pages to page frames at runtime; it''s commonly
    called the **Paging Table** (**PT**):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由操作系统基于每个进程进行的。因此，每个进程都有自己的映射表，用于在运行时将页面转换为页面帧；通常称为**分页表**（**PT**）：
- en: '![](img/051c43fb-a2e3-4f6b-8fa6-72d8dfe5f411.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/051c43fb-a2e3-4f6b-8fa6-72d8dfe5f411.png)'
- en: 'Fig 9: Mapping (virtual) pages to (physical) page frames'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：将（虚拟）页映射到（物理）页面帧
- en: Paging tables – simplified
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页表--简化
- en: 'Again, in our fictional machine, we''ve got: 64 KB of VM, that is, 64K/4K =
    16 pages, and 32 KB of RAM, that is, 32K/4K = 8 page frames.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在我们的虚构机器中，我们有：64 KB的虚拟内存，即64K/4K = 16页，和32 KB的RAM，即32K/4K = 8页帧。
- en: Mapping the 16 (virtual) pages to corresponding (physical) page frames requires
    a table of only 16 entries per process, which makes the whole deal viable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将16个（虚拟）页映射到相应的（物理）页面帧只需要每个进程一个只有16个条目的表，这使得整个交易可行。
- en: 'Very simplistically, the OS-created PT of a single process look as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单地说，单个进程的操作系统创建的页表如下所示：
- en: '| **(Virtual) page** | **(Physical) page frame** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **（虚拟）页** | **（物理）页面帧** |'
- en: '| `0` | `3` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `3` |'
- en: '| `1` | `2` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `2` |'
- en: '| `2` | `5` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `5` |'
- en: '| `[...]` | `[...]` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `[...]` | `[...]` |'
- en: '| `15` | `6` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `15` | `6` |'
- en: 'Table 3: OS-created PT'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：操作系统创建的页表
- en: 'Of course, the astute reader will notice that we have a problem: we''ve got
    16 pages and just eight page frames to map them into – what about the remaining
    eight pages?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，敏锐的读者会注意到我们有一个问题：我们有16页，只有8页帧可以映射到它们中--剩下的八页怎么办？
- en: 'Well, consider this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，考虑一下：
- en: In reality, every process will not use every available page for code or data
    or whatever; several regions of the virtual address space will remain empty (sparse),
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，每个进程都不会使用每个可用的页面来存储代码或数据或其他内容；虚拟地址空间的几个区域将保持空白（稀疏），
- en: 'Even if we do require it, we have a way: don''t forget the memory pyramid.
    When we''re out of RAM, we use swap. So the (conceptual) PT for a process might
    appear like this (as an example, pages 13 and 14 are residing in swap):'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们需要它，我们也有办法：不要忘记内存金字塔。当我们用完RAM时，我们使用交换。因此，进程的（概念性）页表可能如下所示（例如，页面13和14驻留在交换中）：
- en: '| **(Virtual) page** | **(Physical) page frame** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **（虚拟）页** | **（物理）页面帧** |'
- en: '| `0` | `3` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `3` |'
- en: '| `1` | `2` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `2` |'
- en: '| `2` | `5` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `5` |'
- en: '| `[...]` | `[...]` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `[...]` | `[...]` |'
- en: '| `13` | `<swap-address>` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `13` | `<交换地址>` |'
- en: '| `14` | `<swap-address>` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `14` | `<交换地址>` |'
- en: '| `15` | `6` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `15` | `6` |'
- en: 'Table 4: Conceptual PT'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：概念性页表
- en: Again, please note that this description of PTs is purely conceptual; actual
    PTs are more complex and highly arch (CPU/MMU) dependent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些页表的描述纯粹是概念性的；实际的页表更复杂，且高度依赖于体系结构（CPU/MMU）。
- en: Indirection
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接
- en: 'By introducing paging, we have actually introduced a level of indirection:
    we no longer think of a (virtual) address as an absolute offset from zero, but
    rather as a relative quantity: `va = (page, offset)`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入分页，我们实际上引入了一级间接：我们不再将（虚拟）地址视为从零的绝对偏移，而是作为相对数量：`va = (page, offset)`。
- en: We think of each virtual address as associated with a page number and an offset
    from the beginning of that page. This is called using one level of indirection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个虚拟地址视为与页号和从该页开头的偏移相关联。这被称为使用一级间接。
- en: So each time a process refers to a virtual address (and of course, note that
    this is happening almost all of the time), the system must translate the virtual
    address to the corresponding physical address based on the PTs for that process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当进程引用虚拟地址时（当然，几乎一直在发生），系统必须根据该进程的页表将虚拟地址转换为相应的物理地址。
- en: Address-translation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址转换
- en: 'So, at runtime, the process looks up a virtual address which is, say, 9,192
    bytes from 0, that is, its virtual address: **`va = 9192 = 0x000023E8`**. If each
    page is 4,096 bytes in size, this implies the va address is on the third page
    (page #2), at an offset of 1,000 bytes from the start of that page.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在运行时，进程查找一个虚拟地址，比如说，距离0有9,192字节，也就是说，它的虚拟地址：**`va = 9192 = 0x000023E8`**。如果每页大小为4,096字节，这意味着 va 地址在第三页（第2页），从该页的开头偏移1,000字节。
- en: 'So, with one level of indirection, we have: **`va = (page, offset) = (2, 1000)`**.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过一级间接，我们有：**`va = (page, offset) = (2, 1000)`**。
- en: 'Aha! Now we can see how address-translation works: the OS sees that the process
    wants an address in page 2\. It does a lookup on the PT for that process, and
    finds that page 2 maps to page frame 5\. To calculate the physical address shown
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！现在我们可以看到地址转换是如何工作的：操作系统看到进程想要一个地址在第2页。它在该进程的页表上查找，并发现第2页映射到第5页帧。计算如下所示的物理地址：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Voila!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: The system now places the physical address on the bus and the CPU performs its
    work as usual. It looks quite simple, but again, it's not realistic—please see
    the information box as follows as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 系统现在将物理地址放在总线上，CPU像往常一样执行其工作。看起来很简单，但再次强调，这并不现实，请参见下面的信息框。
- en: Another advantage gained by the paging schema is the OS only needs to store
    a page-to-page-frame mapping. This automatically lets us translate any byte in
    the page to the corresponding physical byte in the page frame by just adding the
    offset, as there is a 1:1 mapping between a page and a page frame (both are of
    identical size).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 分页模式带来的另一个优势是，操作系统只需要存储页到页框的映射。这自动让我们能够通过添加偏移量将页面中的任何字节转换为页面框中对应的物理字节，因为页面和页面框之间存在一对一的映射（两者大小相同）。
- en: In reality, it's not the OS that does the actual calculations to perform address-translation.
    This is because doing this in the software would be far too slow (remember, looking
    up virtual addresses is an ongoing activity happening almost all the time). The
    reality is that the address lookup and translation is done by silicon – the hardware **Memory
    Management Unit** (**MMU**) within the CPU!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，执行地址转换的并不是操作系统。这是因为在软件中执行这个操作会太慢（记住，查找虚拟地址是一个几乎一直在进行的活动）。事实是，地址查找和转换是由硅片——CPU内的硬件**内存管理单元**（MMU）来完成的！
- en: 'Keep the following in mind:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记住以下几点：
- en: • The OS is responsible for creating and maintaining PTs for each process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: • 操作系统负责为每个进程创建和维护页表。
- en: • The MMU is responsible for performing runtime address-translation (using the
    OS PTs).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: • MMU负责执行运行时地址转换（使用操作系统的页表）。
- en: • Beyond this, modern hardware supports hardware accelerators, such as the TLB,
    use of CPU caches, and virtualization extensions, which go a long way toward getting
    decent performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: • 此外，现代硬件支持硬件加速器，如TLB、CPU缓存的使用和虚拟化扩展，这在很大程度上有助于获得良好的性能。
- en: Benefits of using VM
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟内存的好处
- en: 'At first glance, the sheer overhead introduced due to virtual memory and the
    associated address-translation would seem to warrant not using it. Yes, the overhead
    is high, but the reality is given as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，由于虚拟内存和相关的地址转换引入的巨大开销似乎不值得使用它。是的，开销很大，但事实如下：
- en: Modern hardware-acceleration (via TLBs/CPU caches/prefetching) mitigates this
    overhead and provides decent enough performance
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代硬件加速（通过TLB/CPU缓存/预取）减轻了这种开销，并提供了足够的性能。
- en: The benefits one derives from VM outweigh the performance issues
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从虚拟内存中获得的好处超过了性能问题。
- en: 'On a VM-based system, we get the following benefits:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于虚拟内存的系统上，我们获得以下好处：
- en: Process-isolation
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程隔离
- en: The programmer need not worry about physical memory
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员不需要担心物理内存
- en: Memory-region protection
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域保护
- en: It's important to understand these a bit better.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解这些是很重要的。
- en: Process-isolation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程隔离
- en: 'With virtual memory, every process runs inside a sandbox, which is the extent
    of its VAS. The key rule: it cannot look outside the box.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有了虚拟内存，每个进程都在一个沙盒中运行，这是它的虚拟地址空间的范围。关键规则：它不能窥视到盒子外面。
- en: So, think about it, it's impossible for a process to peek or poke the memory
    of any other process's VAS. This helps in making the system secure and stable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想想看，一个进程不可能窥视或篡改任何其他进程的虚拟地址空间的内存。这有助于使系统安全稳定。
- en: 'Example: we have two processes, A and B. Process A wants to write to the `0x10ea` virtual
    address in process B. It cannot, even if it attempts to write to that address,
    all it''s really doing is writing to its own virtual address, `0x10ea`! The same
    goes for reading.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：我们有两个进程A和B。进程A想要写入进程B中的虚拟地址`0x10ea`。它不能，即使它试图写入该地址，它实际上只是写入自己的虚拟地址`0x10ea`！读取也是一样的。
- en: So we get process-isolation – each process is completely isolated from every
    other process.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们得到了进程隔离——每个进程完全与其他进程隔离。
- en: Virtual address X for process A is not the same as virtual address X for process
    B; in all likelihood, they translate to different physical addresses (via their
    PTs).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进程A的虚拟地址X来说，它与进程B的虚拟地址X并不相同；很可能它们会通过它们的页表转换为不同的物理地址。
- en: 'Exploiting this property, the Android system is designed to very deliberately
    use the process model for Android apps: when an Android app is launched, it becomes
    a Linux process, which lives within its own VAS, isolated and thus protected from
    other Android apps (processes)!'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这一特性，Android系统被设计得非常有意识地使用进程模型来进行Android应用程序：当一个Android应用程序启动时，它成为一个Linux进程，它存在于自己的虚拟地址空间中，被隔离并因此受到保护，不受其他Android应用程序（进程）的影响！
- en: Again, don't make the mistake of assuming that every single (virtual) page within
    a given process is valid for that process itself. A page is only valid if it's
    mapped, that is, it's been allocated and the OS has a valid translation for it
    (or a way to get to it). In fact, and especially true for the enormous 64-bit
    VAS, the process virtual address space is considered to be sparse, that is, scanty.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，不要误以为给定进程中的每个（虚拟）页面都对该进程本身有效。只有在映射了页面的情况下，页面才是有效的，也就是说，它已经被分配并且操作系统对它有有效的转换（或者有办法获取它）。事实上，特别是对于庞大的64位虚拟地址空间，进程的虚拟地址空间被认为是稀疏的。
- en: 'If process-isolation is as described, then what if process A needs to talk
    to process B? Indeed, this is a frequent design requirement for many, if not most,
    real Linux applications – we need some mechanism(s) to be able to read/write the
    VAS of another process. Modern OSes provide mechanisms to achieve this: **Inter-Process
    Communication** (**IPC**) mechanisms. (A little on IPC can be found in [Chapter
    15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading with Pthreads
    Part II - Synchronization.*)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程隔离是如此描述的，那么如果进程A需要与进程B通信会怎样呢？实际上，这是许多真实的Linux应用程序的频繁设计要求——我们需要一些机制来能够读取/写入另一个进程的虚拟地址空间。现代操作系统提供了实现这一点的机制：**进程间通信**（IPC）机制。（有关IPC的简要介绍可以在[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)中找到，*使用Pthreads进行多线程编程第二部分-同步*。）
- en: The programmer need not worry about physical memory
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序员不需要担心物理内存
- en: On older OSes and even modern RTOSes, the programmer is expected to understand
    the memory layout of the entire system in detail and use memory accordingly (recall
    *Fig 1*). Obviously, this places a major burden on the developer; they have to
    ensure that they work well within the physical constraints of the system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的操作系统甚至现代的实时操作系统中，程序员需要详细了解整个系统的内存布局，并相应地使用内存（回想一下*图1*）。显然，这给开发人员带来了很大的负担；他们必须确保他们在系统的物理限制内工作良好。
- en: 'Most modern developers working on modern OSes never even think this way: if
    we want, say, 512 Kb of memory, do we not just allocate it dynamically (with `malloc(3)`,
    seen later in detail in [Chapter 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml),
    *Dynamic Memory Allocation*), leaving the precise details of how and where it''s
    done to the library and OS layers? In fact, we can do this kind of thing dozens
    of times and not worry about stuff such as, "Will there be enough physical RAM?
    Which physical page frames should be used? What about fragmentation/wastage?"'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在现代操作系统上工作的现代开发人员甚至从不这样思考：如果我们想要，比如说，512 Kb的内存，我们不是只需动态分配它（使用`malloc(3)`，稍后在[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)中详细介绍，*动态内存分配*），将如何和在哪里完成的精确细节留给库和操作系统层？事实上，我们可以做这种事情数十次而不必担心诸如“是否有足够的物理RAM？应该使用哪些物理页框？碎片化/浪费怎么办？”之类的问题。
- en: We get the added benefit that the memory returned to us by the system is guaranteed
    to be contiguous; of course, it's just virtually contiguous, it need not be physically
    contiguous, but that kind of detail is exactly what the VM layers take care of!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的额外好处是系统返回给我们的内存是保证连续的；当然，它只是虚拟连续的，不一定是物理上连续的，但这种细节正是虚拟内存层要处理的！
- en: All is handled, really efficiently, by the library layer and the underlying
    memory-management system in the OS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都由库层和操作系统中的底层内存管理系统高效处理。
- en: Memory-region protection
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域保护
- en: 'Perhaps the most important benefit of VM is this: the ability to define protections
    on virtual memory and have them honored by the OS.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 也许VM最重要的好处就是：能够在虚拟内存上定义保护，并且这些保护会被操作系统遵守。
- en: 'Unix and friends (including Linux), allow four protection or permission values
    on memory pages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Unix和其它类似系统（包括Linux），允许在内存页面上有四个保护或权限值：
- en: '| **Protection or permission type** | **Meaning** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **保护或权限类型** | **意义** |'
- en: '| None | No permission to do anything on the page |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 无权限在页面上执行任何操作 |'
- en: '| Read | Page can be read from |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | 页面可以读取 |'
- en: '| Write | Page can be written to |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 写入 | 页面可以写入 |'
- en: '| Execute | Page (code) can be executed |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | 页面（代码）可以执行 |'
- en: Table 5:  Protection or permission values on memory pages
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表5：内存页面上的保护或权限值
- en: 'Let''s consider a small example: we allocate four pages of memory in our process
    (numbered 0 to 3). By default, the default permission or protections on the pages
    is **RW** (**Read-Write**), which means the pages can be both read from and written
    to.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们考虑一个小例子：我们在我们的进程中分配了四个页面的内存（编号为0到3）。默认情况下，页面的默认权限或保护是**RW**（**读-写**），这意味着页面既可以读取又可以写入。 '
- en: 'With virtual memory OS-level support, the OS exposes APIs (the `mmap(2)` and
    `mprotect(2)` system calls) with which one can change the default page protections! Kindly
    take a look at the following table:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有了虚拟内存操作系统级别的支持，操作系统提供了API（`mmap(2)`和`mprotect(2)`系统调用），可以更改默认的页面保护！请看下表：
- en: '| **Memory page #** | **Default protections** | **Changed protections** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **内存页＃** | **默认保护** | **更改后的保护** |'
- en: '| 0 | RW- | -none- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 0 | RW- | -无- |'
- en: '| 1 | RW- | Read-only (R--) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 1 | RW- | 只读（R--）|'
- en: '| 2 | RW- | Write-only (-W-) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 2 | RW- | 仅写入（-W-）|'
- en: '| 3 | RW- | Read-Execute (R-X) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 3 | RW- | 读取-执行（R-X）|'
- en: With powerful APIs such as this, we can set memory protections to the granularity
    of a single page!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样强大的API，我们可以将内存保护设置到单个页面的粒度！
- en: 'Applications (and indeed the OS) can, and do, leverage these powerful mechanisms;
    in fact, that''s precisely what is done on particular regions of process address
    space by the OS (as we''ll learn in the next section, *SIDEBAR :: Testing the
    memcpy() ''C'' program*).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序（甚至操作系统）可以利用这些强大的机制；事实上，这正是操作系统在进程地址空间的特定区域所做的（正如我们将在下一节学到的那样，*侧边栏::测试memcpy()
    'C'程序*）。
- en: 'Okay, fine, we can set certain protections on certain pages, but what if an
    application disobeys them? For example, after setting page #3 (as seen in the
    preceding table) to read-execute, what if the app (or OS) attempts to write to
    that page?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，我们可以在某些页面上设置某些保护，但是如果应用程序违反了它们怎么办？例如，在设置页面＃3（如前表所示）为读取-执行后，如果应用程序（或操作系统）尝试写入该页面会怎样？
- en: 'This is where the real power of virtual memory (and memory management) is seen:
    the reality is that on a VM-enabled system, the OS – more realistically, the MMU –
    is able to trap into every single memory access and determine whether the end
    user process is obeying the rules or not. If it is, the access proceeds successfully;
    if not, the MMU hardware raises an exception (similar, but not identical, to an
    interrupt). The OS now jumps into a code routine called the exception (or fault)
    handler. The OSes exception-handling routine determines whether the access is
    indeed illegal, and if so, the OS immediately kills the process attempting this
    illegal access.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是虚拟内存（和内存管理）的真正威力所在：事实上，在启用了虚拟内存的系统上，操作系统（更确切地说是MMU）能够陷入每个内存访问，并确定最终用户进程是否遵守规则。如果是，访问将成功进行；如果不是，MMU硬件会引发异常（类似但不完全相同于中断）。操作系统现在会跳转到一个称为异常（或故障）处理程序的代码例程。操作系统的异常处理例程确定访问是否确实非法，如果是，操作系统立即终止尝试进行此非法访问的进程。
- en: How's that for memory protection? In fact, this is pretty much exactly what
    a Segmentation Violation or segfault is; more on this in [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - Part II*. The exception-handler routine is called the OSes fault-handler.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是内存保护吗？事实上，这几乎就是段错误或段错误的定义；在[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中会更详细地介绍这一点，*信号-第二部分*。异常处理例程称为操作系统的故障处理程序。
- en: 'SIDEBAR :: Testing the memcpy() C program'
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏：测试`memcpy()` C程序
- en: 'Now that we better understand the what and why of a VM system, let''s go back
    to the buggy pseudocode example we considered at the beginning of this chapter:
    the case where we used `memcpy(3)` to copy some memory but specified the wrong
    destination address (and it would have overwritten the OS itself in our fictional
    physical-memory-only system).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更好地理解了虚拟内存系统的*什么*和*为什么*，让我们回到本章开头考虑的有bug的伪代码示例：我们使用`memcpy(3)`来复制一些内存，但指定了错误的目标地址（在我们虚构的仅物理内存的系统中，它会覆盖操作系统本身）。
- en: 'A conceptually similar C program, but which runs on Linux—a full-fledged virtual-memory-enabled
    OS—is shown and tried out here. Let''s see how the buggy program works on Linux:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在Linux上运行的概念上类似的C程序，一个完整的虚拟内存启用的操作系统，被展示并在这里尝试。让我们看看这个有bug的程序在Linux上是如何工作的：
- en: '[PRE4]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `malloc(3)` API will be covered in detail in the next chapter; for now,
    just understand that it is used to dynamically allocate 256 KB of memory to the
    process. Also, of course, `memcpy(3)` is used to copy memory from a source to
    a destination pointer, for n bytes:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)` API将在下一章中详细介绍；现在，只需了解它用于为进程动态分配256 KB的内存。当然，`memcpy(3)`也用于将内存从源指针复制到目标指针，共n个字节：'
- en: '[PRE5]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The interesting part is that we have a variable called `arbit_addr`; it's set
    to an arbitrary invalid (virtual) address. As you can see from the code, we set
    the destination pointer to `arbit_addr` when the user passes any argument to the
    program, making it the buggy test case. Let's try running the program for both
    the correct and buggy cases.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '有趣的是我们有一个名为`arbit_addr`的变量；它被设置为一个任意的无效（虚拟）地址。从代码中可以看出，当用户向程序传递任何参数时，我们将目标指针设置为`arbit_addr`，从而使其成为有bug的测试用例。让我们尝试运行这个程序，看看正确和错误的情况。 '
- en: 'Here is the correct case:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的情况：
- en: '[PRE6]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It runs fine, with no errors.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行良好，没有错误。
- en: 'Here is the buggy case:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的情况：
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It crashes! As described earlier, the buggy memcpy causes the MMU to fault;
    the OSes fault-handling code realizes that this is indeed a bug and it kills the
    offending process! The process dies because it's at fault, not the system. Not
    only is this correct, the segfault caused also alerts the developer to the fact
    that their code is buggy and must be fixed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它崩溃了！正如前面所述，有bug的memcpy导致MMU出现故障；操作系统的故障处理代码意识到这确实是一个bug，于是杀死了有问题的进程！进程死于自己的过错，而不是系统的过错。这不仅是正确的，而且*段错误*也提醒开发人员他们的代码有bug，必须修复。
- en: 1\. What's a core dump anyway?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 到底什么是核心转储？
- en: A core dump is a snapshot of certain dynamic regions (segments) of the process
    at the time it crashed (technically, it's a snapshot of minimally the data and
    stack segments). The core dump can be analyzed postmortem using debuggers such
    as GDB. We do not cover these areas in this book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 核心转储是进程在崩溃时某些动态区域（段）的快照（从技术上讲，至少是数据和堆栈段的快照）。核心转储可以在崩溃后使用诸如GDB之类的调试器进行分析。我们在本书中不涵盖这些领域。
- en: 2\. Hey, it says (core dumped) but I don't see any core file?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 嘿，它说（核心已转储），但我没有看到任何核心文件？
- en: Well, there can be several reasons why the core file isn't present; the details
    lie beyond the scope of this book. Please refer to the man page on `core(5)` for
    details: [https://linux.die.net/man/5/core](https://linux.die.net/man/5/core).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，为什么没有核心文件呢？这可能有几个原因，细节超出了本书的范围。请参考`core(5)`的man页面获取详细信息：[https://linux.die.net/man/5/core](https://linux.die.net/man/5/core)。
- en: 'Think about what has happened here in a bit more detail: the destination pointer''s
    value is `0xffffffffff601000;` on the x86_64 processor, this is actually a kernel
    virtual address. Now we, a user mode process, are trying to write some memory
    to this destination region, which is protected against access from userspace.
    Technically, it''s in the kernel virtual address space, which is not available
    to user mode processes (recall our discussion of *CPU privilege levels* in [Chapter
    1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System Architecture*).
    So when we – a user mode process – attempt to write to kernel virtual address
    space, the protection mechanism spins up and prevents us from doing this, killing
    us in the bargain.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微详细地考虑一下这里发生了什么：目标指针的值是`0xffffffffff601000;`在x86_64处理器上，这实际上是一个内核虚拟地址。现在我们，一个用户模式进程，试图向这个目标区域写入一些内存，这个区域受到了来自用户空间的访问保护。从技术上讲，它位于内核虚拟地址空间，这对用户模式进程不可用（回想一下我们在[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中对*CPU特权级别*的讨论，*Linux系统架构*）。所以当我们——一个用户模式进程——试图写入内核虚拟地址空间时，保护机制会启动并阻止我们这样做，从而导致我们死亡。
- en: 'Advanced: How does the system know that this region is protected and what kind
    of protection it has? These details are encoded into the **Paging Table Entry**
    (**PTEs**) for the process, and are checked by the MMU on every access!'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 高级：系统如何知道这个区域受到保护以及它有什么样的保护？这些细节被编码到进程的**分页表项**（**PTEs**）中，并且在每次访问时由MMU进行检查！
- en: 'This kind of advanced memory protection would be impossible without support
    in both hardware and software:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种高级内存保护在硬件和软件中都没有支持是不可能的：
- en: Hardware support via the MMU found in all modern microprocessors
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过所有现代微处理器中的MMU提供的硬件支持
- en: Software support via the operating system
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过操作系统的软件支持
- en: There are many more benefits that VM provides, including (but not limited to)
    making powerful technologies, such as demand paging, **copy-on-write** (**COW**)
    handling, defragmentation, memory overcommit, memory-compaction, **Kernel Samepage
    Merging** (**KSM**), and **Transcendent Memory** (**TM**), possible.  Within this
    book's scope, we will cover a couple of these at later points.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存提供了许多其他好处，包括（但不限于）使强大的技术成为可能，例如需求分页、**写时复制**（**COW**）处理、碎片整理、内存过度承诺、内存压缩、**内核同页合并**（**KSM**）和**超然内存**（**TM**）。在本书的范围内，我们将在以后的章节中涵盖其中的一些。
- en: Process memory layout
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存布局
- en: A process is an instance of a program in execution. It is seen as a live, runtime
    schedulable entity by the OS. In other words, it's the process that runs when
    we launch a program.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是正在执行的程序的实例。它被操作系统视为一个活动的、可调度的实体。换句话说，当我们启动一个程序时，运行的是进程。
- en: The OS, or kernel, stores metadata about the process in a data structure in
    kernel memory; on Linux, this structure is often called the **process descriptor**—though
    the term *task structure* is a more accurate one. Process attributes are stored
    in the task structure; the process **PID** (**process identifier**) – a unique
    integer identifying the process, process credentials, open-file information, signaling
    information, and a whole lot more, reside here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统或内核在内核内存中的数据结构中存储有关进程的元数据；在Linux上，这个结构通常被称为**进程描述符**，尽管术语*任务结构*更准确。进程属性存储在任务结构中；进程**PID**（进程标识符）-
    用于标识进程的唯一整数，进程凭证，打开文件信息，信号信息等等，都驻留在这里。
- en: From the earlier discussion,* Virtual memory*, we understand that a process
    has, among many other attributes, a VAS*.* The VAS is the sum-total space potentially
    available to it. As in our earlier example, with a fictional computer with 16
    address lines, the VAS per process would be 2^16 = 64 KB.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的讨论中，*虚拟内存*，我们了解到进程除了许多其他属性外，还有一个VAS*。VAS是它可能可用的总空间。就像我们之前的例子，使用16个地址线的虚构计算机，每个进程的VAS将是2^16
    = 64 KB。
- en: 'Now, let''s consider a more realistic system: a 32-bit CPU with 32 lines for
    addressing. Clearly, each process has a VAS of 2^32, a fairly large quantity of
    4 GB.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个更现实的系统：一个具有32位寻址的32位CPU。显然，每个进程的VAS为2^32，相当大的4 GB。
- en: 4 GB in hexadecimal format is `0x100000000;` so the VAS spans from the low address
    of `0x0` to the high address of `4GB - 1 = 0xffff ffff.`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制格式的4 GB是`0x100000000;`所以VAS从低地址`0x0`到高地址`4GB - 1 = 0xffff ffff`。
- en: 'However, we have yet to learn more details (see the *Advanced: VM split*) regarding
    the exact usage of the high end of the VAS. Therefore, for the time being at least,
    let''s just refer to this as the high address and not put a particular numerical
    value to it.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要了解更多细节（参见*高级：VM分割*）关于VAS高端的确切使用。因此，至少目前，让我们将其称为高地址，而不给它一个特定的数值。
- en: 'Here is its diagrammatic representation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的图示表示：
- en: '![](img/3cfd1f33-c180-4c72-bfe4-3a6c9dbfc9f2.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cfd1f33-c180-4c72-bfe4-3a6c9dbfc9f2.png)'
- en: 'Fig 10: Process virtual address space (VAS)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：进程虚拟地址空间（VAS）
- en: So, the thing to understand for now is that on a 32-bit Linux, every process
    alive has this image:**0x0** to 0xffff ffff = 4 GB of virtual address space*.*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在要理解的是，在32位Linux上，每个活动的进程都有这个映像：**0x0**到0xffff ffff = 4 GB的虚拟地址空间*.*
- en: Segments or mappings
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 段或映射
- en: When a new process is created (details in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*), its VAS must be set up by the OS. All modern OSes divide
    up the process VAS into homogeneous regions called **segments** (don't confuse
    these segments with the hardware-segmentation approach mentioned in the, *Addressing
    2 – paging in brief *section).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新进程（详细信息见[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)，*进程创建*）时，其VAS必须由操作系统设置。所有现代操作系统都将进程VAS划分为称为**段**的同质区域（不要将这些段与硬件分段方法混淆，该方法在*地址2
    - 简要分页*部分中提到）。
- en: 'A segment is a homogeneous or uniform region of the process VAS; it consists
    of virtual pages. The segment has attributes, such as start and end addresses,
    protections (RWX/none), and mapping types. The key point for now: all pages belonging
    to a segment share the same attributes.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 段是进程VAS的同质或统一区域；它由虚拟页面组成。段具有属性，如起始和结束地址，保护（RWX/none）和映射类型。现在的关键点是：属于段的所有页面共享相同的属性。
- en: Technically, and more accurately from the OS viewpoint, the segment is called
    a **mapping**.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，从操作系统的角度来看，段被称为**映射**。
- en: From now on, when we use the word segment, we also mean mapping and vice versa.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当我们使用“segment”这个词时，我们也指的是mapping，反之亦然。
- en: 'Briefly, from the lower to high end, every Linux process will have the following
    segments (or mappings):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从低到高端，每个Linux进程都会有以下段（或映射）：
- en: Text (code)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本（代码）
- en: Data
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Library (or other)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库（或其他）
- en: Stack
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈
- en: '![](img/22ba5179-fea4-4a15-a907-e45cb70fa355.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22ba5179-fea4-4a15-a907-e45cb70fa355.png)'
- en: 'Fig 11: Overall view of the process VAS with segments'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：带有段的进程VAS的整体视图
- en: Read on for more details about each of these segments.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读有关这些段的更多详细信息。
- en: Text segment
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本段
- en: 'Text is code: the actual opcodes and operands that make up the machine instructions
    that are fed to the CPU to consume. Readers may recall the `objdump --source ./hello_dbg`
    we did in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System
    Architecture*, showing C code translated into assembly and machine language. This
    machine code resides within the process VAS in a segment called **text**. For
    example, let''s say a program has 32 KB of text; when we run it, it becomes a
    process and the text segment takes 32 KB of virtual memory; that''s 32K/4K = 8
    (virtual) pages.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 文本就是代码：构成馈送给CPU消耗的机器指令的实际操作码和操作数。读者可能还记得我们在[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)，*Linux系统架构*中所做的`objdump
    --source ./hello_dbg`，显示C代码转换为汇编和机器语言。这个机器代码驻留在进程VAS中，称为**文本**段。例如，假设一个程序有32 KB的文本；当我们运行它时，它变成一个进程，文本段占用32
    KB的虚拟内存；这是32K/4K = 8（虚拟）页。
- en: 'For optimization and protection, the OS marks, that is, protects, all these
    eight pages of text as **read-execute** (**r-x**). This makes sense: code will
    be read from memory and executed by the CPU, not written to it.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化和保护，操作系统标记，即保护，所有这八页文本都标记为**读-执行**（**r-x**）。这是有道理的：代码将从内存中读取并由CPU执行，而不是写入它。
- en: The text segment on Linux is always toward the low end of the process VAS. Note
    that it will never start at the `0x0` address.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，文本段总是朝着进程VAS的低端。请注意，它永远不会从`0x0`地址开始。
- en: As a typical example, on the IA-32, the text segment usually starts at `0x0804
    8000`. This is very arch-specific though  and changes in the presence of Linux
    security mechanisms like **Address Space Layout Randomization** (**ASLR**).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个典型的例子，在IA-32上，文本段通常从`0x0804 8000`开始。尽管这在架构上是非常特定的，而且在Linux安全机制如**地址空间布局随机化**（**ASLR**）存在时会发生变化。
- en: Data segments
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据段
- en: Immediately above the text segment is the data segment, which is the place where
    the process holds the program's global and static variables (data).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段的上方是数据段，这是进程保存程序的全局和静态变量（数据）的地方。
- en: 'Actually, it''s not one mapping (segment); the data segment consists of three
    distinct mappings. In order from the low address, it consists of: the initialized
    data segment, the uninitialized data segment, and the heap segment.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这不是一个映射（段）；数据段由三个不同的映射组成。从低地址开始，它包括：初始化数据段，未初始化数据段和堆段。
- en: We understand that, in a C program, uninitialized global and static variables
    are automatically initialized to zero. What about initialized globals? The initialized
    data segment is the region of address space where explicitly initialized global
    and static variables are stored.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在C程序中，未初始化的全局和静态变量会自动初始化为零。那么初始化的全局变量呢？初始化数据段是一个地址空间的区域，用于存储显式初始化的全局和静态变量。
- en: 'The uninitialized data segment is the region of address space where, of course,
    uninitialized globals and static variables reside. The key point: these are implicitly
    initialized to zero (they''re actually memset to zero). Also, older literature
    often refers to this region as the BSS. BSS is an old assembler directive – Block
    Started by Symbol – that can be ignored; today, the BSS region or segment is nothing
    but the uninitialized data segment of the process VAS.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的数据段是地址空间的一个区域，当然，未初始化的全局和静态变量驻留在这里。关键是：这些变量会被隐式初始化为零（实际上是memset为零）。此外，旧的文献经常将这个区域称为BSS。BSS是一个旧的汇编指令-由符号开始的块-可以忽略；今天，BSS区域或段仅仅是进程VAS的未初始化数据段。
- en: The heap should be a term familiar to most C programmers; it refers to the memory
    region reserved for dynamic memory allocations (and subsequent free's). Think
    of the heap as a free gift of memory pages made available to the process at startup.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 堆应该是大多数C程序员熟悉的一个术语；它指的是为动态内存分配（和随后的释放）保留的内存区域。把堆想象成一个在启动时为进程提供的免费内存页面的礼物。
- en: 'A key point: the text, initialized data, and uninitialized data segments are
    fixed in size; the heap is a dynamic segment – it can grow or shrink in size at
    runtime. It''s important to note that the heap segment grows toward higher virtual
    addresses. Further details on the heap and its usage can be found in the next
    chapter.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点：文本、初始化数据和未初始化数据段的大小是固定的；堆是一个动态段-它可以在运行时增长或缩小。重要的是要注意，堆段向更高的虚拟地址增长。有关堆及其用法的更多细节可以在下一章中找到。
- en: Library segments
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库段
- en: 'When linking a program, we have two broad choices:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接程序时，我们有两个广泛的选择：
- en: Static linking
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态链接
- en: Dynamic linking
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态链接
- en: Static linking implies that any and all library text (code) and data is saved
    within the program's binary executable file (hence it's larger, and a bit faster
    to load up).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接意味着任何和所有库文本（代码）和数据都保存在程序的二进制可执行文件中（因此它更大，加载速度更快）。
- en: Dynamic linking implies that any and all shared library text (code) and data
    is not saved within the program's binary executable file; instead, it is shared
    by all processes and mapped into the process VAS at runtime (hence the binary
    executable is a lot smaller, though it might take a bit longer to load up). Dynamic
    linking is always the default.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接意味着任何和所有共享库文本（代码）和数据都不保存在程序的二进制可执行文件中；相反，它被所有进程共享，并在运行时映射到进程VAS中（因此二进制可执行文件要小得多，尽管加载速度可能会慢一些）。动态链接始终是默认的。
- en: 'Think about the `Hello, world` C program. You invoked `printf(3)`, but did
    you write the code for it? No, of course not; we understand that it''s within
    glibc and will be linked into our process at runtime. That''s exactly what happens
    with dynamic linking: at process load time, all the library text and data segments
    that the program depends upon (uses) are *memory-mapped* (details in [Chapter
    18](cf0e96e2-0e5d-4fb2-abc2-742bc93b61d0.xhtml), *Advanced File I/O* )into the
    process VAS. Where? In the region between the top of the heap and the bottom of
    the stack: the library segments (refer to the preceding diagram).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 想想“Hello, world” C程序。你调用了`printf(3)`，但你有写它的代码吗？当然没有；我们知道它在glibc中，并且会在运行时链接到我们的进程中。这正是动态链接的发生方式：在进程加载时，程序依赖（使用）的所有库文本和数据段都会*内存映射*到进程VAS中。在哪里？在堆的顶部和栈的底部之间的区域：库段（参见前面的图表）。
- en: 'Another thing: other mappings (besides library text and data) may find their
    way into this region of address space. A typical case is explicit memory mappings
    made by the developer (using the `mmap(2)` system call), implicit mappings such
    as those made by IPC mechanisms, such as shared memory mappings, and the malloc
    routines (refer to [Chapter 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic
    Memory Allocation*).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事：除了库文本和数据之外，其他映射可能会进入这个地址空间的区域。一个典型的情况是开发人员进行的显式内存映射（使用`mmap(2)`系统调用），隐式映射，比如IPC机制所做的映射，比如共享内存映射，以及malloc例程（参见[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)，*动态内存分配*）。
- en: Stack segment
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈段
- en: 'This section explains the process stack: what, why, and how.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节解释了进程栈：什么，为什么，以及如何。
- en: What is stack memory?
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈内存是什么？
- en: You probably remember being taught that stack memory is just memory but with
    a special push/pop semantic; the memory you push last resides at the top of the
    stack, and if you perform a pop operation, that memory gets popped off – removed
    from – the stack.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得被教过，栈内存只是内存，但具有特殊的推/弹出语义；你最后推入的内存位于栈的顶部，如果执行弹出操作，那个内存就会从栈中弹出-从中移除。
- en: 'The pedagogical example of visualizing a stack of dinner plates is a good one:
    the plate you place last is at the top, and you take the top plate off to give
    it to your dinner guest (of course, you could insist that you give them the plate
    from the middle or bottom of the stack, but we think that the plate on the very
    top would be the easiest one to pop off).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将晚餐盘子堆叠的教学示例是一个很好的例子：你最后放置的盘子在顶部，你从顶部取下盘子给你的晚餐客人（当然，你可以坚持说你从堆栈的中间或底部给他们盘子，但我们认为顶部的盘子最容易取下）。
- en: Some literature also refers to this push/pop behavior as **Last In First Out**
    (**LIFO**). Fair enough.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文献还将这种推送/弹出行为称为**后进先出**（**LIFO**）。好吧。
- en: The high end of the process VAS is used for the stack segment (refer to *Fig
    11*). Okay, fine, but what exactly is it for? How does it help?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 进程VAS的高端用于堆栈段（参见*图11*）。好吧，但它到底是用来做什么的？它如何帮助？
- en: Why a process stack?
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要进程堆栈？
- en: 'We''re taught to write nice modular code: divide your work into subroutines,
    and implement them as small, easily readable, and maintainable C functions. That''s
    great.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被教导要编写良好的模块化代码：将工作分解为子例程，并将其实现为小型、易读、易维护的C函数。这很好。
- en: The CPU, though, does not really understand how to invoke a C function, how
    to pass parameters, store local variables, and return a result to the calling
    function. Our savior, the compiler, takes over, converting C code into an assembly
    language that is capable of making this whole function thing work.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CPU实际上并不了解如何调用C函数，如何传递参数，存储局部变量，并将结果返回给调用函数。我们的救世主，编译器接管，将C代码转换为能够使整个函数工作的汇编语言。
- en: The compiler generates assembly code to invoke a function, passes along parameters,
    allocates space for local variables, and finally, emits a return result back to
    the caller. To do this, it uses the stack! So, similar to the heap, the stack
    is also a dynamic segment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成汇编代码来调用函数，传递参数，为局部变量分配空间，最后将返回结果发回给调用者。为了做到这一点，它使用堆栈！因此，类似于堆，堆栈也是一个动态段。
- en: Every time a function is called, memory is allocated in the stack region (or
    segment or mapping) to hold metadata that has the function call, parameter passing
    and the function return mechanism work. This metadata region for each function
    is called the stack frame*.*
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，在堆栈区域（或段或映射）中分配内存来保存具有函数调用、参数传递和函数返回机制的元数据。每个函数的这个元数据区域称为堆栈帧*。*
- en: The stack frame holds the metadata necessary to implement the function call-parameter
    use-return value mechanism. The exact layout of a stack frame is highly CPU (and
    compiler) dependent; it's one of the key areas addressed by the CPU ABI document.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧保存了实现函数调用-参数使用-返回值机制所需的元数据。堆栈帧的确切布局高度依赖于CPU（和编译器）；这是CPU ABI文档涵盖的关键领域之一。
- en: 'On the IA-32 processor, the stack frame layout essentially is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在IA-32处理器上，堆栈帧布局基本上如下：
- en: '`[ <-- high address`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ <-- 高地址`'
- en: '`  [ Function Parameters ... ]`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`  [ 函数参数 ... ]`'
- en: '`  [ RET address ]`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`  [ 返回地址 ]`'
- en: '`  [ Saved Frame Pointer ] (optional)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`  [ 保存的帧指针 ] (可选)`'
- en: '`  [ Local Variables ... ]`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`  [ 局部变量 ... ]`'
- en: '`]  <-- SP: lowest address  `'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`]  <-- SP: 最低地址  `'
- en: 'Consider some pseudocode:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一些伪代码：
- en: '[PRE8]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The call graph is quite obvious:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 调用图相当明显：
- en: '`main --> foo --> bar --> jail`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`main --> foo --> bar --> jail`'
- en: The arrow drawn like --> means calls; so, main calls foo, and so on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头绘制为 --> 表示调用；所以，main 调用 foo，依此类推。
- en: 'The thing to understand: every function invocation is represented at runtime
    by a stack frame in the process''s stack.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解的是：每次函数调用在进程的堆栈中都由一个堆栈帧表示。
- en: 'If the processor is issued a push or pop instruction, it will go ahead and
    perform it. But, think about it, how does the CPU know where exactly – at which
    stack memory location or address – it should push or pop memory? The answer: we
    reserve a special CPU register, the **stack pointer** (usually abbreviated to **SP**),
    for precisely this purpose: the value in SP always points to the top of the stack.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器发出了推送或弹出指令，它将继续执行。但是，想想看，CPU如何知道确切地在哪里 - 在哪个堆栈内存位置或地址 - 它应该推送或弹出内存？答案是：我们保留一个特殊的CPU寄存器，**堆栈指针**（通常缩写为**SP**），用于确切地这个目的：SP中的值始终指向堆栈顶部。
- en: 'The next key point: the stack segment grows toward lower virtual addresses. This
    is often referred to as stack-grows-down semantics. Also note that the direction
    of stack growth is a CPU-specific feature dictated by the ABI for that CPU; most
    modern CPUs (including Intel, ARM, PPC, Alpha, and Sun SPARC) follow the stack-grows-down semantic.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键点：堆栈段向较低的虚拟地址增长。这通常被称为堆栈向下增长的语义。还要注意，堆栈增长的方向是由该CPU的ABI规定的CPU特定特性；大多数现代CPU（包括英特尔、ARM、PPC、Alpha和Sun
    SPARC）都遵循堆栈向下增长的语义。
- en: The SP always points to the top of the stack; as we use a downward-growing stack,
    this is the lowest virtual address on the stack!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: SP始终指向堆栈顶部；由于我们使用的是向下增长的堆栈，这是堆栈上的最低虚拟地址！
- en: 'For clarity, let''s check out a diagram that visualizes the process stack just
    after the call to `main()` (`main()` is invoked by a `__libc_start_main()` glibc
    routine):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚起见，让我们看一张图，它展示了在调用`main()`之后的进程堆栈（`main()`由一个`__libc_start_main()` glibc例程调用）：
- en: '![](img/5a15d9e1-29d7-4985-bc59-b7c57dceefe5.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a15d9e1-29d7-4985-bc59-b7c57dceefe5.png)'
- en: 'Figure 12: Process stack after main() is called'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：调用`main()`后的进程堆栈
- en: 'The process stack upon entry to the `jail()` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`jail()`函数时的进程堆栈：
- en: '![](img/b190513f-f14d-4254-bf61-10212c725059.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b190513f-f14d-4254-bf61-10212c725059.png)'
- en: 'Figure 13: Process stack after jail() is called'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：调用`jail()`后的进程堆栈
- en: Peeking at the stack
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窥视堆栈
- en: 'We can take a peek into the process stack (technically, the stack of `main()`)
    in different ways. Here, we show two possibilities:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式窥视进程堆栈（技术上来说，是`main()`的堆栈）。这里，我们展示了两种可能性：
- en: Automatically via the `gstack(1)` utility
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`gstack(1)`实用程序自动
- en: Manually with the GDB debugger
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GDB调试器手动
- en: 'Peek at the usermode stack, first, via `gstack(1)`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过`gstack(1)`查看用户模式堆栈：
- en: WARNING! Ubuntu users, you might face an issue here. At the time of writing
    (Ubuntu 18.04), gstack does not seem to be available for Ubuntu (and its alternative, pstack,
    does not work well either!). Please use the second method (via GDB), as follows.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！Ubuntu用户，你们可能会在这里遇到问题。在撰写时（Ubuntu 18.04），`gstack`似乎对Ubuntu不可用（它的替代方法`pstack`也不太好用！）。请使用第二种方法（通过GDB），如下。
- en: 'As a quick example, we look up the stack of `bash` (the parameter is the PID
    of the process):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的例子，我们查看`bash`的堆栈（参数是进程的PID）：
- en: '[PRE9]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The stack frame number appears on the left preceded by the `#` symbol; note
    that frame `#0` is the top of the stack, (the lowest frame). Read the stack in
    a bottom-up fashion, that is, from frame `#6` (the frame for the `main()` function)
    up to frame `#0` (the frame for the `waitpid()` function). Also note that, if
    the process is multithreaded, `gstack` will show the stack of *each* thread.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧编号出现在左边，前面有`#`符号；请注意，帧`#0`是堆栈的顶部（最低的帧）。以自下而上的方式读取堆栈，即从帧`#6`（`main()`函数的帧）到帧`#0`（`waitpid()`函数的帧）。还要注意，如果进程是多线程的，`gstack`将显示*每个*线程的堆栈。
- en: Peek at the Usermode Stack, next, via GDB.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过GDB查看用户模式堆栈。
- en: The **G****NU Deb****ugger** (**GDB**) is a renowned, very powerful debug tool
    (if you don't already use it, we highly recommend you learn how to; check out
    the link in the *Further reading* section). Here, we'll use GDB to attach to a
    process and, once attached, peek at its process stack.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**G****NU Deb****ugger** (**GDB**)是一个著名的、非常强大的调试工具（如果你还没有使用它，我们强烈建议你学习一下；请查看*进一步阅读*部分中的链接）。在这里，我们将使用GDB来附加到一个进程，并且一旦附加，就可以查看它的进程堆栈。'
- en: 'A small test C program, that makes several nested function calls, will serve
    as a good example. Essentially, the call graph will look as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的测试C程序，进行了几个嵌套的函数调用，将作为一个很好的例子。基本上，调用图将如下所示：
- en: '[PRE10]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `pause(2)` system call is a great example of a blocking call – it puts the
    calling process to sleep, waiting (or blocking) on an event; the event it's blocking
    upon here is the delivery of any signal to the process. (Patience; we'll learn
    more in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling -
    Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II*).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause(2)`系统调用是一个阻塞调用的很好的例子 - 它让调用进程进入睡眠状态，等待（或阻塞）事件的发生；这里它所阻塞的事件是向进程传递任何信号。（耐心点；我们将在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中学到更多，*信号
    - 第一部分*，和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)，*信号 - 第二部分*）。'
- en: 'Here is the relevant code `(ch2/stacker.c)`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相关的代码`(ch2/stacker.c)`：
- en: '[PRE11]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that, for GDB to see the symbols (names of functions, variables, line numbers),
    one must compile the code with the `-g` switch (produces debug information).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了让GDB看到符号（函数名称、变量、行号），必须使用`-g`开关编译代码（生成调试信息）。
- en: 'Now, we run the process in the background:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在后台运行进程：
- en: '[PRE12]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, open GDB; within GDB, attach to the process (the PID is displayed in
    the preceding code), and view its stack with the **backtrace** ( **bt**) command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开GDB；在GDB中，附加到进程（PID在前面的代码中显示），并使用**backtrace**（**bt**）命令查看其堆栈：
- en: '[PRE13]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On Ubuntu, due to security, GDB will not allow one to attach to any process;
    one can overcome this by running GDB as root; then it works well.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，由于安全原因，GDB不允许附加到任何进程；可以通过以root身份运行GDB来克服这一问题；然后它就可以正常工作了。
- en: 'How about looking up the same process via `gstack` (at the time of writing,
    Ubuntu users, you''re out of luck). Here it is on a Fedora 27 box:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`gstack`查看相同的进程如何？（在撰写时，Ubuntu用户，你们没那么幸运）。这是在Fedora 27上的情况：
- en: '[PRE14]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Guess what? It turns out that `gstack` is really a wrapper shell script that
    invokes GDB in a non-interactive fashion and it issues the very same `backtrace` command
    we just used!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜怎么着？原来`gstack`实际上是一个包装的shell脚本，它以非交互方式调用GDB，并发出了我们刚刚使用的`backtrace`命令！
- en: As a quick learning exercise, check out the `gstack` script.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的学习练习，查看一下`gstack`脚本。
- en: Advanced – the VM split
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 - VM分割
- en: What we have seen so far is actually not the complete picture; in reality, this
    address space needs to be shared between user and kernel space.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的实际上并不是完整的画面；实际上，这个地址空间需要在用户空间和内核空间之间*共享*。
- en: This section is considered advanced. We leave it to the reader to decide whether
    to dive into the details that follow. While they're very useful, especially from
    a debug viewpoint, it's not strictly required for following the rest of this book.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分被认为是高级的。我们把决定是否深入了解接下来的细节留给读者。虽然它们非常有用，特别是从调试的角度来看，但严格来说并不是跟随本书其余部分所必需的。
- en: 'Recall what we mentioned in the *Library segments* section: if a `Hello, world`
    application is to work, it needs to have a mapping to the `printf(3)` glibc routine.
    This is achieved by having the dynamic or shared libraries memory-mapped into
    the process VAS at runtime (by the loader program).'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在*库段*部分提到的内容：如果一个`Hello, world`应用程序要工作，它需要将`printf(3)` glibc例程映射到它。这是通过在运行时将动态或共享库内存映射到进程VAS中（由加载程序）来实现的。
- en: 'A similar argument could be made for any and every system call issued by the
    process: we understood from [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux
    System Architecture*, that the system call code is actually within the kernel
    address space. Thus, if issuing a system call were to succeed, we would need to
    re-vector the CPU''s **Instruction Pointer** (**IP **or PC register) to the address
    of the system call code, which, of course, is within kernel address space. Now,
    if the process VAS consists of just text, data, library, and stack segments, as
    we have been so far suggesting, how would it work? Recall the fundamental rule
    of virtual memory: you cannot look outside the box (available address space).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进程发出的任何系统调用，都可以提出类似的论点：我们从[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中了解到，系统调用代码实际上位于内核地址空间内。因此，如果发出系统调用成功，我们需要将CPU的**指令指针**（**IP**或PC寄存器）重新定位到系统调用代码的地址，这当然是在内核地址空间内。现在，如果进程VAS只包括文本、数据、库和栈段，正如我们迄今所暗示的那样，它将如何工作？回想一下虚拟内存的基本规则：你不能看到盒子外面（可用地址空间）。
- en: In order for this whole scheme to succeed, therefore, even kernel virtual address
    space—yes, please note, even the kernel address space is considered virtual – must
    somehow be mapped into the process VAS.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使整个方案成功，即使内核虚拟地址空间 - 是的，请注意，即使内核地址空间也被认为是虚拟的 - 也必须以某种方式映射到进程VAS中。
- en: As we saw earlier, on a 32-bit system, the total VAS available to a process
    is 4 GB. So far, the implicit assumption is that the top of the process VAS on
    32-bit is therefore 4 GB. That's right. As well, again, the implicit assumption
    is that the stack segment (consisting of stack frames) lies here—at the 4 GB point
    at the top. Well, that's incorrect (please refer to *Fig 11*).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在32位系统上，进程可用的总VAS为4 GB。到目前为止，隐含的假设是32位系统上进程VAS的顶部是4 GB。没错。同样，再次暗示的假设是栈段（由栈帧组成）位于这里
    - 在顶部的4 GB点。嗯，那是不正确的（请参阅*图11*）。
- en: 'The reality is this: the OS creates the process VAS, and arranges for the segments
    within it; however, it reserves some amount of virtual memory at the top end for
    the kernel or OS-mapping (meaning, the kernel code, data structures, stacks, and
    drivers). By the way, this segment, which contains kernel code and data, is usually
    referred to as the kernel segment.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是：操作系统创建了进程VAS，并为其中的段进行了安排；但是，它在顶端保留了一定量的虚拟内存供内核或OS映射使用（即内核代码、数据结构、堆栈和驱动程序）。顺便说一句，这个包含内核代码和数据的段通常被称为内核段。
- en: How much VM is kept for the kernel segment? Ah, that's a tunable or a configurable
    that is set by kernel developers (or the system administrator) at kernel-configuration
    time; it's called **VMSPLIT**. This is the point in the VAS where we split the
    address space between the OS kernel and user mode memory – the text, data, library,
    and stack segments!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 内核段保留了多少VM？啊，这是一个可调整的或可配置的参数，由内核开发人员（或系统管理员）在内核配置时间设置；它被称为**VMSPLIT**。这是VAS中我们在OS内核和用户模式内存之间分割地址空间的点
    - 文本、数据、库和栈段！
- en: 'In fact, for clarity, let''s reproduce Fig 11 (as Fig 14), but this time, explicitly
    reveal the VM Split:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，为了清晰起见，让我们再次重现图11（作为图14），但这次明确显示VM分割：
- en: '![](img/59969b43-5ec2-487f-95a1-407310bffe05.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59969b43-5ec2-487f-95a1-407310bffe05.png)'
- en: 'Figure 14: The process VM Split'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：进程VM分割
- en: 'Let''s not get into the gory details here: suffice it to say that on an IA-32
    (Intel x86 32-bit), the splitting point is typically the 3 GB point. So, we have
    a ratio: *userspace VAS : kernel VAS  ::  3 GB : 1 GB    ; on the IA-32*.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们不要在这里深入细节：可以说在IA-32（Intel x86 32位）上，分割点通常是3 GB点。因此，我们有一个比例：*用户空间VAS：内核VAS
    :: 3 GB：1 GB；在IA-32上*。'
- en: 'Remember, this is tunable. On other systems, such as a typical ARM-32 platform,
    the split might be like this instead:* userspace VAS : kernel VAS  ::  2 GB :
    2 GB   ; on the ARM-32*.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，这是可调的。在其他系统上，例如典型的ARM-32平台，分割可能是这样的：*用户空间VAS：内核VAS :: 2 GB：2 GB；在ARM-32上*。'
- en: 'On an x86_64 with a gargantuan `2^64` VAS (that''s a mind-boggling 16 Exabytes!),
    it would be: *userspace VAS : kernel VAS  ::  128 TB : 128 TB   ; on the x86_64*.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '在具有庞大的`2^64` VAS（这是一个令人难以置信的16艾字节！）的x86_64上，它将是：*用户空间VAS：内核VAS :: 128 TB：128
    TB；在x86_64上*。'
- en: Now one can clearly see why we use the term monolithic to describe the Linux
    OS architecture – each process is indeed like a single, large piece of stone!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以清楚地看到为什么我们使用术语“单片式”来描述Linux OS架构 - 每个进程确实就像一块单一的大石头！
- en: 'Each process contains both of the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都包含以下两者：
- en: Userspace mappings
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间映射
- en: Text (code)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本（代码）
- en: Data
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Initialized data
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化数据
- en: Uninitialized data (BSS)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化的数据（BSS）
- en: Heap
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Library mappings
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库映射
- en: Other mappings
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他映射
- en: Stack
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈
- en: Kernel segments
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核段
- en: Every process alive maps into the kernel VAS (or kernel segment, as it's usually
    called), in its top end.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动进程都映射到内核VAS（或内核段，通常被称为）的顶端。
- en: 'This is a crucial point. Let''s look at a real-world case: on the Intel IA-32
    running the Linux OS, the default value of `VMSPLIT` is 3 GB (which is `0xc0000000`).
    Thus, on this processor, the VM layout for each process is as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键点。让我们看一个现实世界的例子：在运行Linux OS的Intel IA-32上，`VMSPLIT`的默认值为3 GB（即`0xc0000000`）。因此，在这个处理器上，每个进程的VM布局如下：
- en: '**0x0** to **0xbfffffff** : userspace mappings, that is, text, data, library
    and stack.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0x0**到**0xbfffffff**：用户空间映射，即文本、数据、库和栈。'
- en: '**0xc0000000** to **0xffffffff** : kernel space or the kernel segment.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0xc0000000**到**0xffffffff**：内核空间或内核段。'
- en: 'This is made clear in the following diagram:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中清楚地表示出来：
- en: '![](img/fc38a5e3-3fce-441a-8903-4c0dcd6f0bbb.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc38a5e3-3fce-441a-8903-4c0dcd6f0bbb.png)'
- en: 'Fig 15: Full process VAS on the IA-32'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：IA-32上的完整进程VAS
- en: Notice how the top gigabyte of VAS for every process is the same – the kernel
    segment. Also keep in mind that this layout is not the same on all systems – the
    VMSPLIT and the size of user and kernel segments varies with the CPU architecture.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个进程的顶部1GB的VAS都是相同的 - 内核段。还要记住，这种布局在所有系统上都不相同 - VMSPLIT和用户和内核段的大小因CPU架构而异。
- en: Since Linux 3.3 and especially 3.10 (kernel versions, of course), Linux supports
    the `prctl(2)` system call. Looking up its man page reveals all kinds of interesting,
    though non-portable (Linux-only), things one could do. For example, `prctl(2)`,
    used with the `PR_SET_MM` parameter, lets a process (with root privileges) essentially
    specify its VAS layout, its segments, in terms of start and end virtual addresses
    for text, data, heap, and stack. This is certainly not required for normal applications.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux 3.3特别是3.10（当然是内核版本）以来，Linux支持`prctl(2)`系统调用。查阅其手册页面会发现各种有趣的，尽管不可移植（仅限于Linux）的事情。例如，`prctl(2)`与`PR_SET_MM`参数一起使用，让一个进程（具有root权限）基本上可以指定其VAS布局，其段，以文本、数据、堆和栈的起始和结束虚拟地址为单位。这对于普通应用程序当然是不需要的。
- en: Summary
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter delved into an explanation of VM concepts, why VM matters, and
    its many benefits to modern operating systems and the applications running on
    them. We then covered the layout of the process virtual address space on the Linux
    OS, including some information on the text, (multiple) data, and stack segments.
    The true reasons for the stack, and its layout, were covered as well.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入解释了VM概念，为什么VM很重要，以及对现代操作系统和在其上运行的应用程序的许多好处。然后我们介绍了Linux OS上进程虚拟地址空间的布局，包括一些关于文本、（多个）数据和堆栈段的信息。还介绍了堆栈的真正原因及其布局。
- en: 'In the next chapter, the reader will learn about per-process resource limits:
    why they are required, how they work, and of course, the programmer interfaces
    required to work with them.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将了解每个进程的资源限制：为什么需要它们，它们如何工作，当然还有与它们一起工作所需的程序员接口。
