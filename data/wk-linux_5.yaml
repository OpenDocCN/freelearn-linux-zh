- en: Chapter 5. Developers' Treasure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。开发者的宝藏
- en: In this very chapter, we will kick start by building a web server using Python.
    We will then see how to process all our images automatically using ImageMagick.
    Then, we will look at the git flow branching model and how it will help you. Furthermore,
    we will see how meld command line can help merge our git conflicts. We will then
    focus on the working of ngrok tool and see how it saves the day by proxying requests
    coming from the internet to our laptop. We will also explore the versatile query
    capabilities of jq, the Swiss army knife of JSON! Towards the end, we will explore
    ways in which one can manage and kill Linux processes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用Python构建一个Web服务器来开始。然后，我们将看到如何使用ImageMagick自动处理所有图像。然后，我们将介绍git
    flow分支模型及其如何帮助您。此外，我们将看到meld命令行如何帮助合并我们的git冲突。然后，我们将重点介绍ngrok工具的工作原理，并看到它如何通过代理来自互联网的请求到我们的笔记本电脑。我们还将探索jq的多功能查询能力，它是JSON的瑞士军刀！最后，我们将探索管理和终止Linux进程的方法。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Shrinking spells and other ImageMagick
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小咒语和其他ImageMagick
- en: Understanding the work of git flow branching models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解git flow分支模型的工作原理
- en: Using ngrok to secure tunnels to localhost
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ngrok保护本地主机的隧道
- en: Getting yourself acquainted with jq
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉jq
- en: The spot webserver
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The spot webserver
- en: 'We have prepared a basic demo `html` file that contains a button, a `div`,
    a `jquery` function (for helping us do some `ajax` calls), and a script that will
    try to load static content from our server and put the content inside the `div`
    tag. The script is trying to load a simple text file on the disk, `/file`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了一个基本的演示`html`文件，其中包含一个按钮，一个`div`，一个`jquery`函数（用于帮助我们进行一些`ajax`调用），以及一个脚本，该脚本将尝试从我们的服务器加载静态内容并将内容放入`div`标签中。该脚本尝试在磁盘上加载一个简单的文本文件`/file`：
- en: '![The spot webserver](img/image_05_001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![The spot webserver](img/image_05_001.jpg)'
- en: 'If we open this file inside our browser, we can see the page content:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开此文件，我们可以看到页面内容：
- en: '![The spot webserver](img/image_05_002.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![The spot webserver](img/image_05_002.jpg)'
- en: Clicking on the button generates a `javascript` error. It is telling us that
    we want to do a cross-origin request, which is not allowed by default by the browser.
    This is to prevent cross-site scripting attacks. What we need to do in order to
    test our `javascript` code is to serve this file in an HTTP server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮会生成一个`javascript`错误。它告诉我们我们想要进行跨域请求，默认情况下浏览器不允许这样做。这是为了防止跨站脚本攻击。为了测试我们的`javascript`代码，我们需要将此文件提供在一个HTTP服务器上。
- en: 'In order to start an HTTP server in the same folder as the file, we type the
    following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在与文件相同的文件夹中启动一个HTTP服务器，我们输入以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![The spot webserver](img/image_05_003.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![The spot webserver](img/image_05_003.jpg)'
- en: 'This is a basic Python module that opens port `8000` on localhost, serving
    only static content (so, no, you can''t use it for `php`). Let''s open the address
    in the browser:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的Python模块，它在本地主机上打开端口`8000`，仅提供静态内容（因此，不，您不能用它来运行`php`）。让我们在浏览器中打开该地址：
- en: 'Click on the **Click me!** button. We see that our file content was loaded
    in the `div` beneath the button, which means the browser is no longer blocking
    us, because we are issuing requests to the same host using the same protocol.
    Looking at the output from our Python server, we can see all the requests that
    the browser has made to the server. We can see it''s requesting by default a `favicon.ico`
    file that doesn''t exist and it''s giving back a `404` status code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Click me!**按钮。我们可以看到我们的文件内容加载在按钮下方的`div`中，这意味着浏览器不再阻止我们，因为我们正在使用相同的主机和协议发出请求。从我们的Python服务器的输出中可以看到浏览器向服务器发出的所有请求。我们可以看到它默认请求一个不存在的`favicon.ico`文件，并返回一个`404`状态码：
- en: '![The spot webserver](img/image_05_004.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![The spot webserver](img/image_05_004.jpg)'
- en: You can find the files used in this project on the GitHub project page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub项目页面上找到此项目中使用的文件。
- en: Also, if we stop the server and go one level up and fire it up again, we can
    use it as a `webdav` server, with the possibility of navigating through the files
    in the current directory. We could, for example, give access to a folder on our
    local machine to a remote user and allow them to access it through a page in the
    browser, eliminating the need to install a file server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们停止服务器并返回一级目录再次启动它，我们可以将其用作`webdav`服务器，可以通过浏览器中的页面导航到当前目录中的文件。例如，我们可以将本地机器上的文件夹访问权限授予远程用户，并允许他们通过浏览器中的页面访问它，从而无需安装文件服务器。
- en: Shrinking spells and other ImageMagick
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小咒语和其他ImageMagick
- en: 'In this chapter, we will learn how to process images from the command line.
    We will start with the most complex and widely used image command line interface
    processing toolkit called **ImageMagick**. To install it, run the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在命令行中处理图像。我们将从最复杂且广泛使用的图像命令行界面处理工具集ImageMagick开始。要安装它，请运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_005.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Shrinking spells and other ImageMagick](img/image_05_005.jpg)'
- en: As you can see, we have already installed it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经安装了它。
- en: Now, let's find some images to process. Let's use the default Ubuntu backgrounds
    that can be found in `/usr/share/backgrounds`. Let's copy the backgrounds to another
    location so that we don't alter our default ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找一些要处理的图像。让我们使用默认的Ubuntu背景，可以在`/usr/share/backgrounds`中找到。让我们将这些背景复制到另一个位置，以免修改我们的默认背景。
- en: 'We''ll take a look at the first image in our list: we can see from `ls` that
    it is a JPEG image of 1.6 MB. To open it and see how it looks, let''s use the
    **eog** (**eye of gnome**) image viewer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下列表中的第一张图片：从`ls`命令可以看出，它是一张1.6 MB的JPEG图片。为了打开它并查看它的样子，让我们使用**eog**（**eye
    of gnome**）图像查看器：
- en: '![Shrinking spells and other ImageMagick](img/vlcsnap-00001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Shrinking spells and other ImageMagick](img/vlcsnap-00001.jpg)'
- en: 'The first and most important part of knowing how to process an image is knowing
    what that image actually is. To find this out, ImageMagick comes with a tool called
    **identify**. In its simplest form, you have to feed it an image name and it will
    output information like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理图像的第一步，也是最重要的一步，就是了解图像的实际情况。为了找出这一点，ImageMagick提供了一个名为**identify**的工具。在最简单的形式中，您只需提供一个图像名称给它，它将输出以下信息：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that the file is a JPEG image of 1.6 MB and most importantly, its
    size is 3,840x2,400 pixels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该文件是一个1.6 MB的JPEG图像，最重要的是，它的大小是3,840x2,400像素。
- en: 'If we look at the `warty-final-ubuntu.png` we see that the output format is
    similar: the size and resolution are higher and the image format is PNG. Let''s
    see what it looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`warty-final-ubuntu.png`，我们会发现输出格式是相似的：大小和分辨率更高，图像格式是PNG。让我们看看它是什么样子的：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_006.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_006.jpg)'
- en: 'PNG images usually take more space than JPEG images. If you don''t have transparency,
    it is recommended to use `.jpg`. In order to convert from one type to the other,
    we use the `imagemagick` `convert` command with two parameters: input filename
    and output filename:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PNG图像通常比JPEG图像占用更多的空间。如果没有透明度，建议使用`.jpg`。为了从一种类型转换为另一种类型，我们使用`imagemagick`的`convert`命令，带有两个参数：输入文件名和输出文件名：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_007.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_007.jpg)'
- en: 'The format of the output image will be deduced by `convert` from the filename
    extension. As you can see, the output is a JPEG image with the same resolution,
    but with a much smaller size than the PNG version: 180 KB compared to 2.6 MB.
    If we open the image, we can''t see any noticeable differences. This is a big
    thing when it comes to web development, because if we were to use this picture
    on a web page, it would load as much as 15 times faster than the PNG version.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出图像的格式将由`convert`根据文件扩展名推断。正如您所看到的，输出是一个JPEG图像，分辨率与PNG版本相同，但大小要小得多：180 KB与2.6
    MB相比。如果我们打开这个图像，我们看不到任何明显的差异。这对于Web开发来说是一件大事，因为如果我们在网页上使用这张图片，它将比PNG版本加载快15倍。
- en: 'If we want to crop a region of the image, we can do that with `convert`. For
    example, if we want to cut a 500x500 piece of the image, starting at coordinates
    100,100, we would use the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想裁剪图像的某个区域，我们可以使用`convert`来实现。例如，如果我们想剪切一个500x500的图像片段，从坐标100,100开始，我们将使用以下命令：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_008.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_008.jpg)'
- en: As we can see, the output image is at the resolution we requested, but it has
    a much lower size of only 2.5 KB. Visually analyzing the two images we can see
    that the cropped one is a section of the big picture. Normally you wouldn't want
    to guess pixels in the command line, but would use an image processing software,
    such as GIMP, to do the work for you, so that you can visually select and crop
    portions of the images. However, when developing software applications, it is
    often the case that you have to programmatically crop images, in which case this
    comes in handy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，输出图像的分辨率与我们请求的一样，但大小只有2.5 KB。通过视觉分析这两个图像，我们可以看到裁剪的图像是大图的一部分。通常情况下，您不会想在命令行中猜测像素，而是使用图像处理软件（如GIMP）来为您完成工作，以便您可以可视化地选择和裁剪图像的部分。然而，在开发软件应用程序时，经常需要以编程方式裁剪图像，这时这个功能就非常方便了。
- en: 'The `convert` command is also good at creating images. If we want to create
    an image from a text string, we could use the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert`命令也很擅长创建图像。如果我们想从文本字符串创建图像，我们可以使用以下命令：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_009.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_009.jpg)'
- en: 'This will create a JPEG image with a height of 80 pixels, containing the text
    specified, in this case the string `123`. We can see the output, it is a 3.4 KB
    image and, if we look at it visually, we see the text `123`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个高度为80像素的JPEG图像，包含指定的文本，本例中为字符串`123`。我们可以看到输出，它是一个3.4 KB的图像，如果我们在视觉上看它，我们会看到文本`123`：
- en: '![Shrinking spells and other ImageMagick](img/image_05_010.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_010.jpg)'
- en: This can also come in handy in different scenarios where you need to programmatically
    generate readable images, such as using CAPTCHA software or generating default
    profile images with the user's initials.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这在不同的场景中也非常有用，比如需要以编程方式生成可读图像，比如使用CAPTCHA软件或生成带有用户姓名首字母的默认个人资料图像。
- en: 'Now let''s look at some image shrinking tools outside of `imagemagick`. The
    first one is a `png` shrinking tool called `pngquant`. We will install it by typing
    the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`imagemagick`之外的一些图像缩小工具。第一个是一个名为`pngquant`的`png`缩小工具。我们将通过输入以下内容来安装它：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_011.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_011.jpg)'
- en: 'Let''s try to shrink the large PNG image that we were looking at earlier. If
    the image contains transparency and it is necessary to keep it in the PNG format,
    we would just call `pngquant` with the following image name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试缩小之前查看的大型PNG图像。如果图像包含透明度并且需要保留在PNG格式中，我们只需使用以下图像名称调用`pngquant`：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_012.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_012.jpg)'
- en: 'By default, it outputs a file with the same name and an added `fs8` extension.
    We can see that the difference in size is also noticeable (it''s smaller by 1
    MB, which is almost half the original size). If we visually compare the images,
    we won''t be able to spot any differences:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它会输出一个与原文件同名但添加了`fs8`扩展名的文件。我们可以看到大小的差异也是明显的（它比原始大小小了1 MB，几乎是原始大小的一半）。如果我们在视觉上比较这些图像，我们将无法发现任何差异：
- en: '![Shrinking spells and other ImageMagick](img/image_05_013.jpg)![Shrinking
    spells and other ImageMagick](img/image_05_014.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![缩小咒语和其他ImageMagick](img/image_05_013.jpg)![缩小咒语和其他ImageMagick](img/image_05_014.jpg)'
- en: Alright, now let's try and do the same thing for JPEG images.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在让我们尝试对JPEG图像做同样的事情。
- en: 'For this, we''ll install the equivalent of `pngquant,` which is `jpegoptim`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将安装与`pngquant`相当的工具，即`jpegoptim`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Shrinking spells and other ImageMagick](img/image_05_015.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![缩小拼写和其他ImageMagick](img/image_05_015.jpg)'
- en: 'We will call it the same way and we''re just going to give it a command-line
    argument, which is the file to shrink. Let''s pick some random images to try and
    see if we can reduce their size:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以相同的方式调用它，只需给它一个命令行参数，即要缩小的文件。让我们选择一些随机图像来尝试并查看是否可以减小它们的大小：
- en: '![Shrinking spells and other ImageMagick](img/image_05_016.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![缩小拼写和其他ImageMagick](img/image_05_016.jpg)'
- en: 'As you can see from the output, it is saying **Skipped**. That means the image
    had already been shrunk (the guys at Ubuntu probably used the same tool before
    submitting the image). If we try it again on the JPEG produced by `imagemagick`,
    you can see that it is also skipped: `imagemagick` already uses the minimum necessary
    format.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，它显示**Skipped**。这意味着该图像已经被缩小（Ubuntu的人们可能在提交图像之前使用了相同的工具）。如果我们再次尝试在`imagemagick`生成的JPEG上运行它，您可以看到它也被跳过了：`imagemagick`已经使用了最小必要的格式。
- en: The image processing tools come in especially handy when it comes to web development,
    where lots of images need to be used and their size needs to be as small as possible.
    Command-line tools are really useful because they can be used to automate tasks.
    Image shrinking is usually added to build tasks, where production versions of
    websites are prepared. The `imagemagick` toolkit comes with a lot more tools than
    the ones we have seen today, so feel free to explore other handy commands from
    the toolkit. Also, when it comes to graphically processing the images, there are
    some great open source tools like GIMP and Inkscape that can really help you get
    your job done, and also save you a lot of money.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理工具在Web开发中非常有用，因为需要使用大量图像，并且它们的大小需要尽可能小。命令行工具非常有用，因为它们可以用于自动化任务。图像缩小通常添加到构建任务中，用于准备网站的生产版本。`imagemagick`工具包提供的工具比我们今天看到的工具要多得多，所以请随意探索工具包中的其他实用命令。此外，当涉及到图像的图形处理时，还有一些很棒的开源工具，如GIMP和Inkscape，可以帮助您完成工作，还可以节省大量资金。
- en: Go with the Git flow
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随Git流程
- en: '**Git** is by far the most popular version control system out there. In this
    chapter, we will be looking at a plugin for Git, called **GitFlow**, which proposes
    a branching model for software projects. This branching model doesn''t offer much
    help when it comes to small projects, but it''s a great benefit to medium sized
    and large projects. We will be looking at a variation of the `git-flow` plugin,
    called `gitflow-avh`, which adds extra functionality, such as **Git hooks**, [https://github.com/petervanderdoes/gitflow-avh](https://github.com/petervanderdoes/gitflow-avh).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git**是迄今为止最流行的版本控制系统。在本章中，我们将介绍Git的一个插件，称为**GitFlow**，它为软件项目提供了一个分支模型。这个分支模型对于小型项目来说并没有太多帮助，但对于中型和大型项目来说是一个巨大的好处。我们将介绍`git-flow`插件的一个变体，称为`gitflow-avh`，它添加了额外的功能，如**Git钩子**，[https://github.com/petervanderdoes/gitflow-avh](https://github.com/petervanderdoes/gitflow-avh)。'
- en: To install it, we'll follow the instructions on the GitHub page. We are on Ubuntu,
    so we will follow the installation instructions for Linux.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，我们将按照GitHub页面上的说明进行操作。我们使用的是Ubuntu，所以我们将按照Linux的安装说明进行操作。
- en: We can see that it can be directly installed with the `apt` command, but apt
    doesn't usually contain the latest version of the software, so today we will do
    a manual installation. We want to pick the stable version, and use the one line
    command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它可以直接使用`apt`命令安装，但apt通常不包含软件的最新版本，所以今天我们将进行手动安装。我们想选择稳定版本，并使用一行命令。
- en: 'Once this is done, let''s create a dummy project. We''ll create an empty directory
    and initialize it as a Git repository:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们创建一个虚拟项目。我们将创建一个空目录并将其初始化为Git仓库：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Go with the Git flow](img/image_05_017.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_017.jpg)'
- en: Basic Git usage is not part of this course, and we are assuming that you understand
    the basics.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Git使用不是本课程的一部分，我们假设您已经了解基础知识。
- en: 'All right. A good way to get started with `git-flow` is to read the excellent
    cheatsheet created by Daniel Kummer:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。开始使用`git-flow`的一个好方法是阅读由Daniel Kummer创建的优秀备忘单：
- en: '[http://danielkummer.github.io/git-flow-cheatsheet/](http://danielkummer.github.io/git-flow-cheatsheet/)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://danielkummer.github.io/git-flow-cheatsheet/](http://danielkummer.github.io/git-flow-cheatsheet/)'
- en: 'This provides the basic tips and tricks to get you started quickly with `git-flow`.
    So the first thing the cheatsheet suggests is to run the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一些基本的提示和技巧，以便您可以快速开始使用`git-flow`。因此，备忘单建议首先运行以下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Go with the Git flow](img/image_05_018.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_018.jpg)'
- en: 'To configure it, we need to answer a bunch of questions about what names the
    branches should have in each flow and what the version tag prefix and hooks directory
    are. Let''s just leave the defaults. Now, let''s run the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置它，我们需要回答一系列关于每个流程中分支应该具有的名称以及版本标签前缀和钩子目录的问题。让我们使用默认值。现在，让我们运行以下命令：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Go with the Git flow](img/image_05_019.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_019.jpg)'
- en: We can see that we are now on the `develop` branch, so no more developing on
    the `master` branch. This helps us have a stable master, while not so stable features
    are kept on the `develop` branch.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们现在在`develop`分支上，所以不再在`master`分支上进行开发。这有助于我们拥有一个稳定的主分支，而不太稳定的功能则保留在`develop`分支上。
- en: 'If we go back to the cheatsheet, we can look at the first item, which is a
    feature branch. Feature branches are useful when developing a specific part of
    functionality or doing refactoring, but you don''t want to break the existing
    functionality on the develop branch. To create a feature branch, just run the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到备忘单，我们可以看到第一项是一个功能分支。功能分支在开发特定功能部分或进行重构时非常有用，但您不希望破坏开发分支上的现有功能。要创建一个功能分支，只需运行以下命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Go with the Git flow](img/image_05_020.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_020.jpg)'
- en: This is not the most intuitive description of the feature, but it's good for
    demonstration purposes. `GitFlow` will also show us a summary of actions once
    the feature branch has finished. This has created a new branch called `feature/feature1`,
    based on the develop branch and has switched us to that branch. We can also see
    this from our handy `zsh` prompt.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最直观的功能描述，但对于演示目的很好。`GitFlow`在功能分支完成后还会向我们显示操作摘要。这创建了一个名为`feature/feature1`的新分支，基于开发分支，并将我们切换到该分支。我们还可以从我们方便的`zsh`提示中看到这一点。
- en: 'Let''s open up a file, edit, and save it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个文件，进行编辑并保存：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Go with the Git flow](img/image_05_021.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_021.jpg)'
- en: This command will tell us that we have an uncommitted file. Let's go ahead and
    commit it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会告诉我们有一个未提交的文件。让我们继续提交它。
- en: 'Now `git commit` is using the `nano` editor for editing the commit message.
    Since we prefer `vim`, let''s go ahead and change the default editor to `vim`.
    All we need to do is add this line in our `zshrc` and reload it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`git commit`正在使用`nano`编辑器编辑提交消息。由于我们更喜欢`vim`，让我们继续将默认编辑器更改为`vim`。我们只需要在我们的`zshrc`中添加这一行并重新加载它：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now when we do a `git commit` Vim opens up, shows us a summary of the commit,
    and closes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们执行`git commit`时，Vim会打开，显示给我们一个提交摘要，然后关闭。
- en: 'Now let''s assume that we''ve finished adding a new feature. It''s time to
    merge the feature branch back to develop with the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们已经完成了一个新功能的添加。现在是将功能分支与以下内容合并回开发分支的时候了：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Go with the Git flow](img/image_05_022.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_022.jpg)'
- en: 'Again, to get a summary of actions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了获得操作摘要：
- en: The feature branch was merged back to develop
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能分支已合并回开发分支
- en: The feature branch has been deleted
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能分支已被删除
- en: The current branch was switched back to develop
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前分支已切换回开发分支
- en: If we do an `ls`, we see the file from our branch present on the develop branch.
    Looking at the cheatsheet we see a graphical representation of this process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`ls`，我们会看到我们分支上的文件存在于开发分支上。查看备忘单，我们可以看到这个过程的图形表示。
- en: Next up is starting a release. Release branches are good for stopping the incoming
    features and bug fixes from the develop branch, testing the current version, submitting
    bug fixes on it, and releasing it to the general public.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是开始一个发布。发布分支适用于停止来自开发分支的新功能和错误修复，测试当前版本，在其上提交错误修复，并向公众发布它。
- en: 'As we can see, the syntax is similar, the process is similar, the develop is
    branched to a release branch, but when it comes to finishing the branch, the features
    are also merged to the master branch, and a tag is cut from this branch. Time
    to see it in action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，语法相似，过程相似，开发分支分支到发布分支，但是当涉及完成分支时，功能也会合并到主分支，并从该分支切出一个标签。是时候看到它的实际效果了：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Go with the Git flow](img/image_05_023.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_023.jpg)'
- en: This switches us over to our `release/1.0.0` branch. Let's add a `releasenotes.txt`
    file to show what has changed in this release. Added more bugs…Hopefully not!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们切换到我们的`release/1.0.0`分支。让我们添加一个`releasenotes.txt`文件，以显示此版本中的更改。添加了更多的错误……希望没有！
- en: Let's commit the file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交文件。
- en: This is usually the case when you start to run your integration and stress testing,
    to see if all is well and to check that there are no bugs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是当您开始运行集成和压力测试时的情况，以查看是否一切正常，并检查是否有错误。
- en: 'After the testing is finished, we go ahead and finish our release branch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，我们继续完成我们的发布分支：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Go with the Git flow](img/image_05_024.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_024.jpg)'
- en: 'It will prompt us for a series of release messages: we will leave all the defaults.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提示我们输入一系列的发布信息：我们将保留所有默认值。
- en: 'Checking out the summary, we can see that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查摘要，我们可以看到：
- en: The release branch was merged into master
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布分支已合并到主分支
- en: A tag was cut from master with the release version
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主分支切出了一个带有发布版本的标签
- en: The tag has also been merged into develop
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签也已合并到开发分支
- en: The release branch has been deleted
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布分支已被删除
- en: And we are back on the develop branch
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回到了开发分支
- en: 'Now, we run the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行以下命令：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Go with the Git flow](img/image_05_025.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_025.jpg)'
- en: 'We see that the only two available branches are master and develop:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到唯一可用的两个分支是主分支和开发分支：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Go with the Git flow](img/image_05_026.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_026.jpg)'
- en: 'This tells us that there is a 1.0.0 tag cut. We can see that the branch now
    contains two files from the merge of the feature and release branch; and if we
    also switch to the master branch, we can see that, at this point, master is an
    exact replica of develop:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们有一个1.0.0标签。我们可以看到该分支现在包含来自功能和发布分支合并的两个文件；如果我们还切换到主分支，我们可以看到，此时，主分支是开发分支的精确副本：
- en: '![Go with the Git flow](img/image_05_027.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_027.jpg)'
- en: GitFlow also comes with an enhanced hooks functionality. If we read the documentation,
    we can see all the possible hooks in the `hooks` folder. Let's add a `git` hook
    that will be executed before every hotfix branch. For this we just open the template,
    copy the content, and paste it to a file with the name `pre-flow-hotfix-start`
    in our `.git/hooks` directory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow还提供了增强的钩子功能。如果我们阅读文档，可以看到`hooks`文件夹中的所有可能的钩子。让我们添加一个在每个热修复分支之前执行的`git`钩子。为此，我们只需打开模板，复制内容，并将其粘贴到名为`pre-flow-hotfix-start`的文件中，放在我们的`.git/hooks`目录中。
- en: GitFlow has more workflows than the ones presented. We won't go through all
    of them, but you can find additional information by visiting the cheatsheet page
    or by reading the instructions on the GitHub page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow有比所呈现的更多的工作流程。我们不会逐个介绍所有工作流程，但您可以通过访问备忘单页面或阅读GitHub页面上的说明来找到其他信息。
- en: Let's just simply `echo` a message with the version and origin.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只是简单地`echo`一个带有版本和来源的消息。
- en: If we look at the `hotfix` flow, we can see that they are created from the master
    branch and merged back to master and develop, with a tag on master.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`hotfix`流程，我们可以看到它们是从主分支创建的，并在主分支和开发分支上合并，主分支上有一个标签。
- en: 'Let''s see if it works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否有效：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Go with the Git flow](img/image_05_028.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_028.jpg)'
- en: 'Apparently not. Something went wrong, our script was not executed and we need
    to delete our branch:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然不是。出了些问题，我们的脚本没有执行，我们需要删除我们的分支：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Go with the Git flow](img/image_05_029.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_029.jpg)'
- en: 'Analyzing the `git hooks` directory, we see that our hook does not have execution
    permissions. After adding execution permissions, and running the `git hook` command
    again, we can see our message on the top of the hotfix output. Let''s finish this
    hotfix with the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`git hooks`目录，我们发现我们的钩子没有执行权限。添加执行权限后，再次运行`git hook`命令，我们可以在热修复输出的顶部看到我们的消息。让我们使用以下命令完成这个热修复：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Go with the Git flow](img/image_05_030.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![跟随Git流程](img/image_05_030.jpg)'
- en: As you can see, the commands are quite straightforward. There is also an `oh-my-zsh`
    plugin that you can activate to have command line completion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些命令非常简单。还有一个`oh-my-zsh`插件，您可以激活它以进行命令行补全。
- en: As we said earlier, this is a plugin suitable for teams of developers working
    on multiple features, fixing bugs, and releasing hotfixes all at the same time.
    GitFlow is simple to learn, and helps teams have a correct workflow where they
    can easily prepare patches for production code, without worrying about the extra
    functionalities developed on the master branch.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，这是一个适用于同时处理多个功能、修复错误和发布热修复的开发团队的插件。GitFlow易于学习，并帮助团队拥有正确的工作流程，可以轻松为生产代码准备补丁，而不必担心在主分支上开发的额外功能。
- en: 'You can tweak the `config` as you like: some people prefer to place the `hooks`
    folder in a different place so that it is committed on the `git repo` and they
    don''t have to worry about copying the files over; others continue to develop
    on the master branch and use a separate branch such as customer for the production
    code.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要调整`config`：有些人喜欢将`hooks`文件夹放在不同的位置，这样它就会被提交到`git repo`上，他们就不必担心复制文件；其他人继续在主分支上开发，并使用一个单独的分支，如customer，用于生产代码。
- en: Merging Git conflicts with ease
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻松解决Git冲突
- en: Now let's look at another improvement that we can bring to `git`. Most tasks
    are easy to execute from the command line, but some tasks, such as merging, require
    a specialist's eye for understanding the different format.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们可以为`git`带来的另一个改进。大多数任务在命令行上执行起来很容易，但是一些任务，如合并，需要专家的眼睛来理解不同的格式。
- en: 'Let''s open the `feature` file from our previous chapter, edit it, add a new
    line, and save it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们之前章节的`feature`文件，编辑它，添加一行新内容，然后保存：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Merging Git conflicts with ease](img/image_05_031.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_031.jpg)'
- en: 'The `git diff` command will show us colored text explaining the differences
    between the `git` file and the modified file, but some people find this format
    hard to understand:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`git diff`命令将显示彩色文本，解释`git`文件和修改后文件之间的差异，但有些人发现这种格式很难理解：'
- en: '![Merging Git conflicts with ease](img/image_05_032.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_032.jpg)'
- en: 'Luckily, we can tell `git` to use external tools when it comes to merge and
    one external tool that we can use is called **Meld**. Let''s install it using
    the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以告诉`git`在合并时使用外部工具，我们可以使用的一个外部工具称为**Meld**。让我们使用以下命令进行安装：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Merging Git conflicts with ease](img/image_05_033.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_033.jpg)'
- en: 'After this, we can run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以运行以下命令：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Merging Git conflicts with ease](img/image_05_034.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_034.jpg)'
- en: 'It will ask us if we want to launch Meld as an external program for viewing
    the file. It''s also giving us a list of tools that it can use for displaying
    the difference. Hit `y` to open Meld:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它会询问我们是否要将Meld作为查看文件的外部程序启动。它还给出了一个工具列表，可以用于显示差异。按下`y`打开Meld：
- en: '![Merging Git conflicts with ease](img/image_05_035.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_035.jpg)'
- en: Now we can easily see the two files side by side and the differences between
    them. We can see that `1` has been changed to `2` and a new line has been added.
    Based on this output we can easily decide if we want to add it or not. Let's commit
    the file as it is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地并排查看两个文件及其之间的差异。我们可以看到`1`已更改为`2`，并添加了一行新内容。根据这个输出，我们可以轻松决定是否要添加它。让我们将文件提交如此。
- en: 'Next, we will look at merge conflicts. Let''s manually create a branch called
    **test** and **edit** the same file, commit it, and then switch back to the develop
    branch. Let''s update the same file, commit it, and then try to merge the `test`
    branch: and, of course, there is a merge conflict.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下合并冲突。让我们手动创建一个名为**test**的分支，并**编辑**同一个文件，提交它，然后切换回develop分支。让我们更新同一个文件，提交它，然后尝试合并`test`分支：当然，会出现合并冲突。
- en: 'For resolving the conflict, we will be using the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决冲突，我们将使用以下命令：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Merging Git conflicts with ease](img/image_05_036.jpg)![Merging Git conflicts
    with ease](img/image_05_037.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_036.jpg)![轻松解决Git冲突](img/image_05_037.jpg)'
- en: 'Again, it offers to open Meld. In Meld we can see the three files:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，它提供了打开Meld的选项。在Meld中，我们可以看到三个文件：
- en: On the left is the file from our current branch
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧是来自当前分支的文件
- en: On the right is the file from the remote branch
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧是来自远程分支的文件
- en: In the middle is the resulting file that will be created
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间是将要创建的结果文件
- en: 'Let''s say that we decide the correct version for the feature is `4` and that
    we also want to add `of text`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定功能的正确版本是`4`，我们还想添加`of text`：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Merging Git conflicts with ease](img/image_05_038.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_038.jpg)'
- en: 'You can see the predefined commit message. Don''t forget to remove the temporary
    file that was created at the merge:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到预定义的提交消息。不要忘记删除合并时创建的临时文件：
- en: '![Merging Git conflicts with ease](img/image_05_039.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![轻松解决Git冲突](img/image_05_039.jpg)'
- en: In general, most modern IDEs offer plugins for working with `git`, including
    merging and `diffs`. We recommend that you get more acquainted with the command-line
    tools, because then you don't need to learn a new `git` plugin when switching
    from one IDE to another.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大多数现代IDE都提供了用于与`git`一起工作的插件，包括合并和`diffs`。我们建议您更加熟悉命令行工具，因为这样您就不需要在从一个IDE切换到另一个IDE时学习新的`git`插件。
- en: The `git` command works the same way across Linux, Mac, and Windows. It is a
    tool that developers use a lot and being fluent in it will boost your productivity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`git`命令在Linux、Mac和Windows上的工作方式相同。它是开发人员经常使用的工具，熟练掌握它将提高您的工作效率。'
- en: From localhost to instant DNS
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地主机到即时DNS
- en: Often, especially when working with other people or when developing integrations
    with online services, we have to make our computer accessible from the Internet.
    This information could be obtained from our trusty router, but wouldn't it be
    easier if we just had a tool that makes our computer port publicly accessible?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特别是在与他人合作或开发与在线服务集成时，我们需要使我们的计算机可以从互联网访问。这些信息可以从我们可靠的路由器获取，但如果我们只需要一个工具来使我们的计算机端口公开访问，那不是更容易吗？
- en: Luckily for us there is such a tool!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有这样的工具！
- en: Meet `ngrok`, the versatile one line command that makes you forget about router
    configuration and continuous redeploys. `Ngrok` is a simple tool that exposes
    a port from our computer to a unique domain name publicly available on the Internet.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下`ngrok`，这个多功能的一行命令让你忘记路由器配置和持续部署。`Ngrok`是一个简单的工具，它将我们计算机上的一个端口暴露给互联网上一个唯一的域名。
- en: How does it do it?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何做到的？
- en: Well, let's see it in action!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看它的运行方式！
- en: 'Go to the website, click on the **Download** button, and choose your destiny.
    In our case, our destiny is the Linux package in 64-bit. Next, go to the terminal,
    unzip the file, and copy its contents to the `bin` folder:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 转到网站，点击**下载**按钮，选择你的命运。在我们的情况下，我们的命运是64位的Linux包。接下来，进入终端，解压文件，并将其内容复制到`bin`文件夹中：
- en: '`cd` downloads'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd` downloads'
- en: '`unzip ngrok.zip`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unzip ngrok.zip`'
- en: '`mv ngrok ~/bin`![From localhost to instant DNS](img/image_05_040.jpg)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv ngrok ~/bin`![从本地主机到即时DNS](img/image_05_040.jpg)'
- en: 'Now do a rehash and type the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新加载并输入以下命令：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![From localhost to instant DNS](img/image_05_041.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![从本地主机到即时DNS](img/image_05_041.jpg)'
- en: 'We can see that port forwarding for ports 80 and 443 is running on our local
    80 port, at a custom `ngrok` subdomain name. We can also see the region of the
    server, which by default is located in the US. If we are in a different region
    we can set this with the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到端口转发80和443正在我们的本地80端口上运行，使用一个自定义的`ngrok`子域名。我们还可以看到服务器的地区，默认情况下位于美国。如果我们在不同的地区，我们可以使用以下命令进行设置：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ngrok` server is located in Europe. In order to test our `ngrok` server,
    let''s use our trusty Python server to show a simple HTML page:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngrok`服务器位于欧洲。为了测试我们的`ngrok`服务器，让我们使用我们可靠的Python服务器来显示一个简单的HTML页面：'
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![From localhost to instant DNS](img/image_05_042.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![从本地主机到即时DNS](img/image_05_042.jpg)'
- en: 'Then restart `ngrok` with the HTTP traffic forwarded from port `8000`, the
    default Python web server port:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用从端口`8000`转发的HTTP流量重新启动`ngrok`，这是默认的Python Web服务器端口：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![From localhost to instant DNS](img/image_05_043.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![从本地主机到即时DNS](img/image_05_043.jpg)'
- en: Click on the link provided by `ngrok`, and we will see our web page accessible
    to the Internet.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`ngrok`提供的链接，我们将看到我们的网页可以被互联网访问。
- en: That's it. No configuration, no account, no headaches. Just a simple one line
    command that we can run from anywhere. The subdomain provided by `ngrok` is a
    generated one and will change every time we restart `ngrok`. We have the option
    of using our custom domain name like Linux [https://ngrok.com/](https://ngrok.com/),
    but only after acquiring a paid account.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。没有配置，没有账户，没有烦恼。只需一条简单的命令，我们可以从任何地方运行。`ngrok`提供的子域名是一个生成的域名，每次重新启动`ngrok`时都会更改。我们可以选择使用我们自定义的域名，比如Linux
    [https://ngrok.com/](https://ngrok.com/)，但前提是要获得一个付费账户。
- en: The `ngrok` also has a web interface at `http://127.0.0.1:4040` where we can
    see statistics and logs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngrok`还有一个Web界面，位于`http://127.0.0.1:4040`，我们可以在那里查看统计数据和日志。'
- en: 'Power comes from ease of use and `ngrok` provides us with that power:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 强大来自于易用性，而`ngrok`为我们提供了这种力量：
- en: '![From localhost to instant DNS](img/image_05_044.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![从本地主机到即时DNS](img/image_05_044.jpg)'
- en: 'Here are some specific scenarios for using this powerful tool:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这个强大工具的一些具体场景：
- en: When testing integrations with online services that require a callback `url`,
    such as oAuth login and online payments
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试需要回调`url`的在线服务集成时，例如oAuth登录和在线支付
- en: When developing mobile applications that connect to a local service
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发连接到本地服务的移动应用程序时
- en: When we want to expose an `ssh` port
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要暴露一个`ssh`端口时
- en: When we want to give our clients access to a webpage on our laptop, to show
    them some code, maybe
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要让我们的客户访问我们笔记本上的一个网页，向他们展示一些代码，也许
- en: JSON jamming in the new age
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON在新时代的流行
- en: Nowadays, JSON is everywhere, in web `apis`, in configuration files, even in
    logs. JSON is the default format used to structure data. Because it is used so
    much, there will be times when we will need to process JSON from the command line.
    Could you imagine doing this with `grep`, `sed,` or other conventional tools?
    That would be quite a challenge.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，JSON无处不在，出现在Web `api`、配置文件甚至日志中。JSON是用于结构化数据的默认格式。因为它被广泛使用，所以有时我们需要在命令行中处理JSON。你能想象用`grep`、`sed`或其他传统工具来做这个吗？那将是一个相当大的挑战。
- en: Luckily for us, there is a simple Command-line tool called `jq` that we can
    use to query JSON files. It comes with its own language syntax, as we will see
    in just a few minutes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的命令行工具叫做`jq`，我们可以用它来查询JSON文件。它有自己的语言语法，我们将在几分钟内看到。
- en: 'First let''s install `jq` with the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令安装`jq`：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![JSON jamming in the new age](img/image_05_045.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![JSON在新时代的流行](img/image_05_045.jpg)'
- en: 'Now let''s use an example file, a dummy access log in JSON format: `access.log`,
    which we can also find in the course GitHub repository.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一个示例文件，一个以JSON格式的虚拟访问日志：`access.log`，我们也可以在课程的GitHub存储库中找到它。
- en: 'Let''s start with some simple queries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的查询开始：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![JSON jamming in the new age](img/image_05_046.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_046.jpg)'
- en: 'We will print the JSON objects back to the screen, in a pretty format:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以漂亮的格式将JSON对象打印回屏幕上：
- en: '![JSON jamming in the new age](img/image_05_047.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_047.jpg)'
- en: 'If we want to grab the `request` method from each request, run the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取每个请求的`request`方法，请运行以下命令：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![JSON jamming in the new age](img/image_05_048.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_048.jpg)'
- en: 'This will print the request method from each `json` object. Notice the double
    quotes around each method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印每个`json`对象的请求方法。请注意每个方法周围的双引号：
- en: '![JSON jamming in the new age](img/image_05_049.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_049.jpg)'
- en: 'If we want to use the output as input to other scripts we probably don''t want
    the double quotes and that is where the `-r` (raw output) comes in handy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将输出作为其他脚本的输入，我们可能不希望有双引号，这就是`-r`（原始输出）的用处所在：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![JSON jamming in the new age](img/image_05_050.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_050.jpg)'
- en: 'The `jq` is often used for big data queries at a much smaller scale:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`经常用于在更小的规模上进行大数据查询：'
- en: '![JSON jamming in the new age](img/image_05_051.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_051.jpg)'
- en: 'Say, for example, if we want to calculate a statistic of request methods on
    the log file, we could run the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要计算日志文件中请求方法的统计信息，我们可以运行以下命令：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![JSON jamming in the new age](img/image_05_052.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_052.jpg)'
- en: 'Now we can see a count of `get`, `put`, `post,` and `delete` requests. If we
    want the same type of calculation for another field, say `apikey`, we can run
    the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到`get`、`put`、`post`和`delete`请求的计数。如果我们想要对另一个字段（比如`apikey`）进行相同类型的计算，我们可以运行以下命令：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![JSON jamming in the new age](img/image_05_053.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_053.jpg)'
- en: Since that the syntax for accessing nested fields is to just use the dot as
    a delimiter between them. Also notice that we are using single quotes instead
    of double quotes to mark our query as a string. As you probably know, the difference
    between single and double quotes in shell scripting is that double-quoted strings
    will try to expand variables, while single quoted strings will be treated as a
    fixed string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问嵌套字段的语法是使用点作为分隔符，因此请注意我们使用单引号而不是双引号来标记我们的查询为字符串。正如您可能知道的，shell脚本中单引号和双引号的区别在于双引号字符串将尝试展开变量，而单引号字符串将被视为固定字符串。
- en: 'To query for the request bodies, we will be using the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询请求体，我们将使用以下命令：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![JSON jamming in the new age](img/image_05_054.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_054.jpg)'
- en: 'As we can see from the output, even empty request bodies are logged and will
    be printed by `jq`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，即使是空的请求体也会被记录并由`jq`打印出来：
- en: '![JSON jamming in the new age](img/image_05_055.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_055.jpg)'
- en: 'To skip printing empty bodies, we can use jq''s query language to select all
    documents without an empty body:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跳过打印空的请求体，我们可以使用jq的查询语言来选择所有没有空请求体的文档：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![JSON jamming in the new age](img/image_05_056.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_056.jpg)'
- en: 'If we want to refine our search even more and only print the first element
    in the `dataIds` object of the request body, use the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进一步细化搜索并且只打印请求体的`dataIds`对象中的第一个元素，请使用以下命令：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![JSON jamming in the new age](img/image_05_057.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_057.jpg)'
- en: 'We can even perform arithmetic operations with the returned value, such as
    incrementing it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以对返回的值执行算术运算，例如递增它：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![JSON jamming in the new age](img/image_05_058.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_058.jpg)'
- en: 'There are many more examples and use cases for `jq`: just go to the official
    `jq` page and visit the tutorial there:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`还有许多其他示例和用例：只需访问官方`jq`页面并查看教程：'
- en: '[https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
- en: '![JSON jamming in the new age](img/image_05_059.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![JSON jamming in the new age](img/image_05_059.jpg)'
- en: 'There we can see an example of consuming a rest API that returns `json` and
    pipes it to `jq`. To print a `json` with the commit messages from a `github` repository,
    run the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个使用返回`json`并将其传输到`jq`的rest API的示例。要打印带有来自`github`存储库的提交消息的`json`，请运行以下命令：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we said, there are many more examples in the documentation, and many more
    use cases. `jq` is a pretty powerful tool, and a must when interacting with `json`
    from the command line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，文档中还有许多其他示例和用例。`jq`是一个非常强大的工具，在与命令行中的`json`交互时必不可少。
- en: No more mister nice guy
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不再是好人了
- en: The kernel and command line in Linux are stable and powerful. Their reliability
    has been proven throughout the years, with modern legends about Linux servers
    running for multiple years in a row without restarting. However, graphical interfaces
    are not the same, and they sometimes fail or become unresponsive. This can become
    annoying and it's always good to have a quick way of killing unresponsive windows.
    Prepare to meet `xkill`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的内核和命令行是稳定且强大的。它们的可靠性在多年来得到了证明，现代关于Linux服务器连续运行多年而无需重新启动的传说。然而，图形界面并非如此，它们有时会失败或变得无响应。这可能变得很烦人，因此拥有一种快速关闭无响应窗口的方法总是很好。准备好见到`xkill`。
- en: 'First, let''s replicate an unresponsive window. Go to the terminal and start
    `gedit`: and then hit *Ctrl* + *z*. This will send `gedit` to the background,
    while the window is still visible. Trying to click inside the window a couple
    of times will tell Ubuntu that there is no process handling this window anymore
    and Ubuntu will make it gray:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们复制一个无响应的窗口。转到终端并启动`gedit`：然后按下*Ctrl* + *z*。这将将`gedit`发送到后台，同时窗口仍然可见。尝试在窗口内点击几次将告诉Ubuntu没有进程处理此窗口，Ubuntu将使其变灰：
- en: '![No more mister nice guy](img/image_05_060.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![不再是好人](img/image_05_060.jpg)'
- en: 'Hit *Ctrl* + *z*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *z*：
- en: '![No more mister nice guy](img/image_05_061.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![不再是好人](img/image_05_061.jpg)'
- en: 'This will send `gedit` to the background, while the window is still visible.
    Trying to click inside the window a couple of times will tell Ubuntu that there
    is no process handling this window anymore and Ubuntu will make it grey:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`gedit`进入后台，同时窗口仍然可见。尝试在窗口内点击几次将告诉Ubuntu没有进程再处理此窗口，Ubuntu将使其变灰：
- en: '![No more mister nice guy](img/image_05_062.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![不再是好人](img/image_05_062.jpg)'
- en: 'To avoid the process of grepping for the `pid` of the window and then killing
    that process we use a little trick. Go to the terminal and run the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免通过查找窗口的`pid`然后杀死该进程的过程，我们使用一个小技巧。进入终端并运行以下命令：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![No more mister nice guy](img/image_05_063.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![不再是好人](img/image_05_063.jpg)'
- en: Now we see that the mouse pointer has changed to an `x`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到鼠标指针已经变成了一个`x`。
- en: Be careful not to click on anything. Hit *Alt* + *Tab* to bring back the `gedit`
    window, and then click it. The `xkill` command will find and kill the process
    of the window we just clicked on.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要点击任何东西。按下*Alt* + *Tab*将`gedit`窗口带回来，然后点击它。`xkill`命令将找到并杀死我们刚刚点击的窗口的进程。
- en: This trick can be used on any type of window; it's like shooting your windows!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧可以用于任何类型的窗口；就像射击您的窗口一样！
- en: OK, but what happens if the whole system becomes unresponsive and you can't
    type anything in the command line? That might happen, especially on older systems.
    You can hit the **on/off** button on your laptop or server, but in some circumstances,
    this is not possible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，但是如果整个系统变得无响应，您无法在命令行中输入任何内容会发生什么？这可能会发生，特别是在旧系统上。您可以按下笔记本电脑或服务器上的**开/关**按钮，但在某些情况下，这是不可能的。
- en: 'What we are going to show you now is an old trick kept secret by Linux gurus
    for a very long time; nobody really talks about it because it''s so powerful that
    it can do damage in the hands of the wrong people. Please make sure you save all
    your work and close all programs before trying the fatal keyboard shortcut that
    will force a restart of your Linux system. Hold down *Alt* + *PrtScrn* and at
    the same time type the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要向您展示的是一个由Linux专家保守了很长时间的秘密技巧；没有人真正谈论它，因为它非常强大，可以在错误的人手中造成损害。请确保在尝试致命的键盘快捷方式之前保存所有工作并关闭所有程序，这将强制重新启动您的Linux系统。同时按住*Alt*
    + *PrtScrn*，然后输入以下内容：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you've tried it, it means that your computer restarted and you had to come
    back to this course and continue where you left off.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试过，那意味着您的计算机已重新启动，您必须回到本课程并继续之前的进度。
- en: Practice this command with great caution and please don't use it to restart
    your computer on a regular basis. Use it only when the **graphical user interface**
    (**GUI**) is not responding.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心谨慎地练习此命令，并请不要经常使用它来重新启动您的计算机。只有在**图形用户界面**（**GUI**）无响应时才使用它。
- en: 'Another trick: if the GUI is not responding and you have unsaved work, you
    can recover some of it from the command line, by accessing one of Linux''s virtual
    terminals. Ubuntu starts, by default, seven virtual terminals and the graphical
    user interface starts on terminal 7\. To access any of the seven terminals use
    *Ctrl* + *Alt* + *F1* to *F7*. A prompt will appear asking you to log in and,
    after logging in, you can run some commands to close processes and save work before
    exiting. To get back to the user interface, hit *Ctrl* + *Alt* + *F1*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧：如果GUI无响应并且您有未保存的工作，您可以通过访问Linux的一个虚拟终端从命令行中恢复其中一部分。Ubuntu默认启动七个虚拟终端，图形用户界面在终端7上启动。要访问任何七个终端之一，请使用*Ctrl*
    + *Alt* + *F1*到*F7*。会出现提示要求您登录，登录后，您可以运行一些命令来关闭进程并保存工作后退出。要返回用户界面，请按下*Ctrl* +
    *Alt* + *F1*。
