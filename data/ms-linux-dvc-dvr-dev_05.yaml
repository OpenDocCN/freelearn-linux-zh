- en: '*Chapter 4*: Storming the Common Clock Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：突袭通用时钟框架'
- en: From the beginning, embedded systems have always needed clock signals in order
    to orchestrate their inner workings, either for synchronization or for power management
    (for example, enabling clocks when the device is in active use or adjusting the
    clock depending on some criteria, such as the system load). Therefore, Linux has
    always had a clock framework. There has only ever been programming interface declaration
    support for software management of the system clock tree, and each platform had
    to implement this API. Different **System on Chips** (**SoCs**) had their own
    implementation. This was okay for a while, but people soon found that their hardware
    implementations were quite similar. The code also became bushy and redundant,
    which meant it was necessary to use platform-dependent APIs to get/set the clock.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，嵌入式系统一直需要时钟信号来编排其内部工作，无论是用于同步还是用于电源管理（例如，在设备处于活动状态时启用时钟，或者根据某些标准调整时钟，如系统负载）。因此，Linux一直有一个时钟框架。一直只有编程接口声明支持系统时钟树的软件管理，每个平台都必须实现此API。不同的**片上系统**（**SoCs**）有自己的实现。这样做一段时间还可以，但人们很快发现他们的硬件实现非常相似。代码也变得臃肿和冗余，这意味着需要使用平台相关的API来获取/设置时钟。
- en: This was rather an uncomfortable situation. Then, the **common clock framework
    (CCF)** came in, allowing software to manage clocks available on the system in
    a hardware-independent manner. The CCF is an interface that allows us to control
    various clock devices (most of time, these are embedded in SoCs) and offers a
    uniform API that can be used to control them (enabling/disabling, getting/setting
    the rate, gating/un-gating, and so on). In this chapter, the concept of a clock
    does not refer to **Real-Time Clocks** (**RTCs**), nor timekeeping devices, which
    are other kinds of devices that have their own subsystems in the kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当不舒服的情况。然后，**通用时钟框架（CCF）**出现了，允许软件以硬件无关的方式管理系统上可用的时钟。CCF是一个接口，允许我们控制各种时钟设备（大多数时候，这些设备嵌入在SoCs中），并提供可用于控制它们的统一API（启用/禁用，获取/设置速率，门控/解除门控等）。在本章中，时钟的概念并不是指**实时时钟**（**RTC**）或时间设备，这些是内核中具有自己子系统的其他类型设备。
- en: 'The main idea behind the CCF is to unify and abstract the similar code that''s
    spread in different SoC clock drivers. This standardized approach introduced the
    concept of a clock provider and a clock consumer in the following manner:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CCF的主要思想是统一和抽象分散在不同SoC时钟驱动程序中的相似代码。这种标准化方法以以下方式引入了时钟提供者和时钟消费者的概念：
- en: Providers are Linux kernel drivers that connect with the framework and provide
    access to hardware, thereby providing (making these available to consumers) the
    clock tree (thanks to which one can dump the whole clock tree nowadays) according
    to the SoC datasheet.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者是Linux内核驱动程序，它们与框架连接并提供对硬件的访问，从而提供（使这些可用于消费者）时钟树（现在可以通过SoC数据表转储整个时钟树）。
- en: Consumers are Linux kernel drivers or subsystems that access the framework through
    a common API.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者是通过公共API访问框架的Linux内核驱动程序或子系统。
- en: That being said, a driver can be both a provider and a consumer (it would then
    either consume one or more clocks it provides, or one or more clocks provided
    by others).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也就是说，驱动程序既可以是提供者，也可以是消费者（它可以消耗它提供的一个或多个时钟，或者消耗其他人提供的一个或多个时钟）。
- en: 'In this chapter, we will introduce CCF data structures, and then focus on writing
    clock provider drivers (regardless of the clock type) before introducing the consumer
    API. We will do this by covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍CCF数据结构，然后专注于编写时钟提供者驱动程序（无论时钟类型），然后介绍消费者API。我们将通过以下主题来实现这一点：
- en: CCF data structures and interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CCF数据结构和接口
- en: Writing a clock provider device driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写时钟提供者设备驱动程序
- en: Clock consumer device drivers and APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟消费者设备驱动程序和API
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的技术要求：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机体系结构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获取。
- en: CCF data structures and interfaces
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CCF数据结构和接口
- en: In the old kernel days, each platform had to implement a basic API defined in
    the kernel (to grab/release the clock, set/get the rate, enable/disable the clock,
    and so on) that could be used by consumer drivers. Since the implementation of
    these specific APIs was done by each machine's code, this resulted in a similar
    file in each machine directory, with similar logic to implement the clock provider
    functions. This had several drawbacks, among which there was a lot of redundant
    code inside them. Later, the kernel abstracted this common code in the form of
    a clock provider (`drivers/clk/clk.c`), which became what we now call the CCF
    core.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的内核时代，每个平台都必须实现内核中定义的基本API（抓取/释放时钟，设置/获取速率，启用/禁用时钟等），这些API可以被消费者驱动程序使用。由于这些特定API的实现是由每台机器的代码完成的，这导致每个机器目录中都有一个类似的文件，具有类似的逻辑来实现时钟提供者功能。其中有很多冗余代码。后来，内核将这些公共代码抽象成了时钟提供者（`drivers/clk/clk.c`），这就是我们现在称之为CCF核心的东西。
- en: 'Before playing with the CCF, its support needs to be pulled into the kernel
    by means of the `CONFIG_COMMON_CLK` option. The CCF itself is divided into two
    halves:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CCF之前，需要通过`CONFIG_COMMON_CLK`选项将其支持引入内核。CCF本身分为两个部分：
- en: '`struct clk`, which unifies the framework-level code and the traditional platform-dependent
    implementation that used to be duplicated across a variety of platforms. This
    half also allows us to wrap the consumer interface (also called the `struct clk_ops`,
    which must be provided by each clock provider.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk`，它统一了框架级别的代码和传统的依赖于平台的实现，这些实现过去在各种平台上都是重复的。这一部分还允许我们包装消费者接口（也称为`struct
    clk_ops`），每个时钟提供者都必须提供这个接口。'
- en: '`struct clk_ops` that corresponds to the callbacks that are used to let us
    operate on the underlying hardware (these are invoked by the clock''s core implementation),
    as well as the corresponding hardware-specific structures that wrap and abstract
    the clock hardware.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk_ops`对应于用于让我们操作底层硬件的回调（这些回调由时钟的核心实现调用），以及包装和抽象时钟硬件的相应硬件特定结构。'
- en: The two halves are tied together by the `struct clk_hw` structure. This structure
    helps us with implementing our own hardware clock type. In this chapter, this
    is referenced as `struct clk_foo`. Since `struct clk_hw` is also pointed to within
    `struct clk`, it allows for navigation between the two halves.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分由`struct clk_hw`结构绑定在一起。这个结构帮助我们实现自己的硬件时钟类型。在本章中，这被称为`struct clk_foo`。由于`struct
    clk_hw`也在`struct clk`中指向，它允许在这两个部分之间进行导航。
- en: 'Now, we can introduce CCF data structures. The CCF is built on top of common
    heterogeneous data structures (in `include/linux/clk-provider.h`) that help keep
    this framework as generic as possible. These are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以介绍CCF数据结构。CCF是建立在通用异构数据结构（在`include/linux/clk-provider.h`中）之上的，这些数据结构帮助尽可能地使这个框架通用化。它们如下：
- en: '`struct clk_hw`: This structure abstracts the hardware clock line and is used
    in the provider code only. It ties the two halves introduced previously and allows
    navigation to occur between them. Moreover, this hardware clock''s base structure
    allows platforms to define their own hardware-specific clock structure, along
    with their own clock operation callbacks, as long as they wrap an instance of
    the `struct clk_hw` structure.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk_hw`：这个结构抽象了硬件时钟线，只在提供者代码中使用。它将前面介绍的两个部分联系在一起，并允许在它们之间进行导航。此外，这个硬件时钟的基本结构允许平台定义自己的硬件特定时钟结构，以及它们自己的时钟操作回调，只要它们包装一个`struct
    clk_hw`结构的实例。'
- en: '`struct clk_ops`: This structure represents the hardware-specific callbacks
    that can operate on a clock line; that is, the hardware. This is why all of the
    callbacks in this structure accept a pointer to a `struct clk_hw` as the first
    parameter, though only a few of these operations are mandatory, depending on the
    clock type.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk_ops`：这个结构表示可以操作时钟线的硬件特定回调；也就是硬件。这就是为什么这个结构中的所有回调都接受一个`struct clk_hw`的指针作为第一个参数，尽管根据时钟类型，只有少数这些操作是强制性的。'
- en: '`struct clk_init_data`: This holds `init` data that''s common to all clocks
    that are shared between the clock provider and the common clock framework. The
    clock provider is responsible for preparing this static data for each clock in
    the system, and then handing it to the core logic of the clock framework.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk_init_data`：这个结构保存了所有时钟共享的`init`数据，这些数据在时钟提供者和通用时钟框架之间。时钟提供者负责为系统中的每个时钟准备这些静态数据，然后将其交给时钟框架的核心逻辑。'
- en: '`struct clk`: This structure is the consumer representation of a clock since
    each consumer API relies on this structure.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk`：这个结构是时钟的消费者表示，因为每个消费者API都依赖于这个结构。'
- en: '`struct clk_core`: This is the CCF representation of a clock.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct clk_core`：这是时钟的CCF表示。'
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Discerning the difference between `struct clk_hw` and `struct clk` allows us
    to move closer to a clear split between the consumer and provider clk APIs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 区分`struct clk_hw`和`struct clk`之间的差异使我们能够更接近消费者和提供者clk API之间的清晰分离。
- en: Now that we have enumerated the data structures of this framework, we can go
    through them and learn how they are implemented and what they are used for.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列举了这个框架的数据结构，我们可以逐个学习它们是如何实现的以及它们的用途。
- en: Understanding struct clk_hw and its dependencies
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解struct clk_hw及其依赖关系
- en: '`struct clk_hw` is the base structure for every clock type in the CCF. It can
    be seen as a handle for traversing from a `struct clk` to its corresponding hardware-specific
    structure. The following is the body of `struct clk_hw`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct clk_hw`是CCF中每种时钟类型的基本结构。它可以被看作是从`struct clk`到其对应的硬件特定结构的句柄。以下是`struct
    clk_hw`的主体：'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look at the fields in the preceding structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前面结构中的字段：
- en: '`core`: This structure is internal to the framework core. It also internally
    points back to this `struct clk_hw` instance.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`：这个结构是框架核心的内部结构。它也在内部指向这个`struct clk_hw`实例。'
- en: '`clk`: This is a per-user `struct clk` instance that can operate with the `clk`
    API. It is assigned and maintained by the clock framework and provided to the
    clock consumer when needed. Whenever the consumer initiates access to the clock
    device (that is, `clk_core`) in the CCF through `clk_get`, it needs to obtain
    a handle, which is `clk`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk`：这是一个每个用户的`struct clk`实例，可以使用`clk` API。它由时钟框架分配和维护，并在需要时提供给时钟消费者。每当消费者通过`clk_get`在CCF中对时钟设备（即`clk_core`）进行访问时，它需要获取一个句柄，即`clk`。'
- en: '`init`: This is a pointer to `struct clk_init_data`. In the process of initializing
    the underlying clock provider driver, the `clk_register()` interface is called
    to register the clock hardware. Prior to this, you need to set some initial data,
    and this initial data is abstracted into a `struct clk_init_data` data structure.
    During the initialization process, the data from `clk_init_data` is used to initialize
    the `clk_core` data structure that corresponds to `clk_hw`. When the initialization
    is completed, `clk_init_data` has no meaning.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这是指向`struct clk_init_data`的指针。在初始化底层时钟提供程序驱动程序的过程中，调用`clk_register()`接口来注册时钟硬件。在此之前，您需要设置一些初始数据，这些初始数据被抽象为`struct
    clk_init_data`数据结构。在初始化过程中，来自`clk_init_data`的数据用于初始化与`clk_hw`对应的`clk_core`数据结构。初始化完成后，`clk_init_data`就没有意义了。'
- en: '`struct clk_init_data` is defined as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct clk_init_data` 的定义如下：'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It holds initialization data that''s common to all clocks and is shared between
    the clock provider and the common clock framework. Its fields are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它保存了所有时钟通用的初始化数据，并在时钟提供程序和通用时钟框架之间共享。其字段如下：
- en: '`name`, which denotes the name of the clock.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`，表示时钟的名称。'
- en: '`ops` is a set of operation functions related to the clock. This will be described
    later in the *Providing clock ops* section. Its callbacks are to be provided by
    the clock provider driver (in order to allow driving hardware clocks), and will
    be invoked by drivers through the `clk_*` consumer API.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops` 是与时钟相关的一组操作函数。这将在*提供时钟操作*部分中进行描述。它的回调将由时钟提供程序驱动程序提供（以允许驱动硬件时钟），并将由驱动程序通过`clk_*`消费者API调用。'
- en: '`parent_names` contains the names of all the parent clocks of the clock. This
    is an array of strings that holds all possible parents.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_names` 包含时钟的所有父时钟的名称。这是一个字符串数组，保存了所有可能的父时钟。'
- en: '`num_parents` is the number of parents. It should correspond to the number
    of entries in the preceding array.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_parents` 是父时钟的数量。它应该与前面数组中的条目数对应。'
- en: '`flags` represent the framework-level flags of the clock. We will explain this
    in detail later in the *Providing clock ops* section, since these flags actually
    modify some `ops`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 代表时钟的框架级标志。我们将在*提供时钟操作*部分详细解释这一点，因为这些标志实际上修改了一些`ops`。'
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`struct clk` and `struct clk_core` are private data structures and are defined
    in `drivers/clk/clk.c`. The `struct clk_core` structure abstracts a clock device
    to the CCF layer in such a way that each actual hardware clock device (`struct
    clk_hw`) corresponds to a `struct clk_core`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct clk` 和 `struct clk_core` 是私有数据结构，定义在 `drivers/clk/clk.c` 中。`struct
    clk_core` 结构以一种抽象的方式将时钟设备抽象到CCF层，以便每个实际的硬件时钟设备（`struct clk_hw`）对应一个`struct clk_core`。'
- en: Now that we are done with `struct clk_hw`, which is the centerpiece of the CCF,
    we can learn how to register a clock provider with the system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了CCF的核心`struct clk_hw`，我们可以学习如何向系统注册时钟提供程序。
- en: Registering/unregistering the clock provider
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册/注销时钟提供程序
- en: The clock provider is responsible for exposing the clocks it provides in the
    form of a tree, sorting them out, and initializing the interface through the provider
    or the clock framework's core during system initialization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟提供程序负责以树的形式公开其提供的时钟，对其进行排序，并在系统初始化期间通过提供程序或时钟框架的核心初始化接口进行初始化。
- en: 'In the early kernel days (before the CCF), clock registration was unified by
    the `clk_register()` interface. Now that we have `clk_hw`-based (provider) APIs,
    we can get rid of `struct clk`-based APIs while registering clocks. Since it''s
    recommended that clock providers use the new `struct clk_hw`-based API, the appropriate
    registration interface to consider is `devm_clk_hw_register()`, which is the managed
    version of `clk_hw_register()`. However, for historical reasons, the old `clk`-based
    API name is still maintained, and you may find several drivers using it. A resource
    managed version has even been implemented called `devm_clk_register()`. We''re
    only discussing this old API is to let you understand the existing code, not to
    help you implement new drivers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的内核版本（在CCF之前），时钟注册是通过`clk_register()`接口统一的。现在我们有基于`clk_hw`（提供程序）的API，可以在注册时钟时摆脱基于`struct
    clk`的API。由于建议时钟提供程序使用新的基于`struct clk_hw`的API，因此要考虑的适当注册接口是`devm_clk_hw_register()`，这是`clk_hw_register()`的托管版本。然而，出于历史原因，旧的基于`clk`的API名称仍然保留，您可能会发现一些驱动程序在使用它。甚至还实现了一个资源托管版本，称为`devm_clk_register()`。我们只讨论这个旧的API是为了让您了解现有的代码，而不是帮助您实现新的驱动程序：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on this `clk_hw_register()` interface, the kernel also provides other
    more convenient registration interfaces (which will be introduced later), depending
    on the clock type to be registered. It is responsible for registering the clock
    to the kernel and returning a `struct clk_hw` pointer representing the clock.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个`clk_hw_register()`接口，内核还提供了其他更方便的注册接口（稍后将介绍），具体取决于要注册的时钟类型。它负责将时钟注册到内核并返回表示时钟的`struct
    clk_hw`指针。
- en: 'It accepts a pointer to a `struct clk_hw` (since `struct clk_hw` is the provider
    side representation of a clock) and must contain some of the information of the
    clock to be registered. This will be populated with further data by the kernel.
    The implementation logic for this is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个指向`struct clk_hw`的指针（因为`struct clk_hw`是时钟提供程序侧的时钟表示），并且必须包含要注册的时钟的一些信息。内核将进一步填充这些数据。其实现逻辑如下：
- en: 'Assigning the `struct clk_core` space (`clk_hw->core`):'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配`struct clk_core`空间（`clk_hw->core`）：
- en: --Initializing the field's name, `ops`, `hw`, `flags`, `num_parents`, and `parents_names`
    of `clk` according to the information provided by the `struct clk_hw` pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: --根据`struct clk_hw`指针提供的信息，初始化`clk`的字段名称、`ops`、`hw`、`flags`、`num_parents`和`parents_names`。
- en: --Calling the kernel interface, `__clk_core_init()`, on it to perform subsequent
    initialization operations, including building the clock tree hierarchy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: --在其上调用内核接口`__clk_core_init()`，执行后续的初始化操作，包括构建时钟树层次结构。
- en: Assigning the `struct clk` space (`clk_hw->clk`) by means of the internal kernel
    interface, `clk_create_clk()`, and returning this `struct clk` variable.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内部内核接口`clk_create_clk()`分配`struct clk`空间（`clk_hw->clk`），并返回此`struct clk`变量。
- en: Even though `clk_hw_register()` wraps `clk_register()`, you should not use `clk_register()`
    directly as it returns `struct clk`. This may lead to confusion and breaks the
    strict separation between the provider and consumer interfaces.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管`clk_hw_register()`包装了`clk_register()`，但您不应该直接使用`clk_register()`，因为它返回`struct
    clk`。这可能会导致混淆，并破坏提供程序和使用者接口之间的严格分离。
- en: 'The following is the implementation of `clk_hw_register` in `drivers/clk/clk.c`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`drivers/clk/clk.c`中`clk_hw_register`的实现：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should check the return value of `clk_hw_register()` prior to executing
    further steps. Since the CCF framework is responsible for establishing the tree
    structure of the entire abstract clock tree and maintaining its data, it does
    this by means of two static linked lists that are defined in `drivers/clk/clk.c`,
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行进一步步骤之前，应该检查`clk_hw_register()`的返回值。由于CCF框架负责建立整个抽象时钟树的树结构并维护其数据，它通过在`drivers/clk/clk.c`中定义的两个静态链接列表来实现这一点，如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Whenever you call `clk_hw_register()` (which internally calls `__clk_core_init()`
    in order to initialize the clock) on a clock `hw`, if there is a valid parent
    for this clock, it will end up in the `children` list of the parent. On other
    hand, if `num_parent` is `0`, it is placed in `clk_root_list`. Otherwise, it will
    hang inside `clk_orphan_list`, meaning that it has no valid parent. Moreover,
    every time a new `clk` is clk_init'd, CCF will walk through `clk_orphan_list`
    (the list of orphan clocks) and re-parent any that are children of the clock currently
    being initialized. This is how CCF keeps the clock tree consistent with the hardware
    topology.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在时钟`hw`上调用`clk_hw_register()`（在内部调用`__clk_core_init()`以初始化时钟）时，如果此时钟有有效的父级，则它将最终出现在父级的`children`列表中。另一方面，如果`num_parent`为`0`，它将放置在`clk_root_list`中。否则，它将挂在`clk_orphan_list`中，这意味着它没有有效的父级。此外，每当初始化新的`clk`时，CCF将遍历`clk_orphan_list`（孤立时钟的列表），并重新将任何子时钟重新连接到当前正在初始化的时钟。这就是CCF如何保持时钟树与硬件拓扑一致。
- en: On the other hand, `struct clk` is the consumer-side instance of a clock device.
    Basically, all user access to the clock device creates an access handle of the
    `struct clk` type. When different users access the same clock device, although
    the same `struct clk_core` instance is being used under the hood, the handles
    they access (`struct clk`) are different.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`struct clk`是时钟设备的使用者端实例。基本上，对时钟设备的所有用户访问都会创建`struct clk`类型的访问句柄。当不同的用户访问同一个时钟设备时，尽管在幕后使用相同的`struct
    clk_core`实例，但他们访问的句柄（`struct clk`）是不同的。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should keep in mind that `clk_hw_register` (or its ancestor, `clk_register()`)
    plays with `struct clk_core` under the hood since this is the CCF representation
    of a clock.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，`clk_hw_register`（或其祖先`clk_register()`）在幕后使用`struct clk_core`，因为这是时钟的CCF表示。
- en: 'The CCF manages `clk` entities by means of a globally linked list declared
    in `drivers/clk/clkdev.c`, along with a mutex to protect its access, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CCF通过在`drivers/clk/clkdev.c`中声明的全局链接列表来管理`clk`实体，以及用于保护其访问的互斥体，如下所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This comes from the era where the device tree was not heavily used. Back then,
    the clock consumer obtained clk by name (the name of the clk). This was used to
    identify clocks. Knowing that the purpose of `clk_register()` is just to register
    to the common clock framework, there was no way for the consumer to know how to
    locate the clk. So, for the underlying clock provider driver, in addition to calling
    the `clk_register()` function to register to the common clock framework, `clk_register_clkdev()`
    also had to be called immediately after `clk_register()` in order to bind the
    clock with a name (otherwise, the clock consumer wouldn't know how to locate the
    clock). Therefore, the kernel used `struct clk_lookup`, as its name says, to look
    up the available clock in case a consumer requested a clock (by name, of course).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自设备树没有被大量使用的时代。那时，时钟使用者通过名称（时钟的名称）获取时钟。这用于识别时钟。知道`clk_register()`的目的只是注册到公共时钟框架，使用者无法知道如何定位时钟。因此，对于底层时钟提供程序驱动程序，除了调用`clk_register()`函数注册到公共时钟框架外，还必须立即在`clk_register()`之后调用`clk_register_clkdev()`以绑定时钟与名称（否则，时钟使用者将不知道如何定位时钟）。因此，内核使用`struct
    clk_lookup`，正如其名称所示，以查找可用的时钟，以防使用者请求时钟（当然是通过名称）。
- en: This mechanism is still valid and supported in the kernel. However, in order
    to enforce separation between the provider and consumer code using a `hw`-based
    API, `clk_register()` and `clk_register_clkdev()` should be replaced with `clk_hw_register()`
    and `clk_hw_register_clkdev()` in your code, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制在内核中仍然有效并得到支持。但是，为了通过基于`hw`的API强制执行提供程序和使用者代码之间的分离，应该分别在您的代码中用`clk_hw_register()`和`clk_hw_register_clkdev()`替换`clk_register()`和`clk_register_clkdev()`。
- en: 'In other words, let''s say you have the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，假设您有以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should be replaced with the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该替换为以下代码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Going back to the `struct clk_lookup` data structure, let''s take a look at
    its definition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`struct clk_lookup`数据结构，让我们看一下它的定义：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding data structure, `dev_id` and `con_id` are used to identify/find
    the appropriate `clk`. This `clk` is the corresponding underlying clock. `node`
    is the list entry that will hang inside the global clocks list, as shown in the
    low-level `__clkdev_add()` function in the following excerpt:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，`dev_id`和`con_id`用于标识/查找适当的`clk`。这个`clk`是相应的底层时钟。`node`是将挂在全局时钟列表中的列表条目，如以下摘录中的低级`__clkdev_add()`函数所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding `__clkdev_add()` function is indirectly called from within `clk_hw_register_clkdev()`,
    which actually wraps `clk_register_clkdev()`. Now that we''ve introduced the device
    tree, things have changed. Basically, each clock provider became a node in DTS;
    that is, each `clk` has a device node in the device tree that corresponds to it.
    In this case, instead of bundling `clk` and a name, it is better to bundle `clk`
    and your device nodes by means of a new data structure, `struct of_clk_provider`.
    This specific data structure is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的`__clkdev_add()`函数是间接从`clk_hw_register_clkdev()`内部调用的，它实际上包装了`clk_register_clkdev()`。现在我们介绍了设备树，事情已经改变了。基本上，每个时钟供应商都成为了DTS中的一个节点；也就是说，每个`clk`在设备树中都有一个与之对应的设备节点。在这种情况下，与其捆绑`clk`和一个名称，不如通过一个新的数据结构`struct
    of_clk_provider`来捆绑`clk`和您的设备节点。这个特定的数据结构如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding structure, the following takes place:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述结构中，发生了以下情况：
- en: '`link` hangs in the `of_clk_providers` global list.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`挂在`of_clk_providers`全局列表中。'
- en: '`node` represents the DTS node of the clock device.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`表示时钟设备的DTS节点。'
- en: '`get_hw` is a callback for the decoding clock. For devices (consumers), it
    is called through `clk_get()` to return the clock associated with the node or
    `NULL`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_hw`是解码时钟的回调函数。对于设备（消费者），通过`clk_get()`调用它来返回与节点关联的时钟或`NULL`。'
- en: '`get` is there for the old clk-based APIs for historical and compatibility
    reasons.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`是为了历史和兼容性原因而存在的旧的基于`clk`的API。'
- en: 'However, nowadays, due to the frequent and common use of the device tree, for
    the underlying provider driver, the original `clk_hw_register()` + `clk_hw_register_clkdev()`
    (or its old clk-based implementation, `clk_register()` + `clk_register_clkdev()`)
    combination becomes a combination of `clk_hw_register` + `of_clk_add_hw_provider`
    (formerly `clk_register` + `of_clk_add_provider` – this can be found in old and
    non-`clk_hw`-based drivers). Also, a new globally linked list, `of_clk_providers`,
    has been introduced in the CCF to help manage the correspondence between all DTS
    nodes and clocks, along with a mutex to protect this list:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于现在频繁和普遍使用设备树，对于底层供应商驱动程序，原始的`clk_hw_register()` + `clk_hw_register_clkdev()`（或其旧的基于`clk`的实现，`clk_register()`
    + `clk_register_clkdev()`）组合变成了`clk_hw_register` + `of_clk_add_hw_provider`（以前是`clk_register`
    + `of_clk_add_provider` - 这可以在旧的和非`clk_hw`的驱动程序中找到）。此外，CCF引入了一个新的全局链接列表`of_clk_providers`，以帮助管理所有DTS节点和时钟之间的对应关系，以及一个互斥锁来保护这个列表：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although the `clk_hw_register()` and `clk_hw_register_clkdev()` function names
    are quite similar, the goals of these two functions differ. With the former, the
    clock provider can register a clock in the common clock framework. On the other
    hand, `clk_hw_register_clkdev()`registers a `struct clk_lookup` in the common
    clock framework, as its name suggests. This operation is mainly for finding clk.
    If you have a device tree-only platform, you no longer need all the calls to `clk_hw_register_clkdev()`
    (unless you have a strong reason to), so you should rely on one call to `of_clk_add_provider()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`clk_hw_register()`和`clk_hw_register_clkdev()`函数名称非常相似，但这两个函数的目标不同。通过前者，时钟供应商可以在通用时钟框架中注册时钟。另一方面，`clk_hw_register_clkdev()`在通用时钟框架中注册了一个`struct
    clk_lookup`，正如其名称所示。这个操作主要是为了查找时钟。如果您只有设备树平台，您不再需要所有对`clk_hw_register_clkdev()`的调用（除非您有充分的理由），因此您应该依赖于一次对`of_clk_add_provider()`的调用。
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Clock providers are recommended to use the new `struct clk_hw`-based API as
    this allows us to move closer to a clear split of consumer and provider clk APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 建议时钟供应商使用新的基于`struct clk_hw`的API，因为这样可以更接近清晰地分离消费者和供应商的时钟API。
- en: '`clk_hw_*` interfaces are provider interfaces that should be used in clock
    provider drivers, while `clk_*` is for the consumer side. Whenever you encounter
    a `clk_*`-based API in provider code, note that this driver should be updated
    to support the new hw-based interface.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`clk_hw_*`接口是供应商接口，应在时钟供应商驱动程序中使用，而`clk_*`是消费者端。每当在供应商代码中遇到基于`clk_*`的API时，请注意应更新该驱动程序以支持新的基于硬件的接口。'
- en: Some drivers still use both functions (`clk_hw_register_clkdev()` and `of_clk_add_hw_provider()`)
    in order to support both clock lookup methods, such as SoC clock drivers, but
    you should not use both unless you have a reason to do so.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些驱动程序仍然同时使用这两个函数（`clk_hw_register_clkdev()`和`of_clk_add_hw_provider()`），以支持诸如SoC时钟驱动程序之类的时钟查找方法，但除非有理由这样做，否则不应同时使用这两个函数。
- en: 'So far, we have spent time discussing clock registration. However, it might
    be necessary to unregister a clock, either because the underlying clock hardware
    goes off the system or because things went wrong during hardware initialization.
    Clock unregistration APIs are fairly straightforward:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了时间讨论时钟注册。然而，注销时钟可能是必要的，要么是因为底层时钟硬件离开了系统，要么是因为在硬件初始化期间出现了问题。时钟注销API相当简单：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The former targets `clk_hw`-based clocks, while the second targets clk-based
    ones. When it comes to managed variants, unless the Devres core handles unregistration,
    you should use the following APIs:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前者针对基于`clk_hw`的时钟，而后者针对基于`clk`的时钟。在管理变体方面，除非Devres核心处理注销，否则应使用以下API：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In both case, `dev` represents the underlying device structure associated with
    the clock.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，`dev`表示与时钟关联的底层设备结构。
- en: With that, we have finished looking at clock registration/unregistration. That
    being said, one of the main purposes of the driver is to expose device resources
    to potential consumers, and this applies to clock devices as well. In the next
    section, we'll learn how to expose clock lines to consumers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经完成了时钟注册/注销的查看。也就是说，驱动程序的主要目的之一是向潜在的消费者公开设备资源，这也适用于时钟设备。在下一节中，我们将学习如何向消费者公开时钟线。
- en: Exposing clocks to others (in detail)
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向其他设备公开时钟（详细说明）
- en: 'Once the clocks have been registered with CCF, the next step consists of registering
    this clock provider so that other devices can consume its clock lines. In the
    old kernel days (when the device tree was not heavily used), you had to expose
    clocks to the consumer by calling `clk_hw_register_clkdev()` on each clock line,
    which resulted in registering a lookup structure for the given clock line. Nowadays,
    the device tree is used for this purpose by calling the `of_clk_add_hw_provider()`
    interface, as well as a certain number of arguments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦时钟已经在CCF中注册，下一步就是注册这个时钟提供者，以便其他设备可以消耗它的时钟线。在旧的内核时代（当设备树没有被大量使用时），你必须通过在每条时钟线上调用`clk_hw_register_clkdev()`来向消费者公开时钟，这导致为给定的时钟线注册查找结构。如今，可以通过调用`of_clk_add_hw_provider()`接口来使用设备树来实现这个目的，以及一定数量的参数：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a look at the arguments in this function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个函数中的参数：
- en: '`np` is the device node pointer associated with the clock provider.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np`是与时钟提供者相关的设备节点指针。'
- en: '`get` is a callback for the decoding clock. We will discuss this callback in
    detail in the next section.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`是解码时钟的回调。我们将在下一节详细讨论这个回调。'
- en: '`data` is the context pointer for the given `get` callback. This is usually
    a pointer to the clock(s) that need to be associated with the device node. This
    is useful for decoding.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`是给定`get`回调的上下文指针。这通常是一个指向需要与设备节点关联的时钟的指针。这对于解码是有用的。'
- en: 'This function returns `0` on a success path. It does the opposite to `of_clk_del_provider()`,
    which consists of removing the provider from the global list and freeing its space:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在成功时返回`0`。它与`of_clk_del_provider()`相反，后者包括从全局列表中删除提供者并释放其空间：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Its resource managed version, `devm_of_clk_add_hw_provider()`, can also be used
    to get rid of the deletion function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它的资源管理版本`devm_of_clk_add_hw_provider()`也可以用于摆脱删除函数。
- en: The clock provider device tree node and its associated mechanisms
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟提供者设备树节点及其相关机制
- en: 'For a quite some time now, the device tree is the preferred method to describe
    (declare) devices on a system. The common clock framework does not escape this
    rule. Here, we will try to figure out how clocks are described from within the
    device tree and related driver code. To achieve this, we''ll need to consider
    the following device tree excerpt:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，设备树是描述系统上设备的首选方法已经有一段时间了。通用时钟框架也不例外。在这里，我们将尝试弄清楚时钟是如何在设备树和相关驱动程序代码中描述的。为了实现这一点，我们需要考虑以下设备树摘录：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keep in mind that clocks are assigned to consumers through the `clocks` property,
    and that a clock provider can be a consumer as well. In the preceding excerpt,
    `clk54` is a fixed clock; we won't go into the details here. `cdce706` is a clock
    provider that also consumes `clk54` (given as a `phandle` in the `clocks` property).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，时钟是通过`clocks`属性分配给消费者的，时钟提供者也可以是消费者。在上述摘录中，`clk54`是一个固定时钟；我们不会在这里详细讨论。`cdce706`是一个时钟提供者，也消耗`clk54`（在`clocks`属性中作为`phandle`给出）。
- en: 'The most important piece of information that clock provider nodes need to specify
    is the `#clock- cells` property, which determines the length of a clock specifier:
    when it is `0`, this means that only the `phandle` property of this provider needs
    to be given to the consumer. When it is `1` (or greater), this means that the
    `phandle` property has multiple outputs and needs to be provided with additional
    information, such as an ID indicating what output needs to be used. This ID is
    directly represented by an immediate value. It is better to define the ID of all
    clocks in the system in a header file. The device tree can include this header
    file, such as `clocks = <&clock CLK_SPI0>`, where `CLK_SPI0` is a macro defined
    in a header file.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟提供者节点需要指定的最重要的信息是`#clock-cells`属性，它确定时钟说明符的长度：当它为`0`时，这意味着只需要将此提供者的`phandle`属性给出给消费者。当它为`1`（或更大）时，这意味着`phandle`属性具有多个输出，并且需要提供额外的信息，例如指示需要使用哪个输出的ID。这个ID直接由一个立即值表示。最好在头文件中定义系统中所有时钟的ID。设备树可以包括这个头文件，比如`clocks
    = <&clock CLK_SPI0>`，其中`CLK_SPI0`是在头文件中定义的宏。
- en: Now, let's have a look at `clock-output-names`. This is an optional but recommended
    property and should be a list of strings that correspond to the names of the output
    (that is, provided) clock lines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`clock-output-names`。这是一个可选但建议的属性，应该是一个与输出（即提供的）时钟线的名称相对应的字符串列表。
- en: 'Take a look at the following provider node excerpt:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下提供者节点摘录：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding node defines a device that''s providing two clock output lines
    named `ckout1` and `ckout2`, respectively. Consumer nodes should never use these
    names directly to reference these clock lines. Instead, they should use an appropriate
    clock specifier (referencing clocks by index in respect to `#clock-cells` of the
    provider) that allows them to name their input clock line with respect to the
    device''s needs:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的节点定义了一个提供两个时钟输出线的设备，分别命名为`ckout1`和`ckout2`。消费者节点不应直接使用这些名称来引用这些时钟线。相反，他们应该使用适当的时钟说明符（相对于提供者的`#clock-cells`按索引引用时钟），允许他们根据设备的需求命名其输入时钟线：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This device consumes the two clock lines provided by `osc` and names its input
    lines according to its needs. We will discuss consumer nodes at the end of this
    chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设备消耗了`osc`提供的两条时钟线，并根据自己的需求命名了它的输入线。我们将在本章末讨论消费者节点。
- en: 'When a clock line is assigned to a consumer device and when this consumer''s
    driver calls `clk_get()` (or similar interfaces that are used to grab a clock),
    this interface calls `of_clk_get_by_name()`, which, in turn, calls `__of_clk_get()`.
    The function of interest here is `__of_clk_get()`. It is defined in `drivers/clk/clkdev.c`
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当时钟线分配给消费者设备时，当这个消费者的驱动程序调用`clk_get()`（或类似用于获取时钟的接口）时，这个接口调用`of_clk_get_by_name()`，然后调用`__of_clk_get()`。这里感兴趣的函数是`__of_clk_get()`。它在`drivers/clk/clkdev.c`中定义如下：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is totally normal for this function to return a pointer to `struct clk` instead
    of a pointer to `struct clk_hw` as this interface operates from the consumer side.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回`struct clk`的指针而不是`struct clk_hw`的指针是完全正常的，因为这个接口是从消费者方面操作的。
- en: The magic here comes from `of_parse_phandle_with_args()`, which parses lists
    of `phandle` and its arguments, and then calls `__of_clk_get_from_provider()`,
    which we will describe later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的魔法来自`of_parse_phandle_with_args()`，它解析`phandle`及其参数的列表，然后调用`__of_clk_get_from_provider()`，我们稍后会描述。
- en: Understanding the of_parse_phandle_with_args() API
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解`of_parse_phandle_with_args()`API
- en: 'The following is the prototype of `of_parse_phandle_with_args`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`of_parse_phandle_with_args`的原型：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function returns `0` on success and fills `out_args`; it returns an appropriate
    `errno` value on error. Let''s take a look at its arguments:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在成功时返回`0`并填充`out_args`；在错误时返回适当的`errno`值。让我们看一下它的参数：
- en: '`np` is a pointer to a device tree node containing a list. In our case, it
    will be the node corresponding to the consumer.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np`是一个指向包含列表的设备树节点的指针。在我们的情况下，它将是对应于消费者的节点。'
- en: '`list_name` is the property name that contains a list. In our case, it is `clocks`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_name`是包含列表的属性名称。在我们的情况下，它是`clocks`。'
- en: '`cells_name` is the property name that specifies the argument count of phandle.
    In our case, it is `#clock-cells`. It helps us grab an argument (other cells)
    after the `phandle` property in the specifier.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cells_name`是指定phandle参数计数的属性名称。在我们的情况下，它是`#clock-cells`。它帮助我们在指定器中的`phandle`属性之后抓取一个参数（其他cells）。'
- en: '`index` is the index of the `phandle` property and is used to parse out the
    list.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`是`phandle`属性的索引，用于解析列表。'
- en: '`out_args` is an optional and output parameter that''s filled on the success
    path. This parameter is of the `of_phandle_args` type and is defined as follows:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out_args`是一个可选的输出参数，在成功路径上填充。这个参数是`of_phandle_args`类型，并定义如下：'
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `struct of_phandle_args`, the `np` element is the pointer to the node that
    corresponds to the `phandle` property. In the case of the clock specifier, it
    will be the device tree node of the clock provider. The `args_count` element corresponds
    to the number of cells after the phandle in the specifier. It is can be used to
    walk through `args`, which is an array containing the arguments in question.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`struct of_phandle_args`中，`np`元素是指向与`phandle`属性对应的节点的指针。在时钟指定器的情况下，它将是时钟提供者的设备树节点。`args_count`元素对应于指定器中phandle之后的单元格数。它可以用来遍历`args`，这是一个包含相关参数的数组。
- en: 'Let''s look at an example of using `of_parse_phandle_with_args()`, given the
    following DTS excerpt:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`of_parse_phandle_with_args()`的例子，给出以下DTS摘录：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `node3` is a consumer. To get a `device_node` pointer to the `node2` node,
    you can call `of_parse_phandle_with_args(node3, 'list', '#list-cells', 1, &args);`.
    Since `&phandle2` is at index `1` (starting from `0`) in the list, we specified
    `1` in the `index` parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`node3`是一个消费者。要获取指向`node2`节点的`device_node`指针，你可以调用`of_parse_phandle_with_args(node3,
    'list', '#list-cells', 1, &args);`。由于`&phandle2`在列表中的索引为`1`（从`0`开始），我们在`index`参数中指定了`1`。
- en: In the same way, to get the associated `device_node` of the `node1` node, you
    can call `of_parse_phandle_with_args(node3, 'list', '#gpio-cells', 0, &args);`.
    For this second case, if we look at the `args` output parameter, we will see that
    `args->np` corresponds to `node3`, the value of `args->args_count` is `2` (as
    this specifier requires `2` parameters), the value of `args->args[0]` is `1`,
    and the value of `args->args[1]` is `2`, which would correspond to the `2` argument
    in the specifier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要获取`node1`节点的关联`device_node`，你可以调用`of_parse_phandle_with_args(node3, 'list',
    '#gpio-cells', 0, &args);`。对于这第二种情况，如果我们查看`args`输出参数，我们会看到`args->np`对应于`node3`，`args->args_count`的值为`2`（因为这个指定器需要`2`个参数），`args->args[0]`的值为`1`，`args->args[1]`的值为`2`，这将对应于指定器中的第`2`个参数。
- en: Important note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For further reading about the device tree API, take a look at `of_parse_phandle_with_fixed_args()`
    and the other interfaces provided by the device tree core code in `drivers/of/base.c`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步了解设备树API，请查看`of_parse_phandle_with_fixed_args()`和设备树核心代码中提供的其他接口，位于`drivers/of/base.c`中。
- en: Understanding the __of_clk_get_from_provider() API
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解`__of_clk_get_from_provider()`API
- en: 'The next function call in `__of_clk_get()` is `__of_clk_get_from_provider()`.
    The reason why I''m providing its prototype is that you must not use this in your
    code. However, this function simply walks through the clock providers (in the
    `of_clk_providers` list) and when the appropriate provider is found, it calls
    the underlying callback given as the second parameter to `of_clk_add_provider()`
    to decode the underlying clock. Here, the clock specifier returned by `of_parse_phandle_with_args()`
    is given as a parameter. As you may recall when you have to expose a clock provider
    to other devices, we had to use `of_clk_add_hw_provider()`. As a second parameter,
    this interface accepts a callback used by the CCF to decode the underlying clock
    whenever the consumer calls `clk_get()`. The structure of this callback is as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`__of_clk_get()`中的下一个函数调用是`__of_clk_get_from_provider()`。我提供其原型的原因是你不应该在你的代码中使用这个。然而，这个函数只是简单地遍历时钟提供者（在`of_clk_providers`列表中），当找到适当的提供者时，它调用`of_clk_add_provider()`的第二个参数作为底层回调来解码底层时钟。在这里，由`of_parse_phandle_with_args()`返回的时钟指定器被作为参数给出。你可能还记得当你必须向其他设备公开一个时钟提供者时，我们必须使用`of_clk_add_hw_provider()`。作为第二个参数，这个接口接受一个回调，由CCF用于解码底层时钟，每当消费者调用`clk_get()`时。这个回调的结构如下：'
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This callback should return the underlying `clock_hw` according to its parameters.
    `clkspec` is the clock specifier returned by `of_parse_phandle_with_args()`, while
    `data` is the context data given as the third parameter to `of_clk_add_hw_provider()`.
    Remember, `data` is usually a pointer to the clock(s) to be associated with the
    node. To see how this callback is internally called, we need to have a look at
    the definition of the `__of_clk_get_from_provider()` interface, which is defined
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调应根据其参数返回底层的`clock_hw`。`clkspec`是由`of_parse_phandle_with_args()`返回的时钟指定符，而`data`是作为`of_clk_add_hw_provider()`的第三个参数给出的上下文数据。请记住，`data`通常是要与节点关联的时钟的指针。要查看此回调是如何内部调用的，我们需要查看`__of_clk_get_from_provider()`接口的定义，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Clock decoding callbacks
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时钟解码回调
- en: If we had to summarize the mechanisms behind getting a clock from the CCF, we
    would say that, when a consumer calls `clk_get()`, the CCF internally calls `__of_clk_get()`.
    This is given as the first parameter of the `device_node` property of this consumer
    so that the CCF can grab the clock specifier and find the `device_node` property
    (by means of `of_parse_phandle_with_args()`) that corresponds to the provider.
    It then returns this in the form of `of_phandle_args`. This `of_phandle_args`
    corresponds to the clock specifier and is given as a parameter to `__of_clk_get_from_provider()`,
    which simply compares the `device_node` property of the provider in `of_phandle_args`
    (that is, `of_phandle_args->np`) to those that exist in `of_clk_providers`, which
    is the list of device tree clock providers. Once a match is found, the corresponding
    `of_clk_provider->get()` callback of this provider is called and the underlying
    clock is returned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须总结从CCF获取时钟的机制，我们会说，当使用者调用`clk_get()`时，CCF在内部调用`__of_clk_get()`。这作为此使用者的`device_node`属性的第一个参数，以便CCF可以获取时钟指定符并找到与提供程序对应的`device_node`属性（通过`of_parse_phandle_with_args()`）。然后以`of_phandle_args`的形式返回这个。这个`of_phandle_args`对应于时钟指定符，并作为参数给出给`__of_clk_get_from_provider()`，它只是比较提供程序的`of_phandle_args`（即`of_phandle_args->np`）中的`device_node`属性与存在于`of_clk_providers`中的那些的属性，这是设备树时钟提供程序的列表。一旦找到匹配项，就会调用相应的提供程序的`of_clk_provider->get()`回调，并返回底层时钟。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If `__of_clk_get()` fails, this means there was no way to find a valid clock
    for the given device node. This may also mean that the provider did not register
    its clocks with the device tree interface. Therefore, when `of_clk_get()` fails,
    the CCF code calls `clk_get_sys()`, which is a fall back to using a lookup for
    a clock based on its name that's not on the device tree anymore. This is the real
    logic behind `clk_get()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`__of_clk_get()`失败，这意味着找不到给定设备节点的有效时钟。这也可能意味着提供程序没有将其时钟注册到设备树接口。因此，当`of_clk_get()`失败时，CCF代码调用`clk_get_sys()`，这是根据其名称查找时钟的后备方法，该名称不再在设备树上。这是`clk_get()`背后的真正逻辑。
- en: 'This `of_clk_provider->get()` callback often relies on the context data given
    as a parameter to `of_clk_add_provider()` so that the underlying clock is returned.
    Though it is possible to write your own callback (which should respect the prototype
    that was already introduced in the previous section), the CCF framework provides
    two generic decoding callbacks that cover the majority of cases. These are `of_clk_src_onecell_get()`
    and `of_clk_src_simple_get()`, and both have the same prototype:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此`of_clk_provider->get()`回调通常依赖于作为`of_clk_add_provider()`参数给出的上下文数据，以便返回底层时钟。虽然可以编写自己的回调（应该遵守前一节中已经介绍的原型），但CCF框架提供了两个通用的解码回调，涵盖了大多数情况。这些是`of_clk_src_onecell_get()`和`of_clk_src_simple_get()`，两者都具有相同的原型：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`of_clk_hw_simple_get()` is used for simple clock providers, where no special
    context data structure except for the clock itself is needed, such as the clock-gpio
    driver (in `drivers/clk/clk-gpio.c`). This callback simply returns the data given
    as a context data parameter as-is, meaning that this parameter should be a clock.
    It is defined in `drivers/clk/clk.c` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`of_clk_hw_simple_get()`用于简单的时钟提供程序，除了时钟本身之外，不需要特殊的上下文数据结构，例如时钟GPIO驱动程序（在`drivers/clk/clk-gpio.c`中）。此回调只是原样返回作为上下文数据参数给出的数据，这意味着该参数应该是一个时钟。它在`drivers/clk/clk.c`中定义如下：'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the other hand, `of_clk_hw_onecell_get()` is a bit more complex as it requires
    a special data structure called `struct clk_hw_onecell_data`. This can be defined
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`of_clk_hw_onecell_get()`要复杂一些，因为它需要一个称为`struct clk_hw_onecell_data`的特殊数据结构。这可以定义如下：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding structure, `hws` is an array of pointers to `struct clk_hw`,
    and `num` is the number of entries in this array.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，`hws`是指向`struct clk_hw`的指针数组，`num`是此数组中条目的数量。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In old clock provider drivers that do not implement clk_hw-based APIs yet, you
    may see `struct clk_onecell_data`, `of_clk_add_provider()`, `of_clk_src_onecell_get()`,
    and `of_clk_add_provider()` instead of the data structures and interfaces that
    have been introduced in this book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的时钟提供程序驱动程序中，尚未实现基于clk_hw的API的，您可能会看到`struct clk_onecell_data`，`of_clk_add_provider()`，`of_clk_src_onecell_get()`和`of_clk_add_provider()`，而不是在本书中介绍的数据结构和接口。
- en: 'That being said, to keep a hand on the clocks stored in this data structure,
    it is recommended to wrap them inside your context data structure, as shown in
    the following example from `drivers/clk/sunxi/clk-sun9i-mmc.c`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，为了掌握存储在此数据结构中的时钟，建议将它们包装在您的上下文数据结构中，如`drivers/clk/sunxi/clk-sun9i-mmc.c`中的以下示例所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should then dynamically allocate space for these clocks according to the
    number of clocks that should be stored:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据应该存储的时钟数量动态分配这些时钟的空间：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: At the time of writing, the preceding excerpt, which has been taken from the
    sunxi A80 SoC MMC config clocks/resets driver, still use the clk-based API (along
    with the `struct clk`, `clk_register_gate()`, and `of_clk_add_src_provider()`
    interfaces) instead of the `clk_hw` one. Therefore, for learning purposes, I've
    modified this excerpt so that it uses the recommended `clk_hw` API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，前面的摘录来自sunxi A80 SoC MMC配置时钟/复位驱动程序，仍然使用基于clk的API（以及`struct clk`，`clk_register_gate()`和`of_clk_add_src_provider()`接口），而不是`clk_hw`。因此，为了学习目的，我修改了这段摘录，使其使用推荐的`clk_hw`
    API。
- en: 'As you can see, the context data that''s given during clock registration is
    `clk_hw_data`, which is of the `clk_hw_onecell_data` type. Moreover, `of_clk_hw_onecell_get`
    is given as a clock decoder callback function. This helper simply returns the
    clock at the index that was given as an argument in the clock specifier (which
    is of the `of_phandle_args` type). Take a look at its definition to get a better
    understanding:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在时钟注册期间给出的上下文数据是`clk_hw_data`，它是`clk_hw_onecell_data`类型。此外，`of_clk_hw_onecell_get`作为时钟解码器回调函数给出。这个辅助程序简单地返回在时钟指定器中给定的索引处的时钟（它是`of_phandle_args`类型）。查看其定义以更好地理解：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, depending on your needs, feel free to implement your own decoder
    callback, similar to the one in the `max9485` audio clock generator, whose driver
    is `drivers/clk/clk-max9485.c` in the kernel source's tree.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根据您的需求，可以随意实现自己的解码器回调，类似于内核源代码树中的`max9485`音频时钟生成器中的一个，其驱动程序是`drivers/clk/clk-max9485.c`。
- en: In this section, we have learned about the device tree aspects of clock providers.
    We have learned how to expose a device's clock source lines, as well as how to
    assign those clock lines to consumers. Now, the time has come to introduce the
    driver side, which also consists of writing code for its clock providers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了时钟提供者的设备树方面。我们学习了如何公开设备的时钟源线，以及如何将这些时钟线分配给消费者。现在，是时候介绍驱动程序方面了，这也包括为其时钟提供者编写代码。
- en: Writing a clock provider driver
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写时钟提供者驱动程序
- en: 'While the purpose of a device tree is to describe the hardware at hand (the
    clock provider, in this case), it is worth noting that the code used to manage
    the underlying hardware needs to be written. This section deals with writing code
    for clock providers so that once their clock lines have been assigned to consumers,
    they behave the way they were designed to. When writing clock device drivers,
    it is a good practice to embed the full `struct clk_hw` (not a pointer) into your
    private and bigger data structure, since it is given as the first parameter to
    each callback in `clk_ops`. This lets you define a custom `to_<my-data-structure>`
    helper upon the `container_of` macro, which gives you back a pointer to your private
    data structure, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设备树的目的是描述手头的硬件（在本例中是时钟提供者），但值得注意的是，用于管理底层硬件的代码需要编写。本节涉及编写时钟提供者的代码，以便一旦它们的时钟线被分配给消费者，它们就会按照设计的方式运行。在编写时钟设备驱动程序时，最好将完整的`struct
    clk_hw`（而不是指针）嵌入到您的私有和更大的数据结构中，因为它作为`clk_ops`中每个回调的第一个参数给出。这样可以定义一个自定义的`to_<my-data-structure>`辅助程序，使用`container_of`宏，它会将指针返回到您的私有数据结构，如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, `max9485_clk_hw` abstracts the `hw` clock (as it
    contains `struct clk_hw`). Now, from the driver''s point of view, each `struct
    max9485_clk_hw` represents a hw clock, allowing us to define another bigger structure
    that will be used as the driver data this time: the `max9485_driver_data` struct.
    You will notice some cross-referencing in the preceding structures, notably in
    `struct max9485_clk_hw`, which contains a pointer to `struct max9485_driver_data`,
    and `struct max9485_driver_data`, which contains a `max9485_clk_hw` array. This
    allows us to grab the driver data from within any `clk_ops` callback, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`max9485_clk_hw`抽象了`hw`时钟（因为它包含`struct clk_hw`）。从驱动程序的角度来看，每个`struct
    max9485_clk_hw`代表一个hw时钟，允许我们定义另一个更大的结构，这次将用作驱动程序数据：`max9485_driver_data`结构。您会注意到在前面的结构中有一些交叉引用，特别是在`struct
    max9485_clk_hw`中，它包含指向`struct max9485_driver_data`的指针，以及`struct max9485_driver_data`，它包含一个`max9485_clk_hw`数组。这使我们能够从任何`clk_ops`回调中获取驱动程序数据，如下所示：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Moreover, as shown in the following excerpt, it is a good practice to statically
    declare the clock lines (abstracted by `max9485_clk_hw` in this case), as well
    as the associated ops. This is because, unlike private data (which may change
    from one device to another), this information never changes, regardless of the
    number of clock chips of the same type that are present on the system:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如下摘录所示，静态声明时钟线（在本例中由`max9485_clk_hw`抽象），以及相关的ops是一个很好的做法。这是因为，与私有数据不同（可能会从一个设备更改到另一个设备），这些信息永远不会改变，无论系统上存在相同类型的时钟芯片的数量如何：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Though ops are embedded in the abstraction data structure, they could have
    been declared separately, as in the `drivers/clk/clk-axm5516.c` file in the kernel
    sources. On the other hand, it is better to dynamically allocate the driver data
    structure as it would be easier for it to be private to the driver, thus allowing
    private data per declared device, as shown in the following excerpt:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ops嵌入在抽象数据结构中，但它们也可以单独声明，就像内核源代码中的`drivers/clk/clk-axm5516.c`文件中一样。另一方面，最好动态分配驱动程序数据结构，因为这样更容易使其对驱动程序私有，从而允许每个声明的设备私有数据，如下面的摘录所示：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding excerpt, the driver calls `clk_hw_register()` (this is actually
    `devm_clk_hw_register()`, which is the managed version) in order to register each
    clock with the CCF. Now that we have looked at the basics of a clock provider
    driver, we will learn how to allow interactions with the clock line thanks to
    a set of operations that can be exposed in the driver.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，驱动程序调用`clk_hw_register()`（实际上是`devm_clk_hw_register()`，这是托管版本）以便将每个时钟注册到CCF。现在我们已经了解了时钟提供者驱动程序的基础知识，我们将学习如何通过一组操作允许与时钟线进行交互，这些操作可以在驱动程序中公开。
- en: Providing clock ops
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供时钟ops
- en: '`struct clk_hw` is the base hardware clock structure on top of which the CCF
    builds other clock variant structures. As a quick callback, the common clock framework
    provides the following base clocks:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct clk_hw`是CCF构建其他时钟变体结构的基本硬件时钟结构。作为一个快速回调，通用时钟框架提供以下基本时钟：'
- en: '**fixed-rate**: This type of clock can''t have its rate changed and is always
    running.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fixed-rate**: 这种类型的时钟不能改变其速率，并且始终运行。'
- en: '**gate**: This acts as a gate to a clock source as is its parent. Obviously,
    it can''t have its rate changed as it is just a gate.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gate**: 这充当时钟源的门控，因为它是其父级。显然，它不能改变其速率，因为它只是一个门控。'
- en: '**mux**: This type of clock cannot gate. It has two or more clock inputs: its
    parents. It allows us to select a parent among those it is connected to. Moreover,
    it allows us to get the rate from the selected parent.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mux**: 这种类型的时钟不能进行门控。它有两个或更多的时钟输入：其父级。它允许我们在连接的时钟中选择一个父级。此外，它允许我们从所选的父级获取速率。'
- en: '**fixed-factor**: This clock type can''t gate/ungate but does divide and multiply
    the parent rate by its constants.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fixed-factor**: 这种时钟类型不能进行门控，但可以通过其常数来分频和倍频父级速率。'
- en: '**divider**: This type of clock cannot gate/ungate. However, it divides the
    parent clock rate by using a divider that can be selected from among the various
    arrays that are provided at registration.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**divider**: 这种类型的时钟不能进行门控。但是，它通过使用可以从注册时提供的各种数组中选择的分频器来分频父时钟速率。'
- en: '**composite**: This is a combination of three of the base clocks we described
    earlier: mux, rate, and gate. It allows us to reuse those base clocks to build
    a single clock interface.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**composite**: 这是我们之前描述的三种基本时钟的组合：mux、rate和gate。它允许我们重用这些基本时钟来构建单个时钟接口。'
- en: 'You may be wondering how the kernel (that is, the CCF) knows what the type
    of a given clock is when giving `clk_hw` as a parameter to the `clk_hw_register()`
    function. Actually, the CCF does not know this, and does not have to know anything.
    This is the aim of the `clk_hw->init.ops` field, which is of the `struct clk_ops`
    type. According to the callback functions set in this structure, you can guess
    what type of clock it is facing. The following is a detailed presentation of this
    set of operation functions for the clock in a `struct clk_ops`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道内核（即CCF）在将`clk_hw`作为参数传递给`clk_hw_register()`函数时，是如何知道给定时钟的类型的。实际上，CCF并不知道这一点，也不必知道任何事情。这就是`clk_hw->init.ops`字段的目的，它是`struct
    clk_ops`类型。根据在这个结构中设置的回调函数，你可以猜测它所面对的时钟类型。以下是`struct clk_ops`中的一组操作函数的详细介绍：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For clarity, some fields have been removed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，已删除了一些字段。
- en: 'Each `prepare*`/`unprepare*`/`is_prepared` callback is allowed to sleep and
    therefore must not be called from an atomic context, while each `enable*`/`disable*`/`is_enabled`
    callback may not — and must not – sleep. Let''s take a look at this code in more
    detail:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`prepare*`/`unprepare*`/`is_prepared`回调都允许休眠，因此不得从原子上下文中调用，而每个`enable*`/`disable*`/`is_enabled`回调可能不允许休眠，也不得休眠。让我们更详细地看一下这段代码：
- en: '`prepare` and `unprepare` are optional callbacks. What has been done in `prepare`
    should be undone in `unprepare`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare`和`unprepare`是可选的回调。在`prepare`中所做的工作应该在`unprepare`中撤消。'
- en: '`is_prepared` is an optional callback that tells is whether the clock is prepared
    or not by querying the hardware. If omitted, the clock framework core will do
    the following:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_prepared`是一个可选的回调，通过查询硬件告诉我们时钟是否准备好。如果省略，时钟框架核心将执行以下操作：'
- en: --Maintain a prepare counter (incremented by one when the `clk_prepare()` consumer
    API is called, and decremented by one when `clk_unprepare()` is called).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: --维护一个准备计数器（当调用`clk_prepare()`消费者API时递增一个，当调用`clk_unprepare()`时递减一个）。
- en: --Based on this counter, it will determine whether the clock is prepared.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: --基于这个计数器，它将确定时钟是否准备好。
- en: '`unprepare_unused`/`disable_unused`: These callbacks are optional and used
    in the `clk_disable_unused` interface only. This interface is provided by the
    clock framework core and called (in `drivers/clk/clk.c`: `late_initcall_sync(clk_disable_unused)`)
    in the system-initiated late call in order to unprepare/ungate/close unused clocks.
    This interface will call the corresponding `.unprepare_unused` and `.disable_unused`
    functions of each unused clock on the system.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unprepare_unused`/`disable_unused`: 这些回调是可选的，仅在`clk_disable_unused`接口中使用。该接口由时钟框架核心提供，并在系统发起的延迟调用中调用（在`drivers/clk/clk.c`中：`late_initcall_sync(clk_disable_unused)`），以便取消准备/关闭未使用的时钟。该接口将调用系统上每个未使用时钟的相应`.unprepare_unused`和`.disable_unused`函数。'
- en: '`enable`/`disable`: Enables/disables the clock atomically. These functions
    must run atomically and must not sleep. For `enable`, for example, it should return
    **only** when the underlying clock is generating a valid clock signal that can
    be used by consumer nodes.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable`/`disable`: 原子地启用/禁用时钟。这些函数必须以原子方式运行，不得休眠。例如，对于`enable`，它应该仅在底层时钟生成可供使用者节点使用的有效时钟信号时返回。'
- en: '`is_enabled` has the same logic as `is_prepared`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_enabled`具有与`is_prepared`相同的逻辑。'
- en: '`recalc_rate`: This is an optional callback that queries the hardware to recalculate
    the rate of the underlying clock, given the parent rate as an input parameter.
    The initial rate is `0` if this op is omitted.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recalc_rate`: 这是一个可选的回调，通过给定父级速率作为输入参数，查询硬件以重新计算底层时钟的速率。如果省略此操作，初始速率为`0`。'
- en: '`round_rate`: This callback accepts a target rate (in Hz) as input and should
    return the closest rate actually supported by the underlying clock. The parent
    rate is an input/output parameter.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round_rate`: 此回调接受目标速率（以赫兹为单位）作为输入，并应返回底层时钟实际支持的最接近的速率。父级速率是一个输入/输出参数。'
- en: '`determine_rate`: This callback is given a targeted clock rate as a parameter
    and returns the closest one supported by the underlying hardware.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`determine_rate`: 此回调以目标时钟速率作为参数，并返回底层硬件支持的最接近的速率。'
- en: '`set_parent`: This concerns clocks with multiple inputs (multiple possible
    parents). This callback accepts changing the input source when given the index
    as a parameter (as a `u8`) of the parent to be selected. This index should correspond
    to a parent that''s valid in either the `clk_init_data.parent_names` or `clk_init_data.parents`
    arrays of the clock. This callback should return `0` on a success path or `-EERROR`
    otherwise.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_parent`：这涉及具有多个输入（多个可能的父级）的时钟。此回调接受在给定父级索引（作为`u8`）的参数时更改输入源的选择。此索引应与时钟的`clk_init_data.parent_names`或`clk_init_data.parents`数组中有效的父级对应。此回调应在成功路径上返回`0`，否则返回`-EERROR`。'
- en: '`get_parent` is a mandatory callback for clocks with multiple (at least two)
    inputs (multiple `parents`). It queries the hardware to determine the parent of
    the clock. The return value is a `u8` that corresponds to the parent index. This
    index should be valid in either the `clk_init_data.parent_names` or `clk_init_data.parents`
    arrays. In other words, this callback translates the parent value that''s read
    from the hardware into an array index.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_parent`是具有多个（至少两个）输入（多个`parents`）的时钟的强制性回调。它查询硬件以确定时钟的父级。返回值是与父级索引对应的`u8`。此索引应在`clk_init_data.parent_names`或`clk_init_data.parents`数组中有效。换句话说，此回调将从硬件中读取的父级值转换为数组索引。'
- en: '`set_rate`: Changes the rate of the given clock. The requested rate should
    be the return value of the `.round_rate` call in order to be valid. This callback
    should return `0` on a success path or `-EERROR` otherwise.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_rate`：更改给定时钟的速率。请求的速率应该是`.round_rate`调用的返回值，以便有效。此回调应在成功路径上返回`0`，否则返回`-EERROR`。'
- en: '`init` is a platform-specific clock initialization hook that will be called
    when the clock is registered to the kernel. For now, no basic clock type implements
    this callback.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`是一个特定于平台的时钟初始化钩子，当时钟注册到内核时将调用它。目前，没有基本时钟类型实现此回调。'
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Since `.enable` and `.disable` must not sleep (they are called with spinlocks
    held), clock providers in discrete chips that are connected to sleepable buses
    (such as SPI or I2C) cannot be controlled with spinlocks held and should therefore
    implement their enable/disable logic in the prepare/unprepare hooks. The general
    API will directly call the corresponding operation function. This is one of the
    reasons why, from the consumer side (the clk-based API), a call to `clk_enable`
    must be preceded by a call to `clk_prepare()` and a call to `clock_disable()`
    should be followed by `clock_unprepare()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.enable`和`.disable`不能休眠（它们在持有自旋锁时被调用），因此连接到可休眠总线（例如SPI或I2C）的离散芯片中的时钟提供程序不能在持有自旋锁的情况下进行控制，因此应该在准备/取消准备钩子中实现其启用/禁用逻辑。通用API将直接调用相应的操作函数。这是为什么从消费者方面（基于时钟的API）来看，对`clk_enable`的调用必须在调用`clk_prepare()`之前进行，并且对`clock_disable()`的调用应该在`clock_unprepare()`之后进行的原因之一。
- en: 'Last but not the least, the following difference should be noticed as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，还应注意以下差异：
- en: Important note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: SoC-internal clocks can be seen as fast clocks (controlled via simple MMIO register
    writes), and can therefore implement `.enable` and `.disable`, while SPI/I2C-based
    clocks can be seen as slow clocks and should implement `.prepare` and `.unprepare`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: SoC内部时钟可以被视为快速时钟（通过简单的MMIO寄存器写入进行控制），因此可以实现`.enable`和`.disable`，而SPI/I2C时钟可以被视为慢时钟，应该实现`.prepare`和`.unprepare`。
- en: 'These functions are not mandatory for all clocks. Depending on the clock type,
    some may be mandatory, while others may not be. The following array summarizes
    which `clk_ops` callbacks are mandatory for which clock type, based on their hardware
    capabilities:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数并非对所有时钟都是强制性的。根据时钟类型，有些可能是强制性的，而有些可能不是。以下数组总结了根据其硬件功能，哪些`clk_ops`回调对哪种时钟类型是强制性的：
- en: '![Figure 4.1 – Mandatory clk_ops callbacks for clock types'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 时钟类型的强制性clk_ops回调'
- en: '](img/Figure_4.1_B10985.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B10985.jpg)'
- en: Figure 4.1 – Mandatory clk_ops callbacks for clock types
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 时钟类型的强制性clk_ops回调
- en: In the preceding array, the `round_rate` or `determine_rate` is required.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，需要`round_rate`或`determine_rate`。
- en: In the preceding array, **y** means mandatory, while **n** means the concerned
    callback is either invalid or otherwise unnecessary. Empty cells should be considered
    as either optional or that they must be evaluated on a case-by-case basis.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，**y**表示强制性，而**n**表示相关回调无效或无关紧要。空单元格应被视为可选的，或者必须根据具体情况进行评估。
- en: Clock flags in clk_hw.init.flags
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clk_hw.init.flags中的时钟标志
- en: 'Since we have already introduced the clock ops structure, we will now introduce
    the different flags (defined in `include/linux/clk-provider.h`) and see how they
    affect the behavior of some of the callbacks in this structure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经介绍了时钟操作结构，现在我们将介绍不同的标志（在`include/linux/clk-provider.h`中定义），并看看它们如何影响此结构中某些回调的行为：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code shows the different framework-level flags that can be set
    in the `clk_hw->init.flags` field. You can specify multiple flags by OR''ing them.
    Let''s take a look at them in more detail:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了可以在`clk_hw->init.flags`字段中设置的不同框架级标志。您可以通过OR'ing它们来指定多个标志。让我们更详细地看一下它们：
- en: '`CLK_SET_RATE_GATE`: When you change the rate of the clock, it must be gated
    (disabled). This flag also ensures there''s rate change and rate glitch protection;
    when a clock has the `CLK_SET_RATE_GATE` flag set and it has been prepared, the
    `clk_set_rate()` request will fail.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_SET_RATE_GATE`：当您更改时钟的速率时，必须对其进行门控（禁用）。此标志还确保存在速率更改和速率故障保护；当时钟设置了`CLK_SET_RATE_GATE`标志并且已准备就绪时，`clk_set_rate()`请求将失败。'
- en: '`CLK_SET_PARENT_GATE` : When you change the parent of the clock, it must be
    gated.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_SET_PARENT_GATE`：当您更改时钟的父级时，必须对其进行门控。'
- en: '`CLK_SET_RATE_PARENT`: Once you''ve changed the rate of the clock, the change
    must be passed to the upper parent. This flag has two effects:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_SET_RATE_PARENT`：一旦您更改了时钟的速率，更改必须传递给上级父级。此标志有两个效果：'
- en: --When a clock consumer calls `clk_round_rate()` (which the CCF internally maps
    to `.round_rate`) to get an approximate rate, if the clock does not provide the
    `.round_rate` callback, the CCF will immediately return the cached rate of the
    clock if `CLK_SET_RATE_PARENT` is not set. However, if this flag is set still
    without `.round_rate` provided, then the request is routed to the clock parent.
    This means the parent is queried and `clk_round_rate()` is called to get the value
    that the parent clock can provide that's closest to the targeted rate.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: --当时钟使用者调用`clk_round_rate()`（CCF在内部将其映射到`.round_rate`）以获得近似速率时，如果时钟未提供`.round_rate`回调，则如果未设置`CLK_SET_RATE_PARENT`，CCF将立即返回时钟的缓存速率。但是，如果仍设置了此标志而未提供`.round_rate`，则请求将路由到时钟父级。这意味着将查询父级并调用`clk_round_rate()`以获取父时钟可以提供的最接近目标速率的值。
- en: --This flag also modifies the behavior of the `clk_set_rate()` interface (which
    the CCF internally maps to `.set_rate`). If set, any rate change request will
    be forwarded upstream (passed to the parent clock).That is to say, if the parent
    clock can get an approximate rate value, then by changing the parent clock rate,
    you can get the required rate. This flag is usually set on the clock gate and
    mux. Use this flag with care.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: --此标志还修改了`clk_set_rate()`接口的行为（CCF在内部将其映射到`.set_rate`）。如果设置，任何速率更改请求将被转发到上游（传递给父时钟）。也就是说，如果父时钟可以获得近似速率值，那么通过更改父时钟速率，可以获得所需的速率。此标志通常设置在时钟门和多路复用器上。请谨慎使用此标志。
- en: '`CLK_IGNORE_UNUSED`: Ignore the disable unused call. This is primarily useful
    when there''s a driver that doesn''t claim clocks properly, but the bootloader
    leaves them on. It is the equivalent of the `clk_ignore_unused` kernel boot parameters
    but for a single clock. It''s not expected to be used in normal cases, but for
    bring up and debug, it''s very useful to have the option to not gate (not disable)
    unclaimed clocks that are still on.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_IGNORE_UNUSED`：忽略禁用未使用的调用。当有一个驱动程序未正确声明时钟但引导加载程序将它们保留在时钟上时，这是非常有用的。这相当于内核引导参数`clk_ignore_unused`，但适用于单个时钟。不希望在正常情况下使用，但对于启动和调试，有选择地不对仍在运行的未声明的时钟进行门控（禁用）是非常有用的。'
- en: '`CLK_IS_BASIC`: This is no longer used.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_IS_BASIC`：不再使用。'
- en: '`CLK_GET_RATE_NOCACHE`: There are chips where the clock rate can be changed
    by internal hardware without the Linux clock framework being aware of that change
    at all. This flag makes sure the clk rate from the Linux clock tree always matches
    the hardware settings. In other words, the get/set rate does not come from the
    cache and is calculated at the time.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLK_GET_RATE_NOCACHE`：有些芯片的时钟速率可以通过内部硬件更改，而Linux时钟框架根本不知道这种变化。此标志确保Linux时钟树中的clk速率始终与硬件设置匹配。换句话说，获取/设置速率不来自缓存，并且是在那个时间计算的。'
- en: Important note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While dealing with the gate clock type, note that a gated clock is a disabled
    clock, while an ungated clock is an enabled clock. See [https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931)
    and [https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862)
    for more details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 处理门钟类型时，请注意，门控时钟是禁用的时钟，而非门控时钟是启用的时钟。有关更多详细信息，请参见[https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931)和[https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862)。
- en: Now that we are familiar with clock flags, as well as the way those flags may
    modify the behavior of clock-related callbacks, we can walk through each clock
    type and learn how to provide their associated ops.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了时钟标志，以及这些标志如何修改与时钟相关的回调的行为，我们可以逐个遍历每种时钟类型，并学习如何提供它们的相关操作。
- en: Fixed-rate clock case study and its ops
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定速率时钟案例研究及其操作
- en: This is the simplest type of clock. Therefore, we will use this to build some
    of the strong guidelines we must respect while writing clock drivers. The frequency
    of this type of clock cannot be adjusted as it is fixed. Moreover, this type of
    clock cannot be switched, cannot choose its parent, and does not need to provide
    a `clk_ops` callback function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的时钟类型。因此，我们将使用它来建立一些必须在编写时钟驱动程序时遵守的强制性准则。这种类型的时钟的频率不能调整，因为它是固定的。此外，这种类型的时钟不能被切换，不能选择其父级，并且不需要提供`clk_ops`回调函数。
- en: 'The clock framework uses the `struct clk_fixed_rate` structure (described as
    follows) to abstract this type of clock hardware:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟框架使用`struct clk_fixed_rate`结构（如下所述）来抽象这种类型的时钟硬件：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding structure, `hw` is the base structure and ensures there's a
    link between the common and hardware-specific interfaces. Once given to the `to_clk_fixed_rate`
    macro (which is based on `container_of`), you should get a pointer to `clk_fixed_rate`,
    which wraps this `hw`. `fixed_rate` is the constant (fixed) rate of the clock
    device. `flags` represents framework-specific flags.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，`hw`是基础结构，并确保通用和硬件特定接口之间存在链接。一旦给定给`to_clk_fixed_rate`宏（基于`container_of`），您应该获得一个指向`clk_fixed_rate`的指针，它包装了这个`hw`。`fixed_rate`是时钟设备的恒定（固定）速率。`flags`表示框架特定的标志。
- en: 'Let''s have a look at the following excerpt, which simply registers two fake
    fixed-rate clock lines:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下摘录，它简单地注册了两条虚拟固定速率时钟线：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With that, we have defined our clocks. The following code shows how to register
    these clocks on the system:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经定义了我们的时钟。以下代码显示了如何在系统上注册这些时钟：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: General simpliﬁcation considerations
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一般简化考虑
- en: In the previous excerpt, we used `clk_hw_register()` to register the clock.
    This interface is the base registration interface and can be used to register
    any type of clock. Its main parameter is a pointer to the `struct clk_hw` structure
    that's embedded in the underlying clock-type structure.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，我们使用`clk_hw_register()`来注册时钟。此接口是基本注册接口，可用于注册任何类型的时钟。其主要参数是指向嵌入在基础时钟类型结构中的`struct
    clk_hw`结构的指针。
- en: Clock initialization and registration through a call to `clk_hw_register()`
    requires populating the `struct clk_init_data` (thus implementing `clk_ops`) object,
    which gets bundled with `clk_hw`. As an alternative, you can use a hardware-specific
    (that is, clock-type-dependent) registration function. Here, the kernel is responsible
    for building the appropriate `init` data from arguments given to the function
    according to the clock type, before internally calling `clk_hw_register(...)`.
    With this alternative, the CCF will provide appropriate `clk_ops` according to
    the clock hardware type.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`clk_hw_register()`进行时钟初始化和注册需要填充`struct clk_init_data`（从而实现`clk_ops`）对象，该对象与`clk_hw`捆绑在一起。作为替代，您可以使用硬件特定（即，时钟类型相关）的注册函数。在这里，内核负责根据时钟类型从给定给函数的参数构建适当的`init`数据，然后在内部调用`clk_hw_register(...)`。通过这种替代方式，CCF将根据时钟硬件类型提供适当的`clk_ops`。
- en: 'Generally, the clock provider does not need to use nor allocate the base clock
    type directly, which in this case is `struct clk_fixed_rate`. This is because
    the kernel clock framework provides dedicated interfaces for this purpose. In
    a real-life scenario (where there''s a fixed clock), this dedicated interface
    would be `clk_hw_register_fixed_rate()`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，时钟提供程序不需要直接使用或分配基本时钟类型，即`struct clk_fixed_rate`。这是因为内核时钟框架为此目的提供了专用接口。在实际情况下（存在固定时钟的情况下），这种专用接口将是`clk_hw_register_fixed_rate()`：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `clk_register_fixed_rate()` interface uses the clock''s `name`, `parent_name`,
    and `fixed_rate` as parameters to create a clock with a fixed frequency. `flags`
    represents the framework-specific flags, while `dev` is the device that is registering
    the clock. The `clk_ops` property of the clock is also provided by the clock framework
    and does not require the provider to care about it. The kernel clock ops data
    structure for this kind of clock is `clk_fixed_rate_ops`. It is defined in `drivers/clk/clk-fixed-rate.c`
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`clk_register_fixed_rate()`接口使用时钟的`name`、`parent_name`和`fixed_rate`作为参数来创建具有固定频率的时钟。`flags`表示特定于框架的标志，而`dev`是注册时钟的设备。时钟的`clk_ops`属性也由时钟框架提供，不需要提供者关心。这种时钟的内核时钟操作数据结构是`clk_fixed_rate_ops`。它在`drivers/clk/clk-fixed-rate.c`中定义如下：'
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`clk_register_fixed_rate()` returns a pointer to the underlying `clk_hw` structure
    of the fixed-rate clock. The code can then use the `to_clk_fixed_rate` macro the
    grab a pointer to the original clock-type structure.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`clk_register_fixed_rate()`返回固定速率时钟的基础`clk_hw`结构的指针。然后，代码可以使用`to_clk_fixed_rate`宏来获取原始时钟类型结构的指针。'
- en: However, you can still use the low-level `clk_hw_register()` registration interface
    and reuse some of the CCF provided ops callbacks. The fact that the CCF provides
    an appropriate ops structure for your clock does not mean you should use it as-is.
    You may not wish to use the clock-type-dependent registration interface (using
    `clock_hw_register()` instead) and instead use one or more of the individual ops
    provided by the CCF. This does not just apply to adjustable clocks, as per the
    following example, but to all other clock types that we will discuss in this book.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您仍然可以使用低级`clk_hw_register()`注册接口，并重用CCF提供的一些操作回调。CCF提供适当的操作结构来处理您的时钟并不意味着您应该直接使用它。您可能不希望使用时钟类型相关的注册接口（而是使用`clock_hw_register()`），而是使用CCF提供的一个或多个单独的操作。这不仅适用于可调时钟，如下面的示例所示，还适用于本书中将讨论的所有其他时钟类型。
- en: 'Let''s have a look at an example from `drivers/clk/clk-stm32f4.c` for a clock
    divider driver:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个来自`drivers/clk/clk-stm32f4.c`的时钟分频器驱动程序的示例：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding excerpt, the driver only implements the `.set_rate` ops and
    reuses the `.recalc_rate` and `.round_rate` properties of the CCF-provided clock
    divider ops known as `clk_divider_ops`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，驱动程序只实现了`.set_rate`操作，并重用了CCF提供的时钟分频器操作的`.recalc_rate`和`.round_rate`属性，称为`clk_divider_ops`。
- en: Fixed clock device binding
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 固定时钟设备绑定
- en: 'This type of clock can also be natively and directly supported by DTS configuration
    without the need to write any code. This device tree-based interface is generally
    used to provide dummy clocks. There are cases where some devices in the device
    tree may require clock nodes to describe their own clock inputs. For example,
    the *mcp2515* SPI to CAN converter needs to be provided with a clock to let it
    know the frequency of the quartz it is connected to. For such a dummy clock node,
    the compatible property should be `fixed-clock`. An example of this is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的时钟也可以通过DTS配置本地直接支持，无需编写任何代码。这种基于设备树的接口通常用于提供虚拟时钟。有些设备树中的设备可能需要时钟节点来描述它们自己的时钟输入。例如，*mcp2515*
    SPI到CAN转换器需要提供一个时钟以让它知道连接的石英的频率。对于这样的虚拟时钟节点，兼容属性应该是`fixed-clock`。一个示例如下：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The clock framework's core will directly extract the clock information provided
    by DTS and will automatically register it to the kernel without any driver support.
    `#clock-cells` is 0 here because only one fixed rate line is provided, and in
    this case, the specifier only needs to be the `phandle` of the provider.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟框架的核心将直接提取DTS提供的时钟信息，并在没有任何驱动程序支持的情况下自动将其注册到内核。这里的`#clock-cells`为0，因为只提供了一个固定速率线，而在这种情况下，指定器只需要是提供者的`phandle`。
- en: PWM clock alternative
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PWM时钟替代
- en: 'Because of the lack of output clock sources (clock pads), some board designers
    (rightly or wrongly) use PWM output pads as the clock source for external components.
    This kind of clock is only instantiated from the device tree. Moreover, since
    PWM binding requires specifying the period of the PWM signal, `pwm-clock` falls
    into the fixed-rate clock category. An example of such an instantiation can be
    seen in the following code, which is an excerpt from `imx6qdl-sabrelite.dtsi`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏输出时钟源（时钟引脚），一些板设计师（无论对错）使用PWM输出引脚作为外部组件的时钟源。这种时钟只能从设备树中实例化。此外，由于PWM绑定需要指定PWM信号的周期，`pwm-clock`属于固定速率时钟类别。这种实例化的示例可以在以下代码中看到，这是从`imx6qdl-sabrelite.dtsi`中的摘录：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, the `compatible` property should be `pwm-clock`, while `#clock-cells`
    should be `<0>`. This clock-type driver is located at `drivers/clk/clk-pwm.c`,
    and further reading about this can be found at `Documentation/devicetree/bindings/clock/pwm-clock.txt`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`compatible`属性应该是`pwm-clock`，而`#clock-cells`应该是`<0>`。这种时钟类型的驱动程序位于`drivers/clk/clk-pwm.c`，关于这方面的更多信息可以在`Documentation/devicetree/bindings/clock/pwm-clock.txt`中找到。
- en: Fixed-factor clock driver and its ops
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定因子时钟驱动程序及其操作
- en: 'This type of clock divides and multiplies the parent rate by constants (hence
    it being a fixed-factor clock driver). This clock cannot gate:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的时钟通过常数来分频和乘以父时钟的频率（因此它是一个固定因子时钟驱动程序）。这种时钟不能进行门控：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The frequency of the clock is determined by the frequency of the parent clock,
    multiplied by `mult`, and then divided by `div`. It is actually a `CLK_SET_RATE_PARENT`
    flag. Since the frequency of the parent clock can be changed, the fixed-factor
    clock can also have its frequency changed, so callbacks such as `.recalc_rate`/`.set_rate/.round_rate`
    are also provided. That being said, since the set rate request will be propagated
    upstream if the `CLK_SET_RATE_PARENT` flag is set, the `.set_rate` callback of
    such a clock needs to return 0 to ensure its call is a valid **nop** (**no-operation**):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟的频率由父时钟的频率确定，乘以`mult`，然后除以`div`。实际上是一个`CLK_SET_RATE_PARENT`标志。由于父时钟的频率可以更改，固定因子时钟的频率也可以更改，因此还提供了`.recalc_rate`/`.set_rate/.round_rate`等回调。也就是说，由于如果设置了`CLK_SET_RATE_PARENT`标志，设置速率请求将向上游传播，因此这样的时钟的`.set_rate`回调需要返回0，以确保其调用是有效的**nop**（**无操作**）：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For such clocks, you''re better off using the clock framework provider helper
    ops known as `clk_fixed_factor_ops`, which is defined and implemented in `drivers/clk/clk-fixed-factor.c`
    as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的时钟，最好使用时钟框架提供的辅助操作，称为`clk_fixed_factor_ops`，它在`drivers/clk/clk-fixed-factor.c`中定义和实现如下：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The advantage of using this is that you don''t need to care about ops anymore
    since the kernel has already set everything up for you. Its `round_rate` and `recalc_rate`
    callbacks even take care of the `CLK_SET_RATE_PARENT` flag, which means we can
    adhere to our simplification path. Moreover, you''re better off using the clock
    framework helper interface to register such a clock; that is, `clk_hw_register_fixed_factor()`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式的优势在于，你不再需要关心操作，因为内核已经为你设置好了一切。它的`round_rate`和`recalc_rate`回调甚至会处理`CLK_SET_RATE_PARENT`标志，这意味着我们可以遵循我们的简化路径。此外，最好使用时钟框架辅助接口来注册这样的时钟；也就是说，`clk_hw_register_fixed_factor()`：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This interface internally sets up a `struct clk_fixed_factor` that it allocates
    dynamically, and then returns a pointer to the underlying `struct clk_hw`. You
    can use this with the `to_clk_fixed_factor` macro to grab a pointer to the original
    fixed-factor clock structure. The ops that's assigned to the clock is `clk_fixed_factor_ops`,
    as discussed previously. In addition, this type of interface is similar to the
    fixed-rate clock. You do not need to provide a driver. You only need to configure
    the device tree.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口在内部设置了一个动态分配的`struct clk_fixed_factor`，然后返回指向底层`struct clk_hw`的指针。你可以使用`to_clk_fixed_factor`宏来获取指向原始固定因子时钟结构的指针。分配给时钟的操作是`clk_fixed_factor_ops`，如前所述。此外，这种类型的接口类似于固定速率时钟。你不需要提供驱动程序。你只需要配置设备树。
- en: Device tree binding for fixed-factor clocks
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 固定因子时钟的设备树绑定
- en: 'You can find binding documentation for such simple fixed factor rate clocks
    at `Documentation/devicetree/bindings/clock/fixed-factor-clock.txt`, in the kernel
    sources. The required properties are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在内核源代码的`Documentation/devicetree/bindings/clock/fixed-factor-clock.txt`中找到这种简单固定因子速率时钟的绑定文档。所需的属性如下：
- en: '`#clock-cells`: This will be set to 0 according to the common clock binding.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#clock-cells`：根据通用时钟绑定，这将设置为0。'
- en: '`compatible`: This will be `''fixed-factor-clock''`.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compatible`：这将是`''fixed-factor-clock''`。'
- en: '`clock-div`: Fixed divider.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-div`：固定除数。'
- en: '`clock-mult`: Fixed multiplier.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-mult`：固定乘数。'
- en: '`clocks`: The `phandle` of the parent clock.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clocks`：父时钟的`phandle`。'
- en: 'Here''s an example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that the fixed-factor clock has been addressed, the next logical step would
    be to look at the gateable clock, another simple clock type.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在固定因子时钟已经解决了，下一个合乎逻辑的步骤将是看看可开关时钟，另一种简单的时钟类型。
- en: Gateable clock and its ops
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可开关时钟及其操作
- en: 'This type of clock can only be switched, so only providing `.enable`/`.disable`
    callbacks makes sense here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的时钟只能进行切换，因此只提供`.enable`/`.disable`回调在这里是有意义的：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s take a look at the preceding structure in more detail:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下前面的结构：
- en: '`reg`: This represents the register address (virtual address; that is, MMIO)
    for controlling the clock switch.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`：这表示用于控制时钟开关的寄存器地址（虚拟地址；即MMIO）。'
- en: '`bit_idx`: This is the control bit of the clock switch (this can be 1 or 0
    and sets the state of the gate).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bit_idx`：这是时钟开关的控制位（可以是1或0，并设置门的状态）。'
- en: '`clk_gate_flags`: This represents the gate-specific flags of the gate clock.
    These are as follows:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk_gate_flags`：这表示门控时钟的特定标志。具体如下：'
- en: '--`CLK_GATE_SET_TO_DISABLE`: This is the clock switch''s control mode. If set,
    writing `1` turns off the clock, and writing `0` turns on the clock.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '- `CLK_GATE_SET_TO_DISABLE`：这是时钟开关的控制模式。如果设置，写入`1`会关闭时钟，写入`0`会打开时钟。'
- en: '--`CLK_GATE_HIWORD_MASK`: Some registers use the concept of `reading-modifying-writing`
    to operate at the bit level, while other registers only support `0` and `15`)
    consists of changing the corresponding bit in the `16` lower bits (`0` to 15)
    and masking the same bit index in the 16 higher bits (`16` to `31`, hence hiword
    or High Word) in order to indicate/validate the change.For example, if bit `b1`
    needs to be set as a gate, it also needs to indicate the change by setting the
    hiword mask (`b1 << 16`). This means that the gate settings are truly in the lower
    16 bits of the register, while the mask of gate bits is in the higher `16` bits
    of this same register. When setting this flag, `bit_idx` should be no higher than
    `15`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_GATE_HIWORD_MASK`：一些寄存器使用“读取-修改-写入”的概念在位级别上操作，而其他寄存器只支持`0`和`15`），这包括改变`16`个低位（`0`到`15`）中的相应位并屏蔽`16`个高位（`16`到`31`，因此称为高字或High
    Word）以指示/验证更改。例如，如果位`b1`需要设置为门控，还需要通过设置高字掩码（`b1 << 16`）来指示更改。这意味着门控设置实际上在寄存器的低16位中，而门控位的掩码在同一寄存器的高16位中。设置此标志时，`bit_idx`不应大于`15`。
- en: '`lock`: This is the spinlock that should be used if the clock switch requires
    mutual exclusion.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`：这是应该在时钟切换需要互斥时使用的自旋锁。'
- en: 'As you have probably guessed, this structure assumes that the clock gate register
    is mmio. As for the previous clock type, it is better to use the provided kernel
    interface to deal with such a clock; that is, `clk_hw_register_gate()`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，这个结构假定时钟门控寄存器是mmio。与之前的时钟类型一样，最好使用提供的内核接口来处理这样的时钟；也就是说，`clk_hw_register_gate()`：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Some of the parameters of this interface are the same ones we described regarding
    the clock-type structure. Moreover, the following are extra arguments that need
    to be described:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口的一些参数与我们描述的时钟类型结构相同。此外，还有需要描述的额外参数：
- en: '`dev` is the device that is registering the clock.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是注册时钟的设备。'
- en: '`name` is the name of the clock.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是时钟的名称。'
- en: '`parent_name` is the name of the parent clock, which should be NULL if it has
    no parent.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_name`是父时钟的名称，如果没有父时钟，则应为NULL。'
- en: '`flags` represents the framework-specific flags for this clock. It is common
    to set the `CLK_SET_RATE_PARENT` flag for gate clocks that have a parent so that
    rate change requests are propagated up one level.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`表示此时钟的框架特定标志。通常为具有父级的门控时钟设置`CLK_SET_RATE_PARENT`标志，以便将速率更改请求传播到上一级。'
- en: '`clk_gate_flags` corresponds to the `.flags` in the clock-type structure.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk_gate_flags`对应于时钟类型结构中的`.flags`。'
- en: This interface returns a pointer to the underlying `struct clh_hw` of the clock
    gate structure. Here, you can use the `to_clk_gate` helper macro to grab the original
    clock gate structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口返回时钟门控结构的底层`struct clh_hw`的指针。在这里，您可以使用`to_clk_gate`辅助宏来获取原始时钟门控结构。
- en: 'While setting up this clock and prior to its registration, the clock framework
    assigns the `clk_gate_ops` ops to it. This is actually the default ops for the
    gate clock. It relies on the fact that the clock is controlled through mmio registers:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此时钟并在其注册之前，时钟框架将`clk_gate_ops`操作分配给它。这实际上是门控时钟的默认操作。它依赖于时钟通过mmio寄存器控制的事实：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The entire gate clock API is defined in `drivers/clk/clk-gate.c`. Such a clock
    driver can be found in `drivers/clk/clk-asm9260.c`, while its device tree binding
    can be found in `Documentation/devicetree/bindings/clock/alphascale,acc.txt`,
    in the kernel source tree.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 整个门控时钟API在`drivers/clk/clk-gate.c`中定义。这样的时钟驱动程序可以在`drivers/clk/clk-asm9260.c`中找到，而其设备树绑定可以在内核源树中的`Documentation/devicetree/bindings/clock/alphascale,acc.txt`中找到。
- en: I2C/SPI-based gate clock
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于I2C/SPI的门控时钟
- en: 'Not just mmio peripherals can provide gate clocks. There are also discrete
    chips behind I2C/SPI buses that can provide such clocks. Obviously, you cannot
    rely on the structure (`struct clk_gate`) or the interface helper (`clk_hw_register_gate()`)
    that we introduced earlier to develop drivers for such chips. The main reasons
    for this are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是mmio外设可以提供门控时钟。在I2C/SPI总线后面也有离散芯片可以提供这样的时钟。显然，您不能依赖于我们之前介绍的结构（`struct clk_gate`）或接口辅助程序（`clk_hw_register_gate()`）来开发这些芯片的驱动程序。其主要原因如下：
- en: The aforementioned interface and data structure assume that the clock gate register
    control is mmio, which is definitely not the case here.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述接口和数据结构假定时钟门控寄存器控制是mmio，而这在这里绝对不是这样。
- en: The standard gate clock ops are `.enable` and `.disable`. However, these callbacks
    don't need to sleep as they are called with spinlocks held, but we all know that
    I2C/SPI register accesses may sleep.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的门控时钟操作是`.enable`和`.disable`。然而，这些回调不需要休眠，因为它们在持有自旋锁时调用，但我们都知道I2C/SPI寄存器访问可能会休眠。
- en: 'Both of these restrictions have workarounds:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制都有解决方法：
- en: Instead of using the gate-specific clock framework helper, you can want to use
    the low-level `clk_hw_register()` interface to control the parameters of the clock,
    from its flags to its ops.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择使用低级别的`clk_hw_register()`接口来控制时钟的参数，从其标志到其操作，而不是使用特定于门控的时钟框架辅助程序。
- en: You can implement the `.enable`/`.disable` logic in the `.prepare`/`.unprepare`
    callbacks. Remember, `.prepare`/`.unprepare` ops may sleep. This is guaranteed
    to work as it is a requirement for the consumer side to call `clk_prepare()` prior
    to calling `clk_enable()`, and then to follow a call to `clk_disable()` by a call
    to `clk_unprepare()`. By doing so, any consumer call to `clk_enable()` (mapped
    to the provider's `.enable` callback) will immediately return. However, since
    it is always preceded by a consumer call to `clk_prepare()` (mapped to the `.prepare`
    callback), we can be sure that our clock will be ungated. The same goes for `clk_disable`
    (mapped to the `.disable` callback), which guarantees that our clock will be gated.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 `.prepare`/`.unprepare` 回调中实现 `.enable`/`.disable` 逻辑。请记住，`.prepare`/`.unprepare`
    操作可能会休眠。这是有保证的，因为消费者在调用 `clk_enable()` 之前调用 `clk_prepare()` 是要求的，然后在调用 `clk_disable()`
    之后调用 `clk_unprepare()`。通过这样做，任何对 `clk_enable()` 的消费者调用（映射到提供者的 `.enable` 回调）将立即返回。但是，由于它总是由消费者调用
    `clk_prepare()`（映射到 `.prepare` 回调）先进行的，我们可以确保我们的时钟将被解锁。对于 `clk_disable`（映射到 `.disable`
    回调），它保证了我们的时钟将被锁定。
- en: This clock driver implementation can be found in `drivers/clk/clk-max9485.c`,
    while its device tree binding can found in `Documentation/devicetree/bindings/clock/maxim,max9485.txt`,
    in the kernel source tree.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时钟驱动程序的实现可以在 `drivers/clk/clk-max9485.c` 中找到，而它的设备树绑定可以在内核源树中的 `Documentation/devicetree/bindings/clock/maxim,max9485.txt`
    中找到。
- en: GPIO gate clock alternative
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPIO 门时钟替代
- en: 'This is a basic clock that can be enabled and disabled through a gpio output.
    `gpio-gate-clock` instances can only be instantiated from the device tree. For
    this, the `compatible` property should be `gpio-gate-clock` and `#clock-cells`
    should be `<0>` as shown in the following excerpt from `imx6qdl-sr-som-ti.dtsi`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本时钟，可以通过gpio输出进行启用和禁用。`gpio-gate-clock` 实例只能从设备树中实例化。为此，`compatible` 属性应该是
    `gpio-gate-clock`，`#clock-cells` 应该是 `<0>`，如下面从 `imx6qdl-sr-som-ti.dtsi` 中的摘录所示：
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This clock-type driver is located in `drivers/clk/clk-gpio.c`, and further reading
    can be found in `Documentation/devicetree/bindings/clock/gpio-gate-clock.txt`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时钟类型的驱动程序位于 `drivers/clk/clk-gpio.c`，更多的信息可以在 `Documentation/devicetree/bindings/clock/gpio-gate-clock.txt`
    中找到。
- en: Clock multiplexer and its ops
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟复用器及其操作
- en: 'A clock multiplexer has multiple input clock signals or parents, among which
    only one can be selected as output. Since this type of clock can choose from among
    multiple parents, the `.get_parent`/`.set_parent`/`.recalc_rate` callbacks should
    be implemented. A mux clock is represented in the CCF by an instance of `struct
    clk_mux`, which looks as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟复用器具有多个输入时钟信号或父级，其中只能选择一个作为输出。由于这种类型的时钟可以从多个父级中选择，因此应该实现 `.get_parent`/`.set_parent`/`.recalc_rate`
    回调。在CCF中，mux时钟由 `struct clk_mux` 的实例表示，如下所示：
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s take a look at the elements shown in the preceding structure:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前面结构中显示的元素：
- en: '`table` is an array of register values corresponding to the parent index.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table` 是一个对应于父索引的寄存器值数组。'
- en: '`mask` and `shift` are used to modify the `reg` bit field prior to getting
    the appropriate value.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask` 和 `shift` 用于在获取适当值之前修改 `reg` 位字段。'
- en: '`reg` is the mmio register used for parent selection. By default, when the
    register''s value is 0, it corresponds to the first parent, and so on. If there
    are exceptions, various `flags` can be used, as well as another interface.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg` 是用于父级选择的mmio寄存器。默认情况下，当寄存器的值为0时，它对应于第一个父级，依此类推。如果有例外情况，可以使用各种 `flags`，以及另一个接口。'
- en: '`flags` represents the unique flags of the mux clock, which are as follows:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 代表了时钟复用器的唯一标志，如下所示：'
- en: '--`CLK_MUX_INDEX_BIT`: The register value is a power of 2\. We will look at
    how this works shortly.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_MUX_INDEX_BIT`：寄存器值是2的幂。我们很快将看到这是如何工作的。
- en: '--`CLK_MUX_HIWORD_MASK`: This uses the concept of the hiword mask, which we
    explained earlier.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_MUX_HIWORD_MASK`：这使用了我们之前解释过的hiword mask的概念。
- en: '--`CLK_MUX_INDEX_ONE`: The register value does not start from 0, instead starting
    at 1\. This means that the final value should be incremented by one.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_MUX_INDEX_ONE`：寄存器值不是从0开始，而是从1开始。这意味着最终值应该增加一。
- en: '--`CLK_MUX_READ_ONLY`: Some platforms have read-only clock muxes that are preconfigured
    at reset and cannot be changed at runtime.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_MUX_READ_ONLY`：一些平台具有只读时钟复用器，这些时钟复用器在复位时预先配置，并且无法在运行时更改。
- en: '--`CLK_MUX_ROUND_CLOSEST` : This flag uses the parent rate that is closest
    to the desired frequency.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: --`CLK_MUX_ROUND_CLOSEST`：这个标志使用最接近所需频率的父级频率。
- en: '`lock`, if provided, is used to protect access to the register.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`，如果提供，用于保护对寄存器的访问。'
- en: 'The CCF helper that''s used to register such a clock is `clk_hw_register_mux()`.
    This looks as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 用于注册这样一个时钟的CCF助手是 `clk_hw_register_mux()`。如下所示：
- en: '[PRE55]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Some of the parameters in the preceding registration interface were introduced
    when we described the mux clock structure. The remaining parameters are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的注册接口中介绍了一些参数，当我们描述mux时钟结构时引入了这些参数。其余的参数如下：
- en: '`parent_names`: This is an array of strings that describes all possible parent
    clocks.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_names`：这是一个描述所有可能的父时钟的字符串数组。'
- en: '`num_parents`: This specifies the number of parent clocks.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_parents`：这指定了父时钟的数量。'
- en: 'While registering such a clock, depending on the `CLK_MUX_READ_ONLY` flag being
    set or not, the CCF assigns different clock ops. If set, `clk_mux_ro_ops` is used.
    This clock ops only implements the `.get_parent` ops as there would be no way
    to change the parent. If this is not set, `clk_mux_ops` is used. This ops implements
    `.get_parent`, `.set_parent`, and `.determine_rate`, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册这样一个时钟时，根据是否设置了 `CLK_MUX_READ_ONLY` 标志，CCF 分配不同的时钟操作。如果设置了，将使用 `clk_mux_ro_ops`。这个时钟操作只实现了
    `.get_parent` 操作，因为没有办法更改父级。如果没有设置，将使用 `clk_mux_ops`。这个操作实现了 `.get_parent`、`.set_parent`
    和 `.determine_rate`，如下所示：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These clock ops are defined as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时钟操作定义如下：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, there is a `.table` field. This is used to provide a
    set of values according to the parent index. However, the preceding registration
    interface, `clk_hw_register_mux()`, does not provide us with any way to feed this
    table.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个`.table`字段。这用于根据父级索引提供一组值。然而，前面的注册接口`clk_hw_register_mux()`并没有提供任何方法来提供这个表格。
- en: 'Due to this, there is another variant available in the CCF that allows us to
    pass the table:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，在CCF中还有另一种变体可用，允许我们传递表格：
- en: '[PRE58]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The interface registers a mux to control an irregular clock through a table.
    Whatever the registration interface is, the same internal ops are used. Now, let''s
    pay special attention to the most important ones; that is, `.set_parent` and `.get_parent`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口注册了一个多路复用器，用于通过表格控制不规则时钟。无论注册接口是什么，都会使用相同的内部操作。现在，让我们特别关注最重要的部分；即`.set_parent`和`.get_parent`：
- en: '`clk_mux_set_parent`: When this is called, if `table` is not `NULL`, it gets
    a register value from the index in `table`. If `table` is `NULL` and the `CLK_MUX_INDEX_BIT`
    flag is set, this means the register value is a power of 2 according to `index`.
    This value is then obtained with `val = 1 << index`; if `CLK_MUX_INDEX_ONE` is
    set, this value is incremented by one. If `table` is `NULL` and `CLK_MUX_INDEX_BIT`
    is not set, `index` is used as the default value. In either case, the final value
    is left-shifted at `shift` time and OR''ed with a mask prior to us obtaining the
    real value. This should be written into `reg` for parent selection:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk_mux_set_parent`：当调用此函数时，如果`table`不是`NULL`，它会从`table`中的索引获取寄存器值。如果`table`是`NULL`并且设置了`CLK_MUX_INDEX_BIT`标志，则这意味着寄存器值是根据`index`的幂。然后使用`val
    = 1 << index`来获取该值；如果设置了`CLK_MUX_INDEX_ONE`，则该值会增加一。如果`table`是`NULL`并且未设置`CLK_MUX_INDEX_BIT`，则`index`将用作默认值。在任何情况下，最终值在`shift`时间左移，并在我们获取实际值之前与掩码进行OR运算。这应该写入`reg`以进行父级选择：'
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`clk_mux_get_parent`: This reads the value in `reg`, shifts it `shift` time
    to the right and applies (the AND operation) `mask` to it prior to getting the
    real value. This value is then given to the `clk_mux_val_to_index()` helper, which
    will return the right index according to the `reg` value. `clk_mux_val_to_index()`
    first gets the number of parents for the given clock. If `table` is not `NULL`,
    this number is used as the upper limit in a loop to walk through `table`. Each
    iteration will check whether the `table` value at the current position matches
    `val`. If it does, the current position in the iteration is returned. If no match
    is found, an error is returned. `ffs()` returns the position of the first (least
    significant) bit set in the word:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk_mux_get_parent`：这会读取`reg`中的值，将其向右移动`shift`次，并在获取实际值之前应用（AND操作）`mask`。然后将该值传递给`clk_mux_val_to_index()`辅助函数，该函数将根据`reg`的值返回正确的索引。`clk_mux_val_to_index()`首先获取给定时钟的父级数量。如果`table`不是`NULL`，则此数字将用作循环中的上限，以遍历`table`。每次迭代都会检查当前位置的`table`值是否与`val`匹配。如果匹配，则返回当前迭代中的当前位置。如果找不到匹配项，则返回错误。`ffs()`返回字中设置的第一个（最低有效）位的位置：'
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: An example of such a driver can be found in `drivers/clk/microchip/clk-pic32mzda.c`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此类驱动程序的示例可以在`drivers/clk/microchip/clk-pic32mzda.c`中找到。
- en: I2C/SPI-based clock mux
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于I2C/SPI的时钟多路复用
- en: The aforementioned CCF interfaces that are used to handle clock muxes assume
    that control is provided via mmio registers. However, there are some I2C/SPI-based
    clock mux chips where you have to rely on the low-level `clk_hw` (using a `clk_hw_register()`
    registration-based interface) interface and register each clock according to its
    properties before providing the appropriate ops.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理时钟多路复用的上述CCF接口假定通过mmio寄存器提供控制。然而，有一些基于I2C/SPI的时钟多路复用芯片，您必须依赖低级的`clk_hw`（使用基于`clk_hw_register()`注册的接口）接口，并根据其属性注册每个时钟，然后提供适当的操作。
- en: Each mux input clock should be a parent of the mux output, which must have at
    least `.set_parent` and `.get_parent` ops. Other ops are also allowed but not
    mandatory. A concrete example is the Linux driver for the `Si5351a/b/c` programmable
    I2C clock generator from Silicon Labs, available in `drivers/clk/clk-si5351.c`
    in the kernel sources. Its device tree binding is available in `Documentation/devicetree/bindings/clock/silabs,si5351.txt`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 每个多路复用输入时钟应该是多路复用输出的父级，它必须至少具有`.set_parent`和`.get_parent`操作。其他操作也是允许的，但不是强制性的。一个具体的例子是来自Silicon
    Labs的`Si5351a/b/c`可编程I2C时钟发生器的Linux驱动程序，可以在内核源代码中的`drivers/clk/clk-si5351.c`中找到。其设备树绑定可以在`Documentation/devicetree/bindings/clock/silabs,si5351.txt`中找到。
- en: Important note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: To write such clock drivers, you must learn how `clk_hw_register_mux` is implemented
    and base your registration function on it, without the mmio/spinlock part, and
    then provide your own ops according to the clock's properties.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写此类时钟驱动程序，您必须了解`clk_hw_register_mux`是如何实现的，并基于它构建您的注册函数，不包括mmio/spinlock部分，然后根据时钟的属性提供自己的操作。
- en: GPIO mux clock alternative
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPIO多路复用时钟替代方案
- en: 'The GPIO mux clock can be represented as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO多路复用时钟可以表示如下：
- en: '![Figure 4.2 – GPIO mux clock'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - GPIO多路复用时钟'
- en: '](img/Figure_4.2_B10985.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B10985.jpg)'
- en: Figure 4.2 – GPIO mux clock
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - GPIO多路复用时钟
- en: 'This is a limited alternative to clock multiplexing that only accepts two parents,
    as stated in the following excerpt from its drivers, which are available in `drivers/clk/clk-gpio.c`.
    In this case, the parent selection depends on the value of the gpio being used:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是时钟多路复用的有限替代方案，只接受两个父级，如其驱动程序中所述，可以在`drivers/clk/clk-gpio.c`中找到。在这种情况下，父级选择取决于所使用的gpio的值：
- en: '[PRE61]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'According to its binding, it is only instantiable in the device tree. This
    binding can be found in `Documentation/devicetree/bindings/clock/gpio-mux-clock.txt`,
    in the kernel sources. The following example show how to use it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其绑定，它只能在设备树中实例化。此绑定可以在内核源代码中的`Documentation/devicetree/bindings/clock/gpio-mux-clock.txt`中找到。以下示例显示了如何使用它：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we have looked at the clock multiplexer, which allows us to select a clock
    source from its APIs and device tree binding. Moreover, we introduced the GPIO-based
    clock multiplexer alternative, which does not require that we write any code.
    The next clock type in this series is the divider clock, which, as its name suggests,
    divides the parent rate by a given ratio.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看过时钟多路复用器，它允许我们从其API和设备树绑定中选择时钟源。此外，我们介绍了基于GPIO的时钟多路复用器替代方案，它不需要我们编写任何代码。这个系列中的下一个时钟类型是分频器时钟，正如其名称所示，它通过给定的比率将父速率除以。
- en: (Adjustable) divider clock and its ops
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: （可调节）分频器时钟及其操作
- en: 'This type of clock divides the parent rate and cannot gate. Since you can set
    the divider ratio, providing a `.recalc_rate`/`.set_rate`/`.round_rate` callback
    is a must. A clock divider is represented in the kernel as an instance of a `struct
    clk_divider`. This can be defined as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的时钟将父速率除以并且不能进行门控。由于可以设置分频器比率，因此必须提供`.recalc_rate`/`.set_rate`/`.round_rate`回调。时钟分频器在内核中表示为`struct
    clk_divider`的实例。这可以定义如下：
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s take a look at element in this structure:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个结构中的元素：
- en: '`hw`: The underlying `clock_hw` structure that defined the provider side.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw`: 定义了提供方的底层`clock_hw`结构。'
- en: '`reg`: This is the register that controls the clock division ratio. By default,
    the actual divider value is the register value plus one. If there are other exceptions,
    you can refer to the `flags` field descriptions for adapting.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`: 这是控制时钟分频比的寄存器。默认情况下，实际的分频器值是寄存器值加一。如果有其他异常，您可以参考`flags`字段描述进行调整。'
- en: '`shift`: This controls the offset of the bit of the division ratio in the register.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`: 这控制了寄存器中分频比的位的偏移量。'
- en: '`width`: This is the width of the divider bit field. It controls the bit number
    of the division ratio. For example, if `width` is 4, this means the division ratio
    is coded on 4 bits.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 这是分频器位字段的宽度。它控制分频比的位数。例如，如果`width`为4，这意味着分频比编码在4位上。'
- en: '`flags`: This is the divider-clock-specific flag of the clock. Various flags
    can be used here, some of which are as follows:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`: 这是时钟分频器特定标志的标志。这里可以使用各种标志，其中一些如下：'
- en: '--`CLK_DIVIDER_ONE_BASED`: When set, this means that the divider is the raw
    value that''s read from the register since the default divisor is the value that''s
    read from the register plus one. This also implies 0 is invalid, unless the `CLK_DIVIDER_ALLOW_ZERO`
    flag is set.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_ONE_BASED`: 当设置时，这意味着分频器是从寄存器中读取的原始值，因为默认的除数是从寄存器中读取的值加一。这也意味着0是无效的，除非设置了`CLK_DIVIDER_ALLOW_ZERO`标志。'
- en: '--`CLK_DIVIDER_ROUND_CLOSEST`: This should be used when we want to be able
    to round the divider to the closest and best calculated one instead of just rounding
    up, which is the default behavior.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_ROUND_CLOSEST`: 当我们希望能够将分频器四舍五入到最接近和最佳计算的值而不仅仅是向上舍入时，应该使用这个选项，这是默认行为。'
- en: '--`CLK_DIVIDER_POWER_OF_TWO`: The actual divider value is the register value
    raised to a power of 2.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_POWER_OF_TWO`: 实际的分频器值是寄存器值的2的幂。'
- en: '--`CLK_DIVIDER_ALLOW_ZERO`: The divider value can be 0 (no change, depending
    on hardware support).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_ALLOW_ZERO`: 除数值可以为0（不变，取决于硬件支持）。'
- en: '--`CLK_DIVIDER_HIWORD_MASK`: See the *Gateable clock and its ops* section for
    more details on this flag.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_HIWORD_MASK`: 有关此标志的更多详细信息，请参阅*可门控时钟及其操作*部分。'
- en: '--`CLK_DIVIDER_READ_ONLY`: This flag shows that the clock has preconfigured
    settings and instructs the framework not to change anything. This flag also affects
    the ops that have been assigned to the clock.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '--`CLK_DIVIDER_READ_ONLY`: 这个标志表明时钟具有预配置的设置，并指示框架不要改变任何东西。这个标志也影响了分配给时钟的操作。'
- en: '`CLK_DIVIDER_MAX_AT_ZERO`: This allows a clock divider to have a max divisor
    when it''s set to zero. So, if the field value is zero, the divisor value should
    be 2 bits in width. For example, let''s consider a divisor clock with a 2-bit
    field:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLK_DIVIDER_MAX_AT_ZERO`: 这允许时钟分频器在设置为零时具有最大除数。因此，如果字段值为零，则除数值应为2位宽度。例如，让我们考虑一个具有2位字段的除数时钟：'
- en: '[PRE64]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`table`: This is an array of value/divider pairs whose last entry should have
    `div = 0`. This will be described shortly.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`表`: 这是一个值/分频器对的数组，最后一个条目应该有`div = 0`。这将很快描述。'
- en: '`lock`: Like in other clock data structures, if provided, it is used to protect
    access to the register.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`锁定`: 与其他时钟数据结构一样，如果提供了，它将用于保护对寄存器的访问。'
- en: '`clk_hw_register_divider()`: This is the most commonly used registration interface
    for such clocks. It is defined as follows:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clk_hw_register_divider()`: 这是最常用的此类时钟的注册接口。它定义如下：'
- en: '[PRE65]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This function registers a divider clock with the system and returns a pointer
    to the underlying `clk_hw` field. Here, you can can use the `to_clk_divider` macro
    to grab a pointer to the wrapper's `clk_divider` structure. Except for `name`
    and `parent_name`, which represent the name of the clock and the name of its parent,
    respectively, the other arguments in this function match the fields described
    in the `struct clk_divider` structure.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在系统中注册一个分频器时钟，并返回指向底层`clk_hw`字段的指针。在这里，您可以使用`to_clk_divider`宏来获取指向包装器的`clk_divider`结构的指针。除了`name`和`parent_name`，它们分别表示时钟的名称和其父级的名称，此函数中的其他参数与`struct
    clk_divider`结构中描述的字段匹配。
- en: 'You may have noticed that the `.table` field is not being used here. This field
    is kind of special as it is used for clock dividers whose division ratios are
    uncommon. Actually, there are clock dividers where each individual clock line
    has a number of division ratios that are not related to each other''s clock lines.
    Sometimes, there is not even any linearity between each ratio and the register
    value. For such cases, the best solution is to feed each clock line a table, where
    each ratio corresponds to its register value. This requires us to introduce a
    new registration interface that accepts such a table; that is, `clk_hw_register_divider_table`.
    This can be defined as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这里没有使用`.table`字段。这个字段有点特殊，因为它用于那些除法比率不常见的时钟分频器。实际上，有些时钟分频器的每个单独的时钟线都有一些不相关的分频比率。有时，甚至每个比率和寄存器值之间都没有线性关系。对于这种情况，最好的解决方案是为每个时钟线提供一个表，其中每个比率对应其寄存器值。这要求我们引入一个接受这样一个表的新注册接口；即`clk_hw_register_divider_table`。可以定义如下：
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This interface is used to register the clock with an irregular frequency division
    ratio, compared to the preceding interface. The difference is that the relationship
    between the value of the divider and the value of the register is determined by
    a table of the `struct clk_div_table` type. This table structure can be defined
    as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口用于注册具有不规则频率分频比的时钟，与前面的接口相比。不同之处在于分频器的值与寄存器的值之间的关系是由`struct clk_div_table`类型的表确定的。这个表结构可以定义如下：
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding code, `val` represents the register value, while `div` represents
    the division ratio. Their relationship can also be changed byusing `clk_divider_flags`.
    Regardless of what registration interface is used, the `CLK_DIVIDER_READ_ONLY`
    flag determines the ops to be assigned to the clock, as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`val`代表寄存器值，而`div`代表除法比率。它们的关系也可以通过使用`clk_divider_flags`来改变。无论使用何种注册接口，`CLK_DIVIDER_READ_ONLY`标志都确定了要分配给时钟的操作，如下所示：
- en: '[PRE68]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Both these clock ops are defined in `drivers/clk/clk-divider.c`, as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个时钟操作都在`drivers/clk/clk-divider.c`中定义，如下所示：
- en: '[PRE69]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: While the former can set the clock rate, the last one cannot.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 前者可以设置时钟速率，而后者则不能。
- en: Important note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Once again, so far, using the clock-type-dependent registration interface provided
    by the kernel requires your clock to be mmio. Implementing such a clock driver
    for a non-mmio-based (SPI or I2C-based) clock would require using the low-level
    `hw_clk` registration interface and implementing the appropriate ops. An example
    of such a driver for an I2C-based clock, along with the appropriate ops implemented,
    can be found in `drivers/clk/clk-max9485.c`. Its binding can be found in `Documentation/devicetree/bindings/clock/maxim,max9485.txt`.
    This is a much more adjustable clock driver than the divider one.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，到目前为止，使用内核提供的时钟类型相关注册接口需要你的时钟是mmio。为非mmio型（基于SPI或I2C的）时钟实现这样的时钟驱动程序需要使用低级`hw_clk`注册接口并实现适当的操作。一个基于I2C的时钟驱动程序的示例，以及已实现的适当操作，可以在`drivers/clk/clk-max9485.c`中找到。其绑定可以在`Documentation/devicetree/bindings/clock/maxim,max9485.txt`中找到。这是一个比分频器更可调的时钟驱动程序。
- en: 'The adjustable clock has no secrets for us anymore. Its APIs and ops have been
    described, as well as how it deals with irregular ratios. Next, we''ll look at
    our final clock type, which is a mix of all the clock types we have seen so far:
    the composite clock.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 可调时钟对我们来说已经没有秘密了。它的API和操作已经被描述，以及它如何处理不规则的比率。接下来，我们将看看我们迄今为止看到的所有时钟类型的最终时钟类型：复合时钟。
- en: Composite clock and its ops
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合时钟及其操作
- en: 'This clock is used for clock branches that use a combination of mux, divider,
    and gate components. This is the case on most Rockchip SoCs. The clock framework
    abstracts such clocks by means of `struct clk_composite`, which looks as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时钟用于使用复用器、分频器和门组件的时钟分支。这在大多数Rockchip SoC上都是这样。时钟框架通过`struct clk_composite`来抽象这样的时钟，其外观如下：
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The fields in this data structure are quite self-explanatory, as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据结构中的字段相当自明，如下所示：
- en: '`hw`, as in other clock structures, is the handle between common and hardware-
    specific interfaces.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw`，就像其他时钟结构一样，是通用和硬件特定接口之间的处理。'
- en: '`mux_hw` represents the mux clock.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux_hw`代表复用器时钟。'
- en: '`rate_hw` represents the divider clock.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate_hw`代表分频时钟。'
- en: '`gate_hw` represents the gate clock.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_hw`代表门时钟。'
- en: '`mux_ops`, `rate_ops`, and `gate_ops` are the clock ops for mux, rate, and
    gate, respectively.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux_ops`、`rate_ops`和`gate_ops`分别是复用器、速率和门的时钟操作。'
- en: 'Such a clock can be registered through the following interface:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的时钟可以通过以下接口进行注册：
- en: '[PRE71]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This may look a bit complicated, but if you went through the previous clock,
    this one will be more or less obvious to you. Take a look at `drivers/clk/sunxi/clk-a10-hosc.c`
    in the kernel source for an example of a composite clock driver.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点复杂，但如果你已经了解了之前的时钟，这个就会对你来说更加明显。在内核源代码中查看`drivers/clk/sunxi/clk-a10-hosc.c`，可以找到一个复合时钟驱动程序的示例。
- en: Putting it all together – global overview
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容汇总-全局概述
- en: 'If you are still confused, then take a look at the following diagram:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还感到困惑，那么看一下下面的图表：
- en: '![Figure 4.3 – Clock tree example'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 时钟树示例'
- en: '](img/Figure_4.3_B10985.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B10985.jpg)'
- en: Figure 4.3 – Clock tree example
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 时钟树示例
- en: The preceding clock tree shows an oscillator clock feeding three PLLs – that
    is, `pll1`, `pll2`, and `pll3` – as well as a multiplexer. According to the multiplexer
    (mux), `hw3_clk` can be derived from either the `pll2`, `pll3`, or `osc` clock.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 上述时钟树显示了一个振荡器时钟馈送三个PLL - 即`pll1`、`pll2`和`pll3` - 以及一个多路复用器。根据多路复用器（mux），`hw3_clk`可以从`pll2`、`pll3`或`osc`时钟派生出来。
- en: 'The following device tree excerpt can be used to model the preceding clock
    tree:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设备树摘录可用于建模上述时钟树：
- en: '[PRE72]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When it comes to the source code, the following excerpt shows how to register
    `hw_clk3` as a mux (a clock multiplexer) and points out the parent relationship
    of `pll2`, `pll3`, and `osc`:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到源代码时，以下摘录显示了如何将 `hw_clk3` 注册为一个复用器（时钟复用器），并指出了 `pll2`、`pll3` 和 `osc` 的父关系：
- en: '[PRE73]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A downstream clock provider should use `of_clk_get_parent_name()` to obtain
    its parent clock name. For a block with multiple outputs, `of_clk_get_parent_name()`
    can return a valid clock name, but only when the `clock-output-names` property
    is present.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 下游时钟提供者应该使用 `of_clk_get_parent_name()` 来获取其父时钟名称。对于具有多个输出的块，`of_clk_get_parent_name()`
    可以返回一个有效的时钟名称，但只有在存在 `clock-output-names` 属性时才能返回。
- en: 'Now, we can look at the clock tree summary via the CCF *sysfs* interface, `/sys/kernel/debug/clk/clk_summary`.
    This can be seen in the following excerpt:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过CCF *sysfs*接口 `/sys/kernel/debug/clk/clk_summary` 查看时钟树摘要。这可以在以下摘录中看到：
- en: '[PRE74]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: With that, we are done with the clock producer side. We have learned about its
    APIs and discussed its declaration in the device tree. Moreover, we have learned
    how to dump their topology from *sysfs*. Now, let's look at clock consumer APIs.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了时钟生产者方面的工作。我们已经了解了它的API，并讨论了它在设备树中的声明。此外，我们已经学会了如何从 *sysfs* 中转储它们的拓扑结构。现在，让我们来看看时钟消费者API。
- en: Introducing clock consumer APIs
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍时钟消费者APIs
- en: 'Clock producer device drivers are useless without consumers at the other end
    to leverage the clock lines that have been exposed. The main purpose of such drivers
    is to assign their clock source lines to consumers. These clock lines are then
    used for several purposes, and the Linux kernel provides consequent APIs and helpers
    to achieve the required goal. Consumer drivers need to include `<linux/clk.h>`
    in their code for its APIs to be used. Moreover, nowadays, the clock consumer
    interface entirely relies on the device tree, meaning that consumers should be
    assigned clocks they need from the device tree. The consumer binding should follow
    the provider''s since the consumer specifier is determined by the provider''s
    `#clock-cells` property. Take a look at the following UART node description, which
    requires two clock lines:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟生产者设备驱动程序如果没有在另一端利用已暴露的时钟线的消费者，就是无用的。这类驱动程序的主要目的是将它们的时钟源线分配给消费者。然后，这些时钟线被用于多种目的，Linux内核提供了相应的API和辅助程序来实现所需的目标。消费者驱动程序需要在其代码中包含
    `<linux/clk.h>`，以便使用其API。此外，如今，时钟消费者接口完全依赖于设备树，这意味着消费者应该从设备树中分配它们需要的时钟。消费者绑定应该遵循提供者的绑定，因为消费者的指定符是由提供者的
    `#clock-cells` 属性确定的。看一下以下UART节点描述，它需要两条时钟线：
- en: '[PRE75]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This represents a device with two clock inputs. The preceding node excerpt
    allows us to introduce the device tree binding for the clock consumer, which should
    have, at the very least, the following properties:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表一个具有两个时钟输入的设备。前面的节点摘录允许我们为时钟消费者引入设备树绑定，它至少应该具有以下属性：
- en: The `clocks` property is where you should specify the source clock lines for
    a device with respect to the `#clock-cells` property of the provider.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clocks` 属性是您应该指定设备的源时钟线的位置，以相对于提供者的 `#clock-cells` 属性。'
- en: '`clock-names` is the property used to name clocks in the same way they are
    listed in `clocks`. In other words, this property should be used to list the input
    name(s) for the clock(s) with respect to the consuming node. This name(s) should
    reflect the consumer input signal name(s) and can/must be used in the code (see
    `[devm_]clk_get()`) so that it matches the corresponding clock.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-names` 是用来命名时钟的属性，以与它们在 `clocks` 中列出的方式相同。换句话说，这个属性应该用来列出相对于消费节点的时钟的输入名称。这个名称应该反映消费者输入信号的名称，并且可以/必须在代码中使用（参见
    `[devm_]clk_get()`），以便与相应的时钟匹配。'
- en: Important note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Clock consumer nodes must never directly reference the provider's `clock-output-names`
    property.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟消费节点绝对不能直接引用提供者的 `clock-output-names` 属性。
- en: The consumer has a reduced and portable API based on whatever the underlying
    hardware clock is. Next, we'll take a look at the common operations that are performed
    by consumer drivers, along with their associated APIs.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者具有基于底层硬件时钟的简化和可移植的API。接下来，我们将看一下消费驱动程序执行的常见操作，以及它们关联的API。
- en: Grabbing and releasing clocks
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抓取和释放时钟
- en: 'The following functions allow us to grab and release a clock, given its `id`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数允许我们根据其 `id` 抓取和释放时钟：
- en: '[PRE76]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`dev` is the device using this clock, while `id` is the name given to the clock
    in the device tree. On success, `clk_get` returns a pointer to a `struct clk`.
    This can be given to any other `clk-consumer` API. `clk_put` actually releases
    the clock line. The first two APIs in the preceding code are defined in `drivers/clk/clkdev.c`.
    However, other clock consumer APIs are defined in `drivers/clk/clk.c`. `devm_clk_get`
    is simply the managed version of `clk_get`.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev` 是使用此时钟的设备，而 `id` 是在设备树中给出的时钟名称。成功后，`clk_get` 返回一个指向 `struct clk` 的指针。这可以提供给任何其他
    `clk-consumer` API。`clk_put` 实际上释放了时钟线。前面代码中的前两个API在 `drivers/clk/clkdev.c` 中定义。然而，其他时钟消费者API在
    `drivers/clk/clk.c` 中定义。`devm_clk_get` 简单地是 `clk_get` 的托管版本。'
- en: Preparing/unpreparing clocks
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备/取消准备时钟
- en: 'To prepare a clock for use, you can use `clk_prepare()`, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备使用时钟，可以使用 `clk_prepare()`，如下所示：
- en: '[PRE77]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: These functions may sleep, which means they cannot be called from within an
    atomic context. It is worth always calling `clk_prepare()` before `clock_enable()`.
    This may be useful if the underlying clock is behind a slow bus (SPI/I2C) since
    such clock drivers must implement their enable/disable (which must not sleep)
    code from within the prepare/unprepare ops (which are allowed to sleep).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可能会休眠，这意味着它们不能在原子上下文中调用。在调用 `clock_enable()` 之前，始终调用 `clk_prepare()` 是值得的。如果底层时钟位于慢总线（SPI/I2C）后面，这可能很有用，因为这样的时钟驱动程序必须在准备/取消准备操作中实现它们的启用/禁用（不能休眠），而这些操作允许休眠。
- en: Enabling/disabling
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 启用/禁用
- en: 'When it comes to gating/ungating the clock, you can use the following API:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到对时钟进行门控/解除门控时，可以使用以下API：
- en: '[PRE78]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`clk_enable` must not sleep and actually ungates the clock. It returns 0 on
    success or an error otherwise. `clk_disable` does the reverse. To enforce the
    fact of calling prepare prior to calling enable, the clock framework provide the
    `clk_prepare_enable` API, which internally calls both. The opposite can be done
    with `clk_disable_unprepare`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`clk_enable`不能休眠，实际上解除时钟门控。成功返回0，否则返回错误。`clk_disable`则相反。为了在调用启用之前调用准备的事实，时钟框架提供了`clk_prepare_enable`
    API，它在内部同时调用两者。相反的操作可以使用`clk_disable_unprepare`：'
- en: '[PRE79]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Rate functions
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率函数
- en: 'For clocks whose rates can be changed, we can use the following function to
    get/set the rate of the clock:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以更改速率的时钟，我们可以使用以下函数来获取/设置时钟的速率：
- en: '[PRE80]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`clk_get_rate()`returns 0 if `clk` is `NULL`; otherwise, it will return the
    rate of the clock; that is, the cached rate. However, if the `CLK_GET_RATE_NOCACHE`
    flag is set, a new calculation will be done (by means of `recalc_rate()`) to return
    the real clock rate. On the other hand, `clk_set_rate()` will set the rate of
    the clock. However, its rate parameter can''t take any value. To see if the rate
    you are targeting is supported or allowed by the clock, you should use `clk_round_rate()`,
    along with the clock pointer and the target rate in Hz, as follows.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clk`是`NULL`，`clk_get_rate（）`返回0；否则，它将返回时钟的速率；也就是说，缓存速率。但是，如果设置了`CLK_GET_RATE_NOCACHE`标志，将通过`recalc_rate（）`进行新的计算，以返回实际的时钟速率。另一方面，`clk_set_rate（）`将设置时钟的速率。但是，它的速率参数不能取任何值。要查看您所针对的速率是否受时钟支持或允许，应该使用`clk_round_rate（）`，以及时钟指针和目标速率（以赫兹为单位），如下所示。
- en: '[PRE81]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is the return value of `clk_round_rate(`) that must be given to `clk_set_rate()`,
    as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`clk_round_rate（）`的返回值，必须提供给`clk_set_rate（）`，如下所示：
- en: '[PRE82]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Changing the clock rate may fail in the following cases:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，更改时钟速率可能会失败：
- en: The clock is drawing its source from a fixed-rate clock source (for example,
    `OSC0`, `OSC1`, `XREF`, and so on).
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟从固定速率时钟源（例如`OSC0`，`OSC1`，`XREF`等）获取其源。
- en: The clock is in use by multiple modules/children, which would mean that `usecount`
    is greater than 1.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟被多个模块/子级使用，这意味着`usecount`大于1。
- en: The clock source is in use by more than one child.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟源被多个子级使用。
- en: Note that parent rates are returned if `.round_rate()` is not implemented.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果未实现`.round_rate（）`，则将返回父速率。
- en: Parent functions
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父函数
- en: 'There are clocks that are the children of other clocks, thus creating a parent/child
    relationship. To either get/set the parent of a given clock, you can use the following
    functions:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 有些时钟是其他时钟的子级，从而创建了父/子关系。要获取/设置给定时钟的父级，可以使用以下函数：
- en: '[PRE83]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`clk_set_parent()` actually sets the parent of the given clock, while `clk_get_parent()`
    returns the current parent.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`clk_set_parent（）`实际上设置了给定时钟的父级，而`clk_get_parent（）`返回当前父级。'
- en: Putting it all together
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'To summarize this, take a look at the following excerpt of the i.MX serial
    driver (`drivers/tty/serial/imx.c`), which deals with the preceding device node:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，看一下i.MX串行驱动程序（`drivers/tty/serial/imx.c`）的以下摘录，处理前面的设备节点：
- en: '[PRE84]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding code excerpt, we see can how the driver grabs the clock and
    its current rate, and then enables it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码摘录中，我们可以看到驱动程序如何获取时钟及其当前速率，然后启用它。
- en: Summary
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through the Linux Common Clock Framework. We introduced
    both the provider and consumer sides, as well as the user space interface. We
    then discussed the different clock types and learned how to write the appropriate
    Linux drivers for each.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Linux通用时钟框架。我们介绍了提供程序和使用者双方，以及用户空间接口。然后，我们讨论了不同的时钟类型，并学习了如何为每个类型编写适当的Linux驱动程序。
- en: The next chapter deals with ALSA SoC, the Linux kernel framework for audio.
    This framework heavily relies on the clock framework to, for example, sample audio.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涉及ALSA SoC，即Linux内核音频框架。该框架在很大程度上依赖时钟框架，例如用于对音频进行采样。
