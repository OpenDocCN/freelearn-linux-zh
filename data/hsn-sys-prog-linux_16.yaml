- en: Multithreading with Pthreads Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pthreads多线程第三部分
- en: Having covered, in [Chapters 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml), *Multithreading
    with Pthreads Part I - Essentials**,* and [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*, a lot of the whys and
    hows of writing powerful **multithreaded** (**MT**) applications, this chapter
    focuses on teaching the reader several key safety aspects of MT programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)和[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)中已经涵盖了编写强大的多线程（MT）应用程序的许多原因和方法，本章重点介绍了教授读者多线程编程的几个关键安全方面。
- en: It sheds some light on many key safety aspects of developing safe and robust
    MT applications; here, the reader will learn about thread safety, why it is required,
    and how to make a function thread-safe. While running, it's possible to have one
    thread kill another thread; this is achieved via the thread-cancelation mechanism—going hand
    in hand with cancelation, how does one ensure that prior to terminating a thread,
    one ensures that it first releases any resources it is still holding (such as
    locks and dynamic memory)? Thread cleanup handlers are covered to show this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它为开发安全和健壮的MT应用程序的许多关键安全方面提供了一些启示；在这里，读者将了解线程安全性，为什么需要它以及如何使函数线程安全。在运行时，可能会有一个线程杀死另一个线程；这是通过线程取消机制实现的——与取消一起，如何确保在线程终止之前，首先确保它释放任何仍在持有的资源（如锁和动态内存）？线程清理处理程序用于展示这一点。
- en: Finally, this chapter delves into how to safely mix multithreading and signaling,
    some pros and cons of multiprocess versus multithreaded, as well as some tips
    and FAQs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章深入探讨了如何安全地混合多线程和信号，多进程与多线程的一些优缺点，以及一些技巧和常见问题解答。
- en: Thread safety
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全
- en: A key, and unfortunately often not a clearly apparent, issue when developing
    multithreaded applications is that of thread safety.A *thread-safe*, or, as the
    man pages like to specify it, MT-Safe, function or API is one that can be safely
    executed in parallel by multiple threads with no adverse issue.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发多线程应用程序时一个关键，但不幸的是经常不明显的问题是线程安全。一个*线程安全*，或者如man页面所指定的那样，MT-Safe的函数或API是可以安全地由多个线程并行执行而没有不利影响的函数。
- en: 'To understand what this thread-safety issue actually is, let''s go back to
    one of the programs we saw in [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials;* you can find the source code within the book''s GitHub
    repository: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c).
    In this program, we used `fopen(3)`to open a file in append mode and then performed
    some I/O (reads/writes) upon it; we duplicate a small paragraph of that chapter
    here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个线程安全问题实际上是什么，让我们回到我们在[附录A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)中看到的程序之一，*文件I/O基础知识*；您可以在书的GitHub存储库中找到源代码：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c)。在这个程序中，我们使用`fopen(3)`以附加模式打开文件，然后对其进行一些I/O（读/写）；我们在这里复制了该章节的一小段：
- en: 'We `fopen(3)` a stream (in append mode: `a`) to our destination, just a regular
    file in the `/tmp` directory (it will be created if it does not exist)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`fopen(3)`在附加模式（`a`）中打开一个流到我们的目标，只是在`/tmp`目录中的一个常规文件（如果不存在，将创建它）
- en: 'Then, in a loop, for a number of iterations provided by the user as a parameter,
    we will do the following:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在一个循环中，对用户提供的迭代次数，我们将执行以下操作：
- en: Read several (512) bytes from the source stream (they will be random values)
    via the `fread(3)` stdio library API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`fread(3)`stdio库API从源流中读取几个（512）字节（它们将是随机值）
- en: Write those values to our destination stream via the `fwrite(3)` stdio library
    API (checking for EOF and/or error conditions)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`fwrite(3)`stdio库API将这些值写入我们的目标流（检查EOF和/或错误条件）
- en: 'Here''s a snippet of the code, mainly the `testit` function performs the actual
    I/O; refer to: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码片段，主要是`testit`函数执行实际的I/O；参考：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/A_fileio/iobuf.c)：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the first line of code, it's really important to our discussion; the
    memory buffer used to hold the source and destination data is a global (static)
    variable, `gbuf`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码的第一行，它对我们的讨论非常重要；用于保存源和目标数据的内存缓冲区是一个全局（静态）变量，`gbuf`。
- en: 'Here''s where it''s allocated in the `main()` function of the app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在应用程序的`main()`函数中分配的位置：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So what? In [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*, we worked with the implicit assumption that the process
    is single-threaded; so long as this assumption remains true, the program will
    work well. But think carefully about this; the moment we want to port this program
    to become multithreaded-capable, the code is not good enough. Why? It should be
    quite clear: if multiple threads simultaneously execute the code of the `testit`function
    (which is exactly the expectation), the presence of the global shared writable
    memory variable, `gbuf`, tells us that we will have critical sections in the code
    path.As we learned in detail in [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*, every critical section
    must be either eliminated or protected to prevent data races.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那又怎样？在《附录A》*文件I/O基础*中，我们以隐含的假设为前提，即进程是单线程的；只要这个假设保持不变，程序就能正常工作。但仔细想想；一旦我们想要将这个程序移植成多线程能力，这段代码就不够好了。为什么？很明显：如果多个线程同时执行`testit`函数的代码（这正是预期的），全局共享的可写内存变量`gbuf`的存在告诉我们，在代码路径中会有临界区。正如我们在《第15章》*使用Pthreads进行多线程
    - 同步*中详细学到的，每个临界区必须要么被消除，要么被保护起来以防止数据竞争。
- en: In the preceding code fragment, we happily invoke both `fread(3)`and `fwrite(3)`on
    this global buffer without any protection whatsoever*. *Just visualize multiple
    threads that run through this code path simultaneously; the result is havoc.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们高兴地在这个全局缓冲区上调用了`fread(3)`和`fwrite(3)`，而没有任何保护。*想象一下多个线程同时运行这段代码路径；结果将是一片混乱。
- en: So, now we can see it and conclude that the `testit` function is not thread-safe(at
    the very least, the programmer must documentthis fact, preventing others from
    using the code in a multithreaded application!).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们可以看到并得出结论，`testit`函数是不是线程安全的（至少，程序员必须记录这一事实，防止其他人在多线程应用中使用这段代码！）。
- en: Worse imagine that the preceding thread-unsafe function we developed is merged
    into a shared library (often referred to as a shared object file on Unix/Linux);
    any (multithreaded) application that links into this library will have access
    to this function. If multiple threads of such an application ever invoke it, we
    have a potential race—a bug, a defect! Not just that, such defects are the really
    hard-to-spot and hard-to-understand ones, causing issues and perhaps all kinds
    of temporary bandage fixes (which only make the situation worse and the customer
    even less confident in the software). Disasters are caused in seemingly innocent
    ways indeed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，我们开发的前面的线程不安全函数被合并到一个共享库（在Unix/Linux上通常称为共享对象文件）中；任何链接到这个库的（多线程）应用程序都将可以访问这个函数。如果这样的应用程序的多个线程曾经调用它，我们就有了潜在的竞争
    - 一个错误，一个缺陷！不仅如此，这样的缺陷是真正难以发现和理解的，会引起各种问题，也许还会有各种临时的应急措施（这只会让情况变得更糟，让客户对软件的信心更少）。灾难确实是以看似无辜的方式引起的。
- en: Our conclusion on this is either render the function thread-safe, or clearly
    document it as being thread-unsafe (and only use it, if at all, in a single-threaded
    context).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结论是，要么使函数线程安全，要么明确将其标记为线程不安全（如果有的话，只在单线程环境中使用）。
- en: Making code thread-safe
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使代码线程安全
- en: 'Obviously, we would prefer to make the `testit` functionthread-safe. Now the
    question becomes, how exactly can we do that? Well, again, it''s quite straightforward:
    there are two approaches (more than two, actually, but we''ll get to that later).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们希望使`testit`函数线程安全。现在问题变成了，我们究竟该如何做到呢？嗯，再次，这很简单：有两种方法（实际上不止两种，但我们稍后再讨论）。
- en: If we can eliminate any and all global shared writable data in the code path,
    we will have no critical sections and no problem; in other words, it will become
    thread-safe. So, one way to achieve this is to ensure that the function uses only
    local (automatic) variables. The function is now reentrant safe. Before proceeding
    further, it's important to understand some key points regarding reentrant and
    thread safety.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能消除代码路径中的任何全局共享可写数据，我们将不会有临界区问题；换句话说，它将变得线程安全。因此，实现这一点的一种方法是确保函数只使用本地（自动）变量。该函数现在是可重入安全的。在进一步进行之前，了解一些关于可重入和线程安全的关键要点是很重要的。
- en: Reentrant-safe versus thread-safe
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重入安全与线程安全
- en: 'How exactly is reentrant-safe different from thread-safe? Confusion does prevail.
    Here''s a concise take: reentrant safety is an older issue prior to the advent
    of multitasking and multithreading OSes, the implication being that only one thread
    of concern is executing. For a function to be reentrant-safe, it should be able
    to be correctly re-invoked from another context while the previous context has
    not yet completed execution (think of a signal handler re-invoking a given function
    while it is already executing). The key requirement: it should use only local
    variables or have the ability to save and restore the global it uses such that
    it''s safe. (These ideas have been dealt with in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, in the *Reentrant safety and signaling* section. As we mentioned
    in that chapter, a signal handler should only call functions that are guaranteed
    to be reentrant safe; in the signal-handling context, these functions are referred
    to as being async-signal-safe.)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可重入安全究竟与线程安全有何不同？混淆确实存在。这里有一个简洁的解释：可重入安全是在多任务和多线程操作系统出现之前的一个问题，其含义是只有一个相关的线程在执行。为了使函数具有可重入安全性，它应该能够在上一个上下文尚未完成执行的情况下，从另一个上下文中被正确地重新调用（想象一个信号处理程序在已经执行的情况下重新调用给定的函数）。关键要求是：它应该只使用局部变量，或者具有保存和恢复它使用的全局变量的能力，以便它是安全的。（这些想法在《第11章》*信号
    - 第一部分*的*可重入安全和信号*部分中有详细讨论。正如我们在那一章中提到的，信号处理程序应该只调用那些保证是可重入安全的函数；在信号处理上下文中，这些函数被称为是异步信号安全的。）
- en: On the other hand, thread safety is a much more recent issue—we are referring
    to modern OSes that are multithreaded-capable. A function that is thread-safe
    can be invoked in parallel from multiple threads (running on multiple CPU cores
    perhaps) simultaneously, without breaking it. The shared writable data is the
    thing that matters as code is in any case only readable can executable and thus
    completely safe to execute in parallel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程安全是一个更近期的问题-我们指的是支持多线程的现代操作系统。一个线程安全的函数可以在多个线程（可能在多个CPU核心上）同时并行调用，而不会破坏它。共享的可写数据是重要的，因为代码本身只能读取和执行，因此完全可以并行执行。
- en: 'Making a function thread-safe via the use of a mutex lock (these discussions
    follow in some detail with examples) is indeed possible but introduces performance
    issues. There are better ways to make a function thread-safe: refactoring it,
    or using TLS or TSD—we''ll cover these in the *Thread safety via TLS* and *Thread
    safety via TSD* section.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用互斥锁使函数线程安全（这些讨论将详细介绍并举例说明）是可能的，但会引入性能问题。有更好的方法使函数线程安全：重构它，或者使用TLS或TSD-我们将在“通过TLS实现线程安全”和“通过TSD实现线程安全”部分介绍这些方法。
- en: In short, reentrant safety is concerned with one thread re-invoking a function
    while an active invocation still exists; thread safety is concerned with multiple
    threads—concurrent code—executing the same function in parallel. (An excellent
    Stack Overflow post describes this in more detail; please refer to the *Further
    reading* section on the GitHub repository.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可重入安全关注的是一个线程在活动调用仍然存在时重新调用函数；线程安全关注的是多个线程-并发代码-同时执行相同的函数。 （一个优秀的Stack
    Overflow帖子更详细地描述了这一点，请参考GitHub存储库上的*进一步阅读*部分。）
- en: 'Now, back to our earlier discussions. In theory, using only local variables
    sounds good (and, for small utility functions, we should design it that way),
    but the reality is that there are complex projects that evolve in such a manner
    that using global shared writable data objects within functions becomes something
    that cannot always be avoided. In such circumstances, from what we learned in
    the previous [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading
    with Pthreads Part II - Synchronization*, on synchronization, we know the answer:
    identify and protect the critical sections using a mutex lock.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们之前的讨论。理论上，只使用局部变量听起来不错（对于小型实用函数，我们应该设计成这样），但现实是，有些复杂的项目会以这样的方式发展，以至于在函数内部使用全局共享可写数据对象是无法避免的。在这种情况下，根据我们在之前的[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)中学到的关于同步的知识，我们知道答案：识别和保护关键部分，使用互斥锁。
- en: Yes, that would work, but at a significant cost to performance. Remember, locks
    defeat parallelism and serialize the code flow, creating bottlenecks. Achieving
    thread safety without using a mutex lock is what actually constitutes a truly reentrant-safe
    function*.* Such code would indeed be a useful thing, and it can be done; there
    are two powerful techniques to achieve this, called TLSand TSD.A little patience
    please, we shall cover how to use these in the section: *Thread safety via TLS* and *Thread
    safety via TSD*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那样可以，但会显著影响性能。请记住，锁会破坏并行性并使代码流程串行化，从而创建瓶颈。在不使用互斥锁的情况下实现线程安全才是真正构成可重入安全函数的关键。这样的代码确实是有用的，并且可以实现；有两种强大的技术可以实现这一点，称为TLS和TSD。请稍作耐心，我们将在“通过TLS实现线程安全”和“通过TSD实现线程安全”部分介绍如何使用这些技术。
- en: 'A point to emphasize: the designer and programmer must guarantee that all code
    that can be executed by multiple threads at any point in time is designed, implemented,
    tested, and documented to be thread-safe.This is one of the key challenges to
    meet when designing and implementing multithreaded applications.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的一点是：设计师和程序员必须保证所有可以在任何时间点由多个线程执行的代码都被设计、实现、测试和记录为线程安全。这是设计和实现多线程应用程序时需要满足的关键挑战之一。
- en: On the other hand, if one can guarantee that a function will always only be
    executed by a single thread (an example is an early initialization routine called
    from main()before threads are created), then obviously there is no need to guarantee
    that it's thread-safe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果可以保证一个函数始终只会被单个线程执行（例如在创建线程之前从main()调用的早期初始化例程），那显然就不需要保证它是线程安全的。
- en: Summary table – approaches to making functions thread-safe
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结表-使函数线程安全的方法
- en: 'Let''s summarize the preceding points in the form of a table that tells us
    how to achieve the all-important goal of thread-safety for all our functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结前面的观点，以表格的形式告诉我们如何实现所有函数的重要目标-线程安全：
- en: '| **Approach to make a function thread-safe** | **Comments** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '**使函数线程安全的方法** | **评论**'
- en: '| Use only local variables | Naive; hard to achieve in practice. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: 只使用局部变量 | 天真；在实践中难以实现。
- en: '| Use global and/or static variables and protect critical sections with mutex
    locks | Viable but can significantly impact performance [1] |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: 使用全局和/或静态变量，并使用互斥锁保护关键部分 | 可行但可能会显著影响性能[1]
- en: '| Refactor the function, making it reentrant-safe-eliminate the use of static
    variables in a function by using more parameters as required | Useful approach—several
    old `foo` glibc functions refactored to `foo_r`. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: 重构函数，使其可重入安全-通过使用更多参数来消除函数中静态变量的使用 | 有用的方法-将几个旧的`foo` glibc函数重构为`foo_r`。
- en: '| **Thread local storage** (**TLS**) | Ensures thread safety by having one
    copy of the variable per thread; toolchain and OS-version-dependent. Very powerful
    and easy to use. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '**线程本地存储**（**TLS**）| 通过每个线程拥有一个变量副本来确保线程安全；工具链和操作系统版本相关。非常强大且易于使用。'
- en: '| **Thread-specific data** (**TSD**) | Same goal: make data thread-safe –older
    implementation, more work to use. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '**线程特定数据**（**TSD**）| 同样的目标：使数据线程安全-旧的实现，使用起来更麻烦。'
- en: 'Table 1: Approaches to making functions thread-safe'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：使函数线程安全的方法
- en: '[1] Though we say that using the mutex can significantly impact performance,
    the mutex performance is, in the normal case, really very high (largely due to
    its internal implementation on Linux via the futex–fast user mutex).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[1]虽然我们说使用互斥锁可能会显著影响性能，但在正常情况下，互斥锁的性能确实非常高（主要是因为在Linux上通过futex-快速用户互斥锁进行内部实现）。'
- en: Let's check out these approaches in more detail.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这些方法。
- en: The first one, using only local variables, being a fairly naive approach, will
    probably only work well with small programs; we shall leave it at that.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，只使用局部变量，是一个相当天真的方法，可能只适用于小型程序；我们就此打住。
- en: Thread safety via mutex locks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过互斥锁实现线程安全
- en: Given that a function does use global and/or static variables, and the decision
    is to continue to use them (the second approach we mention in *Table 1*), obviously
    the places in the code where they are used constitute critical sections*. *As [Chapter
    15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading with Pthreads
    Part II - Synchronization*, has shown in detail, we must *protect* these critical
    sections; here, we use the pthreads mutex lockto do so.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到函数确实使用全局和/或静态变量，并且决定继续使用它们（我们在*表1*中提到的第二种方法），显然在代码中使用它们的地方构成了关键部分。正如[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)“使用Pthreads进行多线程编程第二部分-同步”中详细展示的那样，我们必须保护这些关键部分；在这里，我们使用pthread的互斥锁来实现。
- en: For readability, only key parts of the source code are displayed here; to view
    the complete source code, build and run it, the entire tree is available for cloning
    from GitHub: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，这里只显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'We apply this approach the addition of a pthread mutex lock to our sample function
    (we rename it appropriately; find the full source code here: `ch16/mt_iobuf_mtx.c`)
    in the following snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种方法应用于我们示例函数的pthread互斥锁的添加（我们适当地重命名它；在下面的片段中找到完整的源代码：`ch16/mt_iobuf_mtx.c`）：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use the same macros to perform the mutex lock and unlock as we did
    in (To avoid repetition, we do not show the code to initialize the mutex lock,
    please refer to [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading
    with Pthreads Part II - Synchronization**,* for these details. Also we added an
    additional `thrdnum`parameter to the function, so as to be able to print out the
    thread number that's currently running through it.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用相同的宏来执行互斥锁和解锁，就像我们在（为了避免重复，我们不显示初始化互斥锁的代码，请参考[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)“使用Pthreads进行多线程编程第二部分-同步”中的细节。我们还添加了一个额外的`thrdnum`参数到函数中，以便能够打印出当前正在运行的线程编号。）
- en: 'The key point: at the critical sections—the places in the code where we access
    (read or write) the shared writable global variable, `gbuf`*—*we take the mutex
    lock, perform the access (in our case, at the `fread(3)`and `fwrite(3)`), and
    unlock the mutex.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点：在关键部分——我们访问（读取或写入）共享可写全局变量`gbuf`的代码部分——我们获取互斥锁，执行访问（在我们的情况下是`fread(3)`和`fwrite(3)`），然后释放互斥锁。
- en: Now, even when multiple threads run through the preceding function, there will
    be no data-integrity issue. Yes, it will work, but at a significant performance
    cost; as stated earlier, each critical section (the code between a lock and the
    corresponding unlock) will be serialized. Hence, locking can form bottlenecks
    in the code path, especially if, as in our example, the `numio` parameter is a
    large number, then the for loop will execute for a while. Similarly, bottlenecks
    will result if the function is a busy one and is invoked often. (a quick check
    with `perf(1)` revealed that the single-threaded version took 379 ms to perform
    a 100,000 I/Os and the multithreaded version with locking took 790 ms for the
    same number of I/Os.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使多个线程运行前面的函数，也不会出现数据完整性问题。是的，它会工作，但会付出显著的性能代价；正如前面所述，每个关键部分（在`lock`和相应的`unlock`之间的代码）都将被序列化。因此，在代码路径中，锁定可能形成瓶颈，特别是如果，就像我们的示例一样，`numio`参数是一个大数，那么`for`循环将执行一段时间。类似地，如果函数是一个繁忙的函数并且经常被调用，那么也会产生瓶颈。（使用`perf(1)`进行快速检查，单线程版本执行100,000次I/O需要379毫秒，而带锁的多线程版本执行相同次数的I/O需要790毫秒。）
- en: 'We have covered this, but let''s quickly test ourselves: why did we not protect
    the places in the code that use the variables such as `fnr` and `syscalls`? The
    answer is because it''s a local variable; more to the point, every thread will
    get its own copy of a local variable when it executes the preceding function,
    because every thread has its own private stack—and local variables are instantiated
    on the stack.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了这一点，但让我们快速测试一下自己：为什么我们没有保护使用变量`fnr`和`syscalls`的代码部分？答案是因为它是一个局部变量；更重要的是，当执行前面的函数时，每个线程都会获得自己的局部变量副本，因为每个线程都有自己的私有堆栈，局部变量是在堆栈上实例化的。
- en: To make the program work, we have had to refactor how the preceding function
    is actually set up as the thread-worker routine; we find we need to pass various
    parameters to each thread using a custom data structure, and then have a small
    `wrapper` function—`wrapper_testit_mt_mtx()`—invoke the actual I/O function; we
    leave it to the reader to check out the source in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序工作，我们必须重构前面的函数如何实际设置为线程工作程序；我们发现需要使用自定义数据结构向每个线程传递各种参数，然后有一个小的`wrapper`函数—`wrapper_testit_mt_mtx()`—调用实际的I/O函数；我们留给读者详细查看源代码。
- en: 'Let''s run it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This reveals the full picture; clearly, the I/O buffer being used, gbuf, is
    the same for both threads (look at the addresses printed out), hence the need
    to lock it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了全部情况；显然，正在使用的I/O缓冲区`gbuf`对于两个线程是相同的（看打印出的地址），因此需要对其进行锁定。
- en: As an aside, within the standard-file streaming APIs, there exists (non-standard) *_unlocked APIs,
    such as `fread_unlocked(3)` and `fwrite_unlocked(3)`. These are the same as their
    regular counterparts, except that they are explicitly marked to be MT-unsafe in
    the documentation. It's not advisable to use them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在标准文件流API中存在（非标准）*_unlocked APIs，例如`fread_unlocked(3)`和`fwrite_unlocked(3)`。它们与常规API相同，只是在文档中明确标记为MT-unsafe。不建议使用它们。
- en: By the way, open files are a shared resource between the threads of a process;
    the developer must take this into account as well. Performing IO simultaneously
    with multiple threads on the same underlying file object can cause corruption,
    unless file-locking techniques are used. Here, in this specific case, we are explicitly
    using a mutex lock to protect critical sections – which happen to be at the precise
    points where we perform file I/O, so explicit file-locking becomes unnecessary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，打开的文件是进程的线程之间共享的资源；开发人员也必须考虑到这一点。在同一底层文件对象上同时使用多个线程进行IO可能会导致损坏，除非使用文件锁定技术。在这种特定情况下，我们明确使用互斥锁来保护临界区-这些临界区恰好是我们进行文件I/O的地方，因此显式文件锁定变得不必要。
- en: Thread safety via function refactoring
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过函数重构实现线程安全
- en: 'As we saw in the preceding example, we need the mutex lock because the `gbuf` global
    buffer was being used by all application threads as their I/O buffer. So, think
    on this: what if we can allocate an I/O buffer that''s local to each thread? That
    would indeed solve the issue! How exactly, will be shown with the following code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中看到的，我们需要互斥锁，因为`gbuf`全局缓冲区被所有应用程序线程用作它们的I/O缓冲区。因此，请考虑一下：如果我们可以为每个线程分配一个本地I/O缓冲区呢？那确实会解决问题！具体如何做将在下面的代码中展示。
- en: 'But first, now that you are familiar with the previous example (where we used
    the mutex lock), study the output of the refactored program:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，现在您已经熟悉了之前的示例（我们在其中使用了互斥锁），请研究重构后程序的输出：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The keyrealization: the I/O buffer used here, `iobuf`,is unique for each thread (just
    look at the addresses printed out)! Thus, this eliminates the critical sections
    in the I/O function and the need to use a mutex. In effect, the function is using
    only local variables and is thus both reentrant and thread-safe.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关键认识：这里使用的I/O缓冲区`iobuf`对于每个线程都是唯一的（只需查看打印出的地址）！因此，这消除了I/O函数中的临界区和使用互斥锁的需要。实际上，该函数仅使用本地变量，因此既可重入又线程安全。
- en: For readability, only key parts of the source code are displayed here. To view
    the complete source code, build and run it; the entire tree is available for cloning
    from GitHub: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，这里只显示了源代码的关键部分。要查看完整的源代码，请构建并运行它；整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'The following code snippets clearly reveal how this is set up (the full source
    code:  `ch16/mt_iobuf_rfct.c`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段清楚地显示了如何设置（完整源代码：`ch16/mt_iobuf_rfct.c`）：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As can be seen, we refactor by adding an additional buffer pointer member to
    our custom `stToThread`structure. The important part: in the thread-wrapper function,
    we then allocate it memory and pass the pointer it to our thread routine. We add
    an additional parameter to our thread I/O routine for this very purpose:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，我们通过向自定义`stToThread`结构添加额外的缓冲区指针成员来进行重构。重要的部分是：在线程包装函数中，我们分配了内存并将指针传递给我们的线程例程。我们为此目的向我们的线程I/O例程添加了额外的参数：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, in the preceding I/O loop, we operate upon the per-thread `iobuf`buffer, thus
    there is no critical section, no need for locking.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的I/O循环中，我们操作每个线程的`iobuf`缓冲区，因此没有临界区，也不需要锁定。
- en: The standard C library and thread safety
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准C库和线程安全
- en: A significant amount of the standard C library (glibc), code is not thread-safe.
    What? one asks. But, hey, a lot of this code was written back in the 1970s and
    1980s, when multithreading did not exist (for Unix, at least); thus, one can hardly
    blame them for not designing it to be thread-safe!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库（glibc）中有相当多的代码不是线程安全的。什么？有人会问。但是，嘿，很多这些代码是在20世纪70年代和80年代编写的，当时多线程并不存在（至少对于Unix来说）；因此，我们几乎不能责怪他们没有设计成线程安全！
- en: List of APIs not required to be thread-safe
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不需要线程安全的API列表
- en: 'The standard C library, glibc, has many older functions that, in the words
    of the Open Group manual, need not be thread-safe (or are not required to be thread-safe).
    All functions defined by this volume of POSIX.1-2017 shall be thread-safe, except that
    the following functions need not be thread-safe. What does that actually mean?
    Simple: these APIs are not thread-safe. So, be careful—do not use them in MT applications. The
    complete list can be found at: [http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库glibc有许多较旧的函数，按照Open Group手册的说法，这些函数不需要线程安全（或者不需要线程安全）。POSIX.1-2017的这一卷中定义的所有函数都应该是线程安全的，除了以下函数不需要线程安全。这实际上意味着什么？简单：这些API不是线程安全的。因此，请小心-不要在MT应用程序中使用它们。完整列表可以在以下网址找到：[http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01)。
- en: Of course, the preceding list is only valid as of POSIX.1-2017 and is bound
    to get outdated. The reader must be aware of this recurring issue, and the need
    to constantly update information like this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的列表只适用于POSIX.1-2017，并且可能会过时。读者必须意识到这个反复出现的问题，以及不断更新这样的信息的需要。
- en: Also, they are mostly library-layer (glibc) APIs*. *Of all the preceding APIs, only
    one of them—`readdir(2)`-is a system call; that too is considered deprecated (we
    are to use its glibc wrapper, `readdir(3)`). As a rule of thumb, all system calls
    are written to be thread-safe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它们大多是库层（glibc）的API。在所有前面的API中，只有一个-`readdir(2)`-是一个系统调用；这也被认为是不推荐使用的（我们应该使用它的glibc包装器`readdir(3)`）。作为一个经验法则，所有系统调用都是编写为线程安全的。
- en: 'An interesting aside: PHP, a popular web-scripting language, is not considered
    thread-safe; hence, web servers that serve PHP pages do so using the traditional
    multiprocess model and not a faster multithreaded framework (for example, Apache uses
    its internal `mpm_prefork` module—which is single-threaded – to deal with PHP
    pages).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实：PHP，一种流行的Web脚本语言，被认为不是线程安全的；因此，提供PHP页面的Web服务器使用传统的多进程模型，而不是更快的多线程框架（例如，Apache使用其内部的`mpm_prefork`模块-这是单线程的-来处理PHP页面）。
- en: So, seeing what we have just discussed, does one conclude that glibc is no longer
    viable to develop thread-safe MT apps? No sir, work has been done to convert (refactor,
    really) many of the preceding APIs to render them thread-safe. Read on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看到我们刚刚讨论的内容，有人会得出结论说`glibc`不再适用于开发线程安全的MT应用程序吗？不，工作已经进行，将前面的许多API转换为线程安全。继续阅读。
- en: Refactoring glibc APIs from foo to foo_r
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`foo`重构`glibc`API为`foo_r`
- en: Of course, today, with MT applications being the de facto reality, what do we
    do? The glibc maintainers understand these issues, and have used precisely the
    refactoringtechniques – passing additional parameters to avoid the usage of global
    and/or static variables (like we did previous with our `ch16/mt_iobuf_rfct.c`
    code), including using parameters as return values—to refactor standard `glibc`functions
    to become thread-safe. The glibc naming convention is if the older function is
    named `foo`, the refactored, usually reentrant- and thread-safe, version is named `foo_r`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，今天，随着MT应用程序成为事实上的现实，我们该怎么办呢？`glibc`的维护人员了解这些问题，并且已经使用了精确的重构技术-传递额外的参数以避免使用全局和/或静态变量（就像我们之前在`ch16/mt_iobuf_rfct.c`代码中所做的那样），包括使用参数作为返回值-来重构标准的`glibc`函数以使其成为线程安全。`glibc`的命名约定是，如果旧函数被命名为`foo`，则重构后的，通常是可重入和线程安全的版本被命名为`foo_r`。
- en: To help lend clarity to this discussion, let's take an example of a glibc API
    that has both the older `foo` and the newer `foo_r` functionality. The `ctime(3)` API is
    often used by application developers; given a Unix-time timestamp, it converts
    it into a human-readable date-timestamp (ASCII text). (Recall that we have used
    the `ctime `API in [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml),* Timers.*)
    Let's recall, directly from [Chaptr 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml),* Timers,
    that* Unix systems store time as the number of seconds elapsed since January 1,
    1970, midnight (00:00) – think of it as Unix's birth! This time value is called
    time since the Epoch or Unix time. OK, but it's going to be a rather large number
    of seconds today, right? So how does one express it in a human-readable format?
    Glad you asked; that's precisely the job of the `ctime(3)` and the `ctime_r(3)`
    APIs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助澄清这个讨论，让我们以一个`glibc`API的例子来说明，它既有旧的`foo`功能，也有新的`foo_r`功能。`ctime(3)`API经常被应用程序开发人员使用；给定一个Unix时间戳，它将其转换为可读的日期时间戳（ASCII文本）。
    （回想一下我们在[第13章](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml)中使用了`ctime`API，*定时器*。）让我们回忆一下，直接来自[第13章](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml)，*定时器，*Unix系统将时间存储为自1970年1月1日午夜（00:00）以来经过的秒数-可以将其视为Unix的诞生！这个时间值被称为自纪元以来的时间或Unix时间。好的，但是今天会是一个相当大的秒数，对吧？那么如何以人类可读的格式表示它呢？很高兴你问到了；这正是`ctime(3)`和`ctime_r(3)`API的工作。
- en: 'The signature of the `ctime(3)` API is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctime(3)`API的签名如下：'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do you spot the issue here for multithreaded applications? The return value
    is the time represented in plain ASCII text; it is stored by `ctime(3)` in a static
    (thus, shared) data variable. If multiple threads execute the `ctime(3)` more
    or less simultaneously (and that, my friend, is exactly what can, and indeed does,
    happen on modern multicore systems!), there is always the risk that we perform
    dirty reads or writes on the shared data. Simply because it is not protected;
    simply because when the `ctime(3)` was first designed and implemented, only a
    single thread would ever run it at a given point in time. Which is not the case
    today, of course. In other words, `ctime(3)` is marked in the man page as being
    MT-Unsafe, that is, it is not thread-safe. Thus, calling `ctime(3)` from an MT
    application is wrong—you run the risk of having a race, a bug, or a defect at
    some point.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否发现了多线程应用程序的问题？返回值是以纯ASCII文本表示的时间；它由`ctime(3)`存储在静态（因此是共享的）数据变量中。如果多个线程同时执行`ctime(3)`（这在现代多核系统上确实会发生），就会存在脏读或写共享数据的风险。这是因为它没有受到保护；仅仅因为当`ctime(3)`首次设计和实现时，只有一个线程会在给定时间点运行它。当然，这在今天不是这样的情况。换句话说，`ctime(3)`在手册页中被标记为MT-Unsafe，也就是说，它不是线程安全的。因此，从MT应用程序中调用`ctime(3)`是错误的-你会面临在某个时候出现竞争、错误或缺陷的风险。
- en: 'The good glibc folks have literally re-implemented (refactored) `ctime(3)` to
    become reentrant and thread-safe; the newer API is christened `ctime_r(3)`. Here
    is a quote from its man page: the reentrant version `ctime_r()` does the same, but
    stores the string in a user-supplied buffer which should have room for at least
    26 bytes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`的开发人员确实重新实现（重构）了`ctime(3)`，使其成为可重入和线程安全；新的API被命名为`ctime_r(3)`。以下是它的手册页中的一句引用：可重入版本`ctime_r()`做同样的事情，但将字符串存储在用户提供的缓冲区中，该缓冲区至少应该有26个字节的空间。'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Excellent! Did you notice that the key point here is that the `ctime(3)` API
    has been refactored (and renamed to  `ctime_r(3)`) to become re-entrant- and thread-safe
    by having the user supply the buffer in which the result is returned? How will
    the user do this? Simple; here''s some code showing one way to achieve this (we
    just require the concept here, no error-checking is shown):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你注意到这里的关键点是`ctime(3)` API已经被重构（并重命名为`ctime_r(3)`)，通过让用户提供结果返回的缓冲区，使其成为可重入和线程安全的？用户将如何做到这一点？简单；下面是一些代码，展示了实现这一点的一种方式（我们只需要理解概念，没有显示错误检查）：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Think about it: each thread that executes the preceding code will allocate a separate
    unique buffer and pass that buffer pointer to the `ctime_r(3)` routine. This way,
    we ensure that we do not step on each other's toes; the API is now reentrant-
    and thread-safe.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：执行前面代码的每个线程都会分配一个独立的唯一缓冲区，并将该缓冲区指针传递给`ctime_r(3)`例程。这样，我们确保不会互相干扰；API现在是可重入和线程安全的。
- en: 'Notice in the preceding code how we achieved this refactoring trick in C: by
    passing the unique buffer to be written into as a value-result-style parameter! This
    is indeed a common technique, often employed by the glibc `foo_r` routines: we
    keep the routine thread-safe by passing one or more values to  it (and even back
    to the caller, as a kind of return value) without using static or global variables
    (instead using value-result (or in-out) style parameters)!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的代码中，我们如何在C中实现了这种重构技巧：通过将要写入的唯一缓冲区作为值-结果式参数传递！这确实是一种常见的技术，通常由glibc `foo_r`例程使用：我们通过传递一个或多个值给它（甚至返回给调用者，作为一种返回值）而不使用静态或全局变量（而是使用值-结果（或输入-输出）式参数）来保持例程的线程安全！
- en: The man page on `ctime(3)`, and indeed on most other APIs, documents whether
    the API it describes are thread-safe: this is extremely important to note! We
    cannot over-stress this: the multithreaded application programmer must check and
    ensure that all functions being called in a function that is supposed to be thread-safe,
    are themselves (documented to be) thread-safe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctime(3)`的man页面，以及大多数其他API的man页面，都记录了它描述的API是否是线程安全的：这一点非常重要！我们无法过分强调：多线程应用程序的程序员必须检查并确保在一个应该是线程安全的函数中调用的所有函数本身（记录为）是线程安全的。'
- en: 'Here''s a screenshot of a part of the man page on `ctime(3)` that shows, under
    the **ATTRIBUTES** section, this information:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ctime(3)`man页面的一部分截图，显示在**ATTRIBUTES**部分下的这些信息：
- en: '![](img/624d94f5-2e34-4d0a-bfea-a95243a043eb.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/624d94f5-2e34-4d0a-bfea-a95243a043eb.png)'
- en: 'Figure 1 : Screenshot of ATTRIBUTES section of the man page on ctime(3)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：`ctime(3)` man页面的ATTRIBUTES部分的截图
- en: Quite obviously, MT-Safe implies the routine is thread-safe; MT-Unsafe implies
    it isn't. The man page on attributes(7) delves further into these details; it
    clearly notes that being thread-safe does not guarantee that the API is also atomic;
    do read through it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，MT-Safe意味着例程是线程安全的；MT-Unsafe意味着它不是。attributes(7)上的man页面深入探讨了这些细节；它清楚地指出，线程安全并不保证API也是原子的；请仔细阅读。
- en: We also note that the man page states that POSIX.1-2008 marks the `ctime_r`
    API itself as obsolete, and to use `strftime(3)` in its place. Please do so. Here,
    we have used the `ctime(3)` and `ctime_r(3)` APIs merely to illustrate an example
    regarding the thread-unsafe and -safe versions of a glibc routine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到man页面指出，POSIX.1-2008将`ctime_r` API本身标记为过时，并建议使用`strftime(3)`来替代。请这样做。在这里，我们仅仅使用`ctime(3)`和`ctime_r(3)`
    API来举例说明glibc例程的线程不安全和安全版本。
- en: Some glibc foo and foo_r APIs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些glibc `foo`和`foo_r` API
- en: 'The `ctime(3)`, this being thread-unsafe, is now replaced by its thread-safe
    counterpart `ctime_r(3)`; this is just one example of a generic trend in modern
    glibc:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctime(3)`，这是不安全的线程，现在被它的线程安全的对应物`ctime_r(3)`所取代；这只是现代glibc中一种通用趋势的一个例子：'
- en: The older, thread (MT-unsafe) unsafe function is called  `foo`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的、线程（MT-unsafe）不安全的函数被称为`foo`
- en: Has a counterpart, the newer, thread (MT-Safe) safe `foo_r` API
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个新的、线程（MT-Safe）安全的`foo_r` API
- en: 'To give the reader an appreciation of this, we enumerate some (not all!) of
    the glibc `foo_r` style of APIs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让读者了解这一点，我们列举了一些（不是全部！）glibc `foo_r`风格的API：
- en: '| `asctime_r(3)` `crypt_r(3)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| `asctime_r(3)` `crypt_r(3)`'
- en: '`ctime_r(3)`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctime_r(3)`'
- en: '`drand48_r(3)` | `getpwnam_r(3)` `getpwuid_r(3)`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`drand48_r(3)` | `getpwnam_r(3)` `getpwuid_r(3)`'
- en: '`getrpcbyname_r(3)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`getrpcbyname_r(3)`'
- en: '`getrpcbynumber_r(3)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`getrpcbynumber_r(3)`'
- en: '`getrpcent_r(3)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`getrpcent_r(3)`'
- en: '`getservbyname_r(3)` | `seed48_r(3)` `setkey_r(3)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`getservbyname_r(3)` | `seed48_r(3)` `setkey_r(3)`'
- en: '`srand48_r(3)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`srand48_r(3)`'
- en: '`srandom_r(3)`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`srandom_r(3)`'
- en: '`strerror_r(3)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`strerror_r(3)`'
- en: '`strtok_r(3)` |'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtok_r(3)` |'
- en: '| `getdate_r(3)` `getgrent_r(3)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '| `getdate_r(3)` `getgrent_r(3)`'
- en: '`getgrgid_r(3)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`getgrgid_r(3)`'
- en: '`getgrnam_r(3)`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`getgrnam_r(3)`'
- en: '`gethostbyaddr_r(3)`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`gethostbyaddr_r(3)`'
- en: '`gethostbyname2_r(3)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`gethostbyname2_r(3)`'
- en: '`gethostbyname_r(3)`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`gethostbyname_r(3)`'
- en: '`gethostent_r(3)`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`gethostent_r(3)`'
- en: '`getlogin_r(3)` | `nrand48_r(3)` `ptsname_r(3)`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`getlogin_r(3)` | `nrand48_r(3)` `ptsname_r(3)`'
- en: '`qecvt_r(3)`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`qecvt_r(3)`'
- en: '`qfcvt_r(3)`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`qfcvt_r(3)`'
- en: '`qsort_r(3)`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`qsort_r(3)`'
- en: '`radtofix_r(3)`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`radtofix_r(3)`'
- en: '`rand_r(3)`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand_r(3)`'
- en: '`random_r(3)`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_r(3)`'
- en: '`readdir_r(3)` | `ustrtok_r(3)` `val_gethostbyaddr_r(3)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`readdir_r(3)` | `ustrtok_r(3)` `val_gethostbyaddr_r(3)`'
- en: '`val_gethostbyname2_r(3)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`val_gethostbyname2_r(3)`'
- en: '`val_gethostbyname_r(3)` |'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`val_gethostbyname_r(3)` |'
- en: 'Table 3: Some of the glibc foo_r APIs'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：一些glibc `foo_r` API
- en: This list is not intended to be exhaustive; note that the `ctime_r(3)` API is
    in this list. At the risk of repetition, ensure you only use the `foo_r` APIs
    in an MT application as they are the thread-safe versions of the `foo` API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不是详尽无遗的；请注意`ctime_r(3)` API在这个列表中。冒着重复的风险，请确保在MT应用程序中只使用`foo_r` API，因为它们是`foo`
    API的线程安全版本。
- en: Thread safety via TLS
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过TLS实现线程安全
- en: The preceding discussion was with regard to the already existing standard C
    library, glibc, and its API set. What about MT applications that are newly designed
    and developed? Obviously, the code we write for them must be thread-safe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论是关于已经存在的标准C库glibc及其API集。那么新设计和开发的MT应用程序呢？显然，我们为它们编写的代码必须是线程安全的。
- en: Let's not forget how we rendered our `testit_mt_refactored` function to become
    thread-safe by refactoring it – adding an `iobuf` parameter that passed along
    the address of the buffer to use for I/O—guaranteeing the buffer will be unique for
    each thread and thus thread-safe (without any need for locking).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们如何通过重构将我们的`testit_mt_refactored`函数变得线程安全——添加一个`iobuf`参数，传递要用于I/O的缓冲区的地址——确保每个线程的缓冲区都是唯一的，因此是线程安全的（无需任何锁定）。
- en: 'Could we get such functionality automatically? Well, yes: the compiler (GCC
    and clang) does provide an almost magical feature to do something similar: TLS.
    With TLS, a variable marked with the `__thread` special storage class keyword will
    be instantiated once per thread that comes alive. In effect, if we use only local
    and TLS variables, our function will by definition be thread-safe, without any
    (expensive) locking required.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能自动获得这样的功能吗？嗯，是的：编译器（GCC和clang）确实提供了一个几乎神奇的功能来做类似的事情：TLS。使用TLS，用`__thread`特殊存储类关键字标记的变量将在每个活动的线程中实例化一次。实际上，如果我们只使用本地和TLS变量，我们的函数将根据定义是线程安全的，而无需任何（昂贵的）锁定。
- en: 'There do exist some ground rules and caveats; let''s check them out:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确实存在一些基本规则和注意事项；让我们来看看：
- en: 'The `__thread` keyword can be used alone, or with (in fact, only with) the `static` or `extern`
    keywords; if used with them, it must appear after them:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__thread`关键字可以单独使用，也可以与（实际上，只能与）`static`或`extern`关键字一起使用；如果与它们一起使用，必须出现在它们之后。'
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: More broadly, the `__thread` keyword can be specified against any global and
    file-or- function scope `static` or `extern` variable. It cannot be applied to
    any local variables.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更广泛地说，`__thread`关键字可以针对任何全局和文件或函数作用域的`static`或`extern`变量进行指定。它不能应用于任何局部变量。
- en: TLS can only be used on (fairly) recent versions of the toolchain and kernel.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS只能在（相当）新版本的工具链和内核上使用。
- en: 'Something important to understand: though it may seem akin to having a locked
    variable, this is certainly not the case! Consider this: given a TLS variable
    called `mytls`, different threads using it in parallel is fine. However, if a
    thread uses the address-of operator on the TLS variable, `&mytls`, it will have
    the address of its instance of the variable. Any other thread, if access to this
    address, can use this address to gain access to the variable; thus, it''s not
    really locked in any real sense. Of course, if the programmer uses normal conventions
    (not letting other threads access a different thread''s TLS variables), then all
    will work well.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解：尽管它可能看起来类似于有锁的变量，但实际上并非如此！考虑这一点：给定一个名为`mytls`的TLS变量，不同的线程并行使用它是可以的。但是，如果一个线程对TLS变量使用地址运算符`&mytls`，它将具有该变量的实例的地址。任何其他线程，如果访问此地址，都可以使用此地址来访问该变量；因此，从实质上讲，它并没有真正被锁定。当然，如果程序员使用正常的约定（不让其他线程访问不同线程的TLS变量），那么一切都会很顺利。
- en: It's important to realize that TLS support is only available from the Linux
    2.6 kernel onward, gcc ver 3.3 or later, and NPTL. Well, practically speaking,
    this implies that pretty much any fairly recent Linux distribution will support
    TLS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到TLS支持仅在Linux 2.6内核及更高版本、gcc ver 3.3或更高版本和NPTL中可用。实际上，这意味着几乎任何相当新的Linux发行版都将支持TLS。
- en: 'So, as usual, let''s port our thread-unsafe function to become thread-safe
    via TLS. This is really simple; all we have to do is make the previously global
    buffer, `gbuf`, into a thread-safe TLS buffer (`iobuf`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像往常一样，让我们通过TLS将我们的线程不安全的函数移植为线程安全。这真的很简单；我们所要做的就是将以前的全局缓冲区`gbuf`变成线程安全的TLS缓冲区（`iobuf`）：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only important change to note is the declaration of the `iobuf` variable
    now as a TLS variable; everything else pretty much remains the same. A quick test
    run confirms that each thread receives a separate copy of the TLS variable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一重要的变化是现在将`iobuf`变量声明为TLS变量；其他几乎都保持不变。快速测试确认每个线程都会收到TLS变量的单独副本：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each `iobuf` is a per-thread TLS instance; each has a unique address. No locking,
    no fuss, job done. Real-world usage of TLS is high; the uninitialized global `errno` is
    a perfect example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`iobuf`都是一个每个线程的TLS实例；每个都有一个唯一的地址。没有锁定，没有麻烦，工作完成。TLS的实际使用很高；未初始化的全局`errno`是一个完美的例子。
- en: 'TLS seems such a powerful and easy-to-use technique to make a function thread-safe;
    is there a downside? Well, think about it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TLS似乎是一种强大且易于使用的技术，可以使函数线程安全；有什么缺点吗？嗯，想想看：
- en: For every variable marked as the TLS storage class, memory will have to be runtime-allocated for
    every thread that comes alive; if we have large TLS buffers, this can cause significant
    amounts of memory to be allocated.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个标记为TLS存储类的变量，将必须为每个活动的线程分配内存；如果我们有大型TLS缓冲区，这可能导致分配大量内存。
- en: 'Platform support: your Linux platform, if too old, will not support it (usually
    shouldn''t be the case).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台支持：如果您的Linux平台太旧，将不支持它（通常不应该是这种情况）。
- en: Thread safety via TSD
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过TSD实现线程安全
- en: Prior to the TLS technique that we just saw (that is, before Linux 2.6 and gcc
    3.3), how did one guarantee writing a new API to be thread safe? A much older
    technology exists, called TSD.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚看到的TLS技术之前（也就是在Linux 2.6和gcc 3.3之前），如何保证编写的新API是线程安全的？还存在一种更古老的技术，称为TSD。
- en: In a nutshell, TSD is a more complex solution from the application developer's
    viewpoint—more work must be done to achieve the very same end result that TLS
    so easily gives us; that of making a function thread-safe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，从应用程序开发人员的角度来看，TSD是一个更复杂的解决方案——需要做更多的工作才能实现TLS轻松给我们的相同结果；使函数线程安全。
- en: With TSD, the thread-safe routine must invoke an initializer function (usually
    done with `pthread_once(3)`), which creates a unique thread-specific data key
    (using the `pthread_key_create(3)` API). This initializer routine associates a
    thread-specific data variable (such as the `iobuf` buffer pointer in our example)
    with that key, using the `pthread_getspecific(3)` and `pthread_setspecific(3)`
    APIs. The end result is that the data item is now thread-specific and therefore
    thread-safe. Here, we do not delve further into using TSD as it's an older solution
    that TLS easily and elegantly replaces on modern Linux platforms. Nevertheless,
    for the interested reader, please refer to the *Further reading* section on the
    GitHub repository—we provide a link to using TSD.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TSD，线程安全的例程必须调用一个初始化函数（通常使用 `pthread_once(3)` 完成），该函数创建一个唯一的线程特定数据键（使用 `pthread_key_create(3)`
    API）。这个初始化例程使用 `pthread_getspecific(3)` 和 `pthread_setspecific(3)` API 将一个线程特定的数据变量（例如我们例子中的
    `iobuf` 缓冲指针）与该键关联起来。最终的结果是数据项现在是线程特定的，因此是线程安全的。在这里，我们不深入讨论使用 TSD，因为它是一个旧的解决方案，在现代
    Linux 平台上 TLS 轻松而优雅地取代了它。然而，对于感兴趣的读者，请参考 GitHub 仓库上的 *进一步阅读* 部分——我们提供了一个使用 TSD
    的链接。
- en: Thread cancelation and cleanup
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程取消和清理
- en: 'The pthreads design provides a sophisticated framework for achieving two other
    key activities for a robust multithreaded application: the ability to have a thread
    in the app cancel (effectively, kill) another thread, and the ability to have
    a thread that is either terminated normally (via the `pthread_exit(3)`) or abnormally
    (via cancelation) be able to perform the required resource cleanup.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: pthread 的设计提供了一个复杂的框架，用于实现多线程应用程序的另外两个关键活动：使应用程序中的一个线程取消（实际上是终止）另一个线程，以及使一个线程能够正常终止（通过
    `pthread_exit(3)`）或异常终止（通过取消）并能够执行所需的资源清理。
- en: The following sections deal with these topics.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涉及这些主题。
- en: Canceling a thread
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消线程
- en: Visualize a GUI application running; it pops up a dialog box informing the user
    that it is now performing some work (perhaps displaying a progress bar as well).
    We imagine that this work is being carried out by a thread of the overall application
    process. For the user's convenience, a Cancel button is provided as well; clicking
    on it should cause the ongoimg work to be canceled.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个运行的 GUI 应用程序；它弹出一个对话框，通知用户它现在正在执行一些工作（也许还显示一个进度条）。我们想象这项工作是由整个应用程序进程的一个线程执行的。为了用户的方便，还提供了一个取消按钮；点击它应该导致正在进行的工作被取消。
- en: How can we implement this? In  other words, how does one kill off a thread?
    The first thing to note is that pthreads provides a framework for exactly this
    type of operation: thread cancelation. Canceling a thread is not sending it a
    signal; it is a way for one thread to request another a thread to die. Making
    this happen requires us to understand and follow the provided framework.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个？换句话说，如何终止一个线程？首先要注意的是，pthreads 提供了一个框架，用于正是这种类型的操作：线程取消。取消线程不是发送信号；它是一种让一个线程请求另一个线程死掉的方式。要实现这一点，我们需要理解并遵循提供的框架。
- en: The thread cancelation framework
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程取消框架
- en: 'To help bring clarity, let''s take an example: let''s say that the main thread
    of an application creates two worker threads, A and B. Now, the main thread wants
    to cancel thread A.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了带来清晰，让我们举个例子：假设一个应用程序的主线程创建了两个工作线程 A 和 B。现在，主线程想要取消线程 A。
- en: 'The API to request cancelation upon a target thread (A, here) is the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请求取消目标线程（这里是 A）的 API 如下：
- en: '`int pthread_cancel(pthread_t thread);`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`int pthread_cancel(pthread_t thread);`'
- en: The `thread` parameter is the target thread—the one we are (politely) requesting
    to please go and die, thank you very much.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread` 参数是目标线程——我们（礼貌地）请求它请去死，非常感谢。'
- en: 'But, you guessed it, it''s not as simple as that: the target thread has two
    attributes (that it can set) that determine whether and when it gets canceled:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你猜对了，事情并不像那么简单：目标线程有两个属性（它可以设置），决定它是否以及何时被取消：
- en: Cancelability state
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消能力状态
- en: Cancelability type
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消能力类型
- en: The cancelability state
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消能力状态
- en: 'The target thread is required to be in an appropriate cancelability state.
    The state is Boolean-cancelability (on the target thread, A) is either *enabled* or *disabled*;
    here is the API to set this up:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目标线程需要处于适当的取消能力状态。该状态是布尔型取消能力（在目标线程 A 上）要么是 *启用* 要么是 *禁用*；以下是设置这一点的 API：
- en: '`int pthread_setcancelstate(int state, int *oldstate);`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`int pthread_setcancelstate(int state, int *oldstate);`'
- en: 'The two possible cancelability states, the value provided as the first parameter, for
    a thread are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的两种可能的取消能力状态，作为第一个参数提供的值，如下所示：
- en: '`PTHREAD_CANCEL_ENABLE`   (default on creation)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTHREAD_CANCEL_ENABLE`（默认创建时）'
- en: '`PTHREAD_CANCEL_DISABLE`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTHREAD_CANCEL_DISABLE`'
- en: Clearly, the previous cancelability state will be returned in the second parameter, `oldstate`.)
    The target thread can only be canceled if its cancelability state is enabled.
    A thread's cancelability state is enabled by default upon creation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前一个取消能力状态将在第二个参数 `oldstate` 中返回。只有当目标线程的取消能力状态为启用时，才能取消线程。线程的取消能力状态在创建时默认为启用。
- en: 'This is a powerful feature of the framework: if the target thread, A, is performing
    a critical activity and does not want to be even considered for cancelation, it
    merely sets its cancelability state to disabled, and, upon finishing the said
    critical activity, resets it to enabled.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是框架的一个强大特性：如果目标线程 A 正在执行关键活动，并且不希望被考虑取消，它只需将其取消能力状态设置为禁用，并在完成所述的关键活动后将其重置为启用。
- en: The cancelability type
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消能力类型
- en: Assuming the target thread has the cancelability state enabled is the first
    step; the thread's cancelability type determines what happens next. There are
    two types: deferred (the default) and asynchronous. When a thread's cancelability
    type is asynchronous, it can be canceled at any point in time (in fact, it should
    happen immediately, but is not always guaranteed to); if the cancelability type is deferred (the
    default), it can only be canceled (terminated) when it hits the next cancelation
    point.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设目标线程已启用取消状态是第一步；线程的可取消类型决定接下来会发生什么。有两种类型：延迟（默认）和异步。当线程的可取消类型是异步时，它可以在任何时候被取消（实际上，它应该立即发生，但并不总是保证）；如果可取消类型是延迟（默认），它只能在下一个取消点时被取消（终止）。
- en: A cancelation point is a list of (usually blocking) functions (more on this
    shortly). When the target thread—that, remember, is of the enabled cancelability
    state and the deferred type—encounters the next cancelation point in its code
    path, it will terminate.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 取消点是一个（通常是阻塞的）函数列表（稍后会详细介绍）。当目标线程——记住，它是启用取消状态和延迟类型的——在其代码路径中遇到下一个取消点时，它将终止。
- en: 'Here is the API to set the cancelability type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置可取消类型的API：
- en: '`int pthread_setcanceltype(int type, int *oldtype);`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`int pthread_setcanceltype(int type, int *oldtype);`'
- en: 'The two possible cancelability types, the value provided as the first parameter
    type, are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个参数类型提供的两种可能的可取消类型值是：
- en: '`PTHREAD_CANCEL_DEFERRED`   (default on creation)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTHREAD_CANCEL_DEFERRED`（默认创建时）'
- en: '`PTHREAD_CANCEL_ASYNCHRONOUS`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTHREAD_CANCEL_ASYNCHRONOUS`'
- en: Clearly, the previous cancelability type will be returned in the second parameter, `oldtype`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，以前的可取消类型将在第二个参数`oldtype`中返回。
- en: 'Whew! Let''s try to represent this cancelation framework as a flowchart:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！让我们尝试将这个取消框架表示为一个流程图：
- en: '![](img/39252ce8-4494-4e42-a3b2-73a52e05d354.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39252ce8-4494-4e42-a3b2-73a52e05d354.png)'
- en: 'Figure 2: Pthreads cancelation'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Pthreads取消
- en: '`pthread_cancel(3)` is a non-blocking API. What we mean is that, even if the
    target thread has its cancelability state disabled, or its cancelability state
    is enabled but the cancelability type is deferred and it has not reached a cancelation
    point, though the target thread might take some time to actually die, the main thread''s `pthread_cancel(3)` call
    will return with success (return value `0`), implying that the cancelation request
    has been successfully queued.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_cancel(3)`是一个非阻塞的API。我们的意思是，即使目标线程已禁用其可取消状态，或者其可取消状态已启用但可取消类型是延迟的，并且尚未达到取消点，尽管目标线程可能需要一些时间才能真正死去，主线程的`pthread_cancel(3)`调用将成功返回（返回值为`0`），这意味着取消请求已成功排队。'
- en: Disabling the cancelation state for a short time while a critical activity is
    carried out is fine, but doing the same for long periods could cause the application
    to seem unresponsive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行关键活动时短暂禁用取消状态是可以的，但是长时间禁用可能会导致应用程序看起来无响应。
- en: Using the asynchronous value for the cancelability type is usually not the right
    thing to do. Why? Well, it becomes a race as to when exactly the thread was canceled;
    was it before it allocated some resource (such as memory via `malloc(3)`) or after?
    In such situations, even cleanup handlers are not really useful. Also, only APIs
    documented as being async-cancel-safe can be safely canceled in an async fashion;
    realistically there are very few—only the cancelation APIs themselves. For these
    reasons, it's considered best to avoid asynchronous cancelation. On the other
    hand, if a thread is predominantly highly CPU-bound (performing some mathematical
    calculation, say prime number generation), then using async cancelation can help
    guarantee the thread dies immediately on request.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不应该使用异步值作为可取消类型。为什么？嗯，这变成了一个竞赛，究竟是在线程分配一些资源（例如通过`malloc(3)`分配内存）之前取消，还是之后取消？在这种情况下，即使清理处理程序也不是真正有用。此外，只有被记录为“异步取消安全”的API才能安全地以异步方式取消；实际上只有很少的API——只有取消API本身。因此，最好避免异步取消。另一方面，如果一个线程主要是高度CPU绑定的（执行一些数学计算，比如素数生成），那么使用异步取消可以帮助确保线程立即在请求时死亡。
- en: 'Another key point: how does (in our example) the main thread know that the
    target thread has actually terminated? Remember that the main thread is expected
    to join upon all threads; hence, the target thread upon termination will get joined,
    and—here''s the thing – the return value (status) from `pthread_join(3)` will
    be `PTHREAD_CANCELED`. `pthread_join(3)` is the only way to check that cancelation
    has actually occurred.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键点：（在我们的例子中）主线程如何知道目标线程是否已经终止？请记住，主线程预期会加入所有线程；因此，目标线程在终止时将被加入，并且这里的关键是`pthread_join(3)`的返回值（状态）将是`PTHREAD_CANCELED`。`pthread_join(3)`是检查取消是否实际发生的唯一方法。
- en: We have learned that, with the (default) cancelation type as deferred, the actual
    thread-cancelation will not occur until the target thread encounters a cancelation
    point function. A cancelation point is merely an API at which thread-cancelation
    is actually detected and made to take effect by the underlying implementation.
    The cancelation points are not limited to the pthreads APIs; many glibc functions
    serve as cancelation points. The reader can find a list of cancelation point APIs
    by following a link (Open Group POSIX.1c threads) provided in the *Further reading* section
    on the GitHub repository. As a rule of thumb, the cancelation points are typically blocking
    library APIs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，默认的取消类型为延迟时，实际的线程取消将不会发生，直到目标线程遇到取消点函数。取消点只是一个API，在该API中，线程取消实际上被检测并由底层实现生效。取消点不仅限于pthread
    API；许多glibc函数都充当取消点。读者可以通过在GitHub存储库的*进一步阅读*部分提供的链接（Open Group POSIX.1c线程）找到取消点API的列表。作为一个经验法则，取消点通常是阻塞库API。
- en: But, what if a thread is executing code that just does not have a cancelation
    point within it (say, a CPU-bound calculation loop)? In such cases, either one
    can use the asynchronous cancelation type or, even better, explicitly introduce
    a guaranteed cancelation point into the loop by invoking the `void pthread_test_cancel(void);`
    API.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果一个线程正在执行的代码中根本没有取消点（比如说，是一个CPU密集型的计算循环）怎么办？在这种情况下，可以使用异步取消类型，或者更好的是，通过调用`void
    pthread_test_cancel(void);`API在循环中显式引入一个保证的取消点。
- en: If the to-be-cancelled target thread hits this function, and a cancelation request
    is pending, it will terminate.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将要取消的目标线程调用此函数，并且有一个取消请求挂起，它将终止。
- en: Canceling a thread – a code example
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消线程-一个代码示例
- en: A simple code example demonstrating thread-cancelation follows; we have the main thread
    create two worker threads (think of them as thread A and thread B) and then have
    the main thread cancel thread A. In parallel, we deliberately have thread A disable
    cancelation (by setting the cancelation state to disabled), do some bogus work
    (we call our trusty `DELAY_LOOP` macro to simulate work), then re-enable cancelation.
    The cancelation request takes effect at the next cancelation point (as, of course,
    the type defaults to deferred), which, here, is simply the `sleep(3)` API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的代码示例，演示了线程取消；我们让`main`线程创建两个工作线程（将它们视为线程A和线程B），然后让`main`线程取消线程A。同时，我们故意让线程A禁用取消（通过将取消状态设置为禁用），做一些虚假的工作（我们调用我们信任的`DELAY_LOOP`宏来模拟工作），然后重新启用取消。取消请求在下一个取消点生效（因为`type`默认为延迟），这里，就是`sleep(3)`API。
- en: The code demonstrating thread cancelation (`ch16/cancelit.c`)follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 演示线程取消的代码（`ch16/cancelit.c`）如下。
- en: For readability, only key parts of the source code are displayed here. To view
    the complete source code, build and run it. The entire tree is available for cloning
    from GitHub: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，这里只显示了源代码的关键部分。要查看完整的源代码，请构建并运行它。整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'We pick up the code in `main`, after the thread creation loop is done:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在线程创建循环完成后在`main`中接着执行代码：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the thread `worker` routine:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是线程`worker`例程：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A quick test run reveals that it indeed works; one can see that thread A has
    been cancelled. We suggest you run the debug version of the program, as shown
    here, as then the `DELAY_LOOP` macro''s effect can be seen (otherwise it completes
    its job almost instantaneously as it''s pretty much optimized away by the compiler):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试运行显示它确实有效；可以看到线程A已被取消。我们建议您运行程序的调试版本，因为这样可以看到`DELAY_LOOP`宏的效果（否则它几乎会被编译器优化掉，几乎瞬间完成其工作）：
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Cleaning up at thread exit
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程退出时进行清理
- en: 'Consider this hypothetical situation: a thread takes a mutex lock and allocates
    some heap memory. Obviously, once the critical section it is in is done, we expect
    it to free up the heap memory and unlock the mutex. Failure to do this cleanup
    will cause serious, if not fatal, application bugs (defects) such as memory leakage
    or deadlock.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种假设情况：一个线程获取互斥锁并分配了一些堆内存。显然，一旦它所在的临界区完成，我们期望它释放堆内存并解锁互斥锁。未进行这种清理将导致严重的，甚至是致命的应用程序错误（缺陷），如内存泄漏或死锁。
- en: But, one wonders, what if the poor thread is canceled prior to the free and
    unlock? It could happen, right? No! Not if the developer understands and uses
    the thread cleanup handler mechanism that the pthreads framework provides.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有人会想，如果可怜的线程在释放和解锁之前被取消了怎么办？这可能发生，对吧？不！只要开发人员理解并使用pthreads框架提供的线程清理处理程序机制就不会发生。
- en: 'What happens when a thread terminates? The following steps are part of the
    pthreads cleanup framework:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程终止时会发生什么？以下步骤是pthreads清理框架的一部分：
- en: All cleanup handlers are popped (reverse order of the cleanup handler push)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有清理处理程序都被弹出（清理处理程序推送的相反顺序）
- en: TSD destructors, if they exist, are invoked
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在TSD析构函数，则会被调用
- en: The thread dies
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程死亡
- en: 'This opens our eyes to an interesting fact: the pthreads framework provides
    a guaranteed way for a thread to ensure that it cleans up after itself—frees up
    memory resources, closes open files, and so on—before terminating.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们看到了一个有趣的事实：pthreads框架提供了一种保证线程在终止之前清理自己的方法-释放内存资源，关闭打开的文件等。
- en: 'The programmer can take care of all these cases by setting up a thread-cleanup
    handler – in effect, a kind of destructor function. A cleanup handler is a function
    that is automatically executed when a thread is canceled or terminates with `pthread_exit(3)`;
    it''s set up by invoking the `pthread_cleanup_push(3)` API:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以通过设置线程清理处理程序来处理所有这些情况-实际上是一种析构函数。清理处理程序是一个在线程被取消或使用`pthread_exit(3)`终止时自动执行的函数；通过调用`pthread_cleanup_push(3)`API来设置它：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Clearly, the first parameter to the preceding routine is the cleanup handler
    function pointer, in other words, the name of the cleanup handler function. The
    second parameter is any argument one cares to pass to the handler function (often
    a pointer to a dynamically allocated buffer or data structure).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面例程的第一个参数是清理处理程序函数指针，换句话说，是清理处理程序函数的名称。第二个参数是任何一个想要传递给处理程序的参数（通常是指向动态分配的缓冲区或数据结构的指针）。
- en: 'The reverse semantic is achieved via the corresponding cleanup pop routine;
    when invoked, it pops off the cleanup handler stack and thus in reverse order
    executes the cleanup handler(s) that were earlier pushed onto the cleanup handler
    stack:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过相应的清理弹出例程可以实现相反的语义；当调用时，它会弹出清理处理程序堆栈，并以相反的顺序执行先前推送到清理处理程序堆栈上的清理处理程序：
- en: '`void pthread_cleanup_pop(int execute);`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`void pthread_cleanup_pop(int execute);`'
- en: One can also explicitly invoke the topmost cleanup handler on the cleanup stack
    by calling the `thread_cleanup_pop(3)` API with a non-zero argument.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过调用`thread_cleanup_pop(3)`API并传递一个非零参数来显式调用清理堆栈上面的清理处理程序。
- en: The POSIX standard maintains that the preceding pair of APIs—the push and pop
    cleanup handlers—can be implemented as macros that expand into functions; indeed,
    it seems to be implemented this way on the Linux platform. As a side effect of
    this, it becomes imperative that the programmer call both routines (the pair)
    within the same function. Failure to comply causes weird compiler failures.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX标准规定，前面一对API——推送和弹出清理处理程序——可以实现为扩展为函数的宏；事实上，在Linux平台上似乎是这样实现的。作为这一副作用，程序员必须在同一个函数内调用这两个例程（一对）。不遵守这一规定会导致奇怪的编译器失败。
- en: As noted, TSD destructor handlers too, if they exist, get invoked; here, we
    ignore this aspect.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所指出的，如果存在TSD析构处理程序，它们也会被调用；在这里，我们忽略了这一方面。
- en: You might think, fine, if we use these cleanup handler techniques, we can safely
    restore state as both thread-cancelation and -termination will guarantee that
    they invoke any registered cleanup handlers (destructors). But, what if another
    process (perhaps a root process) sends my MT app a fatal signal (such as `kill
    -9 <mypid>`)? Well, there's nothing to be done. Please realize that with a fatal
    signal, all threads in the process, and indeed the entire process itself, will
    die (in this example). It's an academic question—a moot point. On the other hand,
    a thread cannot just randomly get killed; there has to be an explicit `pthread_exit(3)`
    or cancelation carried out upon it. Thus, there is no excuse for the lazy programmer—set
    up cleanup handler(s) to perform the appropriate cleanup and all will be well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，好吧，如果我们使用这些清理处理程序技术，我们可以安全地恢复状态，因为线程取消和终止都将保证调用任何注册的清理处理程序（析构函数）。但是，如果另一个进程（也许是一个root进程）向我的MT应用程序发送了一个致命信号（比如`kill
    -9 <mypid>`）呢？那么就没什么可做的了。请意识到，对于致命信号，进程中的所有线程，甚至整个进程本身，都将死亡（在这个例子中）。这是一个学术问题——一个无关紧要的问题。另一方面，一个线程不能随意被杀死；必须对其进行显式的`pthread_exit(3)`或取消操作。因此，懒惰的程序员没有借口——设置清理处理程序来执行适当的清理，一切都会好起来。
- en: Thread cleanup – code example
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程清理-代码示例
- en: As a simple code example, let's modify our earlier refactored program—`ch16/mt_iobif_rfct.c` by
    installing a thread-cleanup handler routine. To test it, we cancel the first worker
    thread if the user passes `1` as the second parameter to our demo program, the 
    `ch16/cleanup_hdlr.c`. program.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的代码示例，让我们修改我们之前重构的程序——`ch16/mt_iobif_rfct.c`，通过安装一个线程清理处理程序例程。为了测试它，如果用户将`1`作为第二个参数传递给我们的演示程序`ch16/cleanup_hdlr.c`，我们将取消第一个工作线程。
- en: For readability, only key parts of the source code are displayed here. To view
    the complete source code, build and run it. The entire tree is available for cloning
    from GitHub: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，这里只显示了源代码的关键部分。要查看完整的源代码，请构建并运行它。整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'Here is the cleanup handler function and the re-worked wrapper routine – now
    with the cleanup handler push and pop APIs:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清理处理程序函数和重新编写的包装程序——现在带有清理处理程序推送和弹出API：
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `main()` sets up the thread-cancelation as required:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`main()`设置了所需的线程取消：
- en: '[PRE18]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A quick test run confirms that, upon cancelation, the cleanup handler is indeed
    invoked and cleanup performed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试确认，在取消时，清理处理程序确实被调用并执行了清理：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Threads and signaling
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和信号
- en: In [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling - Part
    I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling -
    Part II*, we covered signaling in detail. We are still on the same Unix/Linux
    platform; signaling and its usage for the application designer/developer does
    not simply disappear just because we are now working on MT applications! We still
    have to handle signals (recall that you can list your platform's available signals
    with a simple `kill -l` on the shell).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中，*信号-第I部分*，和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中，*信号-第II部分*，我们详细介绍了信号。我们仍然在同一个Unix/Linux平台上；信号及其在应用程序设计/开发中的使用并没有因为我们现在正在处理MT应用程序而消失！我们仍然必须处理信号（请记住，你可以在shell上用简单的`kill
    -l`列出你平台上可用的信号）。
- en: The issue
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: So, what's the problem? There is a significant difference in how we handle signals
    in MT apps. Why? The fact is that the traditional manner of handling signals does
    not really mix well with the pthreads framework. If you can avoid the usage of
    signals in your MT app, please do so. If not (often the case in real-world MT
    apps), then read on—we shall detail how to handle signals when within an MT application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是什么？在MT应用程序中，我们处理信号的方式有很大的不同。为什么？事实是，传统的信号处理方式与pthread框架并不真正兼容。如果你可以避免在MT应用程序中使用信号，请尽量这样做。如果不行（在现实世界的MT应用程序中通常是这样），那么请继续阅读——我们将详细介绍在MT应用程序中处理信号的方法。
- en: 'But why is signaling now an issue? It''s quite straightforward: signals were
    designed and meant for the process model. Consider this: how does one process
    send a signal to another process? It''s quite clear - using the `kill(2)` system
    call:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么现在发出信号成了一个问题？很简单：信号是为进程模型设计和用于的。想想看：一个进程如何向另一个进程发送信号？很明显——使用`kill(2)`系统调用：
- en: '`int kill(pid_t pid, int sig);`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`int kill(pid_t pid, int sig);`'
- en: Clearly, the first parameter, pid, is the PID of the process to deliver the
    `sig` signal (number) to. But, and here we see it, a process can be multithreaded—which
    particular thread will receive, and which particular thread will handle, the signal? The
    POSIX standard cowardly states that "any ready thread cna handle a given signal". What
    if all threads are ready? Then who does? All of them? It's ambiguous, to say the
    least.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，第一个参数pid是要将信号“sig”（数字）传递给的进程的PID。但是，这里我们看到，一个进程可以是多线程的——哪个特定线程会接收，哪个特定线程会处理这个信号？POSIX标准懦弱地声明“任何准备好的线程都可以处理给定的信号”。如果所有线程都准备好了怎么办？那么谁来处理？所有的线程？至少可以说是模棱两可的。
- en: The POSIX solution to handling signals on MT
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX处理MT上的信号的解决方案
- en: The good news is that the POSIX committee has come up with a recommendation
    to the developers of MT applications for signal-handling. This solution rests
    on an interesting design fact; although a process has a table of signal dispositions
    (set up by the kernel and the `sigaction(2)` system call), every thread within
    the process has its own discrete signal mask (using which it can selectively block
    signals) and signal pending mask (by which the kernel remembers which signals are
    pending delivery to the thread).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，POSIX委员会为MT应用程序的开发人员提出了信号处理的建议。这个解决方案基于一个有趣的设计事实；虽然进程有一个由内核和`sigaction(2)`系统调用设置的信号处理表，但进程内的每个线程都有自己独立的信号掩码（使用它可以选择性地阻塞信号）和信号挂起掩码（内核记住了要传递给线程的挂起信号）。
- en: 'Knowing this, the POSIX standard recommends that a developer handle signals
    in a pthreads application as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点，POSIX标准建议开发人员在pthreads应用程序中处理信号如下：
- en: Mask (block) all signals in the main thread.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程中屏蔽（阻塞）所有信号。
- en: Now any thread created by main inherits its signal mask, implying that signals
    will be blocked in all subsequently created threads—this is what we want.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，主线程创建的任何线程都会继承其信号掩码，这意味着所有随后创建的线程中的信号都将被阻塞——这正是我们想要的。
- en: Create a special thread that is dedicated to performing signal-handling for
    the entire application. Its job is to catch (trap) all required signals and handle
    them (in a synchronous fashion).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个专门的线程，专门用于执行整个应用程序的信号处理。它的工作是捕获（陷阱）所有必需的信号并处理它们（以同步方式）。
- en: Note that although it's possible to trap signals via the `sigaction(2)` system
    call, the semantics of signal-handling in MT apps often lead to using the blocking
    variants of signaling APIs—the `sigwait(3)`, `sigwaitinfo(3)`, and `sigtimedwait(3)`
    library APIs. It is usually a good idea to use one of these blocking APIs within
    our dedicated signal-handler thread to block all required signals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然可以通过`sigaction(2)`系统调用捕获信号，但在多线程应用程序中，信号处理的语义通常导致使用信号API的阻塞变体——`sigwait(3)`、`sigwaitinfo(3)`和`sigtimedwait(3)`库API。通常最好在专用的信号处理程序线程中使用这些阻塞API来阻塞所有所需的信号。
- en: Thus, whenever a signal does arrive, the signal-handler thread is unblocked,
    and it receives the signal; also (assuming we're using the `sigwait(3)` API),
    the signal number is updated in the second parameter to `sigwait(3)`. It can now
    perform the required signal-processing on behalf of the application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当信号到达时，信号处理程序线程将被解除阻塞，并接收到信号；此外（假设我们使用`sigwait(3)` API），信号编号将更新到`sigwait(3)`的第二个参数中。现在它可以代表应用程序执行所需的信号处理。
- en: Code example – handling signals in an MT app
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例-在MT应用程序中处理信号
- en: 'A quick demonstration of the POSIX recommended technique for handling signals
    in an MT application  follows (`ch16/tsig.c`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循POSIX推荐的处理MT应用程序中信号的技术的快速演示如下（`ch16/tsig.c`）：
- en: For readability, only key parts of the source code are displayed here. To view
    the complete source code, build and run it. The entire tree is available for cloning
    from GitHub: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，这里只显示了源代码的关键部分。要查看完整的源代码，请构建并运行它。整个树都可以从GitHub克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The worker threads don''t do much—they just invoke our `DELAY_LOOP` macro to
    simulate some work. Here, see the signal-handler thread routine:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程并没有做太多事情——它们只是调用我们的`DELAY_LOOP`宏来模拟一些工作。在这里，看看信号处理程序线程例程：
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We leave it as a quick exercise to the reader to try it out, noting the output. By
    the way, how will you finally kill it? Just open another Terminal window and issue `kill
    -9 <PID>` from there.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其留给读者快速尝试，并注意输出。顺便问一下，你最终会如何杀死它？只需打开另一个终端窗口，然后从那里发出`kill -9 <PID>`。
- en: For the reader's convenience, we repeat an important tip originally shown in [Chapter
    12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling - Part II*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便读者，我们重复了[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中最重要的提示，*信号-第二部分*。
- en: 'An important point to note: neither the `sigwait(3)`, `sigwaitinfo(2)`, nor
    `sigtimedwait(2)` APIs can wait for synchronously generated signals from the kernel—typically
    the ones that indicate a failure of some sort, such as the `SIGFPE` and the `SIGSEGV`.
    These can only be caught in the normal asynchronous fashion—via `signal(2)` or 
    via `sigaction(2)`. For such cases, as we have repeatedly shown, the `sigaction(2)`
    system call would be the superior choice.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是：`sigwait(3)`、`sigwaitinfo(2)`和`sigtimedwait(2)` API都不能等待来自内核的同步生成的信号——通常是指示某种失败的信号，比如`SIGFPE`和`SIGSEGV`。这些只能以正常的异步方式捕获——通过`signal(2)`或`sigaction(2)`。对于这种情况，正如我们反复展示的那样，`sigaction(2)`系统调用将是更好的选择。
- en: Also, to mask signals in a MT app, don't use the `sigprocmask(2)` API—it's not
    thread-safe. Instead, use the `pthread_sigmask(3)` library routine, which is.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在MT应用程序中屏蔽信号时，不要使用`sigprocmask(2)` API——它不是线程安全的。而是使用`pthread_sigmask(3)`库例程。
- en: 'Note that the following APIs are available to send signals to threads within the
    process:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下API可用于向进程内的线程发送信号：
- en: '`pthread_kill(3)`: An API to send a signal to a particular thread within the
    same process'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_kill(3)`：向同一进程内的特定线程发送信号的API'
- en: '`tgkill(2)`: An API to send a signal to a particular thread within a given
    thread group.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tgkill(2)`：向给定线程组内的特定线程发送信号的API。'
- en: '`tkill(2)`: A deprecated predecessor of `tgkill`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tkill(2)`：`tgkill`的已弃用前身。'
- en: Look up the details on their respective man pages. Having said this, it's far
    better to kill a thread via the pthreads cancelation framework than by sending
    it a signal.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '查阅它们各自的手册页面上的详细信息。话虽如此，最好通过pthread取消框架来终止线程，而不是通过发送信号。 '
- en: Threads vs processes – look again
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程与进程-再次查看
- en: Right from the start of this trilogy ( [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),* Multithreading
    with Pthreads Part I - Essentials*, [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*, and [Chapter 16](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml),
    *Multithreading with Pthreads Part III*) on multithreading with pthreads, with
    regard to the multiprocess (single-threaded) versus multithreaded argument, we
    have repeatedly said that it's not all advantages or disadvantages—there is always
    some of both, a trade–off.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个三部曲的开始（[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)，*使用Pthreads进行多线程编程第一部分-基础*，[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)，*使用Pthreads进行多线程编程第二部分-同步*，和[第16章](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml)，*使用Pthreads进行多线程编程第三部分*），关于多线程编程，关于多进程（单线程）与多线程的争论，我们一再说过，并不是完全优势或劣势——总是有一些优点和缺点，是一种权衡。
- en: '*Table 4* and *Table 5 *describe some of the pros and cons of the multiprocess
    (several single-threaded processes) versus the multithreaded (several threads
    within a single process) approaches.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*表4*和*表5*描述了多进程（多个单线程进程）与多线程（单个进程内的多个线程）方法的一些优缺点。'
- en: The multiprocess vs the multithreading model – pros of the MT model
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程与多线程模型- MT模型的优点
- en: 'Here are some pros of the MT model over the single-threaded process:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: MT模型相对于单线程进程的一些优点如下：
- en: '| **Context** | **Multiprocess (single-threaded) model** | **Multithreaded
    (MT) model** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **上下文** | **多进程（单线程）模型** | **多线程（MT）模型** |'
- en: '| Design for parallelized workloads |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 为并行化工作负载设计 |'
- en: Cumbersome
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 繁琐
- en: Non-intuitive
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不直观
- en: Using the fork/wait semantics repeatedly (creating a large number of processes)
    isn't simple or intuitive either
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用fork/wait语义（创建大量进程）也不简单或直观
- en: '|'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Lends itself to building parallelized software; calling the `pthread_create(3)` in
    a loop is easy and intuitive as well
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构建并行化软件；在循环中调用`pthread_create(3)`也很容易和直观
- en: Achieving a logical separation of tasks becomes easy
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现任务的逻辑分离变得容易
- en: The OS will have threads take advantage of multicore systems implicitly; for
    the Linux OS, the granularity of scheduling is a thread, not a process (more on
    this in the next chapter*)*
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统将隐式地使线程利用多核系统；对于Linux操作系统，调度的粒度是线程，而不是进程（关于这一点，下一章会详细介绍）*
- en: Overlapping CPU with IO becomes easy
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠CPU与IO变得容易
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Creation/ destruction performance | Much slower | Much faster than processes; resource-sharingguarantees
    this |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 创建/销毁性能 | 比较慢 | 比进程快得多；资源共享保证了这一点|'
- en: '| Context switching | Slow | Much faster between the threads of a process |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 上下文切换 | 慢 | 在进程的线程之间快得多|'
- en: '| Data sharing | Done via IPC (Inter-Process Communication) mechanisms; involves
    a learning curve, can be fairly complex; synchronization (via the semaphore) required
    | Inherent; all global and static data items are implicitly shared between threads
    of a given process; synchronization (via the mutex) is required |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 数据共享 | 通过IPC（进程间通信）机制完成；需要学习曲线，可能相当复杂；需要同步（通过信号量）| 内在；给定进程的所有全局和静态数据项在线程之间隐式共享；需要同步（通过互斥锁）|'
- en: Table 4: Multiprocess versus multithreading model – pros of the MT model
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：多进程与多线程模型- MT模型的优点
- en: The multiprocess vs the multithreading model – cons of the MT model
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程与多线程模型- MT模型的缺点
- en: 'Here are some cons of the MT model over the single-threaded process:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: MT模型相对于单线程进程的一些缺点
- en: '| **Context** | **Multiprocess (single-threaded) model** | **Multithreaded
    (MT) model** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **上下文** | **多进程（单线程）模型** | **多线程（MT）模型** |'
- en: '| Thread-safety | No such requirement; processes always have address space
    separation. | The most serious downside: every function in the MT application
    that can be run in parallel by threads must be written, verified, and documented
    to be thread-safe. This includes the app code and the project libraries, as well as
    any third-party libraries it links into. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 线程安全 | 没有这样的要求；进程始终具有地址空间分离。| 最严重的缺点：MT应用程序中可以由线程并行运行的每个函数都必须编写、验证和记录为线程安全。这包括应用程序代码和项目库，以及其链接到的任何第三方库。|'
- en: '| Application integrity | In a large MT app, if any one thread encounters a
    fatal error (such as a segfault), the entire app is now buggy and will have to
    shut down. | In a multiprocess app, *o*nly the process that encounters a fatal
    error will have to shut down; the rest of the project keeps running[1]. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序完整性 | 在大型MT应用程序中，如果任何一个线程遇到致命错误（如段错误），整个应用程序现在都有bug并且必须关闭。| 在多进程应用程序中，只有遇到致命错误的进程必须关闭；项目的其余部分继续运行[1]。|'
- en: '| Address space constraints | On 32-bit CPUs, the VAS (virtual address space)
    available to user mode apps is fairly small (either 2 GB or 3 GB), but still large
    enough for a typical single-threaded app; on 64-bit CPUs the VAS is enormous (2^64
    = 16 EB). | On a 32-bit system (still common on many embedded Linux products),
    the available VAS to user mode will be small (2/3 GB). Considering sophisticated
    MT apps with many threads, that''s not a lot! In fact, it''s one of the reasons
    embedded vendors are aggressively moving products to 64-bit systems. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 地址空间限制 | 在32位CPU上，用户模式应用程序可用的虚拟地址空间（VAS）相当小（2GB或3GB），但对于典型的单线程应用程序来说仍然足够大；在64位CPU上，VAS是巨大的（2^64
    = 16 EB）。| 在32位系统上（许多嵌入式Linux产品仍然常见），用户模式的可用VAS将很小（2/3GB）。考虑到具有许多线程的复杂MT应用程序，这并不多！事实上，这是嵌入式供应商积极将产品迁移到64位系统的原因之一。|'
- en: '| The Unix everything''s a file semantics | The semantic holds true: files
    (descriptors), devices, sockets, terminals, and so on can all be treated as files;
    also, each process has its own copy of a given resource. | Resource-sharing, seen
    as an advantage, can also be seen as a downside:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '| Unix的一切都是文件语义 | 语义成立：文件（描述符）、设备、套接字、终端等都可以被视为文件；此外，每个进程都有自己的资源副本。| 资源共享，被视为优势，也可以被视为劣势：'
- en: The sharing can defeat the traditional Unix model advantage
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可能会破坏传统的Unix模型优势
- en: The sharing of open files, memory regions, IPC objects, paging tables, resource
    limits, and so on implies synchronization overhead upon access
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享打开文件、内存区域、IPC对象、分页表、资源限制等会导致访问时的同步开销
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Signal-handling | Designed for the process model. | Not designed for the
    MT model; can be done, but a bit clumsy to handle signals. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 信号处理 | 针对进程模型设计。 | 不适用于MT模型；可以做到，但处理信号有点笨拙。 |'
- en: '| Designing, maintaining, and debugging | Quite straightforward compared to
    the MT model. | Increases complexity because the programmer has to track (in this
    mind) the state of several threads simultaneously, including notoriously complex
    locking scenarios. Debugging deadlock (and other) situations can be quite difficult
    (tools such as GDB and helgrind help, but the human still needs to track things).
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 设计、维护和调试 | 与MT模型相比相当直接。 | 增加了复杂性，因为程序员必须同时跟踪（在脑海中）多个线程的状态，包括众所周知的复杂锁定场景。调试死锁（和其他）情况可能会非常困难（诸如GDB和helgrind之类的工具有所帮助，但人仍然需要跟踪事物）。
    |'
- en: 'Table 5: Multiprocess versus multithreading model – cons of the MT model'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表5：多进程与多线程模型的比较 - MT模型的缺点
- en: '[1] The Google Chrome open source project architecture is based on the multiprocess
    model; see their comic adaptation on why: [http://www.google.com/googlebooks/chrome/med_00.html](http://www.google.com/googlebooks/chrome/med_00.html).
    From a software-design viewpoint, the site is very interesting.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Google Chrome开源项目的架构基于多进程模型；请参阅他们关于此的漫画改编：[http://www.google.com/googlebooks/chrome/med_00.html](http://www.google.com/googlebooks/chrome/med_00.html)。从软件设计的角度来看，该网站非常有趣。'
- en: Pthreads – a few random tips and FAQs
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pthreads - 一些随机提示和常见问题
- en: To conclude this chapter, we provide answers to FAQs on multithreading as well
    as a brief note on how to debug a MT application using GDB. Do read on.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们提供了关于多线程的常见问题的答案，以及如何使用GDB调试MT应用程序的简要说明。请继续阅读。
- en: Every function in your MT application that can be run in parallel by threads must
    be written, verified, and documented to be thread-safe. This includes your MT
    app code, your project  libraries, as well as any third-party libraries you link
    into.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您的MT应用程序中可以由线程并行运行的每个函数都必须编写、验证和记录为线程安全。这包括您的MT应用程序代码、项目库以及您链接到的任何第三方库。
- en: Pthreads – some FAQs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pthreads - 一些常见问题
- en: 'Q: What happens in a multithreaded process when a thread calls one of the `exec*()`
    routines?'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问：在多线程进程中，当一个线程调用`exec*()`例程之一时会发生什么？
- en: A: The calling application (the predecessor) is completely replaced by the successor
    process, which will be only the thread that called exec. Note that no TSD destructors
    or thread-cleanup handlers are called.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 答：调用应用程序（前任）完全被后续进程替换，后续进程将只是调用exec的线程。请注意，不会调用TSD析构函数或线程清理处理程序。
- en: 'Q: What happens in a multithreaded process when a thread calls `fork(2)`?'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问：在多线程进程中，当一个线程调用`fork(2)`时会发生什么？
- en: A: It's OS-dependent. On modern Linux, only the thread that called `fork(2)`
    is replicated in the new child process. All other threads that existed prior to
    the fork are gone. No TSD destructors or thread cleanup handlers are called. Calling
    fork in a multithreaded application can lead to difficulties; it is not recommended.
    Find a link in the *Further reading* section on the GitHub repository regarding
    this very question.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 答：这取决于操作系统。在现代Linux上，只有调用`fork(2)`的线程会在新的子进程中复制。所有在fork之前存在的其他线程都消失了。不会调用TSD析构函数或线程清理处理程序。在多线程应用程序中调用fork可能会导致困难；不建议这样做。在GitHub存储库的*进一步阅读*部分中找到有关这个问题的链接。
- en: 'Think of it this way: calling `fork` in an MT application for multiprocessing
    is considered the wrong approach; invoking fork for the sole purpose of executing
    another program is okay (via the typical fork-exec-wait semantic we learned about).
    In other words, the newly born child process should only call functions documented
    as being async-signal-safe and/or the exec* routines to invoke another application.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想：在MT应用程序中调用`fork`进行多进程处理被认为是错误的方法；仅为执行另一个程序而调用fork是可以的（通过我们学到的典型的fork-exec-wait语义）。换句话说，新生的子进程应该只调用被记录为异步信号安全和/或exec*例程的函数来调用另一个应用程序。
- en: Also, you can set up handlers to run when fork is invoked via the `pthread_atfork(3)`
    API.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以设置处理程序，以在通过`pthread_atfork(3)`API调用fork时运行。
- en: 'Q: What is the effect on Resource Limits (see ulimit/prlimit) in a multithreaded
    application?'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问：多线程应用程序中资源限制（参见ulimit/prlimit）的影响是什么？
- en: A: All resource limits—except the stack size limit, of course—are shared by
    all threads in the process. On older Linux kernels, this was not the case.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 答：所有资源限制 - 当然不包括堆栈大小限制 - 都由进程中的所有线程共享。在旧版Linux内核上，情况并非如此。
- en: Debugging multithreaded (pthreads) applications with GDB
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调试多线程（pthread）应用程序
- en: 'GDB supports debugging MT apps; almost all the usual commands work normally,
    just  a few commands tend to be thread-specific. Here are the key ones to be aware
    of:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: GDB支持调试MT应用程序；几乎所有常用命令都可以正常工作，只有少数命令倾向于特定于线程。以下是需要注意的关键命令：
- en: 'See all visible threads:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看所有可见线程：
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Switch context to a particular thread by using the `thread <thread#>`command*.*
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`thread <thread#>`命令切换上下文到特定线程*。*
- en: 'Apply a given command to all threads of the process: `(gdb) thread apply all
    <cmd>`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将给定命令应用于进程的所有线程：`(gdb) thread apply all <cmd>`
- en: 'Show the stack (GDB''s backtrace or `bt` command) of all threads (the following
    example output is from our earlier MT app, `mt_iobuf_rfct_dbg`; first, we show
    the threads via the `thread find .` command):'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有线程的堆栈（GDB的回溯或`bt`命令）（以下示例输出来自我们之前的MT应用程序`mt_iobuf_rfct_dbg`；首先，我们通过`thread
    find .`命令显示线程）：
- en: '[PRE23]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Some miscellaneous tips and tricks with regard to MT programming with pthreads (including
    several we have already come across), are in a blog article mentioned in the *Further
    reading* section on the GitHub repository (Pthreads Dev - common programming mistakes
    to avoid); please do check it out.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用pthread进行MT编程的一些其他提示和技巧（包括我们已经遇到的几个），在GitHub存储库的*进一步阅读*部分中提到的博客文章中（Pthreads
    Dev - 避免的常见编程错误）；请务必查看。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered several safety aspects of working with threads that
    the powerful pthreads framework provides. We looked at thread-safe APIs, what
    they are, why they are required, and how to make a thread routine thread-safe.
    We also learned how to have one thread cancel (effectively, kill off) a given
    thread, and how to have the victim thread deal with any required cleanup.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了使用强大的pthreads框架处理线程时的几个安全方面。我们看了线程安全的API，它们是什么，为什么需要，以及如何使线程例程线程安全。我们还学习了如何让一个线程取消（有效地终止）给定的线程，以及如何让受害线程处理任何必要的清理工作。
- en: The remainder of the chapter focused on how to safely mix threads with the signaling
    interfaces; we also compared and contrasted – giving pros and cons (some food
    for thought, really)—the typical multiprocess single-threaded with several processes
    versus multithreaded (with one process) approaches. Tips and FAQs round off this
    trilogy of chapters ([Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml), *Multithreading
    with Pthreads Part I - Essentials* and in this chapter).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分侧重于如何安全地混合线程与信号接口；我们还比较和对比了典型的多进程单线程与多线程（一个进程）方法的利弊（确实是一些值得思考的东西）。提示和常见问题解答结束了这一系列章节（[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)，*使用Pthreads进行多线程编程第一部分-基础知识*
    和本章）。
- en: In the next chapter, the reader will be taken through details on CPU scheduling
    on the Linux platform, and very interestingly, how the application developer can
    exploit CPU scheduling (with a multithreaded application demo).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将通过详细了解Linux平台上的CPU调度，以及非常有趣的是，应用程序开发人员如何利用CPU调度（使用多线程应用程序演示）。
