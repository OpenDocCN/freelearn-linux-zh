- en: Process Creation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: 'In the previous chapter, we learned how to handle a (fictional) application
    design and implementation requirement: getting our C program to execute (`exec`)
    another program altogether. However, the reality is that the discussion remains
    incomplete; this chapter on process creationwill fill in several gaps, and much
    more.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理（虚构的）应用程序设计和实现需求：让我们的C程序执行（`exec`）另一个完全不同的程序。然而，现实情况是讨论仍然不完整；这一章关于进程创建将填补一些空白，并且更多。
- en: 'In this chapter, you will learn about some core Unix/Linux systems programming
    concepts: the gory details required to correctly program the critical `fork(2)` system
    call to create a process. Along the journey, Unix aficionado terms such as blocking
    calls, orphans, and zombies are made clear as well. The material carefully brings
    out subtle points, turning the average developer into a proficient one. The reader
    will, in parallel, learn to write C code to implement the preceding key concepts
    in a Linux systems application. As usual, several code examples are used to clearly
    illustrate and harden the concepts taught.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习一些核心的Unix/Linux系统编程概念：正确编程关键的`fork(2)`系统调用所需的细节。在这个过程中，Unix爱好者术语如阻塞调用、孤儿和僵尸也将得到澄清。这些材料将仔细呈现出微妙的要点，将普通开发人员变成熟练的开发人员。同时，读者将学会编写C代码，以在Linux系统应用程序中实现前述关键概念。和往常一样，我们将使用多个代码示例来清楚地说明和巩固所教授的概念。
- en: 'The purpose of this chapter is to guide the Linux systems developer into the
    core system programming worlds of the Unix `fork-exec-wait` semantics and related
    areas. Briefly, we will focus upon the following areas, helping the reader learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是指导Linux系统开发人员进入Unix的核心系统编程世界，包括`fork-exec-wait`语义和相关领域。简而言之，我们将重点关注以下几个方面，帮助读者学习：
- en: The Unix process creation model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix进程创建模型
- en: The whys and the hows of it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中的原因和方法
- en: 'Deeper details, including:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入的细节，包括：
- en: How the fork affects memory allocations, open files and so on, and security
    implications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork`如何影响内存分配、打开文件等，以及安全性影响'
- en: The several forms of the `wait` APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait` API的几种形式'
- en: How these APIs are made use of practically
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些API如何实际使用
- en: The rules of fork
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork`的规则'
- en: Orphan and zombie processes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤儿和僵尸进程
- en: Process creation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: 'Unless a Unix/Linux systems programmer has been living under a rock somewhere,
    they''ve certainly heard of, if not directly worked with, the `fork(2)` system
    call. Why is it so well known and important? The reason is simple: Unix is a multitasking
    OS; programmers must exploit the OS''s capabilities. To have an application multitask,
    we need to create multiple tasks or processes; the fork is the Unix way to create
    a process. In fact, to the typical systems programmer, fork is the only way available
    to create a process.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除非Unix/Linux系统程序员一直生活在某个地方的岩石下，他们肯定听说过，如果不是直接使用过`fork(2)`系统调用。为什么它如此著名和重要？原因很简单：Unix是一个多任务操作系统；程序员必须利用操作系统的能力。要使应用程序多任务，我们需要创建多个任务或进程；`fork`是Unix创建进程的方式。事实上，对于典型的系统程序员来说，`fork`是创建进程的唯一可用方式。
- en: There is another system call to create a process or thread: `clone(2)`*.* It
    also creates, well, a custom process. It's not typically used by Linux application
    developers; library (typically the thread library) developers use it more. In
    this book, we do not explore `clone`; for one thing, it's very Linux-specific
    and non-portable; for another, it's more of a hidden API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个用于创建进程或线程的系统调用：`clone(2)`。它也创建一个自定义进程。它通常不被Linux应用程序开发人员使用；库（通常是线程库）开发人员更多地使用它。在本书中，我们不探讨`clone`；首先，它非常特定于Linux且不可移植；其次，它更像是一个隐藏的API。
- en: The other way to multitask is by multithreading of course, which will be covered
    in detail in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种多任务的方式是通过多线程，当然，这将在后面的章节中详细介绍。
- en: How fork works
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`fork`的工作原理'
- en: 'In theory, the job description of the `fork(2)` system call can be crystallized
    down to one simple statement: *create an identical copy of the calling process*.
    The terminology we shall repeatedly encounter is as follows: the process-calling *fork* is
    called the **parent **and the newly created, newborn process is called the **child**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`fork(2)`系统调用的工作描述可以简化为一个简单的语句：*创建一个调用进程的相同副本*。我们将反复遇到的术语如下：调用`fork`的进程称为**父进程**，而新创建的、新生的进程称为**子进程**。
- en: Please note that, to begin with at least, we shall keep the discussion on how fork works
    purely conceptual and simple; later, we shall delve deeper and clarify how the
    OS performs several necessary optimizations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，起初，我们将保持对`fork`工作方式的讨论纯粹概念化和简单；稍后，我们将深入探讨并澄清操作系统执行的几项必要优化。
- en: Fork is a system call; thus, the real work of process creation is carried out
    by the OS under the hood. Recall from [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*, that the **virtual address space** (**VAS**) of a process is
    built out of homogeneous regions called **segments** (or **mappings**). Thus,
    when a child process is created, the OS will copy the parent's text, data (three
    of them), library (and other mappings), plus the stack segment to the child.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`是一个系统调用；因此，进程创建的实际工作是由操作系统在后台完成的。回想一下[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中的*虚拟内存*，一个进程的**虚拟地址空间**（**VAS**）是由称为**段**（或**映射**）的同质区域构建而成。因此，当创建一个子进程时，操作系统将父进程的文本、数据（三个）、库（和其他映射），以及堆栈段复制到子进程中。'
- en: 'Hang on though; it does not stop there: There is more, much more, to a process
    than just its VAS. This includes open files, process credentials, scheduling information,
    filesystem structures, paging tables, namespaces (PIDs, and so on), audit information,
    locks, signal handling information, timers, alarms, resource limits, IPC structures,
    profiling (perf) information, security (LSM) pointers, seccomp, thread stacks
    and TLS, hardware context (CPU and other registers), and so on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不止于此：进程不仅仅是它的虚拟地址空间。这包括打开的文件，进程凭证，调度信息，文件系统结构，分页表，命名空间（PID等），审计信息，锁，信号处理信息，定时器，警报，资源限制，IPC结构，性能（perf）信息，安全（LSM）指针，seccomp，线程栈和TLS，硬件上下文（CPU和其他寄存器），等等。
- en: Many of the attributes mentioned earlier are well beyond the scope of this book,
    and we shall not attempt to delve into them. The idea is to show that there is
    much more to a process than just VAS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多早期提到的属性远远超出了本书的范围，我们不会尝试深入研究它们。想要表明进程不仅仅是虚拟地址空间。
- en: Phew! So, performing a fork involves the kernel copying several things from
    the parent to the child process. But, think about it: not all attributes are directly
    inherited by the child from the parent (many are, but certainly not all are).
    For example, the process PID and PPID (parent PID) is not inherited (can you figure
    out why?).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！因此，在fork中涉及内核从父进程复制多个东西到子进程。但是，想一想：并非所有属性都直接从父进程继承到子进程（许多是，但肯定不是所有的）。例如，进程PID和PPID（父进程PID）不会被继承（你能想出原因吗？）。
- en: 'As a first-level enumeration, the following process attributesare inherited
    by the child process upon fork (meaning, it-the new born child-gets a copy of
    the parent''s attributes with the same content):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一级枚举，以下进程属性在fork（意思是，新生的孩子-获得父进程的属性副本与相同的内容）时被子进程继承：
- en: 'The **VAS**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟地址空间（VAS）：
- en: Text
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: 'Data:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据：
- en: Initialized
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化
- en: Uninitialized (bss)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化（bss）
- en: Heap
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Library segments
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库段
- en: Other mappings (for example, shared memory regions, mmap regions, and so on)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他映射（例如，共享内存区域，mmap区域等）
- en: Stack
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Open files
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的文件
- en: Process credentials
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程凭证
- en: Scheduling information
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度信息
- en: Filesystem (VFS) structures
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统（VFS）结构
- en: Paging tables
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页表
- en: Namespaces
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Signal dispositions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理
- en: Resource limits
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源限制
- en: IPC structures
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC结构
- en: Profiling (perf) information
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能（perf）信息
- en: 'Security information:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全信息：
- en: Security (LSM) pointers
  id: totrans-44
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全（LSM）指针
- en: Seccomp
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seccomp
- en: Thread stacks and TLS
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程栈和TLS
- en: Hardware context
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件上下文
- en: 'The following attributes of the parent process are not inherited by the child
    process upon forking:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程的以下属性在fork时不会被子进程继承：
- en: PID, PPID
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID，PPID
- en: Locks
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁
- en: Pending and blocked signals (cleared for child)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待处理和阻塞信号（为子进程清除）
- en: Timers, alarms (cleared for child)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器，警报（为子进程清除）
- en: Audit information (CPU/time counters are reset for child)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计信息（CPU/时间计数器为子进程重置）
- en: Semaphore adjustments made via `semop(2)`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`semop(2)`进行信号量调整
- en: '**Asynchronous IO** (**AIO**) ops and contexts'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步IO（AIO）操作和上下文
- en: 'It''s useful to see this in the form of a diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以图表形式看到这一点很有用：
- en: '![](img/0db75d3e-d21d-4750-85a5-ecbc28056640.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0db75d3e-d21d-4750-85a5-ecbc28056640.png)'
- en: As can be seen, `fork(2)` is indeed a heavyweight operation!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，`fork(2)`确实是一个繁重的操作！
- en: If interested, you can find more detail on the inheritance/non-inheritance characteristics
    within the man page on `fork(2)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感兴趣，您可以在`fork(2)`的man页面中找到更多关于继承/非继承特性的详细信息。
- en: Using the fork system call
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fork系统调用
- en: 'The signature of the fork is simplicity itself:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: fork的签名本身就是简单的：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This looks trivial, but you know the saying *the devil lies in the details!*
    Indeed, we shall bring out several subtle, and not-so-subtle, pointers regarding
    the correct usage of this system call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来微不足道，但你知道那句话“魔鬼藏在细节中”！的确，我们将提出几个关于正确使用此系统调用的微妙和不那么微妙的指针。
- en: 'To begin to understand how fork works, lets write a simple C program (`ch10/fork1.c`*)*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始理解fork的工作原理，让我们编写一个简单的C程序（`ch10/fork1.c`*）*：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Build and run it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The fork will, on success, have created a new child process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: fork将在成功时创建一个新的子进程。
- en: '**A key programming rule: ****never assume an API succeeds, always check for
    the failure case !!!**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的编程规则：永远不要假设API成功，总是检查失败的情况！！！
- en: This cannot be overstressed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点无法过分强调。
- en: 'OK, let''s modify the code to check for the failure case; any and every system
    call (with perhaps just two exceptions out of around 380 syscalls) return `-1`
    on failure. Check for it; here is the relevant code snippet (`ch10/fork1.c`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们修改代码以检查失败的情况；任何系统调用（可能除了大约380个系统调用中的两个例外）在失败时返回`-1`。检查它；这是相关的代码片段（`ch10/fork1.c`）：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is identical to what we saw previously (of course, since the fork did
    not fail). So, the `printf` seems to have been executed twice. Indeed it was:
    once by the parent process, and once by the new child process. This immediately
    teaches us something about the way fork works; here, we will attempt to codify
    these things as the rules of fork. In this book, we shall end up codifying seven
    rules of `fork(2)`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前看到的完全相同（当然，因为fork没有失败）。所以，`printf`似乎被执行了两次。确实是这样：一次是由父进程执行的，一次是由新的子进程执行的。这立即教会我们一些关于fork工作方式的东西；在这里，我们将尝试将这些东西编码为fork的规则。在本书中，我们将最终将fork(2)的七条规则编码。
- en: 'Fork rule #1'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃1
- en: '**Fork rule #1**: *After a successful fork, execution in both the parent and
    child process continues at the instruction following the fork*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Fork规则＃1：*成功fork后，父进程和子进程中的执行都将继续在fork后的指令处进行*。
- en: 'Why does it happen this way? Well, think about it: the job of fork is to make
    a (pretty much) identical copy of the parent in the child; this includes the hardware
    context (mentioned earlier), which of course includes the **Instruction Pointer**
    (**IP**) register (sometimes called the **Program Counter** (**PC**)) itself!
    Hence, the child process too will execute the user mode code at the same location
    as the parent. As the fork is successful, control will not go the error handling
    code (the `FATAL()` macro); instead, it will go to the `printf` .* The key point
    is this: this will happen in both the (original) parent and the (new) child process.* Hence
    the output.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？嗯，想一想：`fork`的工作是在子进程中创建父进程的（几乎）相同的副本；这包括硬件上下文（前面提到的），当然也包括**指令指针**（**IP**）寄存器（有时称为**程序计数器**（**PC**））本身！因此，子进程也将在与父进程相同的位置执行用户模式代码。由于`fork`成功，控制不会转到错误处理代码（`FATAL()`宏）；相反，它将转到`printf`。*关键是：这将在（原始）父进程和（新的）子进程中都发生。*因此输出。
- en: 'To reinforce the point, we write a third version of this same simple C program
    (`ch10/fork3.c`). Here, we just show the `printf `statement as it''s the only
    line of code that changes (from the  `ch10/fork3.c`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强这一点，我们编写了这个简单的C程序的第三个版本（`ch10/fork3.c`）。在这里，我们只显示`printf`语句，因为这是唯一一行代码发生了变化（从`ch10/fork3.c`）：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Build and run it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ah! Now we can actually see that two processes have run the `printf`! Probably
    (but not for sure), PID `25496` is the parent process, the other of course is
    the child. After this, both processes execute the `exit(3)` API, and thus both
    die.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！现在我们实际上可以看到两个进程都运行了`printf`！可能（但不确定），PID `25496`是父进程，另一个当然是子进程。之后，两个进程都执行`exit(3)`API，因此都会终止。
- en: 'Fork rule #2 – the return'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃2 - 返回
- en: 'Let''s take a look at the code we''ve used so far:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们迄今为止使用的代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: OK, we now understand from the first rule that the `printf` will be run twice
    and in parallel—once by the parent, and once by the child process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们从第一条规则中了解到`printf`将被父进程和子进程并行运行两次。
- en: 'But, think about it: is this really useful? Can a real-world application benefit
    from this? No. What we are really after, what would be useful, is a division of
    labor, that is to say, have the child perform some task or tasks, and the parent
    perform some other task(s), in parallel. That makes the fork attractive and useful.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，想一想：这真的有用吗？现实世界的应用程序能从中受益吗？不。我们真正追求的，有用的是分工，也就是说，让子进程执行一些任务，父进程执行一些其他任务，以并行方式。这使得`fork`变得有吸引力和有用。
- en: For example, after the fork, have the child run the code of some function `foo` and
    the parent run the code of some other function `bar` (of course, these functions
    can internally invoke any number of other functions as well). Now that would be
    interesting and useful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`fork`之后，让子进程运行某个函数`foo`的代码，父进程运行某个其他函数`bar`的代码（当然，这些函数也可以内部调用任意数量的其他函数）。那将是有趣和有用的。
- en: 'To arrange for this, we would require some means of *distinguishing between
    the parent and child after* *the* *fork*. Again, at first glance, it might appear
    that querying their PIDs (via the `getpid(2)`) would be the way to do this. Well,
    you could, but that''s a crude way to do so. The proper way to distinguish between
    the processes is built into the framework itself: It''s—guess what—based on the
    value returned by the fork.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安排这一点，我们需要一些方法在`fork`之后*区分父进程和子进程*。同样，乍一看，似乎查询它们的PID（通过`getpid(2)`）是这样做的方法。嗯，你可以，但这是一种粗糙的方法。区分进程的正确方法内置在框架本身中：它是——猜猜——基于`fork`返回的值。
- en: In general, you might quite correctly state that if a function is called once,
    it returns once. Well, fork is special—when you call a `fork(3)`, it returns twice*.* How?
    Think about it, the job of the fork is to create a copy of the parent, the child;
    once done, both processes must now return to user space from kernel mode; thus
    fork is called once but returns twice; once in the parent and once in the child
    process context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您可能会正确地说，如果一个函数被调用一次，它就会返回一次。嗯，`fork`是特殊的——当您调用`fork(3)`时，它会返回*两次*。怎么做？想一想，`fork`的工作是创建父进程的副本，子进程；一旦完成，两个进程现在都必须从内核模式返回到用户空间；因此`fork`只被调用一次，但返回两次；一次在父进程中，一次在子进程上下文中。
- en: 'The key though, is that the kernel guarantees that the return values in parent
    and child differ; here are the rules regarding the return value of `fork`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键是内核保证父进程和子进程的返回值不同；以下是关于`fork`返回值的规则：
- en: 'On success:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时：
- en: The return value in the child process is zero (`0`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程中的返回值为零（`0`）
- en: The return value in the parent process is a positive integer, the PID of the
    new child
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程中的返回值是一个正整数，新子进程的PID
- en: On failure, `-1` is returned and `errno` is set accordingly (do check!)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时，返回`-1`并相应地设置`errno`（请检查！）
- en: 'So, here we go:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们开始吧：
- en: '**Fork rule #2**: *To determine whether you are running in the parent or child
    process, use the fork return value: it''s always 0 in the child, and the PID of
    the child in the parent*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork规则＃2**：*要确定您是在父进程还是子进程中运行，请使用fork返回值：在子进程中始终为0，在父进程中为子进程的PID*。'
- en: 'Here''s another detail: look for a moment at the `fork`''s signature:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节：暂时看一下`fork`的签名：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The return value''s data type is a `pid_t`, certainly a `typedef`. What is
    it? Lets find out:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的数据类型是`pid_t`，肯定是一个`typedef`。它是什么？让我们找出来：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There we are: it''s just an integer, after all. But that''s not the point.
    The point here is that when writing code, do not assume it''s integer; just declare
    the data type as per what the man page specifies; in the case of `fork`, as` pid_t`.
    This way, even if in future the library developers change `pid_t` to, say, `long`,
    our code will just require a re-compile. We future-proof our code, keeping it
    portable.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了：它只是一个整数。但这不是重点。这里的重点是，在编写代码时，不要假设它是整数；只需根据手册指定的数据类型声明数据类型；在`fork`的情况下，为`pid_t`。这样，即使在将来库开发人员将`pid_t`更改为，比如，`long`，我们的代码也只需要重新编译。我们未来证明了我们的代码，使其具有可移植性。
- en: Now that we understand three fork rules, let's write a small, but better, fork-based application
    to demonstrate the same. In our demo program, we will write two simple functions `foo `and `bar`;
    their code is identical, they will emit a print and have the process sleep for
    the number of seconds passed to them as a parameter. The sleep is to mimic the
    working of a real program (of course, we can do better, but for now we'll just
    keep it simple).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了三个fork规则，让我们编写一个小巧但更好的基于fork的应用程序来演示相同的内容。在我们的演示程序中，我们将编写两个简单的函数`foo`和`bar`；它们的代码是相同的，它们将发出打印并使进程休眠传递给它们的秒数作为参数。睡眠是为了模拟真实程序的工作（当然，我们可以做得更好，但现在我们只是保持简单）。
- en: 'The `main `function is as follows (as usual, find the full source code on the
    GitHub repository, `ch10/fork4.c`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数如下（通常情况下，在GitHub存储库`ch10/fork4.c`上找到完整的源代码）：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, here is a number of points to note:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几点需要注意：
- en: The return variable has been declared as `pid_t`*.*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回变量已声明为`pid_t`。
- en: 'Rule #1—execution in both the parent and child process continues at the instruction
    following the fork. Here, the instruction following the fork is not the switch (as
    is commonly mistaken), but rather the initialization of the variable `ret`! Think
    about it: it will guarantee that `ret` is initialized twice*:* once in the parent
    and once in the child, but to different values.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则＃1-父进程和子进程中的执行都在fork后的指令继续进行。在这里，跟在fork后的指令不是`switch`（通常被误解为），而是变量`ret`的初始化！想一想：这将保证`ret`被初始化两次：一次在父进程中，一次在子进程中，但值不同。
- en: 'Rule #2—to determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent. Ah, thus we see that the effect of both rules is to make sure that `ret `gets
    correctly initialized and, therefore, we can switch correctly'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则＃2-要确定您是在父进程还是子进程中运行，请使用fork返回值：在子进程中始终为`0`，在父进程中为子进程的PID。啊，因此我们看到两条规则的效果都是确保`ret`得到正确初始化，因此我们可以正确地进行切换
- en: 'A bit of an aside—the need for input validation. Have a look at the parameters
    we pass to the `fork4` program as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有点不相关的事情-需要输入验证。看看我们传递给`fork4`程序的参数：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Need we say more (see the output)? This is a defect (a bug). As mentioned in
    the source code comment, we leave the validation of the two parameters as a small
    exercise to the reader.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要说什么（看输出）？这是一个缺陷（一个错误）。如源代码注释中所述，我们将两个参数的验证留给读者作为一个小练习。
- en: Instead of an `if `condition, we would prefer to use the switch-case syntax;
    in your author's opinion, it makes the code more readable and thus better maintainable.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更喜欢使用`switch-case`语法而不是`if`条件；在作者看来，这使得代码更易读，因此更易维护。
- en: As we learned in rule 2, fork returns 0 in the child and the PID of the child
    in the parent; we use this knowledge in the switch-case and we thus effectively,
    and very readably, distinguish between the child and parent in the code.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在规则2中学到的，fork在子进程中返回0，在父进程中返回子进程的PID；我们在`switch-case`中使用这个知识，因此在代码中有效地、非常易读地区分子进程和父进程。
- en: 'When the child process ID is done, we do not have it call *break*; instead,
    we have it exit. The reason should be obvious: clarity. Have the child do whatever
    it requires within its business logic (`foo()`), and then simply have it go away.
    No fuss; clean code. (If we did use a break, we would require another `if` condition
    after the `switch `statement; this would be ugly and harder to understand.)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子进程ID完成时，我们不让它调用`break`；相反，我们让它退出。原因显而易见：清晰。让子进程在其业务逻辑（`foo()`）中做它需要做的事情，然后简单地让它离开。不麻烦；清晰的代码。（如果我们使用`break`，我们将需要在`switch`语句之后再使用另一个`if`条件；这将很难理解，且难看。）
- en: The parent process falls though the switch-case, it just emits a print, and
    exits.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程通过`switch-case`，只是发出打印并退出。
- en: 'Because the functions `foo` and `bar` are identical, we show the code for `foo` only
    here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数`foo`和`bar`是相同的，所以我们只在这里展示`foo`的代码：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'OK, let''s run it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们运行它：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we chose to keep the child alive for three seconds and the
    parent alive for seven seconds respectively. Study the output: the return values
    from fork are as expected.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们选择让子进程保持活动状态三秒，父进程分别保持活动状态七秒。研究输出：fork的返回值如预期的那样。
- en: 'Now let''s run it again but in the background (Also, we give more sleep time,
    10 seconds and 20 seconds to the child and parent respectively.) Back on the shell,
    we shall use `ps(1)` to see the parent and child processes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次在后台运行它（此外，我们给子进程和父进程分别更多的睡眠时间，10秒和20秒）。回到shell上，我们将使用`ps(1)`来查看父进程和子进程：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ps -l` (l: long listing) reveals more details about each process. (For
    example, we can see both the PID as well as the PPID.)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps -l`（l：长列表）显示了每个进程的更多细节。（例如，我们可以看到PID和PPID。）'
- en: In the preceding output, did you notice how the PPID (parent process ID) of
    the `fork4` parent happens to be the value `32106` and the PID is `308` . Isn't
    this odd? You usually expect the PPID to be a smaller number than the PID. This
    is often true, but not always! The reality is that the kernel recycles PIDs from
    the earliest available value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您是否注意到`fork4`父进程的PPID（父进程ID）恰好是值`32106`，PID是`308`。这不奇怪吗？通常您期望PPID比PID小。这通常是正确的，但并非总是如此！事实是内核从最早可用的值开始回收PID。
- en: '**An experiment to simulate work in the child and parent processes**.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟子进程和父进程中的工作的实验**。'
- en: 'Let''s do this: We create a copy of the `fork4.c` program, calling it `ch10/fork4_prnum.c`.
    Then, we modify the code slightly: We eliminate the functions `foo` and `bar`*,* and,
    instead of just sleeping, we have the processes simulate some real work by invoking
    a simple macro `DELAY_LOOP`. (The code is in the header file `common.h` .) The
    macro prints a given character a given number of times, which we pass as input
    parameters to `fork4_prnum`. Here is a sample run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做：我们创建`fork4.c`程序的副本，将其命名为`ch10/fork4_prnum.c`。然后，我们稍微修改代码：我们消除了`foo`和`bar`函数，而不是只是睡觉，我们让进程通过调用一个简单的宏`DELAY_LOOP`来模拟一些真正的工作。（代码在头文件`common.h`中。）这个宏根据输入参数打印给定字符给定次数，我们将这些参数作为输入参数传递给`fork4_prnum`。这是一个示例运行：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `DELAY_LOOP` macro is coded to print the character `p` (for parent) and `c` (for *c*hild);
    the number of times it's printed is passed along as parameters. You can quite
    literally see the scheduler context switching between the parent and child process!
    (the interleaved `p`'s and `c`'s demonstrate when each of them has the CPU).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELAY_LOOP`宏被编码为打印字符`p`（代表父）和`c`（代表子）；它打印的次数作为参数传递。你可以很清楚地看到调度程序在父进程和子进程之间进行上下文切换！（交错的`p`和`c`表明它们各自何时拥有CPU）。'
- en: 'To be pedantic, we should ensure both processes run on exactly one CPU; this
    can be easily achieved with the `taskset(1)` utility on Linux. We run `taskset`specifying
    a CPU mask of `0` implying that the job(s) should run only on the CPU `0` . (Again,
    we leave it as a simple look-up exercise for the reader: check out the man page
    on `taskset(1)`, and learn how to use it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要严谨一点，我们应该确保两个进程都在同一个CPU上运行；这可以通过Linux上的`taskset(1)`实用程序轻松实现。我们运行`taskset`指定一个CPU掩码为`0`，意味着作业只能在CPU
    `0`上运行。（再次留给读者一个简单的查找练习：查看`taskset(1)`的手册页，学习如何使用它：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We recommend that you actually try out these programs on their system to get
    a feel for how they work.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您实际在系统上尝试这些程序，以了解它们的工作方式。
- en: 'Fork rule #3'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃3
- en: '**Fork rule #3**: *After a successful fork, both the parent and child process
    execute code in parallel*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork规则＃3**：*成功fork后，父进程和子进程都并行执行代码*。'
- en: At first glance, this rule looks pretty much the same as the first rule. But
    no, what's being stressed here is parallelism. The parent's and child's execution
    paths run in parallel with each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个规则看起来与第一个规则几乎一样。但不，这里强调的是并行性。父进程和子进程的执行路径与彼此并行运行。
- en: 'You might wonder how on a single (uni) processor system, this can be? Well,
    that''s right: a fundamental attribute of a modern processor is that exactly one
    machine instruction can run at any given point in time. So, if we''re on a uniprocessor
    box, it just means that the processes will be time-slicing (or timesharing) on
    the CPU. So, it''s pseudo-parallel; however, the speed of a modern CPU being what
    it is, a human user will perceive the execution as being in parallel. On a multicore
    (SMP) system, they would, or could, run truly in parallel. So, the detail regarding
    a uni-processor is just that: a detail. The key point is that we should visualize
    both the parent and child as executing code in parallel.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在单处理器系统上，这是怎么可能的？是的，没错：现代处理器的一个基本属性是在任何给定时间只能运行一条机器指令。因此，如果我们在一个单处理器的机器上，这意味着进程将在CPU上进行时间切片（或时间共享）。因此，这是伪并行；然而，由于现代CPU的速度，人类用户会感知执行是并行的。在多核（SMP）系统上，它们可以真正地并行运行。因此，单处理器的细节只是一个细节。关键点是我们应该将父进程和子进程都视为并行执行代码。
- en: 'So, in the previous code example, this rule tells us that the entire code paths
    of the parent and child processes will run in parallel; visualizing this parallelism
    is really the initial difficulty of the fork for folks new to it! To help  with precisely
    that, see the following figures (though we only show the code of the switch-case for
    brevity): the parent''s code path is highlighted in one color (red), and the child''s
    code path in another color (blue):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上一个代码示例中，这个规则告诉我们父进程和子进程的整个代码路径将并行运行；可视化这种并行性对于新手来说确实是fork的初始困难！为了帮助准确理解，看下面的图表（尽管我们只显示了switch-case的代码以简洁为目的）：父进程的代码路径用一种颜色（红色）突出显示，子进程的代码路径用另一种颜色（蓝色）突出显示：
- en: '![](img/13eae568-7a7f-4c6c-8f7f-607316de7906.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13eae568-7a7f-4c6c-8f7f-607316de7906.png)'
- en: This is the key point: the code in blue and the code in red, the child and parent
    processes, run in parallel!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键点：蓝色的代码和红色的代码，子进程和父进程并行运行！
- en: '![](img/158ee1e0-301c-44d0-82e7-271c4a906d55.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/158ee1e0-301c-44d0-82e7-271c4a906d55.png)'
- en: In the second diagram, the blue and red timeline arrows are used to again depict
    this parallelism.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个图表中，蓝色和红色的时间轴箭头再次用来描述这种并行性。
- en: Atomic execution?
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子执行？
- en: While seeing the preceding code flow diagrams, you can be misled into believing
    that once the process starts executing its code, it continues undisturbed until
    it finishes. This is certainly not necessarily going to happen; in reality, the
    process will often get context switched out of and back into the CPU as they run.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到前面的代码流程图时，你可能会误以为一旦进程开始执行其代码，它就会一直不受干扰地执行直到完成。这并不一定会发生；实际上，进程在运行时经常会被上下文切换出CPU，然后再切换回来。
- en: 'This leads us to an important point: *atomic execution.* A piece of code is
    considered to be atomic IFF (if and only if) it always runs to completion without
    interruption. Atomicity, especially in userspace, is not guaranteed: often, the
    process (or thread) execution is interrupted or preempted (sources of interruption/preemption
    include hardware interrupts, faults, or exceptions, and scheduler context switching).
    Keeping a code section atomic within the kernel can be arranged, though.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到一个重要的观点：*原子执行*。如果一段代码总是在没有中断的情况下运行完成，那么这段代码被认为是原子的。特别是在用户空间，原子性是不被保证的：通常，进程（或线程）的执行会被中断或抢占（中断/抢占的来源包括硬件中断、故障或异常，以及调度程序上下文切换）。在内核中保持代码段的原子性是可以安排的。
- en: 'Fork rule #4 – data'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃4 - 数据
- en: 'When a parent process forks*,* we understand that the child is created; it
    is a copy of the parent. This will include the VAS, and, thus, the data and stack
    segments. Keeping this fact in mind, check out the following code snippet (`ch10/fork5.c`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当父进程*分叉*时，我们知道子进程被创建；它是父进程的副本。这将包括VAS，因此也包括数据和堆栈段。记住这个事实，看看下面的代码片段（`ch10/fork5.c`）：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding program (`ch10/fork5`) has an initialized global variable `g` and
    an initialized local variable `loc`. The parent process, after fork, sleeps for
    two seconds thus more-or-less guaranteeing that the child process runs first (this
    kind of synchronization is incorrect in production quality code; we shall address
    this point in detail later in this chapter). Both the child and parent processes
    work on the global and local variables; the key question here is this*:* will
    the data get corrupted?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序（`ch10/fork5`）有一个初始化的全局变量`g`和一个初始化的局部变量`loc`。父进程在分叉后睡了两秒，因此更多或更少地保证了子进程先运行（这种同步在生产质量代码中是不正确的；我们将在本章后面详细讨论这一点）。子进程和父进程都在全局和局部变量上工作；这里的关键问题是这样的*：*数据会被破坏吗？
- en: 'Let''s just run it and see:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一下看看：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Well, the data variables are not corrupted. Again, the key point here is this:
    as the child has a copy of the parent''s variables, all goes well. They change
    independently of one another; they do not step on each other''s toes. So, consider
    this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，数据变量没有被破坏。再次强调这里的关键点是：由于子进程有父进程变量的副本，一切都进行得很顺利。它们彼此独立地改变；它们不会互相干扰。所以，请考虑这一点：
- en: '**Fork rule #4**: *Data is copied across the fork, not shared*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**分叉规则＃4**：*数据在分叉时被复制，而不是共享*。'
- en: 'Fork rule #5 – racing'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉规则＃5-赛车
- en: Notice the `#if 1` and `#endif` surrounding the `sleep(2);` statement in the
    previous code (`ch10/fork5.c`)? It of course implies that the code will be compiled
    and thus run.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码（`ch10/fork5.c`）中`sleep(2);`语句周围的`#if 1`和`#endif`？这当然意味着代码将被编译并运行。
- en: 'What if we change the `#if 1` to `#if 0` ? It''s obvious, the `sleep(2);` statement
    is effectively compiled out. Let''s do this: rebuild and re-run the `fork5` program.
    What will now happen?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`#if 1`改为`#if 0`？很明显，`sleep(2);`语句被有效地编译掉了。让我们这样做：重新构建和重新运行`fork5`程序。现在会发生什么？
- en: 'Think about this: fork rule #4 tells us the story. After the fork, we will
    still have the child and parent processes working on separate copies of the data
    variables; hence, the values we saw earlier will not change.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个：分叉规则＃4告诉了我们这个故事。在分叉后，我们仍然有子进程和父进程在数据变量的分开副本上工作；因此，我们之前看到的值不会改变。
- en: 'However, this time, there is no sleep to crudely synchronize the parent and
    child; thus, the question arises, will the `printf `for the child or parent code
    (displaying the variable values) run first? In other words, the question we are
    really asking is this: in the absence of any kind of synchronization primitive,
    after the `fork(2)`, which process will get the processor first: parent or child? The
    short answer is the next rule:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次没有`sleep`来粗略地同步父进程和子进程；因此，问题出现了，`printf`对于子进程还是父进程的代码（显示变量值）会先运行？换句话说，我们真正要问的问题是：在没有任何同步原语的情况下，在`fork(2)`之后，哪个进程会先获得处理器：父进程还是子进程？简短的答案是下一个规则：
- en: '**Fork rule #5**: *After the fork, the order of execution between the parent
    and child process is indeterminate*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**分叉规则＃5**：*分叉后，父进程和子进程之间的执行顺序是不确定的*。'
- en: 'Indeterminate? Well, this is a fancy way to say *we really have no idea *or *it''s
    unpredictable*. So that is the deal: the systems developer should not try to predict
    the order of execution. Running the modified `fork5 `(`no sleep(2)` statement)
    now:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定？嗯，这是一种花哨的说法，意思是*我们真的不知道*或者*它是不可预测的*。所以问题就是这样：系统开发人员不应该试图预测执行顺序。现在运行修改后的`fork5`（`没有sleep(2)`语句）：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ah, the parent ran first. That does not really mean anything! The parent might
    run first the next 50,000 times you try it out, but on the 50,001st trial run,
    the child process may run first. Leave it alone: it''s unpredictable.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，父进程先运行。这并不意味着什么！父进程可能在你尝试了下一次50,000次后仍然先运行，但在第50,001次试运行时，子进程可能会先运行。别管它：这是不可预测的。
- en: 'This leads us to another key point (common in software): We have what''s called
    a **race condition** here. A race is literally what it says: we cannot predict
    with certainty who will be the winner. In the previous program, we really don''t
    care whether the parent or child process wins the race (runs first): this is called
    a benign race condition. But often in software design we do actually care; in
    such cases, we need a way to guarantee the winner. In other words, to defeat the
    race. This is called synchronization. (As mentioned earlier, we shall address
    this point in detail later in this chapter.)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个关键点（在软件中常见）：我们这里有一个叫做**竞争条件**的东西。竞争就是字面上的意思：我们无法确定谁会是赢家。在前面的程序中，我们真的不在乎父进程还是子进程赢得了比赛（先运行）：这被称为良性竞争条件。但在软件设计中经常我们确实在乎；在这种情况下，我们需要一种方法来保证赢家。换句话说，打败竞争。这就是所谓的同步。（正如前面提到的，我们将在本章后面详细讨论这一点。）
- en: The process and open files
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和打开的文件
- en: To clearly understand the effect of fork on open files, we need to slightly
    digress and briefly understand some background information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地理解分叉对打开文件的影响，我们需要稍微偏离一下，并简要了解一些背景信息。
- en: In fact, for those readers very new to performing I/O on files within the Unix
    paradigm, it will be beneficial to first read through the [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*, before tackling this section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于那些在Unix范式中对文件进行I/O非常新手的读者，最好先阅读[附录A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)，*文件I/O基础*，然后再着手阅读本节。
- en: 'A Unix/Linux process, upon startup, will by default be assigned three open
    files; we''ve discussed these basic points earlier in the book. For convenience,
    the three open files are called the `stdin`*,* `stdout`*,* and `stderr `of the
    process; they auto-default to the keyboard, the monitor, and, again, the monitor
    for `stdin`*,* `stdout`*, *and `stderr` respectively. Not only that, real applications
    will certainly open other files as they perform their tasks. Recall the layered
    system architecture; if a Linux application opens a file using the `fopen(3)` library
    API, it will ultimately boil down to the `open(2)` system call, which returns
    a handle to the open file, called a** file descriptor**. (Think about it: consider
    a Java app running on Linux that opens a file: Ultimately, this time, via the
    JVM, the work will be done via the same `open(2)` system call!)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux进程在启动时，默认会分配三个打开文件；我们在本书的前面已经讨论过这些基本要点。为了方便起见，这三个打开文件被称为进程的`stdin`、`stdout`和`stderr`；它们自动默认为键盘、显示器和再次显示器，分别用于`stdin`、`stdout`和`stderr`。不仅如此，真实的应用程序在执行任务时肯定会打开其他文件。回想一下分层系统架构；如果Linux应用程序使用`fopen(3)`库API打开文件，最终将归结为`open(2)`系统调用，该调用返回一个称为**文件描述符**的打开文件句柄。（想一想：考虑一个在Linux上运行的Java应用程序打开文件：最终，通过JVM，这次工作将通过相同的`open(2)`系统调用完成！）
- en: 'The point here is this: the kernel stores every process''s open files within
    a data structure (in classic Unix terminology, it''s called the **Open File Descriptor
    Table** (**OFDT**). We saw earlier in the section that talked about characteristics
    inherited by the child process upon fork, thatopen files are indeed inherited
    by the child. To facilitate this discussion, consider the following pseudo-code
    snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是：内核在一个数据结构中存储每个进程的打开文件（在经典的Unix术语中，它被称为**打开文件描述符表**（**OFDT**）。我们在前面的部分中看到，子进程继承了父进程的特性，其中包括打开的文件。为了便于讨论，考虑以下伪代码片段：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the file `myfile `is now available to both processes and can be worked
    upon via the file descriptor `fd`! But hang on: it should be clear that working
    on the same file simultaneously by both child and parent processes could certainly corrupt the
    file; or if not the file content, at least the application. To perceive this,
    consider the function `work_on_file` *(*pseudo-code):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件`myfile`现在对两个进程都可用，并且可以通过文件描述符`fd`进行操作！但是要注意：很明显，父进程和子进程同时对同一个文件进行操作肯定会损坏文件；或者如果不是文件内容，至少会损坏应用程序。为了理解这一点，考虑函数`work_on_file`（伪代码）：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fork rule #6 – open files'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃6 - 打开文件
- en: 'You can see that without any synchronization, havoc would result! Hence the
    next fork rule:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果没有任何同步，将会造成混乱！因此下一个fork规则：
- en: '**Fork rule #6**: *Open files are (loosely) shared across the fork****.***'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork规则＃6**：*打开文件（松散地）在fork中共享。***'
- en: 'The upshot of all that is this: the systems programmer must understand that,
    if the parent process has opened a file (or files), naively working on the file
    simultaneously (remember fork rule #3!) will likely cause bugs. A key reason is
    this: although the processes are distinct, the object they work upon, the open
    file, and, more precisely, its inode, is one distinct object and thus shared.
    In fact, the file''s *seek* *position* is an attribute of the inode; blindly re-positioning
    the seek pointer in parent and child without synchronization will pretty much
    guarantee problems.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的要点是：系统程序员必须明白，如果父进程打开了一个文件（或文件），在没有同步的情况下进行文件操作（记住fork规则＃3！）很可能会导致错误。一个关键原因是：尽管进程是不同的，但它们操作的对象，即打开的文件，更确切地说是它的inode，是一个独立的对象，因此是共享的。事实上，文件的*seek*
    *position*是inode的一个属性；在没有同步的情况下盲目地重新定位父进程和子进程的寻位指针几乎肯定会导致问题。
- en: 'There are broadly two choices to keep things running smoothly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择可以使事情顺利运行：
- en: Have one of the process's close the file
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让其中一个进程关闭文件
- en: Synchronize access to the open file
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步对打开文件的访问
- en: 'The first of them keeps things simple but is of limited use in real-world applications;
    they would usually require that the file remains open. Thus, the second choice:
    how exactly do you synchronize access to the open file?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法保持简单，但在现实应用中的用途有限；它们通常要求文件保持打开。因此，第二种选择：如何确切地同步对打开文件的访问？
- en: 'Again, the details are not covered in this book, but, very briefly, you can
    synchronize file I/O between processes like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本书没有涵盖这些细节，但是，非常简单地说，你可以这样在进程之间同步文件I/O：
- en: Via the SysV IPC or POSIX semaphore
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SysV IPC或POSIX信号量
- en: Via file locking
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过文件锁定
- en: The first one works, but crudely. It's not considered the right way. The second
    solution, using file locking, is definitely the preferred one. (File locking is
    not covered in detail here, please refer the *Further reading *section for a link
    to an excellent tutorial on the same on the GitHub repository.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法可以工作，但很粗糙。这不被认为是正确的方法。第二种解决方案，使用文件锁定，绝对是首选。（文件锁定在这里没有详细介绍，请参考*进一步阅读*部分，链接到GitHub存储库上的一篇优秀教程。）
- en: It's also important to realize that when either the parent or child process
    closes the open file, its access to the open file is closed; the file is still
    open in the other process. This is really what is meant by the phrase "loosely
    shared".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，当父进程或子进程关闭打开文件时，它对打开文件的访问就关闭了；文件在另一个进程中仍然是打开的。这就是所谓的“松散共享”的含义。
- en: As a quick way to demo this issue, we write a simple program `ch10/fork_r6_of.c `
    (here, **of** stands for **open file**).We leave it to the reader to go through
    the source code; an explanation and sample output follows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速演示这个问题，我们编写一个简单的程序`ch10/fork_r6_of.c`（这里，**of**代表**打开文件**）。我们留给读者去阅读源代码；接下来是解释和示例输出。
- en: 'First, we have the process open a regular file tst; then, we have the child
    process do this: seek to offset 10, and write *numlines* (equal to 100) lines
    of `c`''s. In parallel, we have the parent process do this: seek to offset 10+(80*100),
    and write *numlines* lines of p''s. So when we have finished and we examine the
    file, we expect that we have 100 lines of `c`s and 100 lines of `p`s. But, hey,
    it does not actually happen that way. Here''s the actual run:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让进程打开一个名为tst的常规文件；然后，我们让子进程执行这个操作：定位到偏移量10，并写入`numlines`（等于100）行的`c`。与此同时，我们让父进程执行这个操作：定位到偏移量10+(80*100)，并写入`numlines`行的p。因此，当我们完成并检查文件时，我们期望有100行`c`和100行`p`。但是，嘿，实际上并不是这样发生的。以下是实际运行的情况：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the test file''s content after the run:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行后测试文件的内容：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `p`s and `c`s interleave! Yes, indeed, because the processes ran in parallel without
    any form of synchronization. (By examining the file content, we can literally
    see how the kernel CPU scheduler context-switched between the parent and the child
    processes). By not using synchronization, we have set up a race. So how do we
    set this right? It was mentioned earlier: file locking is really the answer (Note:
    do not attempt to synchronize with the silly `sleep(2)` in the parent kind of
    code we''ve used; that''s just for demonstration; Also, we shall cover the proper
    way to synchronize the child and parent shortly.)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`和`c`交错！是的，确实，因为进程在并行运行时没有任何形式的同步。（通过检查文件内容，我们可以清楚地看到内核CPU调度程序在父进程和子进程之间进行了上下文切换）。通过不使用同步，我们设置了一个竞争。那么我们如何解决这个问题呢？前面提到过：文件锁定实际上是答案（注意：不要尝试使用我们使用的父进程中的愚蠢的`sleep(2)`进行同步；那只是为了演示；此外，我们将很快介绍正确的方法来同步子进程和父进程。）'
- en: Open files and security
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件和安全性
- en: A key point again regarding security, for both the exec and fork scenarios.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性的一个关键点，适用于exec和fork的情况。
- en: 'When you perform an `exec `operation, the predecessor process''s VAS is essentially
    overwritten by that of the successor process. However, realize that the predecessor
    process''s open files (held within the OS in a per-process structure called the
    OFDT, mentioned earlier) remain intact and are, in effect, inherited by the successor
    process. This could pose a serious security threat. Think about it: what if a
    security-sensitive file being used by the predecessor is not closed and an exec performed?
    The successor now has access to it via its file descriptor, whether it exploits
    that knowledge or not.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`exec`操作时，前任进程的VAS实质上被继任进程的VAS覆盖。但是，请意识到，前任进程的打开文件（在先前提到的OS中的每个进程结构中称为OFDT）保持不变，并且实际上被继任进程继承。这可能构成严重的安全威胁。想一想：如果前任正在使用的安全敏感文件没有关闭并执行了`exec`，那么继任者现在可以通过其文件描述符访问它，无论它是否利用了这种知识。
- en: 'The same argument holds true for the fork; if a parent process has a security-sensitive
    file open and then forks, the child too has access to the file (fork rule #6).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于fork，同样的论点也成立；如果父进程打开了一个安全敏感的文件，然后fork，子进程也可以访问该文件（fork规则＃6）。
- en: To counter exactly this issue, from the Linux 2.6.23 kernel, the `open(2)` system
    call, includes a new flag: `O_CLOEXEC`. When this flag is specified within the `open(2)`,
    the corresponding file will be closed upon any future `exec `operation performed
    by that process. (In earlier kernels, developers had to perform an explicit `F_SETFD` via `fcntl(2)` to
    set the `FD_CLOEXEC` bit).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗这个问题，从Linux 2.6.23内核开始，`open(2)`系统调用包括一个新标志：`O_CLOEXEC`。当在`open(2)`中指定了这个标志时，相应的文件将在该进程执行的任何未来`exec`操作时关闭。（在早期内核中，开发人员必须通过`fcntl(2)`执行显式的`F_SETFD`来设置`FD_CLOEXEC`位）。
- en: When working with fork, the programmer must include logic to close any security-sensitive
    files in the parent prior to the fork.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用fork时，程序员必须包含逻辑，以在fork之前关闭父进程中的任何安全敏感文件。
- en: Malloc and the fork
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Malloc和fork
- en: 'A common mistake that programmers might stumble upon or make, is this: consider
    a successful memory allocation done in a process, with say, `p = malloc(2048)`.
    Assume that the variable `p`is global. Some time later, the process forks. The
    developer now wants the parent process to communicate some information to the
    child; so, she says, lets just write into the shared buffer `p`, and the job will
    be done. No, it does not work! Let''s elaborate: the malloced buffer is visible
    to both processes, but not in the way they think. The mistaken assumption is that
    the malloced buffer is shared between the parent and child process; it is not
    shared, it''s copied to the child''s VAS. Please recall fork rule #4: Data is
    not shared; it''s copied across the fork.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能会遇到或犯的一个常见错误是：考虑在进程中成功分配内存，比如，`p = malloc(2048)`。假设变量`p`是全局的。一段时间后，进程fork。开发人员现在希望父进程向子进程传递一些信息；所以，她说，让我们只是写入共享缓冲区`p`，工作就完成了。不，这不起作用！让我们详细说明一下：malloc的缓冲区对两个进程都是可见的，但不是以他们认为的方式。错误的假设是malloc的缓冲区在父进程和子进程之间是共享的；它不是共享的，它被复制到子进程的VAS。请回忆fork规则＃4：数据不共享；在fork中被复制。
- en: 'We must test this case; have a look at the following code snippet (source file: `ch10/fork_malloc_test.c`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须测试这种情况；看一下以下代码片段（源文件：`ch10/fork_malloc_test.c`）：
- en: For readability, only the relevant parts of the code are displayed here; to
    view and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，这里只显示了代码的相关部分；要查看并运行它，整个源代码在这里可用：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `disp_few` function to display a few (16) bytes of the memory buffer is
    simple:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`disp_few`函数用于显示内存缓冲区的前几个（16）字节很简单：'
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We build and run it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建并运行它：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Immediately, the first thing to notice is this: the pointer to the memory buffer
    (`0x1802260`) in both the parent and child process is the same leading one to
    the conclusion that it''s the same memory buffer being pointed at. Well, it''s
    not; it''s an easy mistake to make. Check out the *content* of the malloced buffer
    in the parent and child; it''s `p`s in the parent and `c`s in the child; if it
    were really the very same buffer, the content would be identical. So, then, what
    is going on?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 立即要注意的第一件事是：父进程和子进程中指向内存缓冲区（`0x1802260`）的指针是相同的，这导致人们得出结论，它指向的是同一个内存缓冲区。嗯，事实并非如此；这是一个容易犯的错误。查看父进程和子进程中分配的缓冲区的*内容*；父进程中是`p`，子进程中是`c`；如果它们真的是同一个缓冲区，内容应该是相同的。那么，到底发生了什么？
- en: 'As mentioned several times now, data is copied across the fork, not shared
    *(*our fork rule #4). OK, but then how come the address is the same? There are
    two reasons:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如现在已经提到了好几次，数据在fork时被复制，而不是共享（*我们的fork规则＃4）。好吧，那么为什么地址是相同的呢？有两个原因：
- en: The address is a virtual address (not a physical address, as we should well
    know from the discussions in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址是一个虚拟地址（不是物理地址，我们应该从[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)的讨论中知道，这是虚拟内存）
- en: It is actually the same virtual address; modern OSes such as Linux do not, immediately
    on fork, make a copy of the data and stack segments; they use an optimized semantic
    called **copy-on-write** (**COW**).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，这是相同的虚拟地址；现代操作系统如Linux在fork时并不会立即复制数据和堆栈段；它们使用一种优化的语义称为**写时复制**（**COW**）。
- en: COW in a nutshell
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COW的要点
- en: This requires a bit of explanation. Until now, to keep the discussion conceptually
    simple, we have said that upon fork, the kernel copies all the parent's VAS segments
    (plus all the other inherited process attributes) to the new child process. This
    is an exaggeration; the reality is, attempting to do this would make the `fork(2)` untenable
    in practice as it would require too much RAM and too much time. (As it is, even
    with several optimizations, the fork is still considered heavyweight.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一点解释。到目前为止，为了保持讨论在概念上的简单，我们说在fork时，内核会将所有父进程的VAS段（以及所有其他继承的进程属性）复制到新的子进程中。这是夸大其词的；事实上，试图这样做会使`fork(2)`在实践中不可行，因为这将需要太多的RAM和太多的时间。（事实上，即使有几个优化，fork仍然被认为是重量级的。）
- en: 'Let''s digress: one of the optimizations, upon fork is that the kernel does
    not copy the text (code) segment into the child; it merely shares the parent''s
    text segment (virtual) pages with the child process. This works well, as text
    is in any case only readable and executable (r-x); thus, as it can never change,
    why make a copy?'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们岔开一下：在fork时的优化之一是，内核不会将文本（代码）段复制到子进程中；它只是与子进程共享父进程的文本段（虚拟）页面。这很有效，因为文本无论如何只能读取和执行（r-x）；因此，它永远不会改变，为什么要复制呢？
- en: 'But what about the data and stack segments? Their pages are read-write (rw-)
    after all so how can the OS just share them with the child? Ah, that''s where
    the COW semantics come in handy. To understand COW, consider a single virtual
    page that has been marked as COW by the OS. It essentially means this: As long
    as both processes (parent and child) treat the page as read-only, they can share
    it; no copy is necessary. But the moment one of them modifies (even a byte in)
    the page, the OS intervenes and creates a copy of the page, which is then handed
    off to the process that performed the write.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但是数据和堆栈段呢？它们的页面毕竟是读写（rw-），所以操作系统怎么能与子进程共享它们呢？啊，这就是COW语义派上用场的地方。要理解COW，考虑一个由操作系统标记为COW的单个虚拟页面。这基本上意味着：只要两个进程（父进程和子进程）将页面视为只读，它们可以共享它；不需要复制。但是一旦它们中的一个修改了页面（甚至是一个字节），操作系统就会介入并创建页面的副本，然后将其交给执行写入操作的进程。
- en: So, if we have a global variable `g=5` and `fork(2)`, the page containing `g` is
    marked COW by the OS; the parent and child share it, until either writes to `g`.
    At that point, the OS creates a copy of the page containing the (updated) variable
    and hands it to the writer. Thus, the granularity of COW is a page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个全局变量`g=5`并且`fork(2)`，包含`g`的页面由操作系统标记为COW；父进程和子进程共享它，直到其中一个写入`g`。在那时，操作系统会创建包含（更新的）变量的页面的副本，并将其交给写入者。因此，COW的粒度是一个页面。
- en: As a matter of fact, COW is aggressively enforced by Linux to optimize to the
    maximum extent possible. Its not just the data and stack segments, most of the
    other inheritable process attributes we discussed earlier are actually not copied
    to the child, they are COW-shared, effectively making Linux's fork extremely efficient.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Linux积极地执行COW以最大程度地优化。不仅是数据和堆栈段，我们之前讨论的大多数其他可继承的进程属性实际上都没有复制到子进程中，它们是COW共享的，有效地使Linux的fork非常高效。
- en: 'Additional insight into these important points can be gained by noticing the
    same effect, the COW optimization, carried out on the data variables (globals
    and locals) as well; just run our test case program with any parameter and it
    internally runs a small test case on two variables: a global and a local:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注意到相同的效果，COW优化也应用在数据变量（全局和局部）上；只需用任何参数运行我们的测试程序，它就会在两个变量上运行一个小的测试用例：一个全局变量和一个局部变量。
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the addresses of the global `g` and the local `loc `are the same in
    the parent and child processes. But why? COW will have been performed as they
    have been written. Yes, but think: it''s all virtual addressing; the physical
    addresses will actually differ under the hood.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意父进程和子进程中全局变量`g`和局部变量`loc`的地址是相同的。但是为什么呢？COW在它们被写入时已经执行了。是的，但是要想一想：这都是虚拟寻址；在底层，物理地址实际上是不同的。
- en: 'You sometimes gets the feeling that modern OSes go out of their way to confuse
    and confound the poor systems programmer! The two important points we made earlier
    seem to contradict each other:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会觉得现代操作系统似乎费尽心思来困惑和迷惑可怜的系统程序员！我们之前提到的两个重要观点似乎相互矛盾：
- en: 'Fork rule #4: Data is copied across the fork, not shared'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fork规则＃4：数据在fork时被复制，而不是共享
- en: Data/stack (and a lot else) is not actually copied upon fork, but rather COW-shared
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据/堆栈（以及许多其他内容）实际上并没有在fork时复制，而是COW共享
- en: 'How do we resolve this situation? It''s easy, actually: The first (our fork
    rule #4) is the correct way to think when working with the fork; the second statement
    is what really happens under the hood at the OS layer. It''s about optimization, that
    is all.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这种情况？实际上很容易：第一个（我们的fork规则＃4）是在使用fork时正确的思考方式；第二个陈述是在操作系统层面下真正发生的事情。这只是关于优化的问题。
- en: 'Here is a suggestion: When wearing the hat of an application developer, do
    not get overly concerned with the  underlying OS''s COW optimization details;
    it''s more important to understand the intention rather than the optimization.
    Thus, as far as the Linux application developer using `fork(2)` is concerned,
    the key conceptual point that remains is fork rule #4: data is copied across the
    fork, not shared.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个建议：当扮演应用程序开发人员的角色时，不要过于关注底层操作系统的COW优化细节；更重要的是理解意图而不是优化。因此，就Linux应用程序开发人员使用`fork(2)`而言，仍然保持的关键概念点是fork规则＃4：数据在fork时被复制，而不是共享。
- en: Waiting and our simpsh project
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待和我们的simpsh项目
- en: 'Lets set ourselves an interesting learning exercise: a small project. We want
    to implement, using C on the Linux OS of course, a very simple shell of our own.
    Lets call it our `simpsh`—simple shell—project.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设定一个有趣的学习练习：一个小项目。我们想要使用C在Linux操作系统上实现一个非常简单的shell。让我们称它为我们的simpsh——simple
    shell——项目。
- en: Note: simpsh is a very small, minimally functioning shell. It works with only single-word commands.
    It does not support features such as redirection, piping, shell built-ins, and
    so on. It's meant to be a learning exercise.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：simpsh是一个非常小的、最小功能的shell。它只能处理单词命令。它不支持重定向、管道、shell内置等功能。它的目的是作为一个学习练习。
- en: 'The specification, for now at least is this: Display a prompt (say `>>`), accept
    a user command at the prompt, and execute it. This is the stopping condition:
    if the user enters `quit`, terminate (similar to typing `logout`, `exit`, or `Ctrl
    + D` on an actual shell process).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的规范是：显示一个提示符（比如`>>`），在提示符下接受用户命令，并执行它。这是停止条件：如果用户输入`quit`，则终止（类似于在实际shell进程上输入`logout`、`exit`或`Ctrl
    + D`）。
- en: 'It seems pretty straightforward: In our C program you get into a loop, display
    the required prompt, accept the user input (let''s use the `fgets(3)`to do this) into
    a `cmd `variable, and then use one of the exec family APIs (a simple `execl(3)`
    sounds promising) to execute it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常简单：在我们的C程序中，您进入一个循环，显示所需的提示，接受用户输入（让我们使用`fgets(3)`来做到这一点）到一个`cmd`变量中，然后使用`exec
    family`API之一（一个简单的`execl(3)`听起来很有前途）来执行它。
- en: 'Well, yes, except, how could you forget, the predecessor process is effectively
    lost after the exec operation succeeds! Our shell will be lost once we exec anything (just
    like our earlier experiment 1: on the CLI and experiment 2—demonstrated).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是的，除了，你怎么能忘记，前任进程在exec操作成功后实际上已经丢失了！我们的shell在执行任何东西后都会丢失（就像我们之前的实验1：在CLI上和实验2一样）。
- en: 'For example, if with the previous naive approach, we attempt to execute `ps(1)`with
    our shell simpsh, it would look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试用我们的shell simpsh执行`ps(1)`，它会像这样：
- en: '![](img/3dd4bb45-0b97-4f6b-83a7-81d59fb769e3.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dd4bb45-0b97-4f6b-83a7-81d59fb769e3.png)'
- en: The Unix fork-exec semantic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix的fork-exec语义
- en: So, that does not work. What we need, really, is a way for our simple shell simpsh to
    remain alive and well *after* the execoperation, but how can we achieve that?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这样是行不通的。实际上，我们需要的是让我们的简单shell simpsh在exec操作之后保持存活和正常运行，但我们如何实现呢？
- en: 'The fork is the answer! Here''s what we''ll do: after the user supplies input
    (a command), we have our shell fork. We now have two identical shells alive: the
    original parent (let''s say it has PID x) and the brand new child shell (PID y). The
    child shell is used as the sacrificial lamb: We have it exec the user command. So,
    yes, the child is the predecessor process that is impossible to return to; but
    that''s OK as we have the parent shell process alive and well!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: fork就是答案！我们要做的是：在用户提供输入（命令）之后，我们的shell进行fork。现在我们有两个相同的shell存活：原始父进程（假设它的PID为x）和全新的子shell（PID为y）。子shell被用作牺牲品：我们让它执行用户命令。所以，是的，子进程是不可能返回的前任进程；但没关系，因为我们有父shell进程存活正常！
- en: 'This well-known technique is called the *fork-exec* semantic. It combines what
    several other OSes call a spawn into two discrete operations: a process creation
    (fork), and a process execution (exec). Once again, the brilliant Unix design
    is shown off:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种众所周知的技术被称为*fork-exec*语义。它将一些其他操作系统称为生成的内容组合成了两个离散的操作：进程创建（fork）和进程执行（exec）。再次展示了Unix设计的精彩之处。
- en: '![](img/d02c4005-7234-4da0-9e9b-8399cec8896c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d02c4005-7234-4da0-9e9b-8399cec8896c.png)'
- en: In the preceding diagram, visualize the timeline as the (horizontal) x-axis.
    Also, we use the color blue to show the child's execution path.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，将时间线想象为（水平）x轴。此外，我们使用蓝色来显示子进程的执行路径。
- en: Once the parent shell detects that the execed child has completed, it displays
    the shell prompt again.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦父shell检测到exec的子进程已经完成，它会再次显示shell提示符。
- en: The need to wait
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待的需要
- en: 'The fork-execis really interesting, but hang on a second: While the child process
    performs an `exec` on the user command, and the successor is running (indicated
    by the dot-dash blue line in the preceding diagram), what should the parent process
    do? Obviously, it should wait, but for how long? Should we have it sleep? Well,
    no, as sleep takes the number of seconds to sleep as its argument. We do not know
    in advance how long the successor will take (it could be milliseconds, it could
    be months). The correct thing to do is this: have the parent process wait until
    the child (now the successor) dies.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork-exec`真的很有趣，但等一下：当子进程对用户命令执行`exec`时，继任者正在运行（在前面的图表中用点划线表示），父进程应该做什么？显然，它应该等待，但要等多久？我们应该让它睡觉吗？不，因为`sleep`的参数是要睡觉的秒数。我们事先不知道继任者需要多长时间（可能是毫秒，可能是几个月）。正确的做法是：让父进程等待子进程（现在是继任者）死亡。'
- en: This is precisely what the `wait(2)` API is designed to do. When the parent
    process issues the `wait(2)` API, it is put to sleep; the moment its child dies,
    it's woken up!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`wait(2)`API的设计目的。当父进程发出`wait(2)`API时，它被置于睡眠状态；在它的子进程死亡时，它被唤醒！
- en: Performing the wait
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行等待
- en: 'The `wait(2)` API is a classic example of a blocking call: The calling process
    is put into a sleep state until the event it is waiting (or blocking) upon occurs.
    When the event does occur, it is woken up and continues to run.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait(2)`API是一个典型的阻塞调用的例子：调用进程被置于睡眠状态，直到它等待（或阻塞）的事件发生。当事件发生时，它被唤醒并继续运行。'
- en: 'So, think about it: a process forks; the parent process then issues the `wait
    (2)`API, and the event it is blocking upon is the death of the child! The child
    continues to run, of course; when the child does die, the kernel wakes up, or unblocks, the
    parent; it now continues to execute its code. Here is the signature of `wait(2)`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，想一想：一个进程fork；然后父进程发出`wait(2)`API，它阻塞的事件是子进程的死亡！当然，子进程继续运行；当子进程死亡时，内核唤醒或解除阻塞父进程；现在它继续执行它的代码。这是`wait(2)`的签名：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For now, we shall ignore the to `wait(2)`; we shall just pass NULL (or `0`)
    (of course, we shall cover it shortly).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将忽略`wait(2)`；我们将只传递NULL（或`0`）（当然，我们很快会涵盖它）。
- en: Defeating the race after fork
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在fork后打败竞争
- en: 'Recall the example code we saw earlier in chapter `ch10/fork5.c`.In this program,
    we artificially, and crudely, waited for the child process by introducing a `sleep(2);`statement
    in the parent''s code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在第10章中看到的示例代码`ch10/fork5.c`。在这个程序中，我们通过在父进程的代码中引入一个`sleep(2);`语句来人为地、粗糙地等待子进程：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is not good enough: What if the child process takes longer than two seconds
    to complete its work? If it takes just a few milliseconds, then we unnecessarily
    waste time.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不够的：如果子进程花费的时间超过两秒来完成它的工作怎么办？如果只花了几毫秒，那么我们就浪费了时间。
- en: 'This is how we resolve the race: Who will run first, the parent or the child?
    Clearly, fork rule #5 tells us that it''s indeterminate. But, in real-world code,
    we need a way to guarantee that one of them indeed runs first—say, the child process.
    With the wait API, we now we have a proper solution! We change the preceding code
    snippet to this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们解决的竞争：谁会先运行，父进程还是子进程？显然，`fork规则＃5`告诉我们这是不确定的。但是，在现实世界的代码中，我们需要一种方法来保证其中一个确实首先运行——比如说，子进程。有了`wait
    API`，我们现在有了一个合适的解决方案！我们将前面的代码片段更改为这样：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Think about how this works: After the fork, it''s a race: If the child process
    does run first, then no harm is done. However, at some point in the near future,
    the parent process will get the CPU; that''s fine as all it does is block upon
    the child by calling wait. If the parent does run first after the fork, the same
    thing occurs: it blocks upon the child by calling wait. We have effectively defeated
    the race! By issuing the wait as the first thing done in the parent process after
    fork, we effectively guarantee that the child runs first.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这是如何工作的：在`fork`之后，这是一场竞赛：如果子进程确实首先运行，那么没有任何伤害。然而，在不久的将来，父进程将获得CPU；这没问题，因为它所做的就是通过调用`wait`来阻塞子进程。如果父进程在`fork`后首先运行，同样的事情发生：它通过调用`wait`来阻塞子进程。我们有效地打败了竞争！通过在父进程在`fork`后的第一件事就是发出`wait`，我们有效地保证了子进程首先运行。
- en: Putting it together – our simpsh project
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其整合在一起 - 我们的simpsh项目
- en: So, now that we have all the bits and pieces in place—namely, the fork-execsemantic
    and the `wait`API—we can see how our simple shell should be designed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经把所有的部分都放在了一起——即`fork-exec`语义和`wait`API，我们可以看到我们的简单shell应该如何设计。
- en: 'In the C program, get into a loop, display the required prompt, accept user
    input (let''s use the `fgets(3)`to do this—why? Please read the upcoming tip) into
    a `cmd` variable, and then fork. In the child code (use fork rule #2 to distinguish
    between the parent and child), use one of the many exec family APIs (a simple `execlp(3)` sounds
    promising here) to execute the user supplied command. In parallel (recall fork
    rule #3), have the parent process invoke the wait API; the parent now sleeps until the
    child dies. Now loop around again and repeat the whole thing until the user types `''quit''` to
    quit. Everyone''s happy!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在C程序中，进入循环，显示所需的提示，接受用户输入（让我们使用`fgets(3)`来做这个——为什么？请阅读即将到来的提示），将用户输入到一个`cmd`变量中，然后fork。在子代码中（使用`fork规则＃2`来区分父进程和子进程），使用许多`exec
    family`API之一（这里简单的`execlp(3)`听起来很有希望）来执行用户提供的命令。同时（回想`fork规则＃3`），让父进程调用`wait`API；父进程现在睡眠直到子进程死亡。现在再次循环并重复整个过程，直到用户输入`'quit'`退出。大家都很高兴！
- en: '![](img/2992e6e4-fcea-4b60-8bee-81d7b9ebc4bb.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2992e6e4-fcea-4b60-8bee-81d7b9ebc4bb.png)'
- en: In effect, we now have a `fork-exec-wait `semantic that is exploited!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们现在有了一个被利用的`fork-exec-wait`语义！
- en: '`fgets(3)`: For security reasons, do not use the traditionally taught APIs
    such as `gets(3)` or `scanf(3)` to receive user input; they are poorly implemented,
    and they do not provide any bounds-checking capabilities. The `fgets(3)` does;
    thus, using it, or `getline(3)`, is far superior security-wise. (Again, as mentioned
    earlier in this book, hackers exploit these vulnerabilities in commonly used APIs
    to perform stack-smashing, or other types of attacks.)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets(3)`：出于安全原因，不要使用传统教授的API，如`gets(3)`或`scanf(3)`来接收用户输入；它们实现很差，也不提供任何边界检查功能。`fgets(3)`提供了；因此，使用它，或者`getline(3)`，从安全性的角度来看要好得多。（再次提到，黑客利用这些常用API中的漏洞来执行堆栈破坏或其他类型的攻击。）'
- en: 'Of course, our simpsh shell is rather limited in scope: it only works with *s*ingle-word
    commands (such as `ps`, `ls`, `vi`, `w`, and so on). Read the code and think about
    why this is the case.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的simpsh shell的范围相当有限：它只能处理单词命令（如`ps`，`ls`，`vi`，`w`等）。阅读代码，思考为什么会这样。
- en: 'Here we go (source code: `ch10/simpsh_v1.c`):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧（源代码：`ch10/simpsh_v1.c`）：
- en: For readability, only the relevant parts of the code are displayed here; to view
    and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，这里只显示了代码的相关部分；要查看和运行它，整个源代码在这里可用：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we enter the loop, accept the user's command via the `getcmd` function
    we wrote (the `fgets` is issued within it), and then check whether the user has
    typed `quit`, in which case we exit.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们进入循环，通过我们编写的`getcmd`函数接受用户的命令（`fgets`在其中发出），然后检查用户是否输入了`quit`，在这种情况下我们退出。
- en: 'The real work, the `fork-exec-wait` semantic, happens here, within the loop:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作，`fork-exec-wait`语义，发生在这里，在循环内：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (The logic pertaining to argument passing—displaying the help screen, verbose
    switch, the actual `fgets`, the calloc/free, and so on, is not explicitly shown;
    please refer to the source file `simpsh_v1.c`).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: （关于参数传递的逻辑——显示帮助屏幕，详细开关，实际的`fgets`，`calloc/free`等等，并没有明确显示；请参考源文件`simpsh_v1.c`）。
- en: 'Let''s give it a try:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We run the program in verbose mode; you can see the shell prompt string `>>` 
    as well as every verbose print; they are prefixed with `[v]:`. Notice how it works
    for single word commands; the moment we pass something unknown or with more than
    one word (for example `www` and `uname -a` ), the `execlp(3)` fails; we catch
    the failure and emit a warning message; the program continues until the user quits.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以详细模式运行程序；您可以看到shell提示字符串`>>`以及每个详细打印；它们都以`[v]：`为前缀。请注意，它适用于单词命令；一旦我们传递一些未知的或超过一个单词的内容（例如`www`和`uname
    -a`），`execlp(3)`就会失败；我们捕获失败并发出警告消息；程序会继续，直到用户退出。
- en: 'Here is another quick experiment: We can use our `simpsh_v1`program to spawn
    another shell (`/bin/sh`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个快速实验：我们可以使用我们的`simpsh_v1`程序生成另一个shell（`/bin/sh`）：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It works as expected (hey, you could even experiment with spawning the same
    process `simpsh_v1`). So, there we are, a first very simple but functioning shell.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作正如预期的那样（嘿，你甚至可以尝试生成相同的进程`simpsh_v1`）。所以，我们有了一个非常简单但功能齐全的shell。
- en: Why exactly do commands that are more than one word long fail? The answer lies
    in how we're executing the successor, using the `execlp(3)` API. Recall, for execlp, we
    are to pass the program name (the PATH will be auto-searched of course) and all
    arguments, starting with `argv[0]`. Well, in our simple implementation, we just
    don't pass anything more than the first argument `argv[0]`; that's why.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么超过一个单词的命令会失败？答案在于我们如何执行后继操作，使用`execlp(3)`API。回想一下，对于`execlp`，我们需要传递程序名称（当然会自动搜索路径），以及从`argv[0]`开始的所有参数。在我们的简单实现中，我们只传递了第一个参数`argv[0]`之外的任何内容；这就是为什么。
- en: 'So, how do we make it work with commands with any number of arguments? Well,
    it really involves some amount of string-processing work: We will have to tokenize the
    arguments into individual strings, initializing an `argv`array of pointers to
    them, and using that `argv`via the `execv[pe]` API. We leave it as a slightly
    more challenging exercise to the reader! (Tip: the C library provides APIs for
    tokenizing strings; `strtok(3)`*,* `strtok_r(3)`*; *look them up).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使其能够处理任意数量的参数的命令？嗯，这实际上涉及一定量的字符串处理工作：我们将需要将参数标记为单独的字符串，初始化一个指向它们的`argv`指针数组，并通过`execv[pe]`API使用该`argv`。我们将其留作一个稍微具有挑战性的练习给读者！（提示：C库提供了用于标记字符串的API；`strtok(3)`，`strtok_r(3)`；查找它们）。
- en: In effect, our simpsh project is a simplistic implementation of the `system(3)`library
    API. Note that from a security viewpoint, it's always recommended to use field-proven
    and tested APIs like `system(3)`rather than a home-grown` fork-exec-wait` piece
    of code. Here, of course, we code it for learning purposes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的simpsh项目是`system(3)`库API的简单实现。请注意，从安全的角度来看，始终建议使用经过验证和测试的API，如`system(3)`，而不是自行编写的`fork-exec-wait`代码。当然，这里我们编写它是为了学习目的。
- en: The wait API – details
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待API - 详细信息
- en: 'In our simpsh program, we did use the `wait(2)` API, but have not really delved
    into details:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的simpsh程序中，我们确实使用了`wait(2)`API，但并没有深入研究细节：
- en: '[PRE34]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The thing to understand is this: `wait(2)` is a blocking call; it causes the
    calling process to block until a child process dies.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解的是：`wait(2)`是一个阻塞调用；它会导致调用进程阻塞，直到子进程死亡。
- en: 'To be technically correct, the `wait(2)` (and associated APIs that we shall
    see later) actually block upon the child process(es) undergoing a state change;
    well, the state change is the child''s death, right? Yes, but it''s really important
    to understand that it''s not just that: the possible state changes are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`wait(2)`（以及我们稍后将看到的相关API）实际上是在子进程经历状态改变时阻塞；嗯，状态改变就是子进程的死亡，对吧？是的，但非常重要的是要理解，不仅仅是这样：可能的状态改变如下：
- en: 'The child process terminates as follows:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程终止如下：
- en: Normally (by falling off `main`, or calling `[_]exit()`)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常（通过从`main`中退出，或调用`[_]exit()`）。
- en: Abnormally (killed by a signal).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常（被信号杀死）。
- en: The child was sent a signal that stopped it (usually `SIGSTOP` or `SIGTSTP`).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程收到了一个停止它的信号（通常是`SIGSTOP`或`SIGTSTP`）。
- en: Having been stopped, it was delivered a signal that continued (resumed) it (usually `SIGCONT`;
    we shall cover signaling in detail in the next chapter).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被停止后，它收到了一个信号，继续（恢复）了它（通常是`SIGCONT`；我们将在下一章详细介绍信号）。
- en: The generic `wait(2)` system call, though, blocks upon the death (termination)
    of the child, not any of the other signal-related state changes mentioned earlier.
    (Can that be done? Yes, indeed, we cover the `waitpid(2)`system call later in
    this chapter).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通用的`wait(2)`系统调用会在子进程死亡（终止）时阻塞，而不是之前提到的任何其他与信号相关的状态更改。（可以吗？是的，确实可以，我们将在本章后面介绍`waitpid(2)`系统调用）。
- en: 'The parameter to wait, is a pointer to an integer `wstatus`. In reality, it
    is treated as more of a return rather than a parameter to pass along; this is
    a pretty common C programming technique: Treat a parameter as a return value.
    System calls on Linux often use it; this technique is often referred to as a value-result or
    an in-out parameter. Think about this: We pass the address of the variable; the
    API internally, having the address, can update it (poke it).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: wait的参数是一个指向整数`wstatus`的指针。实际上，它更像是一个返回值，而不是要传递的参数；这是一种相当常见的C编程技术：将参数视为返回值。Linux上的系统调用经常使用它；这种技术通常被称为值-结果或输入-输出参数。想想这个：我们传递变量的地址；API在内部，有了地址，就可以更新它（poke
    it）。
- en: 'The next thing regarding the parameter `wstatus` is this: The integer is treated
    as a bitmask,not as an absolute value. This, again, is a common C optimization
    trick that programmers employ: We can fit several pieces of information into an
    integer by treating it as a bitmask. So, how do you interpret this returned bitmask?
    For portability reasons, the C library provides predefined macros that help us
    interpret the bitmask (these are in `<sys/wait.h>`usually). The macros work in
    pairs: The first macro returns a Boolean value; if it returns true, look up the
    second macro''s result; if it returns false, disregard the second macro completely.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关于参数`wstatus`的下一件事是：这个整数被视为一个位掩码，而不是一个绝对值。这又是一种常见的C优化技巧，程序员们使用：我们可以通过将其视为位掩码来将多个信息存储到一个整数中。那么，如何解释这个返回的位掩码呢？出于可移植性的考虑，C库提供了预定义的宏来帮助我们解释位掩码（通常在`<sys/wait.h>`中）。这些宏是成对工作的：第一个宏返回一个布尔值；如果它返回true，查找第二个宏的结果；如果它返回false，完全忽略第二个宏。
- en: 'A digression: a process can die in one of two ways: normally or abnormally. Normal
    termination implies that the process died voluntarily; it just fell off `main()` or called `exit(3)` or `_exit(2)` passing
    the exit status as an argument (the convention for exit status: zero  implies
    success, non-zero implies failure and is treated as the failure code). On the
    other hand, abnormal termination implies that the process died involuntarily—it
    was killed, typically via a signal.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个离题：一个进程可以以两种方式死亡：正常或异常。正常终止意味着进程是自愿死亡的；它只是从`main()`中掉下来，或者调用`exit(3)`或`_exit(2)`并将退出状态作为参数传递（退出状态的约定：零表示成功，非零表示失败并被视为失败代码）。另一方面，异常终止意味着进程是非自愿死亡的——它被杀死，通常是通过信号。
- en: 'Here are the wait macro pairs and their meaning:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是wait宏对及其含义：
- en: '| **First macro** | **Second macro** | **Meaning** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **第一个宏** | **第二个宏** | **含义** |'
- en: '| `WIFEXITED` | `WEXITSTATUS` | Child died normally: `WIFEXITED` is true; 
    then, `WEXITSTATUS`—exit status of child. Child died abnormally: `WIFEXITED` is
    false'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '| `WIFEXITED` | `WEXITSTATUS` | 子进程正常死亡：`WIFEXITED`为true；然后，`WEXITSTATUS`——子进程的退出状态。子进程异常死亡：`WIFEXITED`为false'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `WIFSIGNALED` | `WTERMSIG` | Child died due to signal: `WIFSIGNALED` is true;
    then, `WTERMSIG` is the signal that killed it. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `WIFSIGNALED` | `WTERMSIG` | 子进程因信号而死亡：`WIFSIGNALED`为true；然后，`WTERMSIG`是杀死它的信号。
    |'
- en: '|  | `WCOREDUMP` | True if, upon death, the child produced a core dump. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  | `WCOREDUMP` | 如果在死亡时，子进程产生了核心转储，则为true。 |'
- en: '| `WIFSTOPPED` | `WSTOPSIG` | True if child was stopped by signal; then, `WSTOPSIG`
    is the signal that stopped it. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `WIFSTOPPED` | `WSTOPSIG` | 如果子进程被信号停止，则`WIFSTOPPED`为true；然后，`WSTOPSIG`是停止它的信号。
    |'
- en: '| `WIFCONTINUED` | - | True if child was stopped and later resumed (continued)
    by a signal (`SIGCONT`). |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `WIFCONTINUED` | - | 如果子进程被停止然后后来恢复（继续）通过信号（`SIGCONT`）则为true。 |'
- en: (In the row containing `WCOREDUMP`, the indentation is intended to mean that
    you can tell that `WCOREDUMP` is only meaningful if `WIFSIGNALED` is true).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: （在包含`WCOREDUMP`的行中，缩进意味着您可以知道`WCOREDUMP`仅在`WIFSIGNALED`为true时才有意义）。
- en: What about the actual return value itself of `wait(2)`? Clearly, `-1` indicates
    failure (and of course the kernel will set `errno` to reflect the cause of the
    failure); else, on success, it's the PID of the process that died, thus unblocking
    the parent's wait.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`wait(2)`的实际返回值是什么？很明显，`-1`表示失败（当然内核会设置`errno`以反映失败的原因）；否则，在成功时，它是死亡进程的PID，从而解除了父进程的等待。
- en: 'To try out the things we have just learned, we make a copy of the `simpsh_v1`program
    and call it `ch10/simpsh_v2.c`*. *Again, we only show the relevant snippets here;
    the complete source code files are on the book''s GitHub repository:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试我们刚刚学到的东西，我们复制了`simpsh_v1`程序并将其命名为`ch10/simpsh_v2.c`*。*再次强调，我们这里只展示相关的片段；完整的源代码文件在书的GitHub存储库中。
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, we now capture the return value of `wait (2)`(the PID of the
    child that changed state), and if we are running in verbose mode, we call our
    own function `interpret_wait`; it will provide output detailing what status change
    exactly occurred; here it is:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们现在捕获了`wait(2)`的返回值（改变状态的子进程的PID），如果我们在详细模式下运行，我们将调用我们自己的`interpret_wait`函数；它将提供详细的输出，说明发生了什么状态变化；这就是它：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `VPRINT` macro is simple; it results in a `printf(3)`if the process is
    in verbose mode. We try the program (version 2) out:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`VPRINT`宏很简单；如果进程处于详细模式，则会导致`printf(3)`。我们尝试运行程序（版本2）：'
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, we run it in verbose mode; we can see that the child process `ps(1)` had
    a status change: It died normally, with an exit status of zero, indicating success.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们以详细模式运行它；我们可以看到子进程`ps(1)`的状态发生了变化：它以正常的方式死亡，退出状态为零，表示成功。
- en: 'Interesting: this is how bash knows whether the process that just ran succeeded
    or not; it plugs in the exit status—fetched via an API similar to `wait`*—*into
    the variable **`?`** (which you can access using  `$?` .)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是：这就是bash如何知道刚刚运行的进程成功与否；它将退出状态（通过类似于`wait`的API获取）插入到变量**`?`**中（您可以使用`$?`访问）。
- en: The scenarios of wait
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待的场景
- en: Until now, we've covered the generic `wait(2)` API; however, we have only really
    discussed one possible scenario regarding the `wait`*; *there are several more.
    Let's check them out.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了通用的`wait(2)`API；但是，我们只讨论了关于`wait`的一个可能的场景；还有其他几种。让我们来看看它们。
- en: 'Wait scenario #1'
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待场景＃1
- en: 'It''s the simple case (one we''ve already come across): a process forks, creating
    one child process. The parent subsequently issues the *wait *API; it now blocks on
    a status change in it''s child process; recall, the possible status changes the
    child can possibly go through are these:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的情况（我们已经遇到过的）：一个进程fork，创建一个子进程。父进程随后发出*wait*API；现在它在其子进程的状态变化上阻塞；回想一下，子进程可能经历的可能状态变化是这些：
- en: 'State transition from running (R): dead; that is to say, the child terminates
    (normally/abnormally)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运行状态（R）转换为死亡状态；也就是说，子进程终止（正常/异常）
- en: State transition from running/asleep (R|S|D) to stopped state (T); that is to
    say, it receives a signal causing it be stopped
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运行/睡眠状态（R|S|D）到停止状态（T）的状态转换；也就是说，它接收到一个信号导致它被停止
- en: State transition from stopped state (T) to ready-to-run (R); that is to say, from
    a stopped state to a ready-to-run state
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从停止状态（T）到准备运行状态（R）的状态转换；也就是说，从停止状态到准备运行状态的状态转换
- en: (The state transitions and the letters representing the process state are covered
    in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml), *CPU Scheduling on
    Linux*, on scheduling). Whichever may occur, the fact is that the parent is unblocked and
    continues to execute its code path; the `wait(2) `API returns (along with which
    we receive the PID of the child that died or was signaled), as well as the detailed
    status bitmask.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: （关于状态转换和表示进程状态的字母在[第17章](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml)中有所涵盖，*Linux上的CPU调度*，关于调度）。无论发生什么，事实是父进程被解除阻塞并继续执行其代码路径；`wait(2)`API返回（以及我们接收到死亡或被信号中断的子进程的PID），以及详细的状态位掩码。
- en: 'Wait scenario #2'
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待场景＃2
- en: 'Consider this scenario: A process forks (creates) two children; let''s call
    the parent process P and the children C1 and C2\. Recall fork rule #3—the parent
    and the children processes will all continue to run in parallel. Now, P calls `wait`;
    what will happen?'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：一个进程fork（创建）两个子进程；让我们称父进程为P，子进程为C1和C2。回想一下fork规则＃3-父进程和子进程将继续并行运行。现在，P调用`wait`；会发生什么？
- en: 'This is the answer: process P will remain blocked until one of the children
    dies (or stops), but which one? Any one; whichever one changes state first. So
    how will the systems programmer know which process dies or stopped? That''s easy:
    The return value is the PID of the process that died or stopped.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是答案：进程P将保持阻塞，直到其中一个子进程死亡（或停止），但是哪一个？任何一个；任何一个首先改变状态的。那么系统程序员如何知道哪个进程死亡或停止？很简单：返回值是死亡或停止的进程的PID。
- en: 'In other words, we devise a corollary: a wait blocks on a single child process;
    to block on n children requires n waits.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们得出一个推论：一个`wait`会阻塞一个子进程；要阻塞n个子进程需要n个`wait`。
- en: An interesting exercise would be to construct the preceding scenario in code;
    ensure that the parent process indeed waits upon both children (this very exercise
    is mentioned as `fork2c` on the GitHub repository).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的练习是在代码中构建前面的场景；确保父进程确实等待两个子进程（这个练习在GitHub存储库中被称为`fork2c`）。
- en: To have a parent wait upon all possible children, invoke the `wait`API as the
    condition of a while loop; as long as waitable children exist, it will block and
    return positive; the moment there are no waitable children, the `wait`returns
    `-1`; check for that as the condition to break out of the loop. Note though, that
    there are scenarios requiring a non-blocking wait to be set up; we shall cover
    these as well.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要让父进程等待所有可能的子进程，将`wait`API作为while循环的条件调用；只要存在可等待的子进程，它将阻塞并返回正值；一旦没有可等待的子进程，`wait`返回`-1`；检查这个条件以跳出循环。但请注意，有些情况需要设置非阻塞等待；我们也将涵盖这些情况。
- en: Fork bombs and creating more than one child
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork炸弹和创建多个子进程
- en: Say we want to write code to create three children; would this, the code shown
    as follows, do it?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写代码来创建三个子进程；下面显示的代码会实现吗？
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course not! (try it and see).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不！（试一下就知道了）。
- en: 'Recall fork rule #1: Execution in both the parent and child process continues
    at the instruction following the fork. Thus, as you can see, after the first fork,
    both the parent and child run the second fork (so we''ll now have a total of four
    processes), and then all four will run the third fork (giving us a total of eight
    processes), and so on (havoc!).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 回想fork规则＃1：父进程和子进程中的执行都在fork后的指令处继续。因此，正如你所看到的，第一个fork后，父进程和子进程都运行第二个fork（所以现在我们总共有四个进程），然后所有四个都将运行第三个fork（给我们总共八个进程），依此类推（混乱！）。
- en: If fork is called in this uncontrolled manner—it ends up creating *2^3 = 8*
    children! In other words, it's exponential; n forks implies *2^n* children will
    be created in a runaway sprint.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这种不受控制的方式下调用fork，它最终会创建*2^3 = 8*个子进程！换句话说，这是指数增长；n个fork意味着将创建*2^n*个子进程。
- en: 'Imagine what damage can be done with this code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这段代码可能造成的损害：
- en: '[PRE39]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's quite rightly called a fork bomb!—a type of **denial-of-service** (**DoS**)
    attack**. **
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为fork炸弹！-一种**拒绝服务**（**DoS**）攻击**。**
- en: Interestingly, because of modern Unixes (including Linux of course) having COW-based
    copying semantics, the memory overhead incurred may not be that large. Of course,
    it still consumes huge amounts of CPU; also, a simple calloc within the while
    loop would cause memory to be eaten up as well.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于现代Unix（包括Linux）具有基于COW的复制语义，所以产生的内存开销可能并不那么大。当然，它仍然消耗大量的CPU；此外，while循环中的一个简单的calloc也会导致内存被耗尽。
- en: By the way, carefully tuned resource limits (we studied this in an earlier chapter
    in detail) can help mitigate the fork bomb (and similar) DoS attack risks. Even
    better, would be careful tuning via cgroups for resource bandwidth control. Here
    is the fork bomb wikipedia link: [https://en.wikipedia.org/wiki/Fork_bomb](https://en.wikipedia.org/wiki/Fork_bomb).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，精心调整的资源限制（我们在之前的章节中详细研究过）可以帮助减轻fork炸弹（以及类似的）DoS攻击风险。更好的是，通过cgroups进行资源带宽控制的仔细调整。这是fork炸弹维基百科链接：[https://en.wikipedia.org/wiki/Fork_bomb](https://en.wikipedia.org/wiki/Fork_bomb)。
- en: OK, so, `fork(); fork();` is not the way to create two children. (Try out the
    exercise `Smallbomb` on the GitHub repository.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`fork(); fork();`不是创建两个子进程的方法。（在GitHub存储库上尝试练习`Smallbomb`。）
- en: 'How do you do so correctly? It''s straightforward: take into account the parent
    and child''s execution paths, distinguish between them (fork rule #2),and just
    have the parent create a second child process. This code snippet demonstrates
    the same:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如何正确地做到这一点？很简单：考虑父进程和子进程的执行路径，区分它们（fork规则＃2），并让父进程创建第二个子进程。这段代码片段演示了同样的情况：
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Wait scenario #3'
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待场景＃3
- en: What if a process has no children, never had any children (a bachelor chap),
    and it issues the `wait(2)`API? At first glance, this seems to be a problem case,
    as perhaps it could cause deadlock; but, no, the kernel is smarter than that.
    The kernel code of `wait`checks, and upon finding that the calling process has
    no children (dead or alive or stopped or whatever), it simply *fails *the *wait.* (FYI, `errno`gets
    set to `ECHILD` implying the process had no unwaited-for children).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程没有子进程，从来没有子进程（单身汉），并且发出`wait(2)`API，会发生什么？乍一看，这似乎是一个问题，因为它可能导致死锁；但是，内核比那更聪明。`wait`的内核代码检查，并在发现调用进程没有子进程（无论是死的还是活的还是停止的），它就会简单地*失败*这个*等待*。（FYI，`errno`被设置为`ECHILD`，表示进程没有未等待的子进程）。
- en: 'Again, recall one of our golden rules: *never assume anything; always check
    for the failure case*.Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回想我们的一个黄金法则：*永远不要假设任何事情；总是检查失败的情况*。重要的是，我们的[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，涵盖了这些要点。
- en: There is one more `wait` scenario; however, we need to cover more information
    first.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`wait`场景；但是，我们需要先了解更多信息。
- en: Variations on the wait  – APIs
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待的变体 - API
- en: There are a couple of additional system calls to perform the job of *waiting
    upon the child(ren) process(es)*; we cover them next.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的系统调用来执行*等待子进程*的工作；我们接下来会介绍它们。
- en: The waitpid(2)
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: waitpid(2)
- en: 'Consider that we have a process with three children; it is required that the
    parent waits (blocks) upon the termination of a particular child process. If we
    use the generic `wait` API, we have seen that it will get unblocked upon the state
    change of any of the children. The answer to this conundrum: the `waitpid(2)` system
    call:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个有三个子进程的进程；要求父进程等待（阻塞）特定子进程的终止。如果我们使用通用的`wait`API，我们已经看到它会在任何一个子进程的状态改变时解除阻塞。这个难题的答案：`waitpid(2)`系统调用：
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first parameter `pid`is set to the PID of the child to wait upon. However,
    other values are possible; if `-1` is passed, it generically waits for any `waitable`
    child process. (There are other more arcane cases; we refer you to the man page
    for them). In other words, issuing this is equivalent to a generic `wait(&stat);` API
    call:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`pid`设置为要等待的子进程的PID。但是，也可能有其他值；如果传递`-1`，它会通用地等待任何可等待的子进程。（还有其他更深奥的情况；我们建议您参考man页面）。换句话说，发出这个等同于通用的`wait(&stat);`API调用：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The second parameter is the usual status integer bitmask that we saw in detail
    with the `wait` API.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是我们在`wait`API中详细看到的通常状态整数位掩码。
- en: 'The third parameter is called `options`; previously, we set it to zero, implying
    no special behavior. What other values can it take? Well, you can pass just zero
    or the bitwise OR of the following (it''s also a bitmask):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数称为`options`；之前，我们将其设置为零，表示没有特殊行为。它还可以采用哪些其他值？嗯，你可以传递零或以下位或的按位或（它也是一个位掩码）：
- en: '| **Options parameter value** | **Meaning** |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **Options 参数值** | **含义** |'
- en: '| `0` | Default, same as `wait(2)` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 默认，与`wait(2)`相同 |'
- en: '| `WNOHANG` | Only block upon live children; if there are none, return immediately
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `WNOHANG` | 只在有活的子进程时阻塞；如果没有，立即返回 |'
- en: '| `WUNTRACED` | Also unblock when a child process stops(and does not necessarily
    terminate) |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `WUNTRACED` | 当子进程停止（并不一定终止）时也解除阻塞 |'
- en: '| `WCONTINUED` | Also unblock when a stopped child process is resumed (via
    the `SIGCONT` signal being delivered to it) |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `WCONTINUED` | 当一个停止的子进程恢复（通过传递`SIGCONT`信号）时也解除阻塞 |'
- en: At first, the `WNOHANG` option might sound strange; how can you block upon anything
    but a live child? Well, with a little patience, we shall soon resolve this peculiarity.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，`WNOHANG`选项可能听起来很奇怪；除了活的子进程，你怎么能阻塞？好吧，稍微耐心一点，我们很快就会解决这个奇怪的问题。
- en: 'To test the `waitpid(2)`, we again  make a copy of our `simpsh_v2.c`and call
    it `ch10/simpsh_v3.c`; the only meaningful difference in the code is that we now
    use the `waitpid(2)`instead of the generic `wait`API, passing along options as
    required; from `ch10/simpsh_v3.c`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`waitpid(2)`，我们再次复制我们的`simpsh_v2.c`，并将其命名为`ch10/simpsh_v3.c`；代码中唯一有意义的区别是我们现在使用`waitpid(2)`而不是通用的`wait`API，并根据需要传递选项；来自`ch10/simpsh_v3.c`：
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we run it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行它：
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We issue the `read`(a bash built-in) command, as it itself is a blocking call,
    so we know that the child process `read`will be alive and asleep. In another terminal
    window, we look up the PIDs of our `simpsh_v3`process and of the command we ran
    from within it (the `read`):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出`read`（一个bash内置）命令，因为它本身是一个阻塞调用，所以我们知道子进程`read`会活着并处于睡眠状态。在另一个终端窗口中，我们查看了我们的`simpsh_v3`进程和我们从中运行的命令（`read`）的PID：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (The useful `pstree(1)`utility shows us the process tree's parent-child hierarchy.
    Look up it's man page for details).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: （有用的`pstree(1)`实用程序显示了进程树的父子层次结构。查阅它的man手册以获取详细信息）。
- en: 'Now we send `SIGTSTP` (the terminal stop signal) to the `read`process; it gets stopped:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们发送`SIGTSTP`（终端停止信号）给`read`进程；它被停止了：
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Getting stopped is a status change that we are looking for! Recall, our waiting
    code now is this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 被停止是我们正在寻找的状态变化！回想一下，我们现在的等待代码是这样的：
- en: '[PRE47]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Thus, the moment the child stops the `WUNTRACED` option takes effect, and in
    the original terminal window we see this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦子进程停止，`WUNTRACED`选项就会生效，在原始终端窗口中我们会看到这个：
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now continue the child by sending it the signal `SIGCONT`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过发送信号`SIGCONT`来继续子进程：
- en: '[PRE49]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As our (parent) `waitpid(2)`is also using the `WIFCONTINUED` option, in the
    original Terminal window, we see this (though it does require the user to press
    the *Enter* key it seems):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们（父进程）的`waitpid(2)`也使用了`WIFCONTINUED`选项，在原始终端窗口中，我们看到了这个（尽管似乎需要用户按下*Enter*键）：
- en: '[PRE50]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have so much more control over the child(ren). (Young parents, please note!)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对子进程有更多的控制。（年轻的父母，请注意！）
- en: The `fork-exec-wait` Unixframework is powerful indeed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork-exec-wait` Unix框架确实很强大。'
- en: The waitid (2)
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`waitid(2)`'
- en: 'For further fine tuning and control, there is the `waitid(2)`system call as
    well (from Linux 2.6.9):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步微调和控制，也有`waitid(2)`系统调用（从Linux 2.6.9）：
- en: '`int **waitid**(idtype_t idtype, id_t id, siginfo_t *infop, int options);`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`int **waitid**(idtype_t idtype, id_t id, siginfo_t *infop, int options);`'
- en: 'The first two parameters will in effect specify the children to wait upon:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数实际上会指定要等待的子进程：
- en: '| **waitid(2): 1st parameter: idtype** | **Second parameter: id ** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **waitid(2)：第一个参数：idtype** | **第二个参数：id** |'
- en: '| `P_PID` | Set to the PID of the child to wait (block) upon |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `P_PID` | 设置为要等待（阻塞）的子进程的PID |'
- en: '| `P_PGID` | Wait upon any child whose process group ID (PGID) matches this
    number |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `P_PGID` | 等待任何进程组ID（PGID）与此数字匹配的子进程 |'
- en: '| `P_ALL` | Wait upon any child (this parameter is ignored) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `P_ALL` | 等待任何子进程（此参数将被忽略） |'
- en: 'The fourth `options` parameter is similar to how it was used with the `waitpid(2)`,but
    not identical; there are some additional options that can be passed along; again,
    it''s a bitmask*,* not an absolute value: the `WNOHANG` and `WCONTINUED` options
    have the same meaning as with the `waitpid(2)` system call.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个`options`参数与`waitpid(2)`的使用方式类似，但不完全相同；还有一些额外的选项可以传递；同样，它是一个位掩码，而不是绝对值：`WNOHANG`和`WCONTINUED`选项的含义与`waitpid(2)`系统调用相同。
- en: 'Additionally, the following options can be bitwise-ORed:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下选项可以进行按位或操作：
- en: '`WEXITED`: Block upon children that have (already) terminated (again, we shall
    soon make clear why this even exists)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WEXITED`：阻塞在已经终止的子进程上（我们很快会解释为什么这个选项存在）'
- en: '`WSTOPPED`: Block upon children that will enter the stopped state (similar
    to the `WUNTRACED `option)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WSTOPPED`：阻塞在将进入`stopped`状态的子进程上（类似于`WUNTRACED`选项）'
- en: '`WNOWAIT`: Block upon children, but once unblocked, leave them in a waitable
    state so that they can be waited-upon again with a later wait* API.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WNOWAIT`：阻塞在子进程上，但一旦解除阻塞，将其保持在可等待状态，以便稍后可以使用`wait*`API再次等待它们。'
- en: The third parameter is a (large) data structure of type `siginfo_t`; (we shall
    cover details in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*). On return of `waitid(2)`, this will get populated by the kernel. Various
    fields get set by the OS, among them, the PID of the child that changed state
    (`si_pid`), `si_signo` set to `SIGCHLD`, `si_status, si_code`. We intend to cover
    these in a later chapter (for now, please refer to the man page).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个`siginfo_t`类型的（大型）数据结构；（我们将在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中详细介绍，*信号-第一部分*）。在`waitid(2)`返回时，内核将填充这个数据结构。操作系统会设置各种字段，其中包括改变状态的子进程的PID（`si_pid`）、`si_signo`设置为`SIGCHLD`、`si_status`、`si_code`。我们打算在后面的章节中介绍这些（现在，请参考man手册）。
- en: 'There are BSD variations of `wait`APIs too: the `wait3`and the` wait4`*. *However,
    these are nowadays considered outdated; use the `waitpid(2)`or `waitid(2)` APIs
    instead.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 也有BSD版本的`wait`API：`wait3`和`wait4`。然而，这些现在被认为是过时的；请使用`waitpid(2)`或`waitid(2)`API。
- en: The actual system call
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际的系统调用
- en: 'We have seen several APIs that perform the work of having the parent process `wait `until
    the child changes state (dies, or stops, or resumes after stop):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个API，它们执行了让父进程等待子进程改变状态（死亡、停止或在停止后恢复）的工作：
- en: '`wait`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait`'
- en: '`waitpid`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitpid`'
- en: '`waitid`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitid`'
- en: '`wait3`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait3`'
- en: '`wait4`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait4`'
- en: 'Interestingly, and similar to the situation with the exec family APIs, the
    Linux implementation is such that most of the preceding APIs are library (`glibc`)
    wrappers: The fact is that, on the Linux OS, of all the preceding APIs, `wait4(2)`is
    the actual system call API.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与`exec`系列API的情况类似，Linux的实现是大多数前面的API都是库（`glibc`）包装器：事实上，在Linux操作系统上，所有前面的API中，`wait4(2)`是实际的系统调用API。
- en: 'Performing an `strace(1)`on a program that uses one of the `wait` APIs proves
    the point (we `strace`our `simpsh_v1`program, which calls `wait`):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对使用`wait`API之一的程序执行`strace(1)`证明了这一点（我们对调用`wait`的`simpsh_v1`程序进行了`strace`）：
- en: '[PRE51]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the output of `strace`*:*
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`strace`的输出：
- en: '[PRE52]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'While discussing performing an `strace`, another interesting question does
    arise: if you `strace`an application that calls `fork(2)`*, *after the `fork`API,
    will `strace`trace the execution path of the child process as well? By default,
    no, but just pass along the `-f` option, and it will!'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论执行`strace`时，另一个有趣的问题出现了：如果你`strace`一个调用`fork(2)`的应用程序，那么在`fork`API之后，`strace`会跟踪子进程的执行路径吗？默认情况下不会，但只需传递`-f`选项，它就会跟踪！
- en: 'The man page on `strace(1)` says this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace(1)`的man手册上说：'
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In a similar vein, systems programmers are probably aware of the tremendously
    powerful GNU debugger—GDB. If one is debugging a multiprocess application with
    `gdb(1)`, how can one request GDB which process''s execution path to follow after
    encountering a fork in the instruction stream? The setting is called `follow-fork-mode`:
    in `gdb`; here, we show an example of setting the mode to `child`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，系统程序员可能知道强大的GNU调试器-GDB。如果使用`gdb(1)`调试多进程应用程序，如何请求GDB在遇到指令流中的fork后跟随哪个进程的执行路径？这个设置称为`follow-fork-mode`：在`gdb`中；这里，我们展示了将模式设置为`child`的示例：
- en: '[PRE54]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With respect to GDB: Debugging multi-process applications with GDB: Using the
    GDB `attach <PID>` command is useful to `attach` to another process (say, the
    child). GDB also provides a powerful `catch` command; see `help catch` in GDB
    for more details.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GDB：使用GDB的`attach <PID>`命令对多进程应用程序进行调试是有用的，可以`attach`到另一个进程（比如子进程）。GDB还提供了一个强大的`catch`命令；在GDB中查看`help
    catch`以获取更多详细信息。
- en: A note on the vfork
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于vfork的说明
- en: Decades ago, the BSD Unix developers came up with an efficient special case
    system call— the `vfork(2)`*. *The idea at the time, was to perform some optimizations
    where you performed a fork and almost immediately an exec in the child (the fork-exec, in
    other words). As we know, using the fork-exec is quite a common and useful semantic
    (the shell and network servers use it heavily). When the vfork is called instead
    of the fork, the kernel does not go through the heavy copying operations usually
    required; it optimizes things.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，BSD Unix开发人员提出了一个高效的特殊情况系统调用-`vfork(2)`*。当时的想法是在子进程中执行一些优化，几乎立即在子进程中执行`fork`和`exec`（也就是`fork-exec`）。正如我们所知，使用`fork-exec`是一个非常常见和有用的语义（shell和网络服务器大量使用它）。当调用`vfork`而不是`fork`时，内核不会进行通常需要的大量复制操作；它会优化事情。
- en: 'The bottom line is this: At the time, `vfork(2)` was useful on Unix; but today''s
    Linux `fork(2)` is as optimized as can be, rendering the `vfork` to the back door.
    It''s still there, for perhaps two reasons:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是：当时，`vfork(2)`在Unix上很有用；但今天的Linux`fork(2)`已经优化到了极致，使`vfork`成为了后门。它仍然存在，可能有两个原因：
- en: Compatibility—to aid the porting of BSD apps to Linux
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性-帮助将BSD应用程序移植到Linux
- en: It is apparently useful on some arcane special Linuxes that run on MMU-less
    processors ( like uClinux)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些奇特的特殊Linux系统上显然很有用，这些系统在没有MMU的处理器上运行（如uClinux）
- en: On today's regular Linux platforms, it is not recommended to use the `vfork(2)`;
    just stick to the `fork(2)`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的常规Linux平台上，不建议使用`vfork(2)`；只需使用`fork(2)`。
- en: More Unix weirdness
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Unix怪异现象
- en: 'From fork rule #3, we understand that the parent and child processes run in
    parallel. What if one of them terminate? Will the other die too? Well, no, of
    course not; they are independent entities. However, there are side effects.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从fork规则＃3，我们了解到父进程和子进程并行运行。如果其中一个终止会怎么样？另一个会死吗？当然不会；它们是独立的实体。但是，会有副作用。
- en: Orphans
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤儿
- en: 'Consider this scenario: A process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：一个进程分叉，父进程和子进程同时在并行运行它们各自的代码路径。假设父进程的PID是100，子进程的PID是102，这意味着子进程的PPID当然是100。
- en: 'The parent process, for whatever reason, dies. The child continues on without
    any trouble, except for a side effect: The moment the parent (PID 100) dies, the
    child''s PPID (100) is now invalid! Thus, the kernel intervenes, setting the child''s
    PPID to the overall mothership—the ancestor of all user space tasks, the root
    of the process tree—the init, or on recent Linux, the systemd, process! It''s
    PID is, by venerable Unix convention, always the number `1`.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程出于任何原因死亡。子进程继续进行而没有任何问题，除了一个副作用：父进程（PID 100）死亡时，子进程的PPID（100）现在无效！因此，内核介入，将子进程的PPID设置为整体母舰-所有用户空间任务的祖先，进程树的根-`init`，或者在最近的Linux上是`systemd`进程！根据古老的Unix惯例，它的PID始终是数字`1`。
- en: 'Terminology: the child that lost its immediate parent is now said to be re-parented
    by systemd (or init), and its PPID will thus be `1`; this child is now an orphan.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：失去其直接父进程的子进程现在被称为由`systemd（或init）`重新父化，并且其PPID因此为`1`；这个子进程现在是一个孤儿。
- en: There is a possibility that the overall ancestor process (init or systemd) does *not* have
    PID 1, and thus the orphan's PPID may not be 1; this can occur, for example, on
    Linux containersor custom namespaces.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能整体祖先进程（init或systemd）*不*具有PID 1，因此孤立进程的PPID可能不是1；例如，在Linux容器或自定义命名空间中可能会发生这种情况。
- en: We notice that the child's PPID value abruptly changed; thus, the systems programmer
    must ensure that they do *not *depend on the PPID value being the same (which
    can always be queried via the `getppid(2)`system call) for any reason!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到子进程的PPID值突然改变了；因此，系统程序员必须确保他们不依赖于PPID值相同（可以通过`getppid(2)`系统调用查询）的任何原因！
- en: Zombies
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 僵尸
- en: The orphaned process does not pose any problem; there is another scenario with
    the distinct possibility of a nasty problem arising out of it.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 孤立的进程不会造成任何问题；还有另一种可能性，可能会出现一个严重的问题。
- en: 'Consider this scenario: a process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：一个进程分叉，父进程和子进程同时在并行运行它们各自的代码路径。假设父进程的PID是100，子进程的PID是102，这意味着子进程的PPID当然是100。
- en: 'Now we delve into a further level of detail: the parent process is supposed
    to wait upon the termination of its children (via any of the available `wait*(2)`APIs
    of course); what if it does not? Ah, this is really the bad case.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们深入到更深层次的细节：父进程应该等待其子进程的终止（当然可以通过任何可用的`wait*(2)`API来实现）；如果它没有怎么办？啊，这真的是一个糟糕的情况。
- en: 'Imagine this scenario: the child process terminates, but the parent is not waiting
    (blocking) upon it; thus it continues to execute its code. The kernel, however,
    is not pleased: The Unix rule is that the parent process must block upon its children! As
    the parent isn''t, the kernel cannot afford to completely clean up the just-dead
    child; it does release the entire VAS freeing up all the memory, it does flush
    and close all open files, as well as other data structures, but it does not clear
    the child''s entry in the kernel''s process table. Thus, the dead child still
    has a perfectly valid PID and some miscellaneous information (it''s exit status,
    exit bitmask, and so on). The kernel keeps these details as this is the Unix way:
    the parent must wait upon its children and reap them, that is, fetch their termination
    status information, when they die. How does the parent process reap the child(ren)?
    Simple: by performing the wait!'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这种情况：子进程终止，但父进程没有等待（阻塞）它；因此它继续执行它的代码。然而，内核并不高兴：Unix规则是父进程必须阻塞在它的子进程上！因为父进程没有阻塞，内核无法完全清理刚刚死去的子进程；它释放整个VAS，释放所有内存，刷新和关闭所有打开的文件，以及其他数据结构，但它不清除内核进程表中的子进程条目。因此，死去的子进程仍然有一个完全有效的PID和一些杂项信息（它的退出状态，退出位掩码等）。内核保留这些细节是因为这是Unix的方式：父进程必须等待它的子进程并收割它们，也就是在它们死后获取它们的终止状态信息。父进程如何收割子进程？简单：通过执行等待！
- en: 'So, think about it: The child has died; the parent has not bothered to *wait *for
    it; the kernel has cleaned up, to some extent, the child process. But it technically
    exists, as it''s half dead and half alive; it''s what we call a ***zombie process**.* In
    fact, this is a process state on Unix: Z for zombie (you can see this in the output
    of `ps -l`; additionally, the process is marked as *defunct*).'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请想一想：子进程已经死了；父进程没有等待它；内核在某种程度上清理了子进程。但从技术上讲，它仍然存在，因为它是半死半活的；这就是我们所说的***僵尸进程***。事实上，这是Unix上的一个进程状态：僵尸（你可以在`ps
    -l`的输出中看到这一点；此外，该进程被标记为*defunct*）。
- en: 'So why not just kill off the zombie(s)? Well, they''re already dead; we cannot
    kill them. The reader might then query, well, so what? let them be. OK, there
    are two reasons that zombies cause real headaches on production systems:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么不干脆杀死僵尸？嗯，他们已经死了；我们不能杀死他们。读者可能会问，那又怎样？让他们待着吧。好吧，有两个原因使得僵尸在生产系统上造成了真正的麻烦：
- en: They take up a precious PID
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们占用了宝贵的PID
- en: The amount of kernel memory taken up by the zombie is not insignificant (and
    essentially is a waste)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 僵尸占用的内核内存量并不可忽视（基本上是浪费）
- en: 'So, the bottom line is this: a couple of zombies might be OK, but dozens and
    hundreds, and more, are certainly not. You could reach a point where the system
    is so clogged with zombies that no other process can run—the `fork(2)` fails with `errno `set
    to `EAGAIN` (try again later) as no PIDs are available! It''s a dangerous situation.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题的关键是：几个僵尸可能还好，但是几十个、几百个，甚至更多，肯定不行。你可能会达到一个程度，系统被僵尸堵塞得无法运行其他进程——`fork(2)`失败，`errno`设置为`EAGAIN`（稍后重试），因为没有可用的PID！这是一个危险的情况。
- en: 'The Linux kernel developers had the insight to provide a quick fix: if you
    notice zombies on the system, you can, at least temporarily, get rid of them by
    killing their parent process! (Once the parent is dead, of what use is it to have
    the zombies? The point was, they remained so that the parent could reap them by
    doing a wait). Note that this is merely a bandage, not a solution; the solution
    is to fix the code (see the following rule).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核开发人员有迅速解决的见解：如果你在系统上发现了僵尸，你可以至少暂时通过杀死它们的父进程来摆脱它们！（一旦父进程死了，留着僵尸有什么用呢？问题是，它们仍然存在，以便父进程可以通过`wait`来收割它们）。请注意，这只是一个临时措施，而不是一个解决方案；解决方案是修复代码（参见下一个规则）。
- en: 'This is a key point; in fact, what we call the wait scenario #4: the wait gets
    unblocked with children that already terminated, in effect, the zombies. In other
    words, you not only should, you must, wait upon all children; otherwise, zombies
    will occur (Note that the zombie is a valid process state on the Unix/Linux OS;
    every process, on the ''way'' to death will pass through the **zombie** (Z)  state.
    For most it''s transient; it should not remain in this state for any significant
    length of time).'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键点；事实上，我们称之为`wait`场景＃4：`wait`被已经终止的子进程解除阻塞，实际上就是僵尸。换句话说，你不仅应该，而且必须等待所有子进程；否则，会出现僵尸（请注意，僵尸是Unix/Linux操作系统上的一个有效进程状态；每个进程，在“死亡”的过程中都会经过**僵尸**（Z）状态。对于大多数进程来说，这是短暂的；它不应该在这种状态下停留很长时间）。
- en: 'Fork rule #7'
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork规则＃7
- en: All of this neatly brings us to our next rule of fork.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好地引出了我们的下一个fork规则。
- en: '**Fork rule #7**: *The parent process must wait (block) upon the termination
    (death) of every child, directly or indirectly*.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork规则＃7**：*父进程必须等待（阻塞）每个子进程的终止（死亡），直接或间接*。'
- en: 'The fact is that, just like the `malloc-free`, the `fork-wait` go together.
    There will be situations in real-world projects where it might look impossible
    for us to force the parent process to block on the wait  after the fork; we shall
    address how these seemingly difficult situations can be easily addressed (that''s
    why we refer to an indirect method as well; hint: it''s to do with signaling,
    the topic of the next chapter).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，就像`malloc-free`一样，`fork-wait`是一起的。在现实项目中会有一些情况，我们可能认为不可能强制父进程在`fork`之后阻塞在`wait`上；我们将解决这些看似困难的情况如何轻松解决（这就是为什么我们也提到了一种间接方法；提示：这与信号有关，是下一章的主题）。
- en: The rules of fork – a summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork的规则-总结
- en: 'For your convenience, this table summarizes the fork rules we have encoded
    in this chapter:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这个表格总结了我们在本章中编码的fork规则：
- en: '| **Rule** | **The rule of fork** |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **规则** | **fork的规则** |'
- en: '| 1 | After a successful fork, execution in both the parent and child process
    continues at the instruction following the fork |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 成功fork后，父进程和子进程的执行都在fork后的指令处继续进行 |'
- en: '| 2 | To determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 要确定当前是在父进程还是子进程中运行，使用fork的返回值：在子进程中始终为`0`，在父进程中为子进程的PID |'
- en: '| 3 | After a successful fork, both the parent and child process execute code
    in parallel |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 成功fork后，父进程和子进程同时执行代码 |'
- en: '| 4 | Data is copied across the fork, not shared |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 数据在fork时被复制，而不是共享 |'
- en: '| 5 | After the fork, the order of execution between the parent and child process
    is indeterminate |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 在fork之后，父进程和子进程之间的执行顺序是不确定的 |'
- en: '| 6 | Open files are (loosely) shared across the fork |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 打开的文件在fork时（松散地）被共享 |'
- en: '| 7 | The parent process must wait (block) upon the termination (death) of
    every child, directly or indirectly |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 父进程必须等待（阻塞）每个子进程的终止（死亡），直接或间接地 |'
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A core area of Unix/Linux systems programming is learning how to correctly handle
    the all-important `fork(2)`system call, to create a new process on the system.
    Using the `fork(2)`correctly takes a lot of deep insights. This chapter helped
    the systems developer by providing several key rules of fork. The concepts learned—the
    rules, working with data, open files, security issues, and so on—were revealed
    via several code examples. A lot of details on how to wait for your children processes
    correctly were discussed. What exactly are orphans and zombie processes, and why
    and how we should avoid zombies was dealt with too.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux系统编程的核心领域之一是学习如何正确处理重要的`fork(2)`系统调用，以在系统上创建一个新进程。正确使用`fork(2)`需要深刻的见解。本章通过提供几个fork的关键规则来帮助系统开发人员。通过几个代码示例揭示了学到的概念——规则、处理数据、打开文件、安全问题等。还讨论了如何正确等待子进程的许多细节。还讨论了孤儿进程和僵尸进程的确切含义，以及为什么以及如何避免僵尸进程。
