["```\n/*\n * This struct describes the MFD part (\"cell\").\n * After registration the copy of this structure will\n * become the platform data of the resulting platform_device\n */\nstruct mfd_cell {\n\u00a0\u00a0\u00a0\u00a0const char *name;\n\u00a0\u00a0\u00a0\u00a0int id;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0int (*suspend)(struct platform_device *dev);\n\u00a0\u00a0\u00a0\u00a0int (*resume)(struct platform_device *dev);\n\u00a0\u00a0\u00a0\u00a0/* platform data passed to the sub devices drivers */\n\u00a0\u00a0\u00a0\u00a0void *platform_data;\n\u00a0\u00a0\u00a0\u00a0size_t pdata_size;\n\u00a0\u00a0\u00a0\u00a0/* Device Tree compatible string */\n\u00a0\u00a0\u00a0\u00a0const char *of_compatible;\n\u00a0\u00a0\u00a0\u00a0/* Matches ACPI */\n\u00a0\u00a0\u00a0\u00a0const struct mfd_cell_acpi_match *acpi_match;\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* These resources can be specified relative to the\n\u00a0\u00a0\u00a0\u00a0\u00a0* parent device. For accessing hardware, you should\n\u00a0\u00a0\u00a0\u00a0\u00a0* use resources from the platform dev\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0int num_resources;\n\u00a0\u00a0\u00a0\u00a0const struct resource *resources;\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstatic struct resource da9055_rtc_resource[] = {\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \u201eALM\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.start = DA9055_IRQ_ALARM,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.end = DA9055_IRQ_ALARM,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.flags = IORESOURCE_IRQ,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"TICK\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.start = DA9055_IRQ_TICK,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.end = DA9055_IRQ_TICK,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.flags = IORESOURCE_IRQ,\n\u00a0\u00a0\u00a0\u00a0},\n};\nstatic const struct mfd_cell da9055_devs[] = {\n\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9055-rtc\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9055-rtc\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.resources = da9055_rtc_resource,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.num_resources = ARRAY_SIZE(da9055_rtc_resource),\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0...\n};\n```", "```\nstatic int da9055_rtc_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0alm_irq = platform_get_irq_byname(pdev, \"ALM\");\n\u00a0\u00a0\u00a0\u00a0if (alm_irq < 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return alm_irq;\n\u00a0\u00a0\u00a0\u00a0ret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055_rtc_alm_irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IRQF_TRIGGER_HIGH | \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IRQF_ONESHOT,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"ALM\", rtc);\n\u00a0\u00a0\u00a0\u00a0if (ret != 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_err(rtc->da9055->dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"irq registration failed: %d\\n\", ret);\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nstatic struct resource da9055_rtc_resource[] = {\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \u201eALM\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.start = DA9055_IRQ_ALARM,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.end = DA9055_IRQ_ALARM,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.flags = IORESOURCE_IRQ,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n[...]\nstatic const struct mfd_cell da9055_devs[] = {\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9055-gpio\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9055-gpio\",\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9055-regulator\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9055-regulator\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.id = 1,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9055-rtc\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9055-rtc\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.resources = da9055_rtc_resource,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.num_resources = ARRAY_SIZE(da9055_rtc_resource),\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9055-watchdog\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9055-watchdog\",\n\u00a0\u00a0\u00a0\u00a0},\n};\n```", "```\nint devm_mfd_add_devices(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device *dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int id,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct mfd_cell *cells,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int n_devs,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct resource *mem_base,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int irq_base,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct irq_domain *domain)\n```", "```\n    for (r = 0; r < cell->num_resources; r++) {\n    \u00a0\u00a0\u00a0\u00a0res[r].name = cell->resources[r].name;\n    \u00a0\u00a0\u00a0\u00a0res[r].flags = cell->resources[r].flags;\n    \u00a0\u00a0\u00a0\u00a0/* Find out base to use */\n    \u00a0\u00a0\u00a0\u00a0if ((cell->resources[r].flags & IORESOURCE_MEM) && \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mem_base) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].parent = mem_base;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].start =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mem_base->start + cell->resources[r].start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].end =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mem_base->start + cell->resources[r].end;\n    \u00a0\u00a0\u00a0\u00a0} else if (cell->resources[r].flags & IORESOURCE_IRQ) {\n    [...]\n    ```", "```\n    \u00a0\u00a0\u00a0\u00a0} else if (cell->resources[r].flags & IORESOURCE_IRQ) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (domain) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* Unable to create mappings for IRQ ranges. */\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON(cell->resources[r].start !=\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cell->resources[r].end);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].start = res[r].end =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_create_mapping(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0domain,cell->resources[r].start);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].start =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_base + cell->resources[r].start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[r].end =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_base + cell->resources[r].end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0[...]\n    ```", "```\n#define DA9055_IRQ_NONKEY_MASK 0x01\n#define DA9055_IRQ_ALM_MASK 0x02\n#define DA9055_IRQ_TICK_MASK 0x04\n#define DA9055_IRQ_ADC_MASK 0x08\n#define DA9055_IRQ_BUCK_ILIM_MASK 0x08\n/*\n * PMIC IRQ\n */\n#define DA9055_IRQ_ALARM 0x01\n#define DA9055_IRQ_TICK 0x02\n#define DA9055_IRQ_NONKEY 0x00\n#define DA9055_IRQ_REGULATOR 0x0B\n#define DA9055_IRQ_HWMON 0x03\nstruct da9055 {\n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap;\n\u00a0\u00a0\u00a0\u00a0struct regmap_irq_chip_data *irq_data;\n\u00a0\u00a0\u00a0\u00a0struct device *dev;\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *i2c_client;\n\u00a0\u00a0\u00a0\u00a0int irq_base;\n\u00a0\u00a0\u00a0\u00a0int chip_irq;\n};\n```", "```\nstatic const struct regmap_irq da9055_irqs[] = {\n\u00a0\u00a0\u00a0\u00a0[DA9055_IRQ_NONKEY] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.reg_offset = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mask = DA9055_IRQ_NONKEY_MASK,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[DA9055_IRQ_ALARM] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.reg_offset = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mask = DA9055_IRQ_ALM_MASK,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[DA9055_IRQ_TICK] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.reg_offset = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mask = DA9055_IRQ_TICK_MASK,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[DA9055_IRQ_HWMON] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.reg_offset = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mask = DA9055_IRQ_ADC_MASK,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[DA9055_IRQ_REGULATOR] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.reg_offset = 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mask = DA9055_IRQ_BUCK_ILIM_MASK,\n\u00a0\u00a0\u00a0\u00a0},\n};\nstatic const struct regmap_irq_chip da9055_regmap_irq_chip = {\n\u00a0\u00a0\u00a0\u00a0.name = \"da9055_irq\",\n\u00a0\u00a0\u00a0\u00a0.status_base = DA9055_REG_EVENT_A,\n\u00a0\u00a0\u00a0\u00a0.mask_base = DA9055_REG_IRQ_MASK_A,\n\u00a0\u00a0\u00a0\u00a0.ack_base = DA9055_REG_EVENT_A,\n\u00a0\u00a0\u00a0\u00a0.num_regs = 3,\n\u00a0\u00a0\u00a0\u00a0.irqs = da9055_irqs,\n\u00a0\u00a0\u00a0\u00a0.num_irqs = ARRAY_SIZE(da9055_irqs),\n};\n```", "```\nstatic int da9055_i2c_probe(struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct i2c_device_id *id)\n{\n\u00a0\u00a0\u00a0\u00a0int ret;\n\u00a0\u00a0\u00a0\u00a0struct da9055_pdata *pdata = dev_get_platdata(da9055->dev);\n\u00a0\u00a0\u00a0\u00a0uint8_t clear_events[3] = {0xFF, 0xFF, 0xFF};\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0ret =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0devm_regmap_add_irq_chip(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&client->dev, da9055->regmap,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055->chip_irq, IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055->irq_base, &da9055_regmap_irq_chip,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&da9055->irq_data);\n\u00a0\u00a0\u00a0\u00a0if (ret < 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ret;\n\u00a0\u00a0\u00a0\u00a0da9055->irq_base = regmap_irq_chip_get_base(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055->irq_data);\n\u00a0\u00a0\u00a0\u00a0ret = devm_mfd_add_devices(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055->dev, -1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9055_devs, ARRAY_SIZE(da9055_devs),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NULL, da9055->irq_base,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regmap_irq_get_domain(da9055->irq_data));\n\u00a0\u00a0\u00a0\u00a0if (ret)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err;\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nmfd_add_devices()-> mfd_add_device()-> platform_device_alloc()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> platform_device_add_data()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> platform_device_add_resources()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> platform_device_add()\n```", "```\nstruct priv_chip {\n\u00a0\u00a0\u00a0\u00a0struct device *dev;\n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap;\n\u00a0\u00a0\u00a0\u00a0/* chip client for the parent chip, let's say the PMIC */\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *client;\n\u00a0\u00a0\u00a0\u00a0/* chip client for subdevice 1, let's say an rtc */\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *subdev1_client;\n\u00a0\u00a0\u00a0\u00a0/* chip client for subdevice 2 let's say a gpio controller \u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *subdev2_client;\n\u00a0\u00a0\u00a0\u00a0struct regmap *subdev1_regmap;\n\u00a0\u00a0\u00a0\u00a0struct regmap *subdev2_regmap;\n\u00a0\u00a0\u00a0\u00a0unsigned short subdev1_addr; /* subdevice 1 I2C address */\n\u00a0\u00a0\u00a0\u00a0unsigned short subdev2_addr; /* subdevice 2 I2C address */\n};\nconst struct regmap_config chip_regmap_config = {\n\u00a0\u00a0\u00a0\u00a0[...]\n};\nconst struct regmap_config subdev_rtc_regmap_config = {\n\u00a0\u00a0\u00a0\u00a0[...]\n};\nconst struct regmap_config subdev_gpiochip_regmap_config = {\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstatic int my_mfd_probe(struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct i2c_device_id *id)\n{\n\u00a0\u00a0\u00a0\u00a0struct priv_chip *chip;\n\u00a0\u00a0\u00a0\u00a0struct regmap *map;\n\u00a0\u00a0\u00a0\u00a0chip = devm_kzalloc(&client->dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sizeof(struct priv_chip), GFP_KERNEL);\n\u00a0\u00a0\u00a0\u00a0map = devm_regmap_init_i2c(client, &chip_regmap_config);\n\u00a0\u00a0\u00a0\u00a0chip->client = client;\n\u00a0\u00a0\u00a0\u00a0chip->regmap = map;\n\u00a0\u00a0\u00a0\u00a0chip->dev = &client->dev;\n\u00a0\u00a0\u00a0\u00a0dev_set_drvdata(chip->dev, chip);\n\u00a0\u00a0\u00a0\u00a0i2c_set_clientdata(chip->client, chip);\n\u00a0\u00a0\u00a0\u00a0chip->subdev1_addr = client->addr + 1;\n\u00a0\u00a0\u00a0\u00a0chip->subdev2_addr = client->addr + 2;\n\u00a0\u00a0\u00a0\u00a0/* subdevice 1, let's say an RTC */\n\u00a0\u00a0\u00a0\u00a0chip->subdev1_client = i2c_new_dummy(client->adapter,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0chip->subdev1_addr);\n\u00a0\u00a0\u00a0\u00a0chip->subdev1_regmap =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0devm_regmap_init_i2c(chip->subdev1_client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&subdev_rtc_regmap_config);\n\u00a0\u00a0\u00a0\u00a0i2c_set_clientdata(chip->subdev1_client, chip);\n\u00a0\u00a0\u00a0\u00a0/* subdevice 2, let's say a gpio controller */\n\u00a0\u00a0\u00a0\u00a0chip->subdev2_client = i2c_new_dummy(client->adapter,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0chip->subdev2_addr);\n\u00a0\u00a0\u00a0\u00a0chip->subdev2_regmap =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0devm_regmap_init_i2c(chip->subdev2_client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&subdev_gpiochip_regmap_config);\n\u00a0\u00a0\u00a0\u00a0i2c_set_clientdata(chip->subdev2_client, chip);\n\u00a0\u00a0\u00a0\u00a0/* mfd_add_devices() is called somewhere */\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nstatic int my_mfd_remove(struct i2c_client *client)\n{\n\u00a0\u00a0\u00a0\u00a0struct priv_chip *chip = i2c_get_clientdata(client);\n\u00a0\u00a0\u00a0\u00a0mfd_remove_devices(chip->dev);\n\u00a0\u00a0\u00a0\u00a0i2c_unregister_device(chip->subdev1_client);\n\u00a0\u00a0\u00a0\u00a0i2c_unregister_device(chip->subdev2_client);\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nstatic int subdev_rtc_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct priv_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\u00a0\u00a0\u00a0\u00a0struct regmap *rtc_regmap = chip->subdev1_regmap;\n\u00a0\u00a0\u00a0\u00a0int ret;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0if (!rtc_regmap) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_err(&pdev->dev, \"no regmap!\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = -EINVAL;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto out;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\n&i2c3 {\n\u00a0\u00a0\u00a0\u00a0pinctrl-names = \"default\";\n\u00a0\u00a0\u00a0\u00a0pinctrl-0 = <&pinctrl_i2c3>;\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <400000>;\n\u00a0\u00a0\u00a0\u00a0status = \"okay\";\n\u00a0\u00a0\u00a0\u00a0pmic0: da9062@58 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"dlg,da9062\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg = <0x58>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pinctrl-names = \"default\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pinctrl-0 = <&pinctrl_pmic>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interrupt-parent = <&gpio6>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interrupts = <11 IRQ_TYPE_LEVEL_LOW>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interrupt-controller;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulators {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DA9062_BUCK1: buck1 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-name = \"BUCK1\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-min-microvolt = <300000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-max-microvolt = <1570000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-min-microamp = <500000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-max-microamp = <2000000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-boot-on;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DA9062_LDO1: ldo1 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-name = \"LDO_1\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-min-microvolt = <900000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-max-microvolt = <3600000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regulator-boot-on;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0da9062_rtc: rtc {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"dlg,da9062-rtc\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0watchdog {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"dlg,da9062-watchdog\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0onkey {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"dlg,da9062-onkey\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dlg,disable-key-power;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0};\n};\n```", "```\nstatic struct resource da9063_onkey_resources[] = {\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"ONKEY\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.start = DA9063_IRQ_ONKEY,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.end = DA9063_IRQ_ONKEY,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.flags = IORESOURCE_IRQ,d\n\u00a0\u00a0\u00a0\u00a0},\n};\nstatic const struct mfd_cell da9062_devs[] = {\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = \"da9062-onkey\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.num_resources = ARRAY_SIZE(da9062_onkey_resources),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.resources = da9062_onkey_resources,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_compatible = \"dlg,da9062-onkey\",\n\u00a0\u00a0\u00a0\u00a0},\n};\n```", "```\nstatic const struct of_device_id da9063_compatible_reg_id_table[] = {\n\u00a0\u00a0\u00a0\u00a0{ .compatible = \"dlg,da9063-onkey\", .data = &da9063_regs },\n\u00a0\u00a0\u00a0\u00a0{ .compatible = \"dlg,da9062-onkey\", .data = &da9062_regs },\n\u00a0\u00a0\u00a0\u00a0{ },\n};\nMODULE_DEVICE_TABLE(of, da9063_compatible_reg_id_table);\n[...]\nstatic struct platform_driver da9063_onkey_driver = {\n\u00a0\u00a0\u00a0\u00a0.probe = da9063_onkey_probe,\n\u00a0\u00a0\u00a0\u00a0.driver = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = DA9063_DRVNAME_ONKEY,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_match_table = da9063_compatible_reg_id_table,\n\u00a0\u00a0\u00a0\u00a0},\n};\n```", "```\nstruct syscon {\n\u00a0\u00a0\u00a0\u00a0struct device_node *np;\n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap;\n\u00a0\u00a0\u00a0\u00a0struct list_head list;\n};\n```", "```\nstatic const struct regmap_config syscon_regmap_config = {\n\u00a0\u00a0\u00a0\u00a0.reg_bits = 32,\n\u00a0\u00a0\u00a0\u00a0.val_bits = 32,\n\u00a0\u00a0\u00a0\u00a0.reg_stride = 4,\n};\n```", "```\nstatic DEFINE_SPINLOCK(syscon_list_slock);\nstatic LIST_HEAD(syscon_list);\nstatic struct syscon *of_syscon_register(struct device_node \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*np)\n{\n\u00a0\u00a0\u00a0\u00a0struct syscon *syscon;\n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap;\n\u00a0\u00a0\u00a0\u00a0void __iomem *base;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0if (!of_device_is_compatible(np, \"syscon\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-EINVAL);\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0spin_lock(&syscon_list_slock);\n\u00a0\u00a0\u00a0\u00a0list_add_tail(&syscon->list, &syscon_list);\n\u00a0\u00a0\u00a0\u00a0spin_unlock(&syscon_list_slock);\n\u00a0\u00a0\u00a0\u00a0return syscon;\n}\n```", "```\ngpr: iomuxc-gpr@20e0000 {\n\u00a0\u00a0\u00a0\u00a0compatible = \"fsl,imx6q-iomuxc-gpr\", \"syscon\";\n\u00a0\u00a0\u00a0\u00a0reg = <0x020e0000 0x38>;\n\u00a0\u00a0\u00a0\u00a0hwlocks = <&hwlock1 1>;\n};\nhwlock1: hwspinlock@40500000 {\n\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0reg = <0x40500000 0x1000>;\n\u00a0\u00a0\u00a0\u00a0#hwlock-cells = <1>;\n};\n```", "```\nstruct regmap * syscon_node_to_regmap (struct device_node *np);\nstruct regmap * syscon_regmap_lookup_by_compatible(const char \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*s);\nstruct regmap * syscon_regmap_lookup_by_pdevname(const char \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*s);\nstruct regmap * syscon_regmap_lookup_by_phandle(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device_node *np,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *property);\n```", "```\ngpr: iomuxc-gpr@20e0000 {\n\u00a0\u00a0\u00a0\u00a0compatible = \"fsl,imx6q-iomuxc-gpr\", \"syscon\";\n\u00a0\u00a0\u00a0\u00a0reg = <0x020e0000 0x38>;\n\u00a0\u00a0\u00a0\u00a0my_pdev: my_pdev {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"company,regmap-sample\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regmap-phandle = <&gpr>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0};\n};\n```", "```\nstatic struct regmap *by_node_regmap;\nstatic struct regmap *by_compat_regmap;\nstatic struct regmap *by_pdevname_regmap;\nstatic struct regmap *by_phandle_regmap;\nstatic int my_pdev_regmap_sample(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct device_node *np = pdev->dev.of_node;\n\u00a0\u00a0\u00a0\u00a0struct device_node *syscon_node;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0syscon_node = of_get_parent(np);\n\u00a0\u00a0\u00a0\u00a0if (!syscon_node)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENODEV;\n\u00a0\u00a0\u00a0\u00a0/* If we have a pointer to the syscon device node,\u00a0\u00a0\u00a0\u00a0we use it */\n\u00a0\u00a0\u00a0\u00a0by_node_regmap = syscon_node_to_regmap(syscon_node);\n\u00a0\u00a0\u00a0\u00a0of_node_put(syscon_node);\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(by_node_regmap)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err(\"%s: could not find regmap by node\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__func__);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return PTR_ERR(by_node_regmap);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0/* or we have one of the compatible string of the syscon \u00a0\u00a0\u00a0\u00a0node */\n\u00a0\u00a0\u00a0\u00a0by_compat_regmap =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0syscon_regmap_lookup_by_compatible(\"fsl,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0imx6q-iomuxc-gpr\");\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(by_compat_regmap)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err(\"%s: could not find regmap by compatible\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__func__);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return PTR_ERR(by_compat_regmap);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0/* Or a phandle property pointing to the syscon device node\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0by_phandle_regmap =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0syscon_regmap_lookup_by_phandle(np, \"fsl,tempmon\");\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(map)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err(\"%s: could not find regmap by phandle\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__func__);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return PTR_ERR(by_phandle_regmap);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* It is the extrem and rare case fallback\n\u00a0\u00a0\u00a0\u00a0\u00a0* As of Linux kernel v4.18, there is only one driver\n\u00a0\u00a0\u00a0\u00a0\u00a0* using this, drivers/tty/serial/clps711x.c\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0char pdev_syscon_name[9];\n\u00a0\u00a0\u00a0\u00a0int index = pdev->id;\n\u00a0\u00a0\u00a0\u00a0sprintf(syscon_name, \"syscon.%i\", index + 1);\n\u00a0\u00a0\u00a0\u00a0by_pdevname_regmap =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0syscon_regmap_lookup_by_pdevname(syscon_name);\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(by_pdevname_regmap)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err(\"%s: could not find regmap by pdevname\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__func__);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return PTR_ERR(by_pdevname_regmap);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nsnvs: snvs@20cc000 {\n\u00a0\u00a0\u00a0\u00a0compatible = \"fsl,sec-v4.0-mon\", \"syscon\", \"simple-mfd\";\n\u00a0\u00a0\u00a0\u00a0reg = <0x020cc000 0x4000>;\n\u00a0\u00a0\u00a0\u00a0snvs_rtc: snvs-rtc-lp {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"fsl,sec-v4.0-mon-rtc-lp\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regmap = <&snvs>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0offset = <0x34>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0snvs_poweroff: snvs-poweroff {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"syscon-poweroff\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regmap = <&snvs>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0offset = <0x38>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value = <0x60>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mask = <0x60>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status = \"disabled\";\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0snvs_pwrkey: snvs-powerkey {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = \"fsl,sec-v4.0-pwrkey\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0regmap = <&snvs>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linux,keycode = <KEY_POWER>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wakeup-source;\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```"]