- en: Platform Device Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台设备驱动程序
- en: We all know about plug and play devices. They are handled by the kernel as soon
    as they are plugged in. These may be USB or PCI express, or any other auto-discovered
    devices. Therefore, other device types also exist, which are not hot-pluggable,
    and which the kernel needs to know about prior to being managed. There are I2C,
    UART, SPI, and other devices not wired to enumeration-capable buses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道即插即用设备。它们在插入时立即由内核处理。这些可能是USB或PCI Express，或任何其他自动发现的设备。因此，还存在其他类型的设备，这些设备不是热插拔的，内核需要在管理之前知道它们。有I2C、UART、SPI和其他未连接到可枚举总线的设备。
- en: 'There are real physical buses you may already know: USB, I2S, I2C, UART, SPI,
    PCI, SATA, and so on. Such buses are hardware devices named controllers. Since
    they are a part of SoC, they can''t be removed, are non-discoverable, and are
    also called platform devices.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道的真实物理总线：USB、I2S、I2C、UART、SPI、PCI、SATA等。这些总线是名为控制器的硬件设备。由于它们是SoC的一部分，因此无法移除，不可发现，也称为平台设备。
- en: People often say platform devices are on-chip devices (embedded in the SoC).
    In practice, it is partially true, since they are hard-wired into the chip and
    can't be removed. But devices connected to I2C or SPI are not on-chip, and are
    platform devices too, because they are not discoverable. Similarly, there may
    be on-chip PCI or USB devices, but they are not platform devices, because they
    are discoverable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常说平台设备是芯片上的设备（嵌入在SoC中）。实际上，这在一定程度上是正确的，因为它们被硬连到芯片中，无法移除。但连接到I2C或SPI的设备不是芯片上的设备，它们也是平台设备，因为它们不可发现。同样，可能存在芯片上的PCI或USB设备，但它们不是平台设备，因为它们是可发现的。
- en: From an SoC point of view, those devices (buses) are connected internally through
    dedicated buses, and are most of the time proprietary and specific to the manufacturer.
    From the kernel point of view, these are root devices, and connected to nothing.
    That is where the *pseudo platform bus* comes in. The pseudo platform bus, also
    called platform bus is a kernel virtual bus for devices that do not seat on a
    physical bus known to the kernel. In this chapter, platform devices refer to devices
    that rely on the pseudo platform bus.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从SoC的角度来看，这些设备（总线）通过专用总线内部连接，并且大多数时间是专有的，特定于制造商。从内核的角度来看，这些是根设备，与任何东西都没有连接。这就是*伪平台总线*的作用。伪平台总线，也称为平台总线，是内核虚拟总线，用于内核不知道的物理总线上的设备。在本章中，平台设备指的是依赖于伪平台总线的设备。
- en: 'Dealing with platform devices essentially requires two steps:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理平台设备基本上需要两个步骤：
- en: Register a platform driver (with a unique name) that will manage your devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个管理您的设备的平台驱动程序（使用唯一名称）
- en: Register your platform device with the same name as the driver, and their resources,
    in order to let the kernel know that your device is there
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与驱动程序相同的名称注册您的平台设备，以及它们的资源，以便让内核知道您的设备在那里
- en: 'That being said, in this chapter, we will discuss the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在本章中，我们将讨论以下内容：
- en: Platform devices along with their driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台设备及其驱动程序
- en: Devices and driver-matching mechanisms in the kernel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核中的设备和驱动程序匹配机制
- en: Registering platform drivers with devices, as well as platform data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册平台驱动程序与设备，以及平台数据
- en: Platform drivers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台驱动程序
- en: 'Before going further, please pay attention to the following warning. Not all
    platform devices are handled by platform drivers (or should I say pseudo platform
    drivers). Platform drivers are dedicated to devices not based on conventional
    buses. I2C devices or SPI devices are platform devices, but respectively rely
    on I2C or SPI buses, not on the platform bus. Everything needs to be done manually
    with the platform driver. The platform driver must implement a `probe` function,
    called by the kernel when the module is inserted or when a device claims it. When
    developing platform drivers, the main structure one has to fill is `struct platform_driver`
    , and registering your driver with the platform bus core with dedicated functions
    shown as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意以下警告。并非所有平台设备都由平台驱动程序处理（或者我应该说伪平台驱动程序）。平台驱动程序专用于不基于常规总线的设备。I2C设备或SPI设备是平台设备，但分别依赖于I2C或SPI总线，而不是平台总线。一切都需要使用平台驱动程序手动完成。平台驱动程序必须实现一个`probe`函数，当模块被插入或设备声明它时，内核会调用该函数。在开发平台驱动程序时，必须填写的主要结构是`struct
    platform_driver`，并使用以下显示的专用函数将驱动程序注册到平台总线核心：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us see what the meaning is of each element that composes the structure,
    and what they are used for:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组成结构的每个元素的含义，以及它们的用途：
- en: '`probe()` : This is the function that gets called when a device claims your
    driver after a match occurs. Later, we will see how `probe` is called by the core.
    Its declaration is as follows:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe()`：这是在设备在匹配后声明您的驱动程序时调用的函数。稍后，我们将看到核心如何调用`probe`。其声明如下：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`remove()` : This is called to get rid of the driver when it is not needed
    anymore by devices, and its declaration looks like this:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`：当设备不再需要时，调用此函数来摆脱驱动程序，其声明如下：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`struct device_driver` : This describes the driver itself, providing a name,
    owner, and some field, which we will see later.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct device_driver`：这描述了驱动程序本身，提供名称、所有者和一些字段，我们稍后会看到。'
- en: 'Registering a platform driver with the kernel is as simple as calling `platform_driver_register()`
    or `platform_driver_probe()` in the `init` function (when the module is loaded).
    The difference between those functions is that:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`platform_driver_register()`或`platform_driver_probe()`在`init`函数中（加载模块时）注册平台驱动程序与内核一样简单。这些函数之间的区别在于：
- en: '`platform_driver_register()` registers and puts the driver into a list of drivers
    maintained by the kernel, so that its `probe()` function can be called on demand
    whenever a new match occurs. To prevent your driver from being inserted and registered
    in that list, just use the `next` function.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform_driver_register()`将驱动程序注册并放入内核维护的驱动程序列表中，以便在发生新的匹配时可以按需调用其`probe()`函数。为了防止您的驱动程序被插入和注册到该列表中，只需使用`next`函数。'
- en: 'With `platform_driver_probe()` , the kernel immediately runs the match loop,
    checks if there is a platform device with the matching name, and then calls the
    driver''s `probe()` if a match occurred, meaning that the device is present. If
    not, the driver is ignored. This method prevents the deferred probe, since it
    does not register the driver on the system. Here, the `probe` function is placed
    in an `__init` section, which is freed when the kernel boot has completed, thus
    preventing the deferred probe and reducing the driver''s memory footprint. Use
    this method if you are 100% sure the device is present in the system:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`platform_driver_probe()`，内核立即运行匹配循环，检查是否有与匹配名称相匹配的平台设备，然后调用驱动程序的`probe()`，如果发生匹配，表示设备存在。如果没有，驱动程序将被忽略。这种方法可以防止延迟探测，因为它不会在系统上注册驱动程序。在这里，`probe`函数放置在`__init`部分中，在内核引导完成后释放，从而防止延迟探测并减少驱动程序的内存占用。如果您100%确定设备存在于系统中，请使用此方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is a simple platform driver that registers itself with the kernel:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的平台驱动程序，它在内核中注册自己：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our module does nothing else in the `init` /`exit` function but register/unregister
    with the platform bus core. This is the case with most drivers. In this case,
    we can get rid of `module_init` and `module_exit` , and use the `module_platform_driver`
    macro.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块在`init`/`exit`函数中除了在平台总线核心中注册/注销之外什么也不做。大多数驱动程序都是这样。在这种情况下，我们可以摆脱`module_init`和`module_exit`，并使用`module_platform_driver`宏。
- en: 'The `module_platform_driver` macro looks like as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`module_platform_driver`宏如下所示：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This macro will be responsible for registering our module with the platform
    driver core. No need for `module_init` and `module_exit` macros, nor `init` and
    `exit` function anymore. It does not mean that those functions are not called
    anymore, just that we can forgot writing them by ourselves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将负责在平台驱动核心中注册我们的模块。不再需要`module_init`和`module_exit`宏，也不再需要`init`和`exit`函数。这并不意味着这些函数不再被调用，只是我们可以忘记自己编写它们。
- en: The `probe` function is not a substitute to `init` function. The `probe` function
    is called every time when a given device matches with the driver, whereas the
    `init` function runs only once, when the module gets loaded.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`函数不能替代`init`函数。每当给定设备与驱动程序匹配时，都会调用`probe`函数，而`init`函数只在模块加载时运行一次。'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are specific macros for each bus that one needs to register the driver
    with. The following list is not exhaustive:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个总线都有特定的宏，用于注册驱动程序。以下列表不是详尽无遗的：
- en: '`module_platform_driver(struct platform_driver)` for platform drivers, dedicated
    to devices that do not sit on conventional physical buses (we just used it above)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_platform_driver(struct platform_driver)` 用于平台驱动程序，专用于不位于传统物理总线上的设备（我们刚刚在上面使用了它）'
- en: '`module_spi_driver(struct spi_driver)` for SPI drivers'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_spi_driver(struct spi_driver)` 用于SPI驱动程序'
- en: '`module_i2c_driver(struct i2c_driver)` for I2C drivers'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_i2c_driver(struct i2c_driver)` 用于I2C驱动程序'
- en: '`module_pci_driver(struct pci_driver)` for PCI drivers'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_pci_driver(struct pci_driver)` 用于PCI驱动程序'
- en: '`module_usb_driver(struct usb_driver)` for USB drivers'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_usb_driver(struct usb_driver)` 用于USB驱动程序'
- en: '`module_mdio_driver(struct mdio_driver)` for mdio'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module_mdio_driver(struct mdio_driver)` 用于mdio'
- en: '[...]'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[...]'
- en: If you don't know which bus your driver needs to sit on, then it is a platform
    driver, and you should use `platform_driver_register` or `platform_driver_probe`
    to register the driver.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道驱动程序需要位于哪个总线上，那么它是一个平台驱动程序，您应该使用`platform_driver_register`或`platform_driver_probe`来注册驱动程序。
- en: Platform devices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台设备
- en: 'Actually, we should have said pseudo platform device, since this section concerns
    devices that sit on pseudo platform buses. When you are done with the driver,
    you will have to feed the kernel with devices needing that driver. A platform
    device is represented in the kernel as an instance of `struct platform_device`
    , and looks as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该说伪平台设备，因为这一部分涉及的是位于伪平台总线上的设备。当您完成驱动程序后，您将不得不向内核提供需要该驱动程序的设备。平台设备在内核中表示为`struct
    platform_device`的实例，并且如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When it comes to the platform driver, before driver and device match, the `name`
    field of both `struct platform_device` and `static struct platform_driver.driver.name`
    must be the same. The `num_resources` and `struct resource *resource` field will
    be covered in the next section. Just remember that, since `resource` is an array,
    `num_resources` must contain the size of that array.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及平台驱动程序之前，驱动程序和设备匹配之前，`struct platform_device`和`static struct platform_driver.driver.name`的`name`字段必须相同。`num_resources`和`struct
    resource *resource`字段将在下一节中介绍。只需记住，由于`resource`是一个数组，因此`num_resources`必须包含该数组的大小。
- en: Resources and platform data
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和平台数据
- en: 'At the opposite end to hot-pluggable devices, the kernel has no idea of what
    devices are present on your system, what they are capable of, or what they need
    in order to work properly. There is no auto-negotiation process, so any information
    provided to the kernel would be welcome. There are two methods to inform the kernel
    about the resources (irq, dma, memory region, I/O ports, buses) and data (any
    custom and private data structure you may want to pass to the driver) that the
    device needs which are discussed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与可热插拔设备相反，内核不知道系统上存在哪些设备，它们的功能是什么，或者为了正常工作需要什么。没有自动协商过程，因此内核提供的任何信息都是受欢迎的。有两种方法可以通知内核设备需要的资源（中断请求，直接内存访问，内存区域，I/O端口，总线）和数据（任何自定义和私有数据结构，您可能希望传递给驱动程序），如下所述：
- en: Device provisioning - the old and depreciated way
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备供应 - 旧的和不推荐的方式
- en: This method is to be used with the kernel version that does not support device
    tree. With this method, drivers remain generic, and devices are registered in
    board-related source files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于不支持设备树的内核版本。使用此方法，驱动程序保持通用，设备在与板相关的源文件中注册。
- en: Resources
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Resources represent all the elements that characterize the device from the
    hardware point of view, and which the device needs, in order to be set up and
    work properly. There are only six types of resources in the kernel, all listed
    in `include/linux/ioport.h` , and used as flags to describe the resource''s type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 资源代表了从硬件角度来看设备的所有特征元素，以及设备需要的元素，以便进行设置和正常工作。内核中只有六种资源类型，全部列在`include/linux/ioport.h`中，并用作标志来描述资源的类型：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A resource is represented in the kernel as an instance of `struct resource`
    :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 资源在内核中表示为`struct resource`的实例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let us explain the meaning of each element in the structure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释结构中每个元素的含义：
- en: '`start/end` : This represents where the resource begins/ends. For I/O or memory
    regions, it represents where they begin/end. For IRQ lines, buses or DMA channels,
    start/end must have the same value.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start/end`：这表示资源的开始/结束位置。对于I/O或内存区域，它表示它们的开始/结束位置。对于IRQ线、总线或DMA通道，开始/结束必须具有相同的值。'
- en: '`flags` : This is a mask that characterizes the type of resource, for example
    `IORESOURCE_BUS` .'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：这是一个掩码，用于描述资源的类型，例如`IORESOURCE_BUS`。'
- en: '`name` : This identifies or describes the resource.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这标识或描述资源。'
- en: 'Once one has provided the resources, one needs to extract them back in the
    driver in order to work with them. The `probe` function is a good place to extract
    them. Before one goes further, let''s remember the declaration of the `probe`
    function for a platform device driver:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了资源，就需要在驱动程序中提取它们以便使用。`probe`函数是提取它们的好地方。在继续之前，让我们记住平台设备驱动程序的`probe`函数的声明：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`pdev` is automatically filled by the kernel, with the data and resource we
    registered earlier. Let''s see how to pick them.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdev`由内核自动填充，其中包含我们之前注册的数据和资源。让我们看看如何选择它们。'
- en: 'The `struct resource` embedded in `struct platform_device` can be retrieved
    with the `platform_get_resource()` function. The following is the prototype of
    `platform_get_resource` :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在`struct platform_device`中的`struct resource`可以使用`platform_get_resource()`函数检索。以下是`platform_get_resource`的原型：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first parameter is an instance of the platform device itself. The second
    parameter tells what kind of resource we need. For memory, it should be `IORESOURCE_MEM`
    . Again, please have a look at `include/linux/ioport.h` for more details. `num`
    parameter is an index that says which resource type is desired. Zero indicates
    the first one, and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是平台设备本身的实例。第二个参数告诉我们需要什么类型的资源。对于内存，它应该是`IORESOURCE_MEM`。再次，请查看`include/linux/ioport.h`以获取更多详细信息。`num`参数是一个索引，表示所需的资源类型。零表示第一个，依此类推。
- en: 'If the resource is an IRQ, we must use `int platform_get_irq(struct platform_device
    * pdev, unsigned intnum)` , where `pdev` is the platform device, and `num` is
    the IRQ index within the resource (in case there is more than one). The whole
    `probe` function which we can use to extract the platform data which we registered
    for our device can look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源是IRQ，我们必须使用`int platform_get_irq(struct platform_device * pdev, unsigned
    intnum)`，其中`pdev`是平台设备，`num`是资源中的IRQ索引（如果有多个）。我们可以使用以下整个`probe`函数来提取我们为设备注册的平台数据：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Platform data
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台数据
- en: 'Any other data whose type is not a part of the resource types enumerated in
    the preceding section fall here (for example, GPIO ). Whatever their type is,
    the `struct platform_device` contains a `struct device` field, which in turn contains
    a `struct platform_data` field. Usually, one should embed that data in a structure
    and pass it to the `platform_device.device.platform_data` field. Let''s say, for
    example, that you declare a platform device that needs two gpios number as platform
    data, one irq number, and two memory regions as resource. The following example
    shows how to register platform data along with the device. Here, we use `platform_device_register(struct
    platform_device *pdev)` function, which one uses to register a platform device
    with the platform core:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他数据，其类型不属于前一节中列举的资源类型（例如GPIO），都属于这里。无论它们的类型是什么，`struct platform_device`包含一个`struct
    device`字段，该字段又包含一个`struct platform_data`字段。通常，应该将这些数据嵌入到一个结构中，并将其传递给`platform_device.device.platform_data`字段。例如，假设您声明了一个平台设备，该设备需要两个GPIO号作为平台数据，一个中断号和两个内存区域作为资源。以下示例显示了如何注册平台数据以及设备。在这里，我们使用`platform_device_register(struct
    platform_device *pdev)`函数，该函数用于向平台核心注册平台设备：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, we have used `IORESOURCE_IRQ` and `IORESOURCE_MEM`
    in order to inform the kernel about what kind of resource we provided. To see
    all other flag types, have a look at `include/linux/ioport.h` in the kernel tree.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`IORESOURCE_IRQ`和`IORESOURCE_MEM`来告知内核我们提供了什么类型的资源。要查看所有其他标志类型，请查看内核树中的`include/linux/ioport.h`。
- en: 'In order to retrieve the platform data we registered earlier, we could have
    just used `pdev->dev.platform_data` (remember the `struct platform_device` structure),
    but it is recommended to use the kernel-provided function (which does the same
    thing, admittedly):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索我们之前注册的平台数据，我们可以直接使用`pdev->dev.platform_data`（记住`struct platform_device`结构），但建议使用内核提供的函数（尽管它做的是同样的事情）：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Where to declare platform devices?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在哪里声明平台设备？
- en: 'Devices are registered along with their resources and data. In this old and
    depreciated method, they are declared a separate module, or in the board `init`
    file in the `arch/<arch>/mach-xxx/yyyy.c` , which is `arch/arm/mach-imx/mach-imx6q.c`
    in our case, since we use a UDOO quad based on an i.MX6Q from NXP. The function
    `platform_device_register()` lets you do that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设备与其资源和数据一起注册。在这种旧的和不推荐的方法中，它们被声明为一个单独的模块，或者在`arch/<arch>/mach-xxx/yyyy.c`中的板`init`文件中声明，这在我们的情况下是`arch/arm/mach-imx/mach-imx6q.c`，因为我们使用的是基于NXP
    i.MX6Q的UDOO quad。函数`platform_device_register()`让您可以这样做：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The name of the device is very important, and is used by the kernel to match
    the driver with the same name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的名称非常重要，内核使用它来将驱动程序与相同名称的设备进行匹配。
- en: Device provisioning - the new and recommended way
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备配置-新的推荐方式
- en: 'In the first method, any modification will necessitate rebuilding the whole
    kernel. If the kernel had to include any application/board-specific configurations,
    its size would incredibly increase. In order to keep things simple, and separate
    devices declarations (since they are not really part of the kernel) from the kernel
    source, a new concept has been introduced: *the device tree* . The main goal of
    DTS is to remove very specific and never-tested code from kernel. With the device
    tree, platform data and resources are homogenous. The device tree is a hardware
    description file and has a format similar to a tree structure, where every device
    is represented with a node, and any data or resource or configuration data is
    represented as the node''s property. This way, you only need to recompile the
    device tree when you make some modifications. The device tree forms the subject
    of the next chapter, and we will see how to introduce it to the platform device.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，任何修改都将需要重新构建整个内核。如果内核必须包含任何应用程序/板特定的配置，其大小将会大幅增加。为了保持简单，并将设备声明（因为它们实际上并不是内核的一部分）与内核源代码分开，引入了一个新概念：*设备树*。DTS的主要目标是从内核中删除非常特定且从未经过测试的代码。使用设备树，平台数据和资源是同质的。设备树是硬件描述文件，其格式类似于树结构，其中每个设备都表示为一个节点，并且任何数据、资源或配置数据都表示为节点的属性。这样，您只需要在进行一些修改时重新编译设备树。设备树将成为下一章的主题，我们将看到如何将其引入到平台设备中。
- en: Devices, drivers, and bus matching
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备、驱动程序和总线匹配
- en: Before any match can occur, Linux calls the `platform_match(struct device *dev,
    struct device_driver *drv)` . Platform devices are matched with their drivers
    by means of strings. According to the Linux device model, the bus element is the
    most important part. Each bus maintains a list of drivers and devices that are
    registered with it. The bus driver is responsible for devices and drivers matching.
    Any time one connects a new device or adds a new driver to a bus, that bus starts
    the matching loop.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何匹配发生之前，Linux都会调用`platform_match(struct device *dev, struct device_driver
    *drv)`。平台设备通过字符串与其驱动程序匹配。根据Linux设备模型，总线元素是最重要的部分。每个总线都维护着与其注册的驱动程序和设备的列表。总线驱动程序负责设备和驱动程序的匹配。每当连接新设备或向总线添加新驱动程序时，该总线都会启动匹配循环。
- en: Now, suppose that you register a new I2C device using functions provided by
    the I2C core (discussed in next chapter). The kernel will trigger the I2C bus
    matching loop, by calling the I2C core match function registered with the I2C
    bus driver, to check if there is already a registered driver that matches with
    your device. If there is no match, nothing will happen. If a match occurs, the
    kernel will notify (by means of a communication mechanism called netlink socket)
    the device manager (udev/mdev), which will load (if not loaded yet) the driver
    your device matched with. Once the driver loads, its `probe()` function will immediately
    be executed. Not only does I2C work like that, but every bus has its own matching
    mechanism that is roughly the same. A bus matching loop is triggered at each device
    or driver registration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您使用I2C核心提供的函数（在下一章中讨论）注册了一个新的I2C设备。内核将通过调用与I2C总线驱动程序注册的I2C核心匹配函数来触发I2C总线匹配循环，以检查是否已经有与您的设备匹配的注册驱动程序。如果没有匹配项，将不会发生任何事情。如果发生匹配，内核将通过一种称为netlink套接字的通信机制通知设备管理器（udev/mdev），后者将加载（如果尚未加载）与您的设备匹配的驱动程序。一旦驱动程序加载，其`probe()`函数将立即执行。不仅I2C工作方式如此，而且每个总线都有自己的匹配机制，大致相同。在每个设备或驱动程序注册时都会触发总线匹配循环。
- en: 'We can sum up what we have said in the preceding section in the following figure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结前面部分所说的内容如下图所示：
- en: '![](img/Image00010.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00010.jpg)'
- en: 'Every registered drivers and devices sit on a bus. This makes a tree. USB buses
    may be children of PCI buses, whereas MDIO buses are generally children of other
    devices, and so on. Thus, our preceding figure changes as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个注册的驱动程序和设备都位于总线上。这构成了一棵树。USB总线可能是PCI总线的子级，而MDIO总线通常是其他设备的子级，依此类推。因此，我们前面的图将如下所示：
- en: '![](img/Image00011.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00011.jpg)'
- en: When you register a driver with the `platform_driver_probe()` function, the
    kernel walks through the table of registered platform devices and looks for a
    match. If any, it calls the matched driver's `probe` function with the platform
    data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`platform_driver_probe()`函数注册驱动程序时，内核会遍历已注册的平台设备表，并寻找匹配项。如果有匹配项，它将使用平台数据调用匹配驱动程序的`probe`函数。
- en: How can platform devices and platform drivers match?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台设备和平台驱动程序如何匹配？
- en: 'So far, we have only discussed how to fill different structures of both devices
    and drivers.But now we will see how they are registered with the kernel, and how
    Linux knows which devices are handled by which driver. The answer is `MODULE_DEVICE_TABLE`
    . This macro lets a driver expose its ID table, which describes which devices
    it can support. In the meantime, if the driver can be compiled as a module, the
    `driver.name` field should match the module name. If it does not match, the module
    won''t be automatically loaded, unless we have used the `MODULE_ALIAS` macro to
    add another name for the module. At compilation time, that information is extracted
    from all the drivers in order to build a device table. When the kernel has to
    find the driver for a device (when a matching needs to be performed), the device
    table is walked through by the kernel. If an entry is found matching the `compatible`
    (for device tree), `device/vendor id` or `name` (for device ID table or name)
    of the added device, then the module providing that match is loaded (running the
    module''s `init` function), and the `probe` function is called. The `MODULE_DEVICE_TABLE`
    macro is defined in `linux/module.h` :'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了如何填充设备和驱动程序的不同结构。但现在我们将看到它们如何在内核中注册，以及Linux如何知道哪些设备由哪个驱动程序处理。答案是`MODULE_DEVICE_TABLE`。这个宏让驱动程序暴露其ID表，描述了它可以支持哪些设备。同时，如果驱动程序可以编译为模块，`driver.name`字段应该与模块名称匹配。如果不匹配，模块将不会自动加载，除非我们使用`MODULE_ALIAS`宏为模块添加另一个名称。在编译时，该信息从所有驱动程序中提取出来，以构建设备表。当内核需要为设备找到驱动程序（需要执行匹配时），内核会遍历设备表。如果找到与添加的设备的`compatible`（对于设备树）、`device/vendor
    id`或`name`（对于设备ID表或名称）匹配的条目，那么提供该匹配的模块将被加载（运行模块的`init`函数），并调用`probe`函数。`MODULE_DEVICE_TABLE`宏在`linux/module.h`中定义：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the description of each parameter given to this macro:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是给这个宏的每个参数的描述：
- en: '`type` : This can be either `i2c` , `spi` , `acpi` , `of` , `platform` , `usb`
    , `pci` or any other bus which you may find in `include/linux/mod_devicetable.h`
    . It depends on the bus our device sits on, or on the matching mechanism we want
    to use.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这可以是`i2c`、`spi`、`acpi`、`of`、`platform`、`usb`、`pci`或您可能在`include/linux/mod_devicetable.h`中找到的任何其他总线。它取决于我们的设备所在的总线，或者我们想要使用的匹配机制。'
- en: '`name` : This is a pointer on a `XXX_device_id` array, used for device matching.
    If we were talking about I2C devices, the structure would be `i2c_device_id` .
    For SPI device, it should be `spi_device_id` , and so on. For the device tree
    **Open Firmware** ( **OF** ) matching mechanism, we must use `of_device_id` .'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是一个指向`XXX_device_id`数组的指针，用于设备匹配。如果我们谈论的是I2C设备，结构将是`i2c_device_id`。对于SPI设备，应该是`spi_device_id`，依此类推。对于设备树**Open
    Firmware**（**OF**）匹配机制，我们必须使用`of_device_id`。'
- en: For new non-discoverable platform device drivers, it is recommended not to use
    platform data anymore, but to use device tree capabilities instead, with OF matching
    mechanism. Please do note that the two methods are not mutually exclusive, thus
    one can mix these together.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新的非可发现平台设备驱动程序，建议不再使用平台数据，而是改用设备树功能，使用OF匹配机制。请注意，这两种方法并不是互斥的，因此可以混合使用。
- en: Let's get deeper into the details for matching mechanisms, except for the OF
    style match which we will discuss in [Chapter 6](text00162.html) , *The Concept
    of Device Tree* .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解匹配机制的细节，除了我们将在[第6章](text00162.html)中讨论的OF风格匹配之外，*设备树的概念*。
- en: Kernel devices and drivers-matching function
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核设备和驱动程序匹配函数
- en: 'The function responsible for platform devices and driver-matching functions
    in kernel is defined in `/drivers/base/platform.c` as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中负责平台设备和驱动程序匹配功能的函数在`/drivers/base/platform.c`中定义如下：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can enumerate four matching mechanisms. They are all based on the string
    compare. If we have a look at `platform_match_id` , we''ll understand how things
    work underneath:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以列举四种匹配机制。它们都基于字符串比较。如果我们看一下`platform_match_id`，我们就会了解底层的工作原理：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let's have a look at the `struct device_driver` structure we discussed in
    [Chapter 4](text00121.html) , *Character Device Drivers:*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们在[第4章](text00121.html)中讨论的`struct device_driver`结构：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I intentionally removed fields that we are not interested in. `struct device_driver`
    forms the basis of every device driver. Whether it is an I2C, SPI, TTY, or other
    device driver, they all embed a `struct device_driver` element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意删除了我们不感兴趣的字段。`struct device_driver`构成了每个设备驱动程序的基础。无论是I2C、SPI、TTY还是其他设备驱动程序，它们都嵌入了一个`struct
    device_driver`元素。
- en: OF style and ACPI match
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OF风格和ACPI匹配
- en: OF style is explained in [Chapter 6](text00162.html) , *The Concept of Device
    Tree* . The second mechanism is an ACPI table-based matching. We'll not discuss
    it at all in this book, but for your information, it uses struct `acpi_device_id`
    .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: OF风格在[第6章](text00162.html)中有解释，*设备树的概念*。第二种机制是基于ACPI表的匹配。我们在本书中不会讨论它，但供您参考，它使用`acpi_device_id`结构。
- en: ID table matching
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ID表匹配
- en: 'This match style has been for a long time, and is based on the `struct device_id`
    structure. All device id structures are defined in `include/linux/mod_devicetable.h`
    . To find the right structure name, you need to prefix `device_id` with the bus
    name whom your device driver seats on. Examples are: `struct i2c_device_id` for
    I2C, `struct platform_device_id` for platform devices (that don''t sit on a real
    physical bus), `spi_device_id` for SPI devices, `usb_device_id` for USB, and so
    on. The typical structure of a `device_id table` for a platform device is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种匹配风格已经存在很长时间，它基于`struct device_id`结构。所有设备id结构都在`include/linux/mod_devicetable.h`中定义。要找到正确的结构名称，您需要使用总线名称作为前缀，即您的设备驱动程序所在的总线名称。例如：`struct
    i2c_device_id`用于I2C，`struct platform_device_id`用于平台设备（不在真实物理总线上），`spi_device_id`用于SPI设备，`usb_device_id`用于USB等。平台设备的`device_id表`的典型结构如下：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Anyway, if an ID table is registered, it will be walked through whenever the
    kernel has run the match function to find a driver for an unknown or new platform
    device. If there is a match, the `probe` function of the matched driver will be
    invoked, and given as a parameter a `struct platform_device` , which will hold
    a pointer to the matching ID table entry that originated the match. The `.driver_data`
    element is an `unsigned long` , which is sometimes casted into pointer addresses
    in order to point to anything, just like in the serial-imx driver. The following
    is an example with `platform_device_id` in `drivers/tty/serial/imx.c` :'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果注册了ID表，每当内核运行匹配函数以查找未知或新的平台设备的驱动程序时，都会遍历它。如果匹配成功，将调用匹配驱动程序的 `probe` 函数，并将匹配的ID表条目的指针作为参数传递给
    `struct platform_device` ，该指针将指向发起匹配的匹配ID表条目。`.driver_data` 元素是一个 `unsigned long`
    ，有时会被强制转换为指针地址，以便指向任何东西，就像在 serial-imx 驱动程序中一样。以下是 `drivers/tty/serial/imx.c`
    中使用 `platform_device_id` 的示例：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `.name` field must be the same as the device''s name you give when you
    register the device in the board specific file. The function responsible for this
    match style is `platform_match_id` . If you look at its definition in `drivers/base/platform.c`
    , you''ll see:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`.name` 字段必须与在特定于板的文件中注册设备时给出的设备名称相同。负责此匹配样式的函数是 `platform_match_id` 。如果查看
    `drivers/base/platform.c` 中的定义，你会看到：'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following example, which is an excerpt from `drivers/tty/serial/imx.c`
    in kernel sources, one can see how the platform data is converted back into the
    original data structure, just by casting. That is how people sometimes pass any
    data structure as platform data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，这是内核源代码中 `drivers/tty/serial/imx.c` 的摘录，可以看到平台数据是如何通过强制转换转换回原始数据结构的。这就是人们有时将任何数据结构作为平台数据传递的方式：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`pdev->id_entry` is a `struct platform_device_id` , which is a pointer to the
    matching ID table entry made available by the kernel, and whose `driver_data`
    element is casted back to a pointer on the data structure.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdev->id_entry` 是一个 `struct platform_device_id` ，它是一个指向内核提供的匹配ID表条目的指针，其 `driver_data`
    元素被强制转换回数据结构的指针。'
- en: '**Per device-specific data on ID table matching**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**ID表匹配的每个特定设备数据**'
- en: 'In the previous section, we have used `platform_device_id.platform_data` as
    a pointer. Your driver may need to support more than one device type. In this
    situation, you will need specific device data for each device type you support.
    You should then use the device id as an index to an array that contains every
    possible device data, and not as a pointer address anymore. The following are
    detailed steps in an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经将 `platform_device_id.platform_data` 用作指针。你的驱动程序可能需要支持多种设备类型。在这种情况下，你将需要为你支持的每种设备类型使用特定的设备数据。然后，你应该将设备ID用作包含每种可能的设备数据的数组的索引，而不再是指针地址。以下是示例中的详细步骤：
- en: 'We define an enumeration, depending on the device type that we need to support
    in our driver:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据驱动程序需要支持的设备类型定义一个枚举：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We define the specific data-type structure:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义特定的数据类型结构：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We fill an array with default values, and depending on the index in `device_id`
    , we can pick the right data:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用默认值填充数组，并根据 `device_id` 中的索引，我们可以选择正确的数据：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We define our `platform_device_id` with a specific index:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用特定索引定义我们的 `platform_device_id`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we just have to do the stuff in the `probe` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `probe` 函数中我们只需要做一些事情：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Name matching - platform device name matching
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称匹配 - 平台设备名称匹配
- en: 'Now-a-days most platform drivers do not provide any table at all; they simply
    fill the name of the driver itself in the driver''s name field. But the matching
    works because, if you look at the `platform_match` function, you will see that
    at the end the match falls back to name matching, comparing the driver''s name
    and the device''s name. Some older drivers still use that matching mechanism.
    The following is name matching from `sound/soc/fsl/imx-ssi.c` :'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数平台驱动程序根本不提供任何表；它们只是在驱动程序的名称字段中填写驱动程序本身的名称。但匹配仍然有效，因为如果查看 `platform_match`
    函数，你会发现最终匹配会回退到名称匹配，比较驱动程序的名称和设备的名称。一些旧的驱动程序仍然使用该匹配机制。以下是 `sound/soc/fsl/imx-ssi.c`
    中的名称匹配：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To add a device that matches this driver, one must call `platform_device_register`
    or `platform_add_devices` , with the same name `imx-ssi` , in the board-specific
    file (usually in `arch/<your_arch>/mach-*/board-*.c` ). For our quad core i.MX6-based
    UDOO, it is `arch/arm/mach-imx/mach-imx6q.c` .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加与此驱动程序匹配的设备，必须在特定于板的文件中（通常在 `arch/<your_arch>/mach-*/board-*.c` 中）调用 `platform_device_register`
    或 `platform_add_devices` ，并使用相同的名称 `imx-ssi` 。对于我们的四核 i.MX6-based UDOO，它是 `arch/arm/mach-imx/mach-imx6q.c`
    。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The kernel pseudo platform bus has no secrets for you anymore. With bus matching
    mechanisms, you are able to understand how, when, and why your driver has been
    loaded, as well as which device it was for.We can implement any `probe` function,
    based on the matching mechanism we want. Since the main purpose of a driver is
    to handle a device, we are now able to populate devices in the system (the old
    and depreciated way). To finish in beauty, the next chapter will exclusively deal
    with the device tree, which is the new mechanism used to populate devices, along
    with their configurations, on the system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 内核伪平台总线对你来说已经没有秘密了。通过总线匹配机制，你能够理解你的驱动程序何时、如何以及为什么被加载，以及它是为哪个设备加载的。我们可以根据我们想要的匹配机制实现任何
    `probe` 函数。由于驱动程序的主要目的是处理设备，我们现在能够在系统中填充设备（旧的和不推荐的方式）。最后，下一章将专门讨论设备树，这是用于在系统上填充设备及其配置的新机制。
