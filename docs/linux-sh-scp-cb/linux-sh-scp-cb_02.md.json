["```\n$ cat file1 file2 file3 ...\n```", "```\n$ cat file.txt\nThis is a line inside file.txt\nThis is the second line inside file.txt\n\n```", "```\n$ echo 'Text through stdin' | cat \u2013 file.txt\n\n```", "```\n$ cat -s file\n\n```", "```\n$ cat multi_blanks.txt\nline 1\n\nline2\n\nline3\n\nline4\n\n$ cat -s multi_blanks.txt # Squeeze adjacent blank lines\nline 1\n\nline2\n\nline3\n\nline4\n\n```", "```\n$ cat multi_blanks.txt | tr -s '\\n'\nline 1\nline2\nline3\nline4\n\n```", "```\n$ cat file.py\ndef function():\n var = 5\n next = 6\n third = 7\n\n$ cat -T file.py\ndef function():\n^Ivar = 5\n next = 6\n^Ithird = 7^I\n\n```", "```\n$ cat lines.txt\nline \nline\nline\n\n$ cat -n lines.txt\n 1\tline\n 2\tline\n 3\tline\n\n```", "```\n$ script -t 2> timing.log -a output.session\ntype commands;\n\u2026\n..\nexit\n\n```", "```\n$ scriptreplay timing.log output.session\n# Plays the sequence of commands and output\n\n```", "```\n    $ mkfifo scriptfifo\n\n    ```", "```\n    $ cat scriptfifo\n\n    ```", "```\n    $ script -f scriptfifo\n    $ commands;\n\n    ```", "```\ncat scriptfifo\n\n```", "```\n$ find base_path\n```", "```\n$ find . -print\n# Print lists of files and folders\n\n```", "```\n$ find /home/slynux -name \"*.txt\" \u2013print\n\n```", "```\n$ ls\nexample.txt  EXAMPLE.txt  file.txt\n$ find . -iname \"example*\" -print\n./example.txt\n./EXAMPLE.txt\n\n```", "```\n$ ls\nnew.txt  some.jpg  text.pdf\n$ find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\) -print\n./text.pdf\n./new.txt\n\n```", "```\n$ find /home/users -path \"*slynux*\" -print\nThis will match files as following paths.\n/home/users/list/slynux.txt\n/home/users/slynux/eg.css\n\n```", "```\n$ ls\nnew.PY  next.jpg  test.py\n$ find . -regex \".*\\(\\.py\\|\\.sh\\)$\"\n./test.py\n\n```", "```\n$ find . -iregex \".*\\(\\.py\\|\\.sh\\)$\"\n./test.py\n./new.PY\n\n```", "```\n$ find . ! -name \"*.txt\" -print\n\n```", "```\n$ ls\nlist.txt  new.PY  new.txt  next.jpg  test.py\n\n$ find . ! -name \"*.txt\" -print\n.\n./next.jpg\n./test.py\n./new.PY\n\n```", "```\n$ find . -maxdepth 1 -type f -print\n\n```", "```\n$ find . -mindepth 2 -type f -print\n./dir1/dir2/file1\n./dir3/dir4/f2\n\n```", "```\n$ find . -type d -print\n\n```", "```\n$ find . -type f -print\n\n```", "```\n$ find . -type l -print\n\n```", "```\n    $ find . -type f -atime -7 -print\n\n    ```", "```\n    $ find . -type f -atime 7 -print\n\n    ```", "```\n    $ find . -type f -atime +7 -print\n\n    ```", "```\n$ find . -type f -amin +7 -print\n\n```", "```\n$ find . -type f -newer file.txt -print\n\n```", "```\n$ find . -type f -size +2k\n# Files having size greater than 2 kilobytes\n\n$ find . -type f -size -2k\n# Files having size less than 2 kilobytes\n\n$ find . -type f -size 2k\n# Files having size 2 kilobytes\n\n```", "```\n$ find . -type f -name \"*.swp\" -delete\n\n```", "```\n$ find . -type f -perm 644 -print\n# Print files having permission 644\n\n```", "```\n$ find . \u2013type f \u2013name \"*.php\" ! -perm 644 \u2013print\n\n```", "```\n$ find . -type f -user slynux -print\n\n```", "```\n# find . -type f \u2013user root \u2013exec chown slynux {} \\;\n\n```", "```\nchown slynux {}\n\n```", "```\n$ find . -type f -name \"*.c\" -exec cat {} \\;>all_c_files.txt\n\n```", "```\n$ find . -type f -mtime +10 -name \"*.txt\" -exec cp {} OLD  \\;\n\n```", "```\n$ find . -type f -name \"*.txt\" -exec printf \"Text file: %s\\n\" {} \\;\n\n```", "```\n$ find devel/source_path  \\( -name \".git\" -prune \\) -o \\( -type f -print \\)\n\n# Instead of \\( -type -print \\), use required filter.\n\n```", "```\ncat foo.txt | grep \"test\"\n\n```", "```\ncommand | xargs\n\n```", "```\n    $ cat example.txt # Example file\n    1 2 3 4 5 6 \n    7 8 9 10 \n    11 12\n\n    $ cat example.txt | xargs\n    1 2 3 4 5 6 7 8 9 10 11 12\n\n    ```", "```\n    $ cat example.txt | xargs -n 3\n    1 2 3 \n    4 5 6 \n    7 8 9 \n    10 11 12\n\n    ```", "```\n$ echo \"splitXsplitXsplitXsplit\" | xargs -d X\nsplit split split split\n\n```", "```\n$ echo \"splitXsplitXsplitXsplit\" | xargs -d X -n 2\nsplit split\nsplit split\n\n```", "```\n#!/bin/bash\n#Filename: cecho.sh\n\necho $*'#' \n```", "```\n$ ./cecho.sh arg1 arg2\narg1 arg2 #\n\n```", "```\n    ./cecho.sh arg1\n    ./cecho.sh arg2\n    ./cecho.sh arg3\n    ```", "```\n    ./cecho.sh arg1 arg2\n    ./cecho.sh arg3\n    ```", "```\n    ./cecho.sh arg1 arg2 arg3\n    ```", "```\n$ cat args.txt\narg1\narg2\narg3\n\n```", "```\n$ cat args.txt | xargs -n 1 ./cecho.sh\narg1 #\narg2 #\narg3 #\n\n```", "```\nINPUT | xargs \u2013n X\n```", "```\n$ cat args.txt | xargs -n 2 ./cecho.sh \narg1 arg2 #\narg3 #\n\n```", "```\n$ cat args.txt | xargs ./ccat.sh\narg1 arg2 arg3 #\n\n```", "```\n./cecho.sh \u2013p arg1 \u2013l\n```", "```\n./cecho.sh \u2013p arg1 \u2013l\n./cecho.sh \u2013p arg2 \u2013l\n./cecho.sh \u2013p arg3 \u2013l\n```", "```\n$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l\n-p arg1 -l #\n-p arg2 -l #\n-p arg3 -l #\n\n```", "```\n$ find . -type f -name \"*.txt\"  -print | xargs rm -f \n\n```", "```\n$ find . -type f -name \"*.txt\" -print0 | xargs -0 rm -f\n\n```", "```\n$ find source_code_dir_path -type f -name \"*.c\" -print0 | xargs -0 wc -l\n\n```", "```\n$ cat files.txt  | ( while read arg; do cat $arg; done )\n# Equivalent to cat files.txt | xargs -I {} cat {}\n\n```", "```\n$ cmd0 | ( cmd1;cmd2;cmd3) | cmd4\n```", "```\ntr [options] set1 set2\n```", "```\n$ echo \"HELLO WHO IS THIS\" | tr 'A-Z' 'a-z'\n\n```", "```\n$ echo 12345 | tr '0-9' '9876543210'\n87654 #Encrypted\n\n$ echo 87654 | tr '9876543210' '0-9'\n12345 #Decrypted\n\n```", "```\n$ echo \"tr came, tr saw, tr conquered.\" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'\n\n```", "```\nge pnzr, ge fnj, ge pbadhrerq.\n\n```", "```\n$ echo ge pnzr, ge fnj, ge pbadhrerq. | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'\n\n```", "```\ntr came, tr saw, tr conquered.\n\n```", "```\n$ cat text | tr '\\t' ' '\n\n```", "```\n$ cat file.txt | tr -d  '[set1]'\n#Only set1 is used, not set2\n```", "```\n$ echo \"Hello 123 world 456\" | tr -d '0-9'\nHello  world\n# Removes the numbers from stdin and print\n\n```", "```\ntr -c [set1] [set2]\n```", "```\n$ echo hello 1 char 2 next 4 | tr -d -c '0-9 \\n'\n 1  2  4\n\n```", "```\n$ echo \"GNU is       not     UNIX. Recursive   right ?\" | tr -s ' '\nGNU is not UNIX. Recursive right ?\n# tr -s '[set]'\n\n```", "```\n$ cat sum.txt\n1\n2\n3\n4\n5\n\n$ cat sum.txt | echo $[ $(tr '\\n' '+' ) 0 ]\n15\n\n```", "```\necho $[ 1+2+3+4+5+0 ]\n```", "```\ntr [:class:] [:class:]\n```", "```\ntr '[:lower:]' '[:upper:]'\n```", "```\n$ md5sum filename\n68b329da9893e34099c7d8ad5cb9c940 filename\n\n```", "```\n$ md5sum filename > file_sum.md5\n\n```", "```\n$ md5sum file1 file2 file3 ..\n\n```", "```\n[checksum1]   file1\n[checksum1]   file2\n[checksum1]   file3\n\n```", "```\n$ md5sum -c file_sum.md5\n# It will output message whether checksum matches or not\n\n```", "```\n$ md5sum *.md5\n\n```", "```\n$ md5deep -rl directory_path > directory.md5\n# -r  for enable recursive.\n# -l for using relative path. By default it writes absolute file path in output\n\n```", "```\n$ find directory_path -type f -print0 | xargs -0 md5sum >> directory.md5\n\n```", "```\n$ md5sum -c directory.md5\n\n```", "```\n$ sort file1.txt file2.txt .. > sorted.txt\n\n```", "```\n$ sort file1.txt file2.txt .. -o sorted.txt\n\n```", "```\n$ cat sorted_file.txt | uniq> uniq_lines.txt\n\n```", "```\n$ sort -n file.txt\n\n```", "```\n$ sort -r file.txt\n\n```", "```\n$ sort -M months.txt\n\n```", "```\n#!/bin/bash\n#Desc: Sort\nsort -C file ;\nif [ $? -eq 0 ]; then\n   echo Sorted;\nelse\n   echo Unsorted;\nfi\n\n# If we are checking numerical sort, it should be sort -nC\n```", "```\n$ sort -m sorted1 sorted2\n\n```", "```\n$ cat data.txt\n1  mac      2000\n2  winxp    4000\n3  bsd      1000\n4  linux    1000\n\n```", "```\n# Sort reverse by column1\n$ sort -nrk 1  data.txt\n4\tlinux\t\t1000 \n3\tbsd\t\t1000 \n2\twinxp\t\t4000 \n1\tmac\t\t2000 \n# -nr means numeric and reverse\n\n# Sort by column 2\n$ sort -k 2  data.txt\n3\tbsd\t\t1000 \n4\tlinux\t\t1000 \n1\tmac\t\t2000 \n2\twinxp\t\t4000\n\n```", "```\n$ cat data.txt\n1010hellothis\n2189ababbba\n7464dfddfdfd\n$ sort -nk 2,3 data.txt\n\n```", "```\n$ sort -nk 1,1 data.txt\n\n```", "```\n$ sort -z data.txt | xargs -0\n#Zero terminator is used to make safe use with xargs\n\n```", "```\n$ sort -bd unsorted.txt\n\n```", "```\n$ cat sorted.txt\nbash \nfoss \nhack \nhack\n\n$ uniq sorted.txt\nbash \nfoss \nhack \n\n```", "```\n$ sort unsorted.txt | uniq\n\n```", "```\n$ sort -u unsorted.txt\n\n```", "```\n$ uniq -u sorted.txt\nbash\nfoss\n\n```", "```\n$ sort unsorted.txt | uniq -u\n\n```", "```\n$ sort unsorted.txt | uniq -c\n 1 bash\n 1 foss\n 2 hack\n\n```", "```\n$ sort unsorted.txt  | uniq -d\nhack\n\n```", "```\n$ cat data.txt\nu:01:gnu \nd:04:linux \nu:01:bash \nu:01:hack\n\n```", "```\n$ sort data.txt | uniq -s 2 -w 2\nd:04:linux \nu:01:bash \n\n```", "```\n$ uniq -z file.txt\n\n```", "```\n$ uniq \u2013z file.txt | xargs -0 rm\n\n```", "```\nINPUT= \"ahebhaaa\"\nOUTPUT=` echo $INPUT | sed 's/[^\\n]/&\\n/g' | sed '/^$/d' | sort | uniq -c | tr -d ' \\n'`\necho $OUTPUT \n```", "```\necho $INPUT  # Print the input to stdout\nsed 's/./&\\n/g'\n\n```", "```\ntemp_file=$(tempfile)\n```", "```\ntemp_file=\"/tmp/file-$RANDOM\"\n```", "```\ntemp_file=\"/tmp/var.$$\"\n```", "```\n$ dd if=/dev/zero bs=100k count=1 of=data.file\n\n```", "```\n$ split -b 10k data.file\n$ ls\ndata.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj\n\n```", "```\n$ split -b 10k data.file -d  -a 4\n$ ls\ndata.file x0009  x0019  x0029  x0039  x0049  x0059  x0069  x0079\n\n```", "```\n$ split [COMMAND_ARGS] PREFIX\n```", "```\n$ split -b 10k data.file -d  -a 4 split_file\n$ ls\ndata.file       split_file0002  split_file0005  split_file0008  strtok.c\nsplit_file0000  split_file0003  split_file0006  split_file0009\nsplit_file0001  split_file0004  split_file0007\n\n```", "```\n$ split -l 10 data.file \n# Splits into files of 10 lines each.\n\n```", "```\n$ cat server.log\nSERVER-1 \n[connection] 192.168.0.1 success \n[connection] 192.168.0.2 failed \n[disconnect] 192.168.0.3 pending \n[connection] 192.168.0.4 success \nSERVER-2 \n[connection] 192.168.0.1 failed \n[connection] 192.168.0.2 failed \n[disconnect] 192.168.0.3 success \n[connection] 192.168.0.4 failed \nSERVER-3 \n[connection] 192.168.0.1 pending \n[connection] 192.168.0.2 pending \n[disconnect] 192.168.0.3 pending \n[connection] 192.168.0.4 failed\n\n```", "```\n $ csplit server.log /SERVER/ -n 2 -s {*}  -f server -b \"%02d.log\"  ; rm server00.log \n\n$ ls\nserver01.log  server02.log  server03.log  server.log\n\n```", "```\nfile_jpg=\"sample.jpg\"\nname=${file_jpg%.*}\necho File name is: $name\n```", "```\nFile name is: sample\n```", "```\nextension=${file_jpg#*.}\necho Extension is: jpg\n```", "```\nExtension is: jpg\n```", "```\nVAR=hack.fun.book.txt\n```", "```\n$ echo ${VAR%.*}\n\n```", "```\n$ echo ${VAR%%.*}\n\n```", "```\nVAR=hack.fun.book.txt\n```", "```\n$ echo ${VAR#*.} \n```", "```\n$ echo ${VAR##*.}\n```", "```\n$ echo ${URL%.*} # Remove rightmost .*\nwww.google\n\n$ echo ${URL%%.*} # Remove right to leftmost  .* (Greedy operator)\nwww\n\n$ echo ${URL#*.} # Remove leftmost  part before *.\ngoogle.com\n\n$ echo ${URL##*.} # Remove left to rightmost  part before *. (Greedy operator)\ncom\n```", "```\n#!/bin/bash\n#Filename: rename.sh\n#Description: Rename jpg and png files\n\ncount=1;\nfor img in *.jpg *.png\ndo\nnew=image-$count.${img##*.}\n\nmv \"$img\" \"$new\" 2> /dev/null\n\nif [ $? -eq  0 ];\nthen\n\necho \"Renaming $img to $new\"\nlet count++\n\nfi\n\ndone \n```", "```\n$ ./rename.sh\nRenaming hack.jpg to image-1.jpg\nRenaming new.jpg to image-2.jpg\nRenaming next.jpg to image-3.jpg\n\n```", "```\n$ rename *.JPG *.jpg\n\n```", "```\n$ rename 's/ /_/g' *\n\n```", "```\n$ rename 'y/A-Z/a-z/' *\n$ rename 'y/a-z/A-Z/' *\n\n```", "```\n$ find path -type f -name \"*.mp3\" -exec mv {} target_dir \\;\n\n```", "```\n$ find path -type f -exec rename 's/ /_/g' {} \\;\n\n```", "```\n$ ls /usr/share/dict/ \namerican-english  british-english\n\n```", "```\n#!/bin/bash\n#Filename: checkword.sh\nword=$1\ngrep \"^$1$\" /usr/share/dict/british-english -q \nif [ $? -eq 0 ]; then\n  echo $word is a dictionary word;\nelse\n  echo $word is not a dictionary word;\nfi\n```", "```\n$ ./checkword.sh ful \nful is not a dictionary word \n\n$ ./checkword.sh fool \nfool is a dictionary word\n\n```", "```\n#!/bin/bash \n#Filename: aspellcheck.sh\nword=$1 \n\noutput=`echo \\\"$word\\\" | aspell list` \n\nif [ -z $output ]; then \n        echo $word is a dictionary word; \nelse \n        echo $word is not a dictionary word; \nfi \n```", "```\n$ look word filepath\n\n```", "```\n$ grep \"^word\" filepath\n\n```", "```\n$ look word\n# When used like this it takes default dictionary as file\n\n```", "```\n$ look android\nandroid\nandroid's\nandroids\n\n```", "```\n$ command\nEnter a number: 1\nEnter name : hello\nYou have entered 1,hello\n\n```", "```\n#!/bin/bash\n#Filename: interactive.sh\nread -p \"Enter number:\" no ;\nread -p \"Enter name:\" name\necho You have entered $no, $name;\n```", "```\n$ echo -e \"1\\nhello\\n\" | ./interactive.sh \nYou have entered 1, hello \n\n```", "```\n$ echo -e \"1\\nhello\\n\"  > input.data\n$ cat input.data\n1\nhello\n\n```", "```\n$ ./interactive.sh < input.data\n\n```", "```\n#!/usr/bin/expect \n#Filename: automate_expect.sh\nspawn ./interactive .sh \nexpect \"Enter number:\" \nsend \"1\\n\" \nexpect \"Enter name:\" \nsend \"hello\\n\" \nexpect eof \n```", "```\n$ ./automate_expect.sh\n\n```"]