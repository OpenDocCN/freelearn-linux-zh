- en: Chapter 7. Process Memory Forensics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。进程内存取证
- en: In the previous chapter, we examined the key methods and ways to approach the
    analysis of an ELF binary in Linux, especially when concerning malware, and ways
    to detect the presence of a parasite within executable code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们检查了在Linux中分析ELF二进制文件时的关键方法和方法，特别是在涉及恶意软件时，以及检测可执行代码中寄生体存在的方法。
- en: Just as an attacker may patch a binary on disk, they may also patch a running
    program in memory to achieve similar goals, while avoiding being detected by programs
    that look for file modification, such as a tripwire. This sort of hot patching
    of a process image can be used to hijack functions, inject shared libraries, execute
    parasite shellcode, and so on. These types of infections are often the components
    needed for memory-resident backdoors, viruses, key loggers, and hidden processes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如攻击者可能会在磁盘上对二进制文件进行打补丁一样，他们也可能会在内存中对运行的程序进行打补丁，以实现类似的目标，同时避免被寻找文件修改的程序检测到，比如tripwire。这种对进程映像的热打补丁可以用于劫持函数、注入共享库、执行寄生壳代码等。这些类型的感染通常是内存驻留后门、病毒、键盘记录器和隐藏进程所需的组件。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An attacker can run sophisticated programs that will run cloaked within an existing
    process address space. This has been demonstrated with Saruman v0.1, which is
    available at [http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以运行复杂的程序，这些程序将在现有进程地址空间内运行。这已经在Saruman v0.1中得到证明，可以在[http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman)找到。
- en: The examination of a process image when performing forensics or runtime analysis
    is rather similar to looking at a regular ELF binary. There are more segments
    and overall moving pieces in a process address space, and the ELF executable will
    undergo some changes, such as runtime relocations, segment alignment, and .bss
    expansion.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行取证或运行时分析时，对进程映像的检查与查看常规ELF二进制文件非常相似。在进程地址空间中有更多的段和整体移动部分，ELF可执行文件将经历一些变化，例如运行时重定位、段对齐和.bss扩展。
- en: However, in reality, the investigation steps are very similar for an ELF executable
    and an actual running program. The running program was initially created by the
    ELF images that are loaded into the address space. Therefore, understanding the
    ELF format will help understand how a process looks in memory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，对ELF可执行文件和实际运行的程序进行调查步骤非常相似。运行的程序最初是由加载到地址空间的ELF映像创建的。因此，了解ELF格式将有助于理解进程在内存中的外观。
- en: What does a process look like?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程的外观是什么样的？
- en: One important file on any Linux system is the `/proc/$pid/maps` file. This file
    shows the entire process address space of a running program, and it is something
    that I often parse in order to determine the location of certain files or memory
    mappings within a process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Linux系统上，一个重要的文件是`/proc/$pid/maps`文件。这个文件显示了运行程序的整个进程地址空间，我经常解析它以确定某些文件或内存映射在进程中的位置。
- en: On Linux kernels that have the Grsecurity patches, there is a kernel option
    called **GRKERNSEC_PROC_MEMMAP** that, if enabled, will zero out the `/proc/$pid/maps`
    file so that you cannot see the address space values. This makes parsing a process
    from the outside a bit more difficult, and you must rely on other techniques such
    as parsing the ELF headers and going from there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有Grsecurity补丁的Linux内核上，有一个名为GRKERNSEC_PROC_MEMMAP的内核选项，如果启用，将清零`/proc/$pid/maps`文件，以便您无法看到地址空间的值。这使得从外部解析进程变得更加困难，您必须依赖其他技术，如解析ELF头文件并从那里开始。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we will be discussing the **ECFS** (short for **Extended
    Core File Snapshot**) format, which is a new ELF file format that expands on regular
    core files and contains an abundance of forensics-relevant data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论**ECFS**（扩展核心文件快照）格式，这是一种新的ELF文件格式，它扩展了常规核心文件，并包含大量取证相关的数据。
- en: 'Here''s an example of the process memory layout of `the hello_world` program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`hello_world`程序的进程内存布局示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding maps file output shows the process address space of a very simple
    `Hello World` program. Let's go over it in several chunks, explaining each part.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的maps文件输出显示了一个非常简单的`Hello World`程序的进程地址空间。让我们分几块来解释每个部分。
- en: Executable memory mappings
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行内存映射
- en: 'The first three lines are the memory mappings for the executable itself. This
    is quite obvious because it shows the executable path at the end of the file mapping:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行是可执行文件本身的内存映射。这是相当明显的，因为它显示了文件映射的末尾处的可执行路径：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到：
- en: The first line is the text segment, which is easy to tell because the permissions
    are read plus execute
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行是文本段，很容易识别，因为权限是读取加执行
- en: The second line is the first part of the data segment, which has been marked
    as read-only due to RELRO (read-only relocation) security protection
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行是数据段的第一部分，由于RELRO（只读重定位）安全保护而被标记为只读
- en: The third mapping is the remaining part of the data segment that is still writable
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个映射是仍然可写的数据段的剩余部分
- en: The program heap
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序堆
- en: 'The heap is typically grown right after the data segment. Before ASLR existed,
    it was extended from the end of the data segment address. Nowadays, the heap segment
    is randomly memory-mapped, but it can be found in the *maps* file right after
    the end of the data segment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 堆通常在数据段之后增长。在ASLR存在之前，它是从数据段地址的末尾扩展的。如今，堆段是随机内存映射的，但可以在*maps*文件中在数据段结束后找到：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are also anonymous memory mappings that may be created when a call to
    `malloc()` requests a chunk of memory that exceeds `MMAP_THRESHOLD` in size. These
    types of anonymous memory segments will not be marked with the `[heap]` label.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`malloc()`请求一个超过`MMAP_THRESHOLD`大小的内存块时，还可能创建匿名内存映射。这些类型的匿名内存段不会被标记为`[heap]`。
- en: Shared library mappings
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库映射
- en: 'The next four lines are the memory mappings for the shared library, `libc-2.19.so`.
    Notice that there is a memory mapping marked with no permissions between the text
    and data segments. This is simply for occupying space in that area so that no
    other arbitrary memory mappings may be created to use the space between the text
    and data segments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四行是共享库`libc-2.19.so`的内存映射。请注意，在文本和数据段之间有一个标记为无权限的内存映射。这只是为了占据该区域的空间，以便不会创建其他任意内存映射来使用文本和数据段之间的空间：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition to regular shared libraries, there is the dynamic linker, which
    is also technically a shared library. We can see that it is mapped to the address
    space by looking at the file mappings right after the `libc` mappings:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的共享库之外，还有动态链接器，从技术上讲也是一个共享库。我们可以看到它通过查看`libc`映射后的文件映射来映射到地址空间：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The stack, vdso, and vsyscall
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈、vdso和vsyscall
- en: 'At the end of the maps file, you will see the stack segment, followed by **VDSO**
    (short for **Virtual Dynamic Shared Object**) and vsyscall:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射文件的末尾，您将看到栈段，接着是**VDSO**（**虚拟动态共享对象**）和vsyscall：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: VDSO is used by `glibc` to invoke certain system calls that are frequently called
    and would otherwise create a performance issue. VDSO helps speed this up by executing
    certain syscalls in userland. The vsyscall page is deprecated on x86_64, but on
    32-bit, it accomplishes the same thing as VDSO.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: VDSO是`glibc`用来调用频繁调用的系统调用的，否则会导致性能问题。VDSO通过在用户空间执行某些syscalls来加快速度。在x86_64上，vsyscall页面已被弃用，但在32位上，它实现了与VDSO相同的功能。
- en: '![The stack, vdso, and vsyscall](img/00016.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![栈、vdso和vsyscall](img/00016.jpeg)'
- en: What the process looks like
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是什么样子的
- en: Process memory infection
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存感染
- en: There are many rootkits, viruses, backdoors, and other tools out there that
    can be used to infect a system's userland memory. We will now name and describe
    a few of these.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多rootkits、病毒、后门和其他工具可以用来感染系统的用户空间内存。我们现在将命名并描述其中的一些。
- en: Process infection tools
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程感染工具
- en: '**Azazel**: This is a simple but effective `LD_PRELOAD` injection userland
    rootkit for Linux that is based on its predecessor rootkit named Jynx. `LD_PRELOAD`
    rootkits will preload a shared object into the program that you want to infect.
    Typically, such a rootkit will hijack functions such as open, read, write, and
    so on. These hijacked functions will show up as PLT hooks (modified GOT). For
    more information, visit [https://github.com/chokepoint/azazel](https://github.com/chokepoint/azazel).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azazel**：这是一个简单但有效的Linux用户空间rootkit，基于其前身rootkit Jynx。`LD_PRELOAD` rootkits将预加载一个共享对象到您想要感染的程序中。通常，这样的rootkit将劫持函数，如open、read、write等。这些被劫持的函数将显示为PLT钩子（修改的GOT）。有关更多信息，请访问[https://github.com/chokepoint/azazel](https://github.com/chokepoint/azazel)。'
- en: '**Saruman**: This is a relatively new anti-forensics infection technique that
    allows a user to inject a complete dynamically linked executable into an existing
    process. Both the injected and the injectee will run concurrently within the same
    address space. This allows stealthy and advanced remote process infection. For
    more information, visit [https://github.com/elfmaster/saruman](https://github.com/elfmaster/saruman).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saruman**：这是一种相对较新的反取证感染技术，允许用户将完整的动态链接可执行文件注入到现有进程中。注入者和被注入者将在相同的地址空间内同时运行。这允许隐秘和高级的远程进程感染。有关更多信息，请访问[https://github.com/elfmaster/saruman](https://github.com/elfmaster/saruman)。'
- en: '**sshd_fucker (phrack .so injection paper)**: `sshd_fucker` is the software
    that comes with the Phrack 59 paper *Runtime process infection*. The software
    infects the sshd process and hijacks PAM functions that usernames and passwords
    are passed through. For more information, visit [http://phrack.org/issues/59/8.html](http://phrack.org/issues/59/8.html)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sshd_fucker（phrack .so注入论文）**：`sshd_fucker`是随Phrack 59论文*Runtime process
    infection*一起提供的软件。该软件感染sshd进程并劫持PAM函数，用户名和密码通过这些函数传递。有关更多信息，请访问[http://phrack.org/issues/59/8.html](http://phrack.org/issues/59/8.html)'
- en: Process infection techniques
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程感染技术
- en: What does process infection mean? For our purposes, it means describing ways
    of injecting code into a process, hijacking functions, hijacking control flow,
    and anti-forensics tricks to make analysis more difficult. Many of these techniques
    were covered in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, but we will recapitulate some of these here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进程感染是什么意思？对于我们的目的，这意味着描述将代码注入进程、劫持函数、劫持控制流和反取证技巧，以使分析更加困难。这些技术中的许多在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中已经涵盖，*ELF病毒技术- Linux/Unix病毒*，但我们将在这里重述其中的一些。
- en: Injection methods
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入方法
- en: '**ET_DYN (shared object) injection**: This is accomplished using the `ptrace()`
    system call and shellcode that uses either the `mmap()` or `__libc_dlopen_mode()`
    function to load the shared library file. A shared object might not be a shared
    object at all; it may be a PIE executable, as with the Saruman infection technique,
    which is a form of anti-forensics for allowing a program to run inside of an existing
    process address space. This technique is what I call **process cloaking**.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ET_DYN（共享对象）注入**：这是使用`ptrace()`系统调用和使用`mmap()`或`__libc_dlopen_mode()`函数加载共享库文件的shellcode来实现的。共享对象可能根本不是共享对象；它可能是一个PIE可执行文件，就像Saruman感染技术一样，这是一种允许程序在现有进程地址空间内运行的反取证形式。这种技术就是我所说的**进程伪装**。'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`LD_PRELOAD` is another common trick for loading a malicious shared library
    into a process address space to hijack shared library functions. This can be detected
    by validating the PLT/GOT. The environment variables on the stack can also be
    analyzed to find out whether `LD_PRELOAD` has been set.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD`是另一个常见的技巧，用于将恶意共享库加载到进程地址空间中，以劫持共享库函数。这可以通过验证PLT/GOT来检测。还可以分析栈上的环境变量，以找出是否已设置`LD_PRELOAD`。'
- en: '**ET_REL (relocatable object) injection**: The idea here is to inject a relocatable
    object file into a process for advanced hot patching techniques. The ptrace system
    call (or programs that use `ptrace()`, such as GDB) can be used to inject shellcode
    into the process, which in turn memory-maps the object file to the memory.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ET_REL（可重定位对象）注入：这里的想法是将可重定位对象文件注入到进程中，用于高级热修补技术。 ptrace系统调用（或使用`ptrace()`的程序，如GDB）可用于将shellcode注入到进程中，进而将对象文件内存映射到内存中。
- en: '**PIC code (shellcode) injection**: Injecting shellcode into a process is typically
    done with ptrace. Often, shellcode is the first stage in injecting more sophisticated
    code (such as `ET_DYN` and `ET_REL` files) into the process.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIC代码（shellcode）注入：将shellcode注入到进程通常使用ptrace完成。通常，shellcode是向进程注入更复杂代码（如`ET_DYN`和`ET_REL`文件）的第一阶段。
- en: Techniques for hijacking execution
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 劫持执行的技术
- en: '**PLT/GOT redirection**: Hijacking shared library functions is most commonly
    accomplished by modifying the GOT entry for the given shared library so that the
    address reflects the location of the code injected by the attacker. This is essentially
    the same thing as overwriting a function pointer. We will discuss methods of detecting
    this later in this chapter.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLT/GOT重定向：劫持共享库函数最常见的方法是修改给定共享库的GOT条目，以便地址反映攻击者注入代码的位置。这本质上与覆盖函数指针相同。我们将在本章后面讨论检测这一点的方法。
- en: '**Inline function hooking**: This method, also called **function trampolines**,
    is common both on disk and in memory. An attacker can replace the first 5 to 7
    bytes of code in a function with a `jmp` instruction that transfers control to
    a malicious function. This can be detected easily by scanning the initial byte
    code in every function.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数挂钩：这种方法，也称为**函数跳板**，在磁盘和内存中都很常见。攻击者可以用`jmp`指令替换函数中的前5到7个字节的代码，将控制转移到恶意函数。这可以通过扫描每个函数的初始字节代码来轻松检测到。
- en: '**Patching .ctors and .dtors**: The .ctors and .dtors sections in a binary
    (which can be located in the memory) contain an array of function pointers for
    initialization and finalization functions. These can be patched by an attacker
    on disk and in memory so that they point to parasite code.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补.ctors和.dtors：二进制文件中的.ctors和.dtors部分（可以位于内存中）包含初始化和终结函数的函数指针数组。攻击者可以在磁盘和内存中对其进行修补，使其指向寄生代码。
- en: '**Hijacking VDSO for syscall interception**: The VDSO page that is mapped to
    the process address space contains code for invoking system calls. An attacker
    can use `ptrace(PTRACE_SYSCALL, …)` to locate this code and then replace the **%rax**
    register with the system call number that they want to invoke. This allows a clever
    attacker to invoke any system call that they want to in a process without having
    to inject shellcode. Check out this paper I wrote in 2009; it describes the technique
    in detail at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用VDSO进行系统调用拦截：映射到进程地址空间的VDSO页面包含用于调用系统调用的代码。攻击者可以使用`ptrace(PTRACE_SYSCALL,
    ...)`来定位这段代码，然后用所需调用的系统调用号替换**%rax**寄存器。这允许聪明的攻击者在进程中调用任何他们想要的系统调用，而无需注入shellcode。查看我2009年写的这篇论文；它详细描述了这一技术：[http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html)。
- en: Detecting the ET_DYN injection
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测ET_DYN注入
- en: I think that the most prevalent type of process infection is DLL injection,
    also known as `.so` injection. It is a clean and effective solution that suits
    the needs of most attackers and runtime malware. Let's take a look at an infected
    process, and I will highlight the ways in which we can identify parasite code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最普遍的进程感染类型是DLL注入，也称为`.so`注入。这是一种干净有效的解决方案，适合大多数攻击者和运行时恶意软件的需求。让我们看看一个被感染的进程，我将强调我们可以识别寄生代码的方法。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terms **shared object**, **shared library**, **DLL**, and **ET_DYN** are
    all used synonymously throughout this book, especially in this particular section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**共享对象**，**共享库**，**DLL**和**ET_DYN**在本书中都是同义词，特别是在本节中。
- en: Azazel userland rootkit detection
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azazel用户态rootkit检测
- en: Our infected process is a simple test program named `./host` that is infected
    with the Azazel userland rootkit. Azazel is the newer version of the popular Jynx
    rootkit. Both of these rootkits rely on `LD_PRELOAD` to load a malicious shared
    library that hijacks various `glibc` shared library functions. We will inspect
    the infected process using various GNU tools and the Linux environment, such as
    the `/proc` filesystem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的感染进程是一个名为`./host`的简单测试程序，它被Azazel用户态rootkit感染。 Azazel是流行的Jynx rootkit的新版本。这两个rootkit都依赖于`LD_PRELOAD`来加载恶意共享库，劫持各种`glibc`共享库函数。我们将使用各种GNU工具和Linux环境，如`/proc`文件系统，来检查被感染的进程。
- en: Mapping out the process address space
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射进程地址空间
- en: The first step while analyzing a process is to map out the address space. The
    most straightforward way to do this is by looking at the `/proc/<pid>/maps` file.
    We want to take note of any strange file mappings and segments with odd permissions.
    Also in our case, we may need to check the stack for environment variables, so
    we will want to take note of its location in memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分析进程时的第一步是映射地址空间。最直接的方法是查看`/proc/<pid>/maps`文件。我们要注意任何奇怪的文件映射和具有奇怪权限的段。在我们的情况下，我们可能需要检查环境变量的堆栈，因此我们需要注意其在内存中的位置。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `pmap <pid>` command can also be used instead of `cat /proc/<pid>/maps`.
    I prefer looking directly at the maps file because it shows the entire address
    range of each memory segment and the complete file path of any file mappings,
    such as shared libraries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap <pid>`命令也可以用来代替`cat /proc/<pid>/maps`。我更喜欢直接查看映射文件，因为它显示了每个内存段的整个地址范围以及任何文件映射的完整文件路径，如共享库。'
- en: 'Here''s an example of memory mappings of an infected process `./host`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个被感染进程`./host`的内存映射的示例：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The areas of interest and concern are highlighted in the preceding output of
    the maps file for the process of *./host*. In particular, notice the shared library
    with the `/home/user/git/azazel/libselinux.so` path. This should immediately grab
    your attention because the path is not the standard shared library path and it
    has the name `libselinux.so`, which is traditionally stored with all other shared
    libraries (that is, `/usr/lib`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*./host*进程的maps文件的前述输出中突出显示了感兴趣和关注的区域。特别注意具有`/home/user/git/azazel/libselinux.so`路径的共享库。这应立即引起您的注意，因为该路径不是标准的共享库路径，并且它的名称是`libselinux.so`，传统上存储在所有其他共享库中（即`/usr/lib`）。'
- en: This could indicate possible shared library injection (also known as the `ET_DYN`
    injection), which would mean that this is not the authentic `libselinux.so` library.
    The first thing that we might check for in this case is the `LD_PRELOAD` environment
    variable to see whether it was used to **preload** the `libselinux.so` library.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能表明可能存在共享库注入（也称为`ET_DYN`注入），这意味着这不是真正的`libselinux.so`库。在这种情况下，我们可能首先检查`LD_PRELOAD`环境变量，看它是否被用于**预加载**`libselinux.so`库。
- en: Finding LD_PRELOAD on the stack
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在堆栈上查找LD_PRELOAD
- en: 'The environment variables for a program are stored near the bottom of the stack
    at the beginning of a program''s runtime. The bottom of the stack is actually
    the highest address (the beginning of the stack), since the stack grows into smaller
    addresses on the x86 architecture. Based on the output from `/proc/<pid>/maps`,
    we can get the location of the stack:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的环境变量在运行时存储在堆栈的底部附近。堆栈的底部实际上是最高地址（堆栈的开始），因为堆栈在x86架构上向较小的地址增长。根据`/proc/<pid>/maps`的输出，我们可以获得堆栈的位置：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, we want to check the stack from `0x7fff82fcf000` onward. Using GDB, we can
    attach to the process and quickly locate the environment variables on the stack
    by using the `x/s <address>` command, which tells GDB to view the memory in ASCII
    format. The `x/4096s <address>` command does the same thing but reads from 4,096
    bytes of data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要从`0x7fff82fcf000`开始检查堆栈。使用GDB，我们可以附加到进程并通过使用`x/s <address>`命令快速定位堆栈上的环境变量，该命令告诉GDB以ASCII格式查看内存。`x/4096s
    <address>`命令执行相同的操作，但从4,096字节的数据中读取。
- en: We can safely presume that the environment variables will be in the first 4,096
    bytes of the stack, but since the stack grows into lower addresses, we must start
    reading at `<stack_bottom> - 4096`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以合理推测环境变量将位于堆栈的前4,096字节内，但由于堆栈向较小地址增长，我们必须从`<stack_bottom> - 4096`开始读取。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The argv and envp pointers point to command-line arguments and environment variables
    respectively. We are not looking for the actual pointers but rather the strings
    that these pointers reference.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: argv和envp指针分别指向命令行参数和环境变量。我们不是在寻找实际的指针，而是这些指针引用的字符串。
- en: 'Here''s an example of using GDB to read environment variables on a stack:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用GDB读取堆栈上环境变量的示例：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see from the preceding output, we have verified that `LD_PRELOAD`
    was used to preload `libselinux.so` into the process. This means that any glibc
    functions within the program that have the same name as any functions in the preloaded
    shared library will be overridden and effectively hijacked by the ones in `libselinux.so`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述输出中，我们已经验证了`LD_PRELOAD`被用于预加载`libselinux.so`到进程中。这意味着程序中任何与预加载共享库中的函数同名的glibc函数将被覆盖，并有效地被`libselinux.so`中的函数劫持。
- en: In other words, if the `./host` program calls the `fopen` function from glibc
    and `libselinux.so` contains its own version of `fopen`, then that is the `fopen`
    function that will be stored in the PLT/GOT (the `.got.plt` section) and used
    instead of the glibc version. This leads us to the next indicated item—detecting
    function hijacking in the PLT/GOT (the PLT's global offset table).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`./host`程序调用glibc的`fopen`函数，而`libselinux.so`包含自己版本的`fopen`，那么PLT/GOT（`.got.plt`部分）中将存储`fopen`函数，并且会使用`libselinux.so`版本而不是glibc版本。这将引导我们到下一个指示的项目——检测PLT/GOT（PLT的全局偏移表）中的函数劫持。
- en: Detecting PLT/GOT hooks
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测PLT/GOT挂钩
- en: Before checking the PLT/GOT that is in the ELF section called `.got.plt` (which
    is in the data segment of the executable), let's see which functions in the `./host`
    program have relocations for the PLT/GOT. Remember from the chapter on ELF internals
    that the relocation entries for the global offset table are of the `<ARCH>_JUMP_SLOT`
    type. Refer to the ELF(5) manual for details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查ELF部分中名为`.got.plt`的PLT/GOT（位于可执行文件的数据段中）之前，让我们看看`./host`程序中哪些函数对PLT/GOT有重定位。从ELF内部章节中记得，全局偏移表的重定位条目是`<ARCH>_JUMP_SLOT`类型的。详细信息请参考ELF(5)手册。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The relocation type for the PLT/GOT is called `<ARCH>_JUMP_SLOT` because they
    are just that—jump slots. They contain function pointers that the PLT uses with
    jmp instructions to transfer control to the destination function. The actual relocation
    types are named `X86_64_JUMP_SLOT, i386_JUMP_SLOT`, and so on depending on the
    architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PLT/GOT的重定位类型称为`<ARCH>_JUMP_SLOT`，因为它们就是那样——跳转槽。它们包含函数指针，PLT使用jmp指令将控制传输到目标函数。实际的重定位类型根据架构命名为`X86_64_JUMP_SLOT,
    i386_JUMP_SLOT`等等。
- en: 'Here''s an example of identifying shared library functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是识别共享库函数的示例：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that there are several well-known glibc functions being called. It
    is possible that some or all of these are being hijacked by the imposture shared
    library `libselinux.so`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有几个调用的知名glibc函数。可能其中一些或全部被冒牌共享库`libselinux.so`劫持。
- en: Identifying incorrect GOT addresses
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别不正确的GOT地址
- en: 'From the `readelf` output that displays the PLT/GOT entries in the `./host`
    executable, we can see the address of each symbol. Let''s take a look at the global
    offset table in the memory for the following symbols: `fopen`, `opendir`, and
    `unlink`. It is possible that these have been hijacked and no longer point to
    the `libc.so` library.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从`readelf`输出中显示`./host`可执行文件中的PLT/GOT条目，我们可以看到每个符号的地址。让我们来看看内存中全局偏移表中以下符号的地址：`fopen`，`opendir`和`unlink`。这些可能已经被劫持，不再指向`libc.so`库。
- en: 'Here''s an example of the GDB output displaying the GOT values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GDB输出显示GOT值的示例：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A quick look at the executable memory region of the `selinux.so` shared library
    shows us that the addresses displayed in the GOT by GDB point to functions within
    `selinux.so` and not `libc.so`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看`selinux.so`共享库的可执行内存区域，我们可以看到GDB中GOT中显示的地址指向`selinux.so`内部的函数，而不是`libc.so`。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this particular malware (Azazel), the malicious shared library was preloaded
    using `LD_PRELOAD`, which made verifying the library as suspicious an easy task.
    This is not always the case, as many forms of malware will inject the shared library
    via `ptrace()` or shellcode that uses either `mmap()` or `__libc_dlopen_mode()`.
    The heuristics for determining whether or not a shared library has been injected
    will be detailed in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种特定的恶意软件（Azazel），恶意共享库是使用`LD_PRELOAD`预加载的，这使得验证库是否可疑变得非常简单。但情况并非总是如此，因为许多形式的恶意软件将通过`ptrace()`或使用`mmap()`或`__libc_dlopen_mode()`的shellcode注入共享库。确定共享库是否已被注入的启发式方法将在下一节详细介绍。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we will see in the following chapter, the ECFS technology for process memory
    forensics has some features that make identifying injected DLLs and other types
    of ELF objects almost simple.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章中看到的那样，用于进程内存取证的ECFS技术具有一些功能，使得识别注入的DLL和其他类型的ELF对象几乎变得简单。
- en: ET_DYN injection internals
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ET_DYN注入内部
- en: As we just demonstrated, detecting shared libraries that have been preloaded
    with `LD_PRELOAD` is rather simple. What about shared libraries that were injected
    into a remote process? Or in other words, shared objects that were inserted into
    a pre-existing process? It is important to know whether or not a shared library
    was maliciously injected if we want to be able to take the next step and detect
    PLT/GOT hooks. First, we must identify all the ways in which a shared library
    can be injected into a remote process, as we briefly discussed in section 7.2.2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚演示的，检测已使用`LD_PRELOAD`预加载的共享库是相当简单的。那么注入到远程进程中的共享库呢？换句话说，已插入到现有进程中的共享对象呢？如果我们想要能够迈出下一步并检测PLT/GOT钩子，那么知道共享库是否被恶意注入是很重要的。首先，我们必须确定共享库可以被注入到远程进程的所有方式，正如我们在第7.2.2节中简要讨论的那样。
- en: Let's look at a concrete example of how this might be accomplished. Here is
    some example code from Saruman that injects PIE executables into a process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子，说明这可能是如何实现的。这是Saruman的一些示例代码，它将PIE可执行文件注入到进程中。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PIE executables are in the same format as shared libraries, so the same code
    will work for the injection of either type into a process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PIE可执行文件与共享库的格式相同，因此相同的代码将适用于将任一类型注入到进程中。
- en: Using the `readelf` utility, we can see that in the standard C library (`libc.so.6`),
    there exists a function named `__libc_dlopen_mode`. This function actually accomplishes
    the same thing as the `dlopen` function, which is not resident in `libc`. This
    means that with any process that uses `libc`, we can get the dynamic linker to
    load whatever `ET_DYN` object we want to, while also automatically handling all
    the relocation patches.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf`实用程序，我们可以看到在标准C库（`libc.so.6`）中存在一个名为`__libc_dlopen_mode`的函数。这个函数实际上实现了与`dlopen`函数相同的功能，而`dlopen`函数并不驻留在`libc`中。这意味着对于任何使用`libc`的进程，我们都可以让动态链接器加载我们想要的任何`ET_DYN`对象，同时还自动处理所有的重定位补丁。
- en: Example – finding the symbol for __libc_dlopen_mode
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 - 查找__libc_dlopen_mode符号
- en: 'It is rather common for attackers to use this function to load `ET_DYN` objects
    into a process:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者通常使用这个函数将`ET_DYN`对象加载到进程中：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Code example – the __libc_dlopen_mode shellcode
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码示例 - __libc_dlopen_mode shellcode
- en: 'The following code is in C, but when compiled into machine code, it can be
    used as shellcode that we inject into the process using `ptrace`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用C编写的，但编译成机器代码后，可以作为我们使用`ptrace`注入到进程中的shellcode：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that one of the arguments is `void *dlopen_addr`. Saruman locates the
    address to the `__libc_dlopen_mode()` function, which resides in `libc.so`. This
    is accomplished using a function for resolving symbols within the `libc` library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意其中一个参数是`void *dlopen_addr`。Saruman定位了`__libc_dlopen_mode()`函数的地址，该函数驻留在`libc.so`中。这是通过一个解析`libc`库中符号的函数来实现的。
- en: Code example – libc symbol resolution
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码示例 - libc符号解析
- en: 'There are many more details to the following code, and I would highly encourage
    you to check out Saruman. It is specifically for injecting executable programs
    that are compiled as `ET_DYN` objects, but as mentioned previously, the injection
    method will also work for shared libraries since they are also compiled as `ET_DYN`
    objects:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码还有许多细节，我强烈建议您查看Saruman。它专门用于注入编译为`ET_DYN`对象的可执行程序，但正如之前提到的，注入方法也适用于共享库，因为它们也编译为`ET_DYN`对象：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To further demystify shared library injection, let me show you a much simpler
    technique that uses `ptrace` injected shellcode to `open()/mmap()` the shared
    library into the process address space. This technique is fine to use, but it
    requires that the malware manually handle all of the hot patching of relocations.
    The `__libc_dlopen_mode()` function handles all of this transparently with the
    help of the dynamic linker itself, so it is actually easier in the long run.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步揭开共享库注入的神秘面纱，让我向您展示一种更简单的技术，即使用`ptrace`注入的shellcode来将共享库`open()/mmap()`到进程地址空间中。这种技术可以使用，但需要恶意软件手动处理所有的热补丁重定位。`__libc_dlopen_mode()`函数通过动态链接器本身透明地处理所有这些，因此从长远来看实际上更容易。
- en: Code example – the x86_32 shellcode to mmap() an ET_DYN object
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码示例-用于mmap() ET_DYN对象的x86_32 shellcode
- en: The following shellcode can be injected into an executable segment within a
    given process and then be executed using `ptrace`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shellcode可以注入到给定进程中的可执行段中，然后使用`ptrace`执行。
- en: 'Note that this is the second time I''ve used this hand-written shellcode as
    an example in the book. I wrote it in 2008 for a 32-bit Linux system, and it was
    convenient to use as an example. Otherwise, I''m sure I would have written something
    new to demonstrate a more modern approach in x86_64 Linux:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是我在本书中第二次使用这个手写的shellcode作为示例。我在2008年为32位Linux系统编写了它，并且方便在示例中使用。否则，我肯定会写一些新的内容来演示x86_64
    Linux中更现代的方法：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With `PTRACE_POKETEXT` to inject it and `PTRACE_SETREGS` to set `%eip` to the
    entry point of the shellcode, once the shellcode hits the `int3` instruction,
    it will effectively pass the control back to your program that is performing the
    infection. This can then simply detach from the host process that is now infected
    with the shared library (`/lib/libtest.so.1.0`).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PTRACE_POKETEXT`注入它，并使用`PTRACE_SETREGS`将`%eip`设置为shellcode的入口点，一旦shellcode触发`int3`指令，它将有效地将控制权传递回执行感染的程序。然后，它可以简单地从现在感染了共享库(`/lib/libtest.so.1.0`)的主机进程中分离出来。
- en: In some cases, such as on binaries that have PaX mprotect restrictions enabled
    ([https://pax.grsecurity.net/docs/mprotect.txt](https://pax.grsecurity.net/docs/mprotect.txt)),
    the `ptrace` system call cannot be used to inject shellcode into the text segment.
    This is because it is read-only, and the restrictions will also prevent marking
    the text segment writeable, so you cannot simply get around this. However, this
    can be circumvented in several ways, such as by setting the instruction pointer
    to `__libc_dlopen_mode` and storing the arguments to the function in registers
    (such as `%rdi`, `%rsi`, and so on). Alternatively, in the case of a 32-bit architecture,
    the arguments can be stored on the stack.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如启用了PaX mprotect限制的二进制文件（[https://pax.grsecurity.net/docs/mprotect.txt](https://pax.grsecurity.net/docs/mprotect.txt)），`ptrace`系统调用无法用于将shellcode注入到文本段中。这是因为它是只读的，并且限制还将阻止将文本段标记为可写，因此您不能简单地绕过这一点。但是，可以通过几种方式来规避这一限制，例如将指令指针设置为`__libc_dlopen_mode`并将函数的参数存储在寄存器中（如`%rdi`、`%rsi`等）。或者，在32位架构的情况下，参数可以存储在堆栈上。
- en: Another way is by manipulating the VDSO code that is present in most processes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是操纵大多数进程中存在的VDSO代码。
- en: Manipulating VDSO to perform dirty work
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵VDSO执行脏工作
- en: This technique is one that is demonstrated at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html),
    but the general idea is simple. The VDSO code that is mapped to the process address
    space, as seen in the `/proc/<pid>/maps` output earlier in this chapter, contains
    code that invokes system calls via the *syscall* (for 64-bit) and *sysenter* (for
    32-bit) instructions. The calling convention for system calls in Linux always
    places the system call number in the `%eax/%rax` register.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是在[http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html)上演示的，但是基本思想很简单。VDSO代码映射到进程地址空间，如本章前面的`/proc/<pid>/maps`输出所示，其中包含通过*syscall*（64位）和*sysenter*（32位）指令调用系统调用的代码。在Linux中，系统调用的调用约定总是将系统调用号放在`%eax/%rax`寄存器中。
- en: If an attacker uses `ptrace(PTRACE_SYSCALL, …)`, they can quickly locate the
    syscall instruction in the VDSO code and replace the register values to invoke
    whichever system call is desired. If this is done carefully and done while restoring
    the original system call that was executing, then it will not cause the application
    to crash. The `open` and `mmap` system calls can be used to load an executable
    object such as `ET_DYN` or `ET_REL` into the process address space. Alternatively,
    they can be used to simply create an anonymous memory mapping that can store shellcode.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者使用`ptrace(PTRACE_SYSCALL, …)`，他们可以快速定位VDSO代码中的syscall指令，并替换寄存器值以调用所需的系统调用。如果这样做得当，并且在恢复原始正在执行的系统调用时进行，那么它不会导致应用程序崩溃。`open`和`mmap`系统调用可用于将可执行对象（如`ET_DYN`或`ET_REL`）加载到进程地址空间中。或者，它们可以用于简单地创建一个可以存储shellcode的匿名内存映射。
- en: 'This is a code example in which the attacker takes advantage of this code on
    a 32-bit system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码示例，攻击者利用这个代码在32位系统上：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a 64-bit system, the VDSO contains at least two locations where the syscall
    instruction is used. The attacker can manipulate either of these.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位系统上，VDSO包含至少两个使用syscall指令的位置。攻击者可以操纵其中任何一个。
- en: 'The following is a code example in which the attacker takes advantage of this
    code on a 64-bit system:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，攻击者利用这个代码在64位系统上：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Shared object loading – legitimate or not?
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享对象加载-合法与否？
- en: The dynamic linker is the only legitimate way to bring a shared library into
    a process. Remember, however, that an attacker can use the `__libc_dlopen_mode`
    function, which invokes the dynamic linker to load an object. So how do we tell
    when the dynamic linker is doing legitimate work? There are three legitimate ways
    in which a shared object is mapped to a process by the dynamic linker.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器是将共享库引入进程的唯一合法方式。但是，请记住，攻击者可以使用`__libc_dlopen_mode`函数，该函数调用动态链接器来加载对象。那么我们如何知道动态链接器是否在进行合法工作呢？有三种合法的方式，动态链接器将共享对象映射到进程中。
- en: Legitimate shared object loading
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合法的共享对象加载
- en: 'Let''s look at what we consider legitimate shared object loading:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们认为是合法的共享对象加载的方式：
- en: There is a valid `DT_NEEDED` entry in the executable program that corresponds
    to the shared library file.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行程序中有一个有效的`DT_NEEDED`条目，对应于共享库文件。
- en: The shared libraries that are validly loaded by the dynamic linker may in turn
    have their own `DT_NEEDED` entries in order to load other shared libraries. This
    can be called transitive shared library loading.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态链接器有效加载的共享库可能会有自己的`DT_NEEDED`条目，以便加载其他共享库。这可以称为传递式共享库加载。
- en: If a program is linked with `libdl.so`, then it may use the dynamic loading
    functions to load libraries on the fly. The function for loading shared objects
    is named `dlopen`, and the function for resolving symbols is named `dlsym`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序链接了`libdl.so`，那么它可以使用动态加载函数来动态加载库。加载共享对象的函数名为`dlopen`，解析符号的函数名为`dlsym`。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we have previously discussed, the `LD_PRELOAD` environment variable also
    invokes the dynamic linker, but this method is in a gray area as it is commonly
    used for both legitimate and illegitimate purposes. Therefore, it was not included
    in the list of *legitimate shared object loading*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，`LD_PRELOAD`环境变量也会调用动态链接器，但这种方法处于灰色地带，因为它通常用于合法和非法两种目的。因此，它没有包括在*合法的共享对象加载*列表中。
- en: Illegitimate shared object loading
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非法的共享对象加载
- en: 'Now, let''s take a look at the illegitimate ways in which a shared object can
    be loaded into a process, that is to say, by an attacker or a malware instance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看共享对象可以被加载到进程中的非法方式，也就是说，由攻击者或恶意软件实例：
- en: The `__libc_dlopen_mode` function exists within `libc.so` (not `libdl.so`) and
    is not intended to be called by a program. It is actually marked as a `GLIBC PRIVATE`
    function. Most processes have `libc.so`, and this is therefore a function commonly
    used by attackers or malware to load arbitrary shared objects.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__libc_dlopen_mode`函数存在于`libc.so`（而不是`libdl.so`）中，并且不打算由程序调用。它实际上被标记为`GLIBC
    PRIVATE`函数。大多数进程都有`libc.so`，因此这是攻击者或恶意软件常用的函数，用于加载任意共享对象。'
- en: '`VDSO` manipulation. As we have already demonstrated, this technique can be
    used to execute arbitrary syscalls, and therefore it can be simple to memory-map
    a shared object with this method.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VDSO`操纵。正如我们已经展示的，这种技术可以用于执行任意系统调用，因此可以简单地使用这种方法内存映射共享对象。'
- en: Shellcode that directly invokes the `open` and `mmap` system calls.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接调用`open`和`mmap`系统调用的Shellcode。
- en: The `DT_NEEDED` entries can be added by an attacker by overwriting the `DT_NULL`
    tag in the dynamic segment of an executable or shared library, thus being able
    to tell the dynamic linker to load whatever shared object they wish. This particular
    method was discussed in [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux*,
    and it falls more into the topic of that chapter, but it may also be necessary
    when inspecting a suspicious process.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者可以通过覆盖可执行文件或共享库的动态段中的`DT_NULL`标签来添加`DT_NEEDED`条目，从而能够告诉动态链接器加载他们希望加载的任何共享对象。这种特定方法在[第6章](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "第6章。Linux中的ELF二进制取证")中已经讨论过，更多地属于那一章的主题，但在检查可疑进程时可能也是必要的。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to inspect the binary of a suspicious process, and verify that the dynamic
    segment doesn't appear suspicious. Refer to the *Checking the dynamic segment
    for DLL injection traces* section of [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查可疑进程的二进制，并验证动态段是否看起来可疑。参考[第6章](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "第6章。Linux中的ELF二进制取证")中的*检查动态段以查找DLL注入痕迹*部分。
- en: Now that we have a clear definition of legitimate versus illegitimate loading
    of shared objects, we can get into the discussion of heuristics for detecting
    when a shared library is legitimate or not.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地定义了合法与非法加载共享对象的标准，我们可以开始讨论检测共享库是否合法的启发式方法。
- en: Beforehand, it is worth noting again that `LD_PRELOAD` is commonly used for
    good as well as bad purposes, and the only sure-fire way of knowing this is by
    inspecting what the actual code that resides in the preloaded shared object does.
    Therefore, we will leave `LD_PRELOAD` out of the discussion on heuristics here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`LD_PRELOAD`通常用于好坏两种目的，唯一确定的方法是检查预加载的共享对象中实际的代码。因此，在这里的启发式讨论中，我们将不讨论`LD_PRELOAD`。
- en: Heuristics for .so injection detection
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .so注入检测的启发式方法
- en: In this section, I will describe the general principles behind detecting whether
    a shared library is legitimate or not. In [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*, we will be discussing the ECFS technology, which
    actually incorporates these heuristics into its feature set.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将描述检测共享库是否合法的一般原则。在[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章。ECFS – 扩展核心文件快照技术")中，我们将讨论ECFS技术，该技术实际上将这些启发式方法纳入了其功能集中。
- en: 'For now, let''s look at the principles only. We want to get a list of the shared
    libraries that are mapped to the process and then see which ones qualify for being
    legitimately loaded by the dynamic linker:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只看原则。我们想要获取映射到进程的共享库列表，然后查看哪些符合动态链接器的合法加载条件：
- en: Get a list of shared object paths from the `/proc/<pid>/maps` file.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/proc/<pid>/maps`文件中获取共享对象路径列表。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some maliciously injected shared libraries won't appear as file mappings because
    the attacker created anonymous memory mappings and then memcpy'd the shared object
    code into those memory regions. In the next chapter, we will see that ECFS can
    weed these more stealthy entities out as well. A scan can be done of each executable
    memory region that is anonymously mapped to see whether ELF headers exist, particularly
    those with the `ET_DYN` file type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意注入的共享库不会出现为文件映射，因为攻击者创建了匿名内存映射，然后将共享对象代码复制到这些内存区域中。在下一章中，我们将看到ECFS也可以清除这些更隐秘的实体。可以扫描每个匿名映射到可执行内存区域，以查看是否存在ELF头，特别是具有`ET_DYN`文件类型的头。
- en: Determine whether or not a valid `DT_NEEDED` entry exists in the executable
    that corresponds to the shared library you are seeing. If one exists, then it
    is a legitimate shared library. After you have verified that a given shared library
    is legitimate, check that shared library's dynamic segment and enumerate the `DT_NEEDED`
    entries within it. Those corresponding shared libraries can also be marked as
    legitimate. This goes back to the concept of transitive shared object loading.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定可执行文件中是否存在与您所看到的共享库对应的有效`DT_NEEDED`条目。如果存在，则它是合法的共享库。在验证了给定的共享库是合法的之后，检查该共享库的动态段，并枚举其中的`DT_NEEDED`条目。这些对应的共享库也可以标记为合法的。这回到了传递共享对象加载的概念。
- en: 'Look at the `PLT/GOT` of the process''s actual executable program. If there
    are any `dlopen` calls being used, then analyze the code to find any calls to
    `dlopen`. The `dlopen` calls may be passed arguments that can be inspected statically,
    like this for instance:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看进程的实际可执行程序的`PLT/GOT`。如果使用了任何`dlopen`调用，则分析代码以查找任何`dlopen`调用。`dlopen`调用可能会传递静态检查的参数，例如：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In such cases, the string will be stored as a static constant and will therefore
    be in the `.rodata` section of the binary. So, check whether the `.rodata` section
    (or wherever the string is stored) contains any strings that contain the shared
    library path you are trying to validate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字符串将被存储为静态常量，因此将位于二进制文件的`.rodata`部分。因此，检查`.rodata`部分（或者存储字符串的任何地方）是否包含任何包含您要验证的共享库路径的字符串。
- en: If any of the shared object paths found in the maps file cannot be found or
    accounted for by a `DT_NEEDED` section and cannot be accounted for by any `dlopen`
    calls either, then that means it was either preloaded by `LD_PRELOAD` or injected
    by some other means. At this point, you should qualify the shared object as suspicious.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在maps文件中找到的任何共享对象路径找不到或者不能由`DT_NEEDED`部分解释，并且也不能由任何`dlopen`调用解释，那么这意味着它要么是由`LD_PRELOAD`预加载，要么是由其他方式注入的。在这一点上，您应该将共享对象标记为可疑。
- en: Tools for detecting PLT/GOT hooks
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于检测PLT/GOT挂钩的工具
- en: 'Currently, there are not many great tools that are specifically for process
    memory analysis in Linux. This is the reason that I designed ECFS (discussed in
    [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985 "Chapter 8. ECFS
    – Extended Core File Snapshot Technology"), *ECFS – Extended Core File Snapshot
    Technology*). There are only a few tools I know of that can detect PLT/GOT overwrites,
    and each one of them essentially uses the same heuristics that we just discussed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Linux中没有太多专门用于进程内存分析的好工具。这就是我设计ECFS的原因（在[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章 ECFS – 扩展核心文件快照技术")中讨论，“ECFS – 扩展核心文件快照技术”）。我知道的只有几个工具可以检测PLT/GOT覆盖，它们每一个基本上都使用我们刚刚讨论的相同的启发式方法：
- en: '**Linux VMA Voodoo**: This tool is a prototype that I designed through the
    DARPA CFT program in 2011\. It is capable of detecting many types of process memory
    infections, but currently only works on 32-bit systems and is not available to
    the public. However, the new ECFS utility is open source, which was inspired by
    VMA Voodoo. You may read about VMA Voodoo at [http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux VMA Voodoo：这个工具是我在2011年通过DARPA CFT计划设计的原型。它能够检测许多类型的进程内存感染，但目前只能在32位系统上运行，而且不对公众开放。然而，新的ECFS实用程序是开源的，受到VMA
    Voodoo的启发。您可以在[http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu)了解VMA
    Voodoo。
- en: '**ECFS (Extended core file snapshot) technology**: This technology was originally
    designed to work as a native snapshot format for process memory forensics tools
    in Linux. It has evolved into something even more than that and has an entire
    chapter dedicated to it ([Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*). It can be found at [https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECFS（扩展核心文件快照）技术：这项技术最初是为了在Linux中作为本机快照格式用于进程内存取证工具而设计的。它已经发展成为更多的东西，并且有一个专门的章节介绍它（[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章 ECFS – 扩展核心文件快照技术")，“ECFS – 扩展核心文件快照技术”）。它可以在[https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)找到。
- en: '**Volatility plt_hook**: The Volatility software is primarily geared towards
    full system memory analysis, but Georg Wicherski designed a plugin in 2013 that
    is specifically for detecting PLT/GOT infections within a process. This plugin
    uses heuristics similar to those that we previously discussed. This feature has
    now merged with the Volatility source code at [https://github.com/volatilityfoundation/volatility](https://github.com/volatilityfoundation/volatility).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Volatility plt_hook：Volatility软件主要用于全系统内存分析，但Georg Wicherski在2013年设计了一个插件，专门用于检测进程内的PLT/GOT感染。这个插件使用了我们之前讨论的类似的启发式方法。这个功能现在已经与Volatility源代码合并在一起，可以在[https://github.com/volatilityfoundation/volatility](https://github.com/volatilityfoundation/volatility)找到。
- en: Linux ELF core files
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux ELF核心文件
- en: In most UNIX flavored OSes, a process can be delivered a signal so that it dumps
    a core file. A core file is essentially a snapshot of the process and its state
    right before it cored (crashed or dumped). A core file is a type of ELF file that
    is primarily made up of program headers and memory segments. They also contain
    a fair amount of notes in the `PT_NOTE` segment that describe file mappings, shared
    library paths, and other information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数UNIX风格的操作系统中，可以向进程发送信号，以便它转储核心文件。核心文件本质上是进程及其状态在核心（崩溃或转储）之前的快照。核心文件是一种ELF文件，主要由程序头和内存段组成。它们还包含大量的注释，描述文件映射、共享库路径和其他信息。
- en: A core file by itself is not especially useful for process memory forensics,
    but it may yield some results to the more astute analyst.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 核心文件本身对于进程内存取证并不特别有用，但对于更敏锐的分析师可能会产生一些结果。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is actually where ECFS comes into the picture; it is an extension of the
    regular Linux ELF core format and provides features that are specifically for
    forensic analysis.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是ECFS介入的地方；它是常规Linux ELF核心格式的扩展，并提供了专门用于取证分析的功能。
- en: Analysis of the core file – the Azazel rootkit
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心文件的分析- Azazel rootkit
- en: Here, we will infect a process with the azazel rootkit using the `LD_PRELOAD`
    environment variable, and then deliver an abort signal to the process so that
    we can capture a core dump for analysis.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`LD_PRELOAD`环境变量感染一个进程，然后向该进程发送中止信号，以便我们可以捕获用于分析的核心转储。
- en: Starting up an Azazel infected process and getting a core dump
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动Azazel感染的进程并获取核心转储
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Core file program headers
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心文件程序头
- en: In a core file, there are many program headers. All of them except one are of
    the `PT_LOAD` type. There is a `PT_LOAD` program header for every single memory
    segment in the process, with the exception of special devices (that is `/dev/mem`).
    Everything from shared libraries and anonymous mappings to the stack, the heap,
    text, and data segments is represented by a program header.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心文件中，有许多程序头。除了一个之外，所有程序头都是`PT_LOAD`类型。对于进程中的每个内存段，都有一个`PT_LOAD`程序头，特殊设备（即`/dev/mem`）除外。从共享库和匿名映射到堆栈、堆、文本和数据段，所有内容都由程序头表示。
- en: Then, there is one program header of the `PT_NOTE` type; it contains the most
    useful and descriptive information in the entire core file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一个`PT_NOTE`类型的程序头；它包含了整个核心文件中最有用和描述性的信息。
- en: The PT_NOTE segment
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PT_NOTE段
- en: 'The `eu-readelf -n` output that is shown next shows the parsing of the core
    file notes segment. The reason we used `eu-readelf` here instead of the regular
    `readelf` is that eu-readelf (the ELF Utils version) takes time to parse each
    entry in the notes segment, whereas the more commonly used `readelf` (the binutils
    version) only shows the `NT_FILE` entry:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来显示的`eu-readelf -n`输出显示了核心文件注释段的解析。我们之所以在这里使用`eu-readelf`而不是常用的`readelf`，是因为eu-readelf（ELF
    Utils版本）需要时间来解析注释段中的每个条目，而更常用的`readelf`（binutils版本）只显示`NT_FILE`条目：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Being able to view the register state, auxiliary vector, signal information,
    and file mappings is not bad news at all, but they are not enough by themselves
    to analyze a process for malware infection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 能够查看寄存器状态、辅助向量、信号信息和文件映射并不是坏消息，但它们本身还不足以分析进程的恶意软件感染。
- en: PT_LOAD segments and the downfalls of core files for forensics purposes
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PT_LOAD段和核心文件在取证目的上的缺陷
- en: Each memory segment contains a program header that describes the offset, address,
    and size of the segment it represents. This would almost suggest that you can
    access every part of a process image through the program segments, but this is
    only partially true. The text image of the executable and every shared library
    that is mapped to the process get only the first 4,096 bytes of themselves dumped
    into a segment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内存段都包含一个程序头，描述了它所代表的段的偏移量、地址和大小。这几乎表明你可以通过程序段访问进程镜像的每个部分，但这只是部分正确的。可执行文件的文本镜像和映射到进程的每个共享库只有自己的前4,096字节被转储到一个段中。
- en: This is for saving space and because the Linux kernel developers figured that
    the text segment will not be modified in memory. So, it suffices to reference
    the original executable file and shared libraries when accessing the text areas
    from a debugger. If a core file were to dump the complete text segment for every
    shared library, then for a large program such as Wireshark or Firefox, the output
    core dump files would be enormous.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了节省空间，因为Linux内核开发人员认为文本段不会在内存中被修改。因此，在访问文本区域时，只需引用原始可执行文件和共享库即可满足调试器的需求。如果核心文件要为每个共享库转储完整的文本段，那么对于诸如Wireshark或Firefox之类的大型程序，输出的核心转储文件将是巨大的。
- en: So for debugging reasons, it is usually okay to assume that the text segments
    have not changed in memory, and to just reference the executable and shared library
    files themselves to get the text. But what about runtime malware analysis and
    process memory forensics? In many cases, the text segments have been marked as
    writeable and contain polymorphic engines for code mutation, and in these instances,
    core files may be useless for viewing the code segments.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，出于调试目的，通常可以假设文本段在内存中没有发生变化，并且只需引用可执行文件和共享库文件本身来获取文本。但是对于运行时恶意软件分析和进程内存取证呢？在许多情况下，文本段已被标记为可写，并包含用于代码变异的多态引擎，在这些情况下，核心文件可能无法用于查看代码段。
- en: Also, what if the core file is the only artifact available for analysis and
    the original executable and shared libraries are no longer accessible? This further
    demonstrates why core files are not particularly good for process memory forensics;
    nor were they ever meant to be.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果核心文件是唯一可用于分析的工件，原始可执行文件和共享库已不再可访问呢？这进一步证明了为什么核心文件并不特别适合进程内存取证；也从未打算如此。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we will see how ECFS addresses many of the weaknesses that
    render core files a useless artifact for forensic purposes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到ECFS如何解决许多使核心文件成为取证目的无用工件的弱点。
- en: Using a core file with GDB for forensics
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GDB进行取证的核心文件
- en: 'Combined with the original executable file, and assuming that no code modifications
    were made (to the text segment), we can still use core files to some avail for
    malware analysis. In this particular case, we are looking at a core file for the
    Azazel rootkit, which—as we demonstrated earlier in this chapter—has PLT/GOT hooks:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结合原始可执行文件，并假设没有对代码进行修改（对文本段），我们仍然可以在一定程度上使用核心文件进行恶意软件分析。在这种特殊情况下，我们正在查看Azazel
    rootkit的核心文件，正如我们在本章前面所演示的那样，它具有PLT/GOT钩子：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, let''s take a look at the function that we already know is hijacked by
    Azazel. The `fopen` function is one of the four shared library functions in the
    infected program, and as we can see from the preceding output, it has a GOT entry
    at `0x601040`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看一下我们已经知道被Azazel劫持的函数。`fopen`函数是受感染程序中的四个共享库函数之一，正如我们从前面的输出中可以看到的，它在`0x601040`处有一个GOT条目：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we look again at the `NT_FILE` entry in the `PT_NOTE` segment (`readelf
    -n core`), we can see at what address range the `libc-2.19.so` file is mapped
    to the memory, and check whether or not the GOT entry for fopen is pointing to
    `libc-2.19.so` as it should be:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看`PT_NOTE`段中的`NT_FILE`条目（`readelf -n core`），我们可以看到`libc-2.19.so`文件在内存中映射到的地址范围，并检查`fopen`的GOT条目是否指向了`libc-2.19.so`，正如它应该的那样：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `fopen@got.plt` points to `0x7ff1673a8609`. This is outside of the `libc-2.19.so`
    text segment range displayed previously, which is `0x7ff166fe0000` to `0x7ff16719b000`.
    Examining a core file with GDB is very similar to examining a live process with
    GDB, and you can use the same method shown next to locate the environment variables
    and check whether `LD_PRELOAD` has been set.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen@got.plt`指向`0x7ff1673a8609`。这超出了之前显示的`libc-2.19.so`文本段范围，即`0x7ff166fe0000`到`0x7ff16719b000`。使用GDB检查核心文件与使用GDB检查实时进程非常相似，您可以使用下面显示的相同方法来定位环境变量并检查`LD_PRELOAD`是否已设置。'
- en: 'Here''s an example of locating environment variables in a core file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在核心文件中定位环境变量的示例：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The art of process memory forensics is a very specific aspect of forensic work.
    It obviously focuses primarily on memory pertaining to a process image, which
    is quite complicated even on its own, as it requires intricate knowledge about
    CPU registers, the stack, dynamic linking, and ELF as a whole.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 进程内存取证的艺术是法证工作的一个非常特定的方面。它主要关注与进程图像相关的内存，这本身就相当复杂，因为它需要对CPU寄存器、堆栈、动态链接和ELF有复杂的了解。
- en: Therefore, being proficient in inspecting a process for anomalies is truly an
    art and a skill that builds on itself through experience. This chapter served
    as a primer for the subject so that the beginner can get some insights into how
    they should get started. In the next chapter, we will be discussing process forensics,
    and you will learn how the ECFS technology can make it much easier.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，熟练地检查进程中的异常确实是一种通过经验不断积累的艺术和技能。本章作为该主题的入门指南，让初学者能够了解如何开始。在下一章中，我们将讨论进程取证，您将了解ECFS技术如何使其变得更加容易。
- en: After you have completed this chapter and the next, I recommend that you use
    some of the tools cited in this chapter to infect some processes on your system
    and experiment with the ways of detecting them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章和下一章之后，我建议您使用本章中引用的一些工具在您的系统上感染一些进程，并尝试检测它们的方法。
