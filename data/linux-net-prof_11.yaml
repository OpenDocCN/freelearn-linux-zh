- en: '*Chapter 8*: Certificate Services on Linux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：Linux上的证书服务'
- en: In this chapter, we'll cover several topics that involve using certificates
    in securing or encrypting traffic, and in particular configuring and using various
    **Certificate Authority** (**CA**) servers in Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖几个涉及在Linux中使用证书来保护或加密流量，并特别是配置和使用各种**证书颁发机构**（**CA**）服务器的主题。
- en: We'll cover the basics of how these certificates can be used, and then progress
    on to building a certificate server. Finally, we'll look at security considerations
    around certificate services, both in protecting CA infrastructures and using **Certificate
    Transparency** (**CT**) to enforce the trust model, and for inventory/audit or
    reconnaissance within an organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍这些证书的基本用途，然后继续构建证书服务器。最后，我们将讨论围绕证书服务的安全考虑，无论是在保护CA基础设施还是使用**证书透明度**（**CT**）来强制信任模型，以及在组织内进行清单/审计或侦察。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are certificates?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书是什么？
- en: Acquiring a certificate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取证书
- en: Using a certificate—web server example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证书-Web服务器示例
- en: Building a private Certificate Authority
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建私有证书颁发机构
- en: Securing your Certificate Authority infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的证书颁发机构基础设施
- en: Certificate Transparency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书透明度
- en: Certificate automation and the **Automated Certificate Management Environment**
    (**ACME**) protocol
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书自动化和**自动证书管理环境**（**ACME**）协议
- en: '`OpenSSL` cheat sheet'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenSSL`速查表'
- en: When we've completed this chapter, you'll have a working private CA on your
    Linux host, with a good idea of how certificates are issued and how to both manage
    and secure your CA, whether you are using it in a lab or a production environment.
    You'll also have a solid understanding of how a standard certificate handshake
    works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成本章时，您将在Linux主机上拥有一个可用的私有CA，并且对证书的发放方式以及如何管理和保护您的CA都有一个很好的理解，无论您是在实验室还是生产环境中使用它。您还将对标准证书握手的工作原理有很好的理解。
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we can continue to use the same Ubuntu **virtual machine**
    (**VM**) or workstation that we've been using to date, as this is a learning exercise.
    Even in sections where we're acting as both a CA and a certificate applicant,
    the examples in this section can all be completed on this single host.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们可以继续使用同一台Ubuntu **虚拟机**（**VM**）或工作站，因为这是一个学习练习。即使在我们既是CA又是证书申请人的部分，本节中的示例也都可以在这一台主机上完成。
- en: Given that we're building a certificate server, though, if you are using this
    guide to help in building a production host, it's strongly suggested that you
    build this on a separate host or VM. A VM is preferred for a production service—read
    the *Securing your CA infrastructure* section for more on this recommendation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们正在构建证书服务器，如果您正在使用此指南来帮助构建生产主机，强烈建议您在单独的主机或虚拟机上构建。虚拟机是生产服务的首选-请阅读“保护您的CA基础设施”部分，了解更多建议。
- en: What are certificates?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书是什么？
- en: 'Certificates are essentially *attestations of truth*—in other words, a certificate
    is a document that says, *trust me, this is true*. This sounds simple, and in
    some ways it is. But in other ways, the various uses of certificates and deploying
    a CA infrastructure securely is a significant challenge—for instance, we''ve seen
    some spectacular failings in public CAs in recent years: companies whose only
    business was securing the certificate process couldn''t get it right when under
    scrutiny. We cover the challenges and solutions in securing CAs in more detail
    later in this chapter, in the *Securing your CA infrastructure* and *CT* sections.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 证书本质上是*真相的证明* - 换句话说，证书是一份声明，“相信我，这是真的”。这听起来很简单，某种程度上确实如此。但在其他方面，证书的各种用途以及安全地部署CA基础设施是一个重大挑战-例如，我们在最近几年看到了一些公共CA的惊人失败：那些唯一业务是保护证书流程的公司在受到审查时却无法做到。我们将在本章后面的*保护您的CA基础设施*和*CT*部分更详细地介绍保护CA的挑战和解决方案。
- en: At the root of things, workstations and servers have a list of CAs that they
    trust. This trust is delivered using cryptographically signed documents that are
    the public certificates of each of those CAs, which are stored in a specific place
    on a Linux or Windows host.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，工作站和服务器都信任一系列CA。这种信任是通过使用加密签名的文档来传递的，这些文档是每个CA的公共证书，存储在Linux或Windows主机的特定位置上。
- en: When you browse to a web server, for instance, that local *certificate store*
    is referenced to see if we should trust the web server's certificate. This is
    done by looking at the public certificate of that web server and seeing if it
    was signed by one of your trusted CAs (or a subordinate of one of your trusted
    CAs). The use of *child* or *subordinate* CAs for actual signing is common—each
    public CA wants to protect its *root* CA as much as possible, so *subordinate
    CAs* or *issuing CAs* are created, which are the ones that the public internet
    sees.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您浏览到一个Web服务器时，本地的*证书存储*会被引用，以查看我们是否应该信任Web服务器的证书。这是通过查看该Web服务器的公共证书，并查看它是否由您信任的CA之一（或其下属）签名而完成的。实际签名使用*子*或*下属*
    CA是常见的-每个公共CA都希望尽可能保护其*根* CA，因此创建了*下属CA*或*颁发CA*，这些是公共互联网所见的。
- en: Organizations can create their own CAs, to be used for authentication and authorization
    between their users, servers, workstations, and network infrastructure. This keeps
    that trust *within the family*, so to speak—completely under the control of the
    organization. It also means that the organization can use internal and free certificate
    services rather than paying for hundreds or thousands of workstations or user
    certificates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以创建自己的CA，用于验证其用户、服务器、工作站和网络基础设施之间的身份和授权。这使得信任保持在“家庭”内，完全受到组织的控制。这也意味着组织可以使用内部和免费的证书服务，而不必为数百或数千个工作站或用户证书付费。
- en: Now that we know what a certificate is, let's look at how they are issued.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了证书是什么，让我们看看它们是如何颁发的。
- en: Acquiring a certificate
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取证书
- en: 'In the following diagram, an application—for instance, a web server—needs a
    certificate. This diagram looks complex, but we''ll break it down into simple
    steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，一个应用程序 - 例如，一个Web服务器 - 需要一个证书。这个图看起来复杂，但我们将把它分解成简单的步骤：
- en: '![Figure 8.1 – Certificate signing request (CSR) and issuing a certificate'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 证书签名请求（CSR）和颁发证书'
- en: '](img/B16336_08_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_08_001.jpg)'
- en: Figure 8.1 – Certificate signing request (CSR) and issuing a certificate
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 证书签名请求（CSR）和颁发证书
- en: 'Let''s walk through the steps involved in creating a certificate, right from
    the initial request to having a certificate ready to install in the target application
    (*Steps 1-6*), as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解创建证书涉及的步骤，从最初的请求到准备在目标应用程序中安装证书（*步骤1-6*），如下所示：
- en: The process starts by creating a CSR. This is simply a short text file that
    identifies the server/service and the organization that is requesting the certificate.
    This file is cryptographically "obfuscated"—while the fields are standardized
    and are just text, the final result is not human-readable. Tools such as OpenSSL,
    however, can read both CSR files and certificates themselves (see the *OpenSSL
    cheat sheet* section at the end of this chapter if you need examples of this).
    The text information for a CSR includes some—or all—of these standard fields:![](img/B16336_08_Table_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程从创建CSR开始。这只是一个简短的文本文件，用于标识请求证书的服务器/服务和组织。这个文件在加密时被“混淆” - 虽然字段是标准化的，只是文本，但最终结果不是人类可读的。然而，诸如OpenSSL之类的工具可以读取CSR文件和证书本身（如果需要示例，请参见本章末尾的*OpenSSL备忘单*部分）。CSR的文本信息包括这些标准字段的一些或全部：![](img/B16336_08_Table_01.jpg)
- en: The preceding list is not an exhaustive list of fields that can be used in a
    CSR, but these are the ones most commonly seen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并非CSR中可以使用的字段的详尽列表，但这些是最常见的字段。
- en: The reason we need all this information is so that when a client connects to
    the service that's using a certificate (for instance, a web server using **HyperText
    Transfer Protocol Secure** (**HTTPS**) and **Transport Layer Security** (**TLS**)),
    the client can verify that the server name being connected to matches the CN field
    or one of the SAN entries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要所有这些信息的原因是，当客户端连接到使用证书的服务时（例如，使用**超文本传输安全协议**（**HTTPS**）和**传输层安全**（**TLS**）的Web服务器），客户端可以验证连接到的服务器名称是否与CN字段或其中一个SAN条目匹配。
- en: This makes it important that the CA operator verifies this information. For
    a public-facing certificate, this is done by the operator/vendor verifying the
    company name, email, and so on. Automated solutions accomplish this by verifying
    that you have administrative control over the domain or host.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得CA操作员验证这些信息变得很重要。对于面向公众的证书，操作员/供应商通过验证公司名称、电子邮件等信息来完成这一过程。自动化解决方案通过验证您对域或主机具有管理控制权来实现这一点。
- en: Still sticking with *Figure 8.1*, this text information is next cryptographically
    combined with the public key of the applicant, to form the `CSR` file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然遵循*图8.1*，接下来将这些文本信息与申请人的公钥加密组合，形成`CSR`文件。
- en: The now-completed CSR is sent to the CA. When the CA is a public CA, this is
    often done via a website. Automated public CAs such as **Let's Encrypt** often
    use the ACME **application programming interface** (**API**) for communications
    between the applicant and the CA. In higher-stake implementations, *Steps 3* and
    *6* might use secure media, physically handed off between trusted parties using
    formal *chain-of-custody* procedures. The important thing is that the communication
    between the applicant and the CA uses some secure method. While less secure methods
    such as email are possible, they are not recommended.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在完成的CSR被发送到CA。当CA是公共CA时，通常通过网站完成。自动化的公共CA（如**Let's Encrypt**）通常使用ACME **应用程序编程接口**（**API**）在申请人和CA之间进行通信。在高风险的实施中，*步骤3*和*6*可能使用安全媒体，通过正式的*保管链*程序在受信任的各方之间物理交接。重要的是申请人和CA之间的通信使用一些安全的方法。虽然可能存在较不安全的方法，如电子邮件，但不建议使用。
- en: At the CA, the identity information (we're still following the information flow
    in *Figure 8.1*) is validated. This can be an automated or a manual process, depending
    on several factors. For instance, if this is a public CA, you may already have
    an account, which would make a semi-automated check more likely. If you don't
    have an account, this check is most likely manual. For a private CA, this process
    may be entirely automated.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CA处，身份信息（我们仍然遵循*图8.1*中的信息流）得到验证。这可能是一个自动化或手动的过程，取决于几个因素。例如，如果这是一个公共CA，您可能已经有一个帐户，这将使半自动化检查更有可能。如果您没有帐户，这个检查很可能是手动的。对于私人CA，这个过程可能是完全自动化的。
- en: Once validated, the validated CSR is cryptographically combined with the CA's
    private key to create a final certificate.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦验证，验证的CSR将与CA的私钥加密组合，创建最终的证书。
- en: This certificate is then sent back to the applicant and is ready for installation
    into the application where it will be used.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将此证书发送回申请人，并准备安装到将使用该证书的应用程序中。
- en: Note that the applicant's private key is never used in this transaction—we'll
    see where it gets used in the TLS key exchange (in the very next section of this
    chapter).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此交易中，申请人的私钥从未被使用 - 我们将在TLS密钥交换中看到它在哪里使用（在本章的下一节）。
- en: Now that we understand how a certificate is created or issued, how does an application
    use a certificate for trusting a service or encrypting session traffic? Let's
    look at the interaction between a browser and a TLS-protected website to see how
    this works.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了证书是如何创建或发布的，应用程序如何使用证书来信任服务或加密会话流量呢？让我们看看浏览器和受TLS保护的网站之间的交互，以了解这是如何工作的。
- en: Using a certificate – web server example
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用证书 - Web服务器示例
- en: When asked, most people would say that the most common use for certificates
    is to secure websites, using the HTTPS protocol. While this may not be the most
    common use for certificates in today's internet, it certainly remains the most
    visible. Let's discuss how a web server's certificate is used to provide trust
    in the server and help establish an encrypted HTTPS session.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及时，大多数人会说证书最常见的用途是使用HTTPS协议保护网站。虽然这可能不是当今互联网上证书最常见的用途，但它确实仍然是最显眼的。让我们讨论一下Web服务器的证书如何用于在服务器中提供信任并帮助建立加密的HTTPS会话。
- en: If you remember our *applicant* in our CSR example, in this example that applicant
    is the website [www.example.com](http://www.example.com), which might reside on
    the web server, for instance. We'll start our example where the previous session
    left off—the certificate is issued and is installed on the web server, ready for
    client connections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们CSR示例中的*申请人*，在这个例子中，申请人是[www.example.com](http://www.example.com)这个网站，可能驻留在Web服务器上。我们将从上一个会话结束的地方开始我们的例子——证书已经颁发并安装在Web服务器上，准备好接受客户端连接。
- en: '**Step 1**: The client makes an initial HTTPS request to the web server, called
    a **CLIENT HELLO** (*Figure 8.2*).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1**：客户端向Web服务器发出初始的HTTPS请求，称为**客户端HELLO**（*图8.2*）。'
- en: 'In this initial *Hello* exchange, the client sends the following to the server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始的*Hello*交换中，客户端向服务器发送以下内容：
- en: The TLS versions that it supports
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持的TLS版本
- en: The encryption ciphers that it supports
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持的加密密码
- en: 'This process is illustrated in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在下面的图表中有所说明：
- en: '![Figure 8.2 – TLS communication starts with a client hello'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – TLS通信从客户端hello开始'
- en: '](img/B16336_08_002.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_08_002.jpg)'
- en: Figure 8.2 – TLS communication starts with a client hello
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – TLS通信从客户端hello开始
- en: The web server replies by sending its certificate. If you remember, the certificate
    contains several bits of information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器通过发送其证书进行回复。如果你还记得，证书包含几个信息。
- en: '**Step 2**: The web server replies by sending its certificate (*Figure 8.3*).
    If you remember, the certificate contains several bits of information, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2**：Web服务器通过发送其证书（*图8.3*）进行回复。如果你还记得，证书包含以下几个信息：'
- en: The text information that states the identity of the server
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈述服务器身份的文本信息
- en: The public key of the web server/service
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器/服务的公钥
- en: The identity of the CA
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CA的身份
- en: 'The server also sends the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还发送以下内容：
- en: Its supported TLS versions
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的TLS版本
- en: Its first proposal on the cipher (usually the highest-strength cipher in the
    client list that the server supports)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在密码中的第一个提议（通常是服务器支持的客户端列表中最高强度的密码）
- en: 'The process is illustrated in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在下面的图表中有所说明：
- en: '![Figure 8.3 – TLS exchange: server hello is sent and certificate is validated
    by the client'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – TLS交换：服务器hello被发送并由客户端验证'
- en: '](img/B16336_08_003.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_08_003.jpg)'
- en: 'Figure 8.3 – TLS exchange: server hello is sent and certificate is validated
    by the client'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – TLS交换：服务器hello被发送并由客户端验证
- en: '**Step 3**: The client receives this certificate and the rest of the information
    (called the server hello), and then (shown next in *Figure 8.4*) validates a few
    pieces of information, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3**：客户端接收此证书和其他信息（称为服务器hello），然后（如*图8.4*中所示）验证一些信息，如下所示：'
- en: Is the identity of the server that I requested in the certificate that I just
    received (usually this will be in the CN field or the SAN field)?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我刚刚收到的证书中是否包含我请求的服务器的身份（通常会在CN字段或SAN字段中）？
- en: Does today's date/time fall between the certificate's *after* and *before* dates
    (that is, has the certificate expired)?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的日期/时间是否在证书的*之后*和*之前*日期之间（也就是说，证书是否已过期）？
- en: Do I trust the CA? It will verify this by looking in its certificate store,
    where the public certificates of several CAs are typically located (several public
    CAs, and often one or more private CAs that are used within the organization).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我信任CA吗？它将通过查看其证书存储来验证这一点，其中通常包含几个CA的公共证书（几个公共CA，通常还有一个或多个在组织内部使用的私有CA）。
- en: The client also has the opportunity to check if the certificate has been revoked,
    by sending a request to an **Online Certificate Status Protocol** (**OCSP**) server.
    The older method of checking a **certificate revocation list** (**CRL**) is still
    supported but is not used much anymore—this list was proven to not scale well
    with thousands of revoked certificates. In modern implementations, the CRL normally
    consists of public CA certificates that have been revoked rather than regular
    server certificates.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端还有机会通过向**在线证书状态协议**（**OCSP**）服务器发送请求来检查证书是否已被吊销。检查**证书吊销列表**（**CRL**）的旧方法仍然受到支持，但不再经常使用——这个列表被证明在成千上万的吊销证书中不太适用。在现代实现中，CRL通常由已吊销的公共CA证书组成，而不是常规服务器证书。
- en: The *trust* and *revocation* checks are extremely important. These validate
    that the server is who it claims to be. If these checks aren't done, then anyone
    could stand up a server claiming to be your bank, and your browser would just
    let you log in to those malicious servers. Modern-day phishing campaigns often
    try to *game the system* by *lookalike domains* and other methods to get you to
    do just that.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任*和*吊销*检查非常重要。这些检查验证服务器是否是其所声称的。如果这些检查没有进行，那么任何人都可以建立一个声称是你的银行的服务器，你的浏览器就会让你登录到这些恶意服务器上。现代网络钓鱼活动经常试图通过*相似域*和其他方法来*欺骗系统*，让你做这样的事情。'
- en: '**Step 4**: If the certificate passes all the checks on the client side, the
    client will generate a pseudo-random symmetric key (called a pre-master key).
    This is encrypted using the server''s public key and sent to the server (as shown
    in *Figure 8.4*). This key will be used to encrypt the actual TLS session.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**：如果证书在客户端通过了所有检查，客户端将生成一个伪随机对称密钥（称为预主密钥）。这个密钥使用服务器的公钥加密并发送给服务器（如*图8.4*所示）。这个密钥将用于加密实际的TLS会话。'
- en: The client is allowed to modify the cipher at this point. The final cipher is
    a negotiation between the client and the server—keep that in mind, as we'll dig
    a bit deeper into this when we talk about attacks and defenses. Long story short—the
    client normally doesn't change the cipher because the server has picked one that
    came from the client's list in the first place.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，客户端被允许修改密码。最终密码是客户端和服务器之间的协商-请记住这一点，因为当我们讨论攻击和防御时，我们将深入探讨这一点。长话短说-客户端通常不会更改密码，因为服务器已经选择了来自客户端列表的密码。
- en: 'The process is illustrated in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程在以下图表中说明：
- en: '![Figure 8.4 – Client key exchange and the server gets one last chance to change
    the cipher'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 客户端密钥交换，服务器有最后一次机会更改密码'
- en: '](img/B16336_08_004.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_08_004.jpg)'
- en: Figure 8.4 – Client key exchange and the server gets one last chance to change
    the cipher
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 客户端密钥交换，服务器有最后一次机会更改密码
- en: '**Step 5**: After this step, the server gets one last chance to change the
    cipher as well (still in *Figure 8.4*). This step usually doesn''t happen, and
    cipher negotiation is usually completed. The pre-master key is now final and is
    called the master secret.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤5**：在这一步之后，服务器也有最后一次更改密码的机会（仍在*图8.4*中）。这一步通常不会发生，密码协商通常已经完成。预主密钥现在已经最终确定，并称为主密钥。'
- en: '**Step 6**: Now that the certificate verification is all done and the ciphers
    and symmetric key are all agreed on, communications can proceed. Encryption is
    done using the symmetric key from the previous step.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤6**：现在证书验证已经完成，密码和对称密钥都已经达成一致，通信可以继续进行。加密是使用上一步的对称密钥进行的。'
- en: 'This is illustrated in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图表中说明：
- en: '![Figure 8.5 – Negotiation is complete and communication proceeds using the
    master secret (key) for encryption'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 协商完成，通信使用主密钥（密钥）进行加密进行'
- en: '](img/B16336_08_005.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_08_005.jpg)'
- en: Figure 8.5 – Negotiation is complete and communication proceeds using the master
    secret (key) for encryption
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 协商完成，通信使用主密钥（密钥）进行加密进行
- en: 'There are two important things to note in this exchange that are implied but
    not spelled out yet, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种交换中有两个重要的事情暗示但尚未明确说明，如下：
- en: Once the negotiation completes, the certificate is no longer used—encryption
    is done using the negotiated master secret key.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦协商完成，证书将不再使用-加密将使用协商的主密钥进行。
- en: During a normal negotiation, the CA is not needed. This will become an important
    point later, when we start discussing securing our organization's CA infrastructure.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正常的协商过程中，不需要CA。当我们开始讨论保护组织的CA基础设施时，这将成为一个重要的观点。
- en: Now that we have a better understanding of how certificates work (at least in
    this one use case), let's build a Linux-based CA for our organization. We'll do
    this a few different ways to give you some options in your own organization. We'll
    also use a CA in the next chapter, [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153),
    *RADIUS Services for Linux*, so this is an important set of examples to follow
    closely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对证书的工作原理有了更好的理解（至少在这个用例中），让我们为我们的组织构建一个基于Linux的CA。我们将以几种不同的方式进行此操作，以便为您的组织提供一些选项。我们还将在下一章[*第9章*]（B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153），*Linux的RADIUS服务*中使用CA，因此这是一组重要的示例，需要密切关注。
- en: Building a private Certificate Authority
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建私有证书颁发机构
- en: 'Building a private CA starts with the same decision we''ve faced with each
    of our infrastructure packages: *Which CA package should we use?* As with so many
    server solutions, there are several to pick from. A few options are outlined here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 构建私有CA始于我们面临的每个基础设施包的相同决定：*我们应该使用哪个CA包？*与许多服务器解决方案一样，有几种选择。以下概述了一些选项：
- en: '**OpenSSL** technically gives us all the tools we need to write our own scripts
    and maintain our own directory structure of **public key infrastructure** (**PKI**)
    bits and pieces. You can create root and subordinate CAs, make a CSR, and then
    sign those certificates to make real certificates. In practice, while this approach
    is universally supported, it ends up being a bit too far on the manual side of
    the spectrum for most people.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenSSL**在技术上为我们提供了编写自己的脚本和维护**公钥基础设施**（**PKI**）位和片段的目录结构的所有工具。您可以创建根和从属CA，制作CSR，然后签署这些证书以制作真正的证书。实际上，虽然这种方法得到了普遍支持，但对大多数人来说，它最终变得有点太过于手动化。'
- en: '**Certificate Manager** is a CA bundled with Red Hat Linux and related distributions.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书管理器**是与Red Hat Linux和相关发行版捆绑在一起的CA。'
- en: '**openSUSE** and related distributions can use the native **Yet another Setup
    Tool** (**YaST**) configuration and management tool as a CA.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**openSUSE**和相关发行版可以使用本机**另一种设置工具**（**YaST**）配置和管理工具作为CA。'
- en: '**Easy-RSA** is a set of scripts that are essentially a wrapper around the
    same OpenSSL commands.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Easy-RSA**是一组脚本，本质上是对相同的OpenSSL命令的包装。'
- en: '**Smallstep** implements more automation—it can be configured as a private
    ACME server and can easily allow your clients to request and fulfill their own
    certificates.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Smallstep**实现更多自动化-它可以配置为私有ACME服务器，并且可以轻松允许您的客户请求和履行其自己的证书。'
- en: '`LetsEncrypt` GitHub page and written in Go.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LetsEncrypt` GitHub页面并用Go编写。'
- en: As you can see, there are a reasonably large number of CA packages out there.
    Most of the older ones are wrappers around various OpenSSL commands. The newer
    ones have additional automation in place, specifically around the ACME protocol,
    which was pioneered by `LetsEncrypt`. Links to the documentation for each of the
    packages mentioned previously are in this chapter's *Further reading* list. As
    the most widely deployed Linux CA, we'll build our example CA server using OpenSSL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有相当多的CA包可供选择。大多数较旧的包都是对各种OpenSSL命令的包装。较新的包具有额外的自动化功能，特别是围绕ACME协议，这是由`LetsEncrypt`首创的。先前提到的每个包的文档链接都在本章的*进一步阅读*列表中。作为最广泛部署的Linux
    CA，我们将使用OpenSSL构建我们的示例CA服务器。
- en: Building a CA with OpenSSL
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OpenSSL构建CA
- en: Because we're only using commands that are included in almost every Linux distribution,
    there is nothing to install before we start our CA build using this method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只使用几乎每个Linux发行版都包含的命令，所以在开始使用此方法构建我们的CA之前，无需安装任何内容。
- en: 'Let''s start this process, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始这个过程：
- en: 'First, we''ll create a location for the CA. The `/etc/ssl` directory should
    already exist in your host''s file structure, we''ll add two new directories to
    that by running the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为CA创建一个位置。`/etc/ssl`目录应该已经存在于您的主机文件结构中，我们将通过运行以下代码向其中添加两个新目录：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, keep in mind that as certificates are issued, the CA needs to keep track
    of serial numbers (usually sequential), and also some details about each certificate
    as it''s issued. Let''s start the serial numbers in a `serial` file, at `1`, and
    create an empty `index` file to further track certificates, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请记住，随着证书的发放，CA需要跟踪序列号（通常是顺序的），以及关于每个证书的一些详细信息。让我们在`serial`文件中开始序列号，从`1`开始，并创建一个空的`index`文件来进一步跟踪证书，如下所示：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we''ll edit the existing `/etc/ssl/openssl.cnf` configuration file and
    navigate to the `[CA_default]` section. This section in the `default` file looks
    like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑现有的`/etc/ssl/openssl.cnf`配置文件，并导航到`[CA_default]`部分。默认文件中的此部分如下所示：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we'll create a self-signed root certificate. This is normal for the root
    of a private CA. (In a public CA, you would create a new CSR and get it signed
    by another CA, to provide a *chain* to a trusted root.)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个自签名的根证书。这对于私有CA的根是正常的。（在公共CA中，您将创建一个新的CSR并让另一个CA对其进行签名，以提供对受信任根的*链*。）
- en: 'Since this is an internal CA for an organization, we normally choose a long
    life for this so that we''re not rebuilding the entire CA infrastructure every
    year or two. Let''s choose 10 years (3,650 days). Note that this command asks
    for a passphrase (don''t lose this!) as well as other information that will identify
    the certificate. Note in the following code snippet that the `openssl` command
    creates a private key for the CA (`cakey.pem`) and the root certificate (`cacert.pem`)
    in one step. When prompted, use your own host and company information to fill
    in the requested values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个组织的内部CA，我们通常会选择一个很长的寿命，这样我们就不必每一两年重建整个CA基础设施。让我们选择10年（3,650天）。请注意，此命令要求输入密码（不要丢失！）以及其他将标识证书的信息。请注意在以下代码片段中，`openssl`命令一步创建了CA（`cakey.pem`）和根证书（`cacert.pem`）的私钥。在提示时，请使用您自己的主机和公司信息填写请求的值：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this final step, we'll move the key and root certificate to the correct locations.
    Note that you'll need `sudo` rights again to do this.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步中，我们将密钥和根证书移动到正确的位置。请注意，您需要再次拥有`sudo`权限才能执行此操作。
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your CA is now open for business! Let's proceed on to create a CSR and sign
    it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的CA现在已经开业！让我们继续创建CSR并对其进行签名。
- en: Requesting and signing a CSR
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求和签署CSR
- en: 'Let''s create a test CSR—you can do this on the same example host that we''ve
    been working with. First, create a private key for this certificate, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个测试CSR——您可以在我们一直在使用的相同示例主机上执行此操作。首先，为此证书创建一个私钥，如下所示：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keep track of that passphrase as it will be required when the time comes to
    install the certificate! Also, note that the key has a `2048`-bit modulus—that
    is the minimum value you should expect to see or use for this purpose.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住该密码，因为在安装证书时将需要它！还要注意，该密钥具有`2048`位模数——这是您应该期望在此目的上看到或使用的最小值。
- en: Passphrases for certificate keys are important and very sensitive information
    and you should store them someplace secure—for instance, if you plan on renewing
    that certificate when it expires (or before that, hopefully), you're going to
    need that passphrase to complete the process. Rather than keep it in a plain text
    file, I'd suggest using a password vault or a password manager to store these
    important passphrases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 证书密钥的密码非常重要且非常敏感，您应该将它们存储在安全的地方——例如，如果您计划在证书到期时（或者希望在此之前）更新该证书，您将需要该密码来完成该过程。我建议不要将其保存在纯文本文件中，而是建议使用密码保险库或密码管理器来存储这些重要的密码。
- en: 'Note that many daemon-style services will need a key and certificate without
    a passphrase (Apache web server, Postfix, and many other services) in order to
    auto-start without intervention. If you are creating a key for such a service,
    we''ll strip out the passphrase to create an *insecure key*, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多守护程序样式的服务将需要没有密码的密钥和证书（例如Apache Web服务器、Postfix和许多其他服务），以便在没有干预的情况下自动启动。如果您为这样的服务创建密钥，我们将去除密码以创建一个*不安全的密钥*，如下所示：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s rename the keys—the `server.key` *secure* key becomes `server.key.secure`,
    and the `server.key.insecure` *insecure* key becomes `server.key`, as shown in
    the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重命名密钥——`server.key`的*安全*密钥变为`server.key.secure`，而`server.key.insecure`的*不安全*密钥变为`server.key`，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whichever *style* of key we are creating (with or without a passphrase), the
    final file is `server.key`. Using this key, we can now create a CSR. This step
    requires a different passphrase that will be required to sign the CSR, as illustrated
    in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们创建哪种类型的密钥（带有或不带有密码），最终文件都是`server.key`。使用此密钥，我们现在可以创建CSR。此步骤需要另一个密码，该密码将用于签署CSR，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have the CSR in the `server.csr` file, it''s ready to be signed.
    On the certificate server (which happens to be the same host for us, but this
    won''t be typical), take the `CSR` file and sign it with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`server.csr`文件中有了CSR，它已经准备好被签名。在证书服务器上（对我们来说恰好是同一台主机，但这不是典型的情况），使用以下命令对`CSR`文件进行签名：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will generate several pages of output (not shown) and ask for a couple
    of confirmations. One of these confirmations will be the passphrase that we supplied
    when the CSR was created previously. When all is said and done, you'll see the
    actual certificate scroll by as the last section of the output. You'll also notice
    that since we didn't specify any dates, the certificate is valid starting from
    now, and is set to expire 1 year from now.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成几页输出（未显示）并要求确认几次。其中一个确认将是我们在之前创建CSR时提供的密码。当一切都说完了，你会看到实际的证书在输出的最后一部分滚动显示。你还会注意到，由于我们没有指定任何日期，证书从现在开始有效，并且设置在一年后过期。
- en: 'The certificate we just signed is stored in `/etc/ssl/newcerts/01.pem`, as
    illustrated in the following code snippet, and should be ready for use by the
    requesting service:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚签署的证书存储在`/etc/ssl/newcerts/01.pem`中，如下面的代码片段所示，并且应该准备好供请求服务使用：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we progress, the issued certificates will increment to `02.pem`, `03.pem`,
    and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，颁发的证书将递增到`02.pem`，`03.pem`等等。
- en: 'Note in the following code snippet that the `index` file has been updated with
    the certificate details, and the `serial number` file has been incremented, ready
    for the next signing request:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在下面的代码片段中，`index`文件已经更新了证书的详细信息，`序列号`文件已经递增，准备好下一个签名请求：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With a CA example completed and operating with a test certificate issued, let's
    look at how you might secure your CA infrastructure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了一个CA示例并且使用了一个测试证书，让我们看看如何保护你的CA基础设施。
- en: Securing your Certificate Authority infrastructure
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的证书颁发机构基础设施
- en: There are several best practices that are usually recommended to protect your
    CA. Some of the "legacy" advice is specific to individual CAs, but with virtualization
    becoming common in most data centers, this brings with it additional opportunities
    to streamline and secure CA infrastructures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议采取一些最佳实践来保护你的CA。一些“传统”的建议是针对个别CA的，但随着虚拟化在大多数数据中心变得普遍，这带来了额外的机会来简化和保护CA基础设施。
- en: Legacy tried-and-true advice
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的经过验证的建议
- en: The traditional advice for securing an organization's certificate infrastructure
    takes advantage of the fact that it is only used when certificates are being issued.
    If you have a good administrative handle on when new certificates will be needed,
    you can simply power off your CA server when it's not needed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的建议是为了保护组织的证书基础设施，利用它只在颁发证书时使用的事实。如果你能很好地掌握新证书需求的时间，那么在不需要时可以关闭CA服务器。
- en: If you need more flexibility, you can create a hierarchal certificate infrastructure.
    Create a root CA for your organization, whose only job is to sign certificates
    that are used to create a subordinate CA (or possibly multiple subordinates).
    These subordinates are then used to create all client and server certificates.
    The root CA can then be powered off or otherwise taken offline, except for patching.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更灵活性，可以创建一个分级证书基础设施。为你的组织创建一个根CA，它的唯一工作是签署用于创建下级CA（或可能是多个下级CA）的证书。然后使用这些下级CA来创建所有客户端和服务器证书。根CA可以在不需要时关闭或以其他方式下线，除了打补丁。
- en: If an organization is particularly concerned with securing their CA, special-purpose
    hardware such as a **hardware security module** (**HSM**) can be used to store
    the private key and CA certificate of their CA offline, often in a safety-deposit
    box or some other offsite, secure location. Commercial examples of an HSM would
    include Nitrokey HSM or YubiHSM. NetHSM is a good example of an open source HSM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组织特别关心保护他们的CA，可以使用专用硬件，比如硬件安全模块（HSM）来存储他们的CA的私钥和证书，通常是在保险箱或其他离线、安全的地方。HSM的商业示例包括Nitrokey
    HSM或YubiHSM。NetHSM是开源HSM的一个很好的例子。
- en: Modern advice
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代建议
- en: The preceding advice is all 100% still valid. The new piece of the puzzle that
    we see helping secure our CAs in a modern infrastructure is server virtualization.
    What this means in most environments is that every server has one or more image
    backups stored on local disk, due to how VMs are backed up. So, if a host is damaged
    beyond repair, whether that's from malware (usually ransomware) or some drastic
    configuration error, it's a matter of 5 minutes or so to roll the whole server
    back to the previous night's image or, in the worst case, an image from two nights
    before.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的建议仍然完全有效。我们在现代基础设施中看到有助于保护我们的CA的新要素是服务器虚拟化。在大多数环境中，这意味着每台服务器都有一个或多个镜像备份存储在本地磁盘上，因为VM是如何备份的。因此，如果主机受到无法修复的损坏，无论是来自恶意软件（通常是勒索软件）还是一些严重的配置错误，只需要大约5分钟的时间就可以将整个服务器回滚到前一天的镜像，或者在最坏的情况下，回滚到两天前的镜像。
- en: All that is lost in this recovery would be the server data about any certificates
    that were issued in that *lost* interval, and if we refer again back to how a
    session is negotiated, that server data is never actually used in setting up a
    session. This means that this *trip back in time* that the server took for recovery
    doesn't impact any of the clients or servers that use the issued certificates
    for negotiating encryption (or authentication, which we'll see when we get to
    [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153), *RADIUS Services
    for Linux*).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种恢复中丢失的一切将是在那个*丢失*间隔中颁发的任何证书的服务器数据，如果我们再次回顾一下会话是如何协商的，那么服务器数据实际上从未在建立会话时使用。这意味着服务器为恢复所花费的这段*时光旅行*不会影响任何使用颁发的证书进行加密协商的客户端或服务器（或者认证，当我们到达[*第9章*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153)，*Linux的RADIUS服务*时我们会看到）。
- en: In a smaller environment, depending on the situation, you can easily secure
    your infrastructure with only a single CA server—just keep image backups so that
    if you need to restore, that byte-for-byte image is available and can be rolled
    back in minutes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的环境中，根据情况，你可以只使用一个CA服务器轻松地保护你的基础设施——只需保留镜像备份，这样如果需要恢复，那个逐字节的镜像是可用的，并且可以在几分钟内回滚。
- en: In a larger environment, it can still make good sense to have a hierarchal model
    for your CA infrastructure—for instance, this can make mergers and acquisitions
    much easier. A hierarchal model helps to maintain the infrastructure as a single
    organization, while making it simpler to bolt CAs for multiple business units
    under a single master. You can then use **operating system** (**OS**)-based security
    to limit the *splatter zone* in the case of a malware incident in one division
    or another; or, in a day-to-day model, you can use that same OS security to limit
    administrative access to certificates between business units, if that's needed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的环境中，为您的CA基础设施建立一个分层模型仍然是有意义的——例如，这可以使合并和收购变得更加容易。分层模型有助于将基础设施保持为一个单一组织，同时使得更容易将多个业务单元的CA连接到一个主服务器下。然后，您可以使用**操作系统**（**OS**）的安全性来限制在某个部门发生恶意软件事件时的*扩散区域*；或者在日常模型中，如果需要，您可以使用相同的操作系统安全性来限制业务单元之间的证书管理访问。
- en: The main risk in depending on image backups to protect your CA infrastructure
    goes back to how CA servers are traditionally used—in some environments, certificates
    might be required only infrequently. If, for instance, you keep a week's worth
    of server image backups locally but it takes you a month (or several months) to
    realize that the script or patch that you applied has imploded your CA server,
    then recovering from backups can become problematic. This is handled nicely by
    more widespread use of certificates (for instance, in authenticating wireless
    clients to wireless networks), and automated certificate-issuing solutions such
    as Certbot and the ACME protocol (pioneered by the Let's Encrypt platform). These
    things, especially in combination, mean that CAs are becoming more and more frequently
    used, to the point that if a CA server is not operating correctly, it's now likely
    that the situation will escalate in hours or days, rather than in weeks or months.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖镜像备份来保护您的CA基础设施的主要风险在于CA服务器的传统用法——在某些环境中，可能只偶尔需要证书。例如，如果您在本地保留了一周的服务器镜像备份，但需要一个月（或几个月）才意识到您应用的脚本或补丁已经使您的CA服务器崩溃，那么从备份中恢复可能会变得棘手。这可以通过更广泛地使用证书（例如，在对无线客户端进行身份验证以连接到无线网络时）以及自动证书颁发解决方案（例如Certbot和ACME协议（由Let's
    Encrypt平台开创））来解决。这些事情，特别是结合起来，意味着CA的使用频率越来越高，以至于如果CA服务器无法正常运行，情况现在可能会在几小时或几天内升级，而不是几周或几个月内。
- en: CA-specific risks in modern infrastructures
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代基础设施中的CA特定风险
- en: '*Certificate Authority* or *CA* is not a term that comes up in casual conversation
    at parties, or even in the break room at work. What this means is that if you
    give your CA server a hostname of `ORGNAME-CA01`, while the `CA01` part of the
    name makes the server obviously important to you, don''t count on the `CA` in
    the hostname being obvious to anyone else. For instance, it most likely won''t
    be a red flag for your manager, a programmer, the person filling in for you when
    you''re on vacation, or the summer student that has the hypervisor root password
    for some reason. If you are a consultant, there might be no-one who actually works
    in the organization that knows what the CA does.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书颁发机构*或*CA*不是在派对上随意谈论的术语，甚至在工作的休息室里也不会出现。这意味着，如果您给您的CA服务器命名为`ORGNAME-CA01`，虽然名称中的`CA01`部分显然对您很重要，但不要指望主机名中的`CA`对其他人来说也很重要。例如，对于您的经理、程序员、在您度假时替您工作的人，或者因某种原因拥有超级用户密码的暑期学生来说，这很可能不会引起注意。如果您是顾问，可能没有人实际在组织中知道CA的作用。'
- en: What this means is that, especially in virtualized infrastructures, we see CA
    VMs being (sort of) accidentally deleted from time to time. It happens frequently
    enough that when I build a new CA VM, I will usually call it `ORGNAME-CA01 – DO
    NOT DELETE, CONTACT RV`, where `RV` represents the initials of the admin who owns
    that server (in this case, it would be me).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，特别是在虚拟化基础设施中，我们经常会看到CA虚拟机被（某种程度上）意外删除。这种情况发生的频率足够高，以至于当我构建一个新的CA虚拟机时，我通常会将其命名为`ORGNAME-CA01
    – 不要删除，联系RV`，其中`RV`代表拥有该服务器的管理员的缩写（在这种情况下，是我）。
- en: It might make good sense to put alerts in place when any server VM is deleted,
    advising whoever is on the administration team for that host—this will give you
    another layer of if not defense, then at least a timely notification so that you
    can recover quickly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何服务器虚拟机被删除时，设立警报可能是个明智的选择，通知管理团队的任何人——这将为您提供另一层防御，或者至少及时通知，以便您可以快速恢复。
- en: Finally, implementing **role-based access control** (**RBAC**) on your hypervisor
    infrastructure is on everyone's best-practice list. Only the direct admins for
    any particular server should be able to delete, reconfigure, or change the power
    state of that server. This level of control is easily configurable in modern hypervisors
    (for instance, VMware's vSphere). This at least makes it that much more difficult
    to accidentally delete a VM.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您的虚拟化基础设施上实施**基于角色的访问控制**（**RBAC**）是每个人的最佳实践清单上的事项。任何特定服务器的直接管理员应该能够删除、重新配置或更改该服务器的电源状态。这种控制级别在现代虚拟化器中很容易配置（例如，VMware的vSphere）。这至少使意外删除虚拟机变得更加困难。
- en: Now that we've got some security practices in place to protect our CA, let's
    look at CT, both from an attacker's point of view and that of an infrastructure
    defender.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经制定了一些安全实践来保护我们的CA，让我们从攻击者和基础设施防御者的角度来看看CT。
- en: Certificate Transparency
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书透明性
- en: Reviewing the opening paragraphs of the chapter, recall that one of the major
    *jobs* of a CA is *trust*. Whether it is a public or a private CA, you have to
    trust a CA to verify that whoever is requesting a certificate is who they say
    they are. If this check fails, then anyone who wants to represent [yourbank.com](http://yourbank.com)
    could request that certificate and pretend to be your bank! That would be disastrous
    in today's web-centric economy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章的开头段落，回想一下CA的主要*工作*之一是*信任*。无论是公共CA还是私人CA，您都必须信任CA来验证请求证书的人是否是他们所说的那个人。如果这个检查失败，那么任何想要代表[yourbank.com](http://yourbank.com)的人都可以请求该证书，并假装是你的银行！在当今以网络为中心的经济中，这将是灾难性的。
- en: When this trust does fail, the various CAs, browser teams (Mozilla, Chrome,
    and Microsoft especially), and OS vendors (primarily Linux and Microsoft) will
    simply delist the offending CA from the various OS and browser-certificate stores.
    This essentially moves all of the certificates issued by that CA to an *untrusted*
    category, forcing all of those services to acquire certificates from elsewhere.
    This has happened a few times in the recent past.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种信任失败时，各种CA、浏览器团队（尤其是Mozilla、Chrome和Microsoft）以及操作系统供应商（主要是Linux和Microsoft）将简单地从各种操作系统和浏览器证书存储中删除违规的CA。这基本上将由该CA签发的所有证书移至*不受信任*类别，迫使所有这些服务从其他地方获取证书。这在最近的过去发生过几次。
- en: DigiNotar was delisted after it was compromised, and the attackers got control
    of some of its key infrastructure. A fraudulent `*.`[google.com](http://google.com)—note
    that the `*` is what makes this certificate a wildcard that can be used to protect
    or impersonate any host in that domain. Not only was that fraudulent wildcard
    issued—it was then used to intercept real traffic. Needless to say, everyone took
    a dim view of this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DigiNotar在遭到破坏后被删除，攻击者控制了其一些关键基础设施。一个欺诈的`*.`[google.com](http://google.com)——请注意，`*`是使这个证书成为通配符，可以用来保护或冒充该域中的任何主机。不仅是那个欺诈的通配符被签发了，它还被用来拦截真实的流量。不用说，每个人对此都持负面看法。
- en: Between 2009 and 2015, the Symantec CA issued a number of **test certificates**,
    including for domains belonging to Google and Opera (another browser). When this
    came to light, Symantec was subject to more and more stringent restrictions. At
    the end of the day, Symantec's staff repeatedly skipped steps in verifying important
    certificates, and the CA was finally delisted in 2018.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在2009年至2015年期间，赛门铁克CA签发了许多**测试证书**，包括属于谷歌和Opera（另一个浏览器）的域。当这一事件曝光后，赛门铁克受到了越来越严格的限制。最终，赛门铁克的工作人员反复跳过了验证重要证书的步骤，该CA最终在2018年被删除。
- en: To aid in detecting events of this type, public CAs now participate in **Certificate
    Transparency** (**CT**), as described in **Request for Comments** (**RFC**) *6962*.
    What this means is that as a certificate is issued, information on it is published
    by that CA to its CT service. This process is mandatory for all certificates used
    for **Secure Sockets Layer** (**SSL**)/TLS. This program means that any organization
    can check (or, more formally, audit) the registry for certificates that it purchased.
    More importantly, it can check/audit the registry for certificates that it *didn't*
    purchase. Let's see how that can work in practice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助检测这种类型的事件，公共CA现在参与**证书透明度**（**CT**），如**请求评论**（**RFC**）*6962*中所述。这意味着当证书被签发时，该CA会将有关证书的信息发布到其CT服务中。这个过程对于所有用于**安全套接字层**（**SSL**）/TLS的证书是强制性的。这个程序意味着任何组织都可以检查（或更正式地说，审计）它购买的证书的注册表。更重要的是，它可以检查/审计它*没有*购买的证书的注册表。让我们看看这在实践中是如何运作的。
- en: Using CT for inventory or reconnaissance
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CT进行库存或侦察
- en: As we discussed, the primary reason that CT services exist is to ensure trust
    in public CAs by allowing anyone to verify or formally audit issued certificates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，CT服务存在的主要原因是通过允许任何人验证或正式审计已签发的证书来确保对公共CA的信任。
- en: However, in addition to that, an organization can query a CT service to see
    if there are legitimate certificates for their company that were purchased by
    people who shouldn't be in the server business. For instance, it's not unheard
    of for a marketing team to stand up a server with a cloud-service provider, circumventing
    all the security and cost controls that might have been discussed if the **Information
    Technology** (**IT**) group had built the server on their behalf. This situation
    is often called *shadow IT*, where a non-IT department decides to go rogue with
    their credit card and create parallel and often less-well-secured servers that
    the *real* IT group doesn't see (often until it's too late).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除此之外，组织可以查询CT服务，看看是否有为他们公司购买的合法证书，而这些证书是由不应该从事服务器业务的人购买的。例如，市场团队建立了一个与云服务提供商合作的服务器，绕过了可能已经讨论过的所有安全和成本控制，如果**信息技术**（**IT**）组为他们代建服务器的话。这种情况通常被称为*影子IT*，即非IT部门决定用他们的信用卡去做一些并行的、通常安全性较差的服务器，而*真正的*IT组通常直到为时已晚才发现。
- en: Alternatively, in a security assessment or penetration test context, finding
    all of your customer's assets is a key piece of the puzzle—you can only assess
    what you can find. Using a CT service will find all SSL/TLS certificates issued
    for a company, including any certificates for test, development, and **quality
    assurance** (**QA**) servers. It's the test and development servers that often
    are the least well-secured, and often these servers provide an open door to a
    penetration tester. All too often, those development servers contain recent copies
    of production databases, so in many cases, compromising the development environment
    is a full breach. Needless to say, real attackers use these same methods to find
    these same vulnerable assets. What this also means is that the *blue team* (the
    defenders in the IT group) in this scenario should be checking things such as
    CT servers frequently as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在安全评估或渗透测试的情境中，找到客户的所有资产是谜题的关键部分——你只能评估你能找到的东西。使用CT服务将找到为公司颁发的所有SSL/TLS证书，包括测试、开发和质量保证（QA）服务器的任何证书。测试和开发服务器通常是最不安全的，而且这些服务器通常为渗透测试人员提供了一个开放的入口。很多时候，这些开发服务器包含了生产数据库的最新副本，因此在许多情况下，入侵开发环境就等于完全入侵。不用说，真正的攻击者也使用这些方法来找到这些同样脆弱的资产。这也意味着在这种情况下的蓝队（IT组中的防御者）应该经常检查诸如CT服务器之类的东西。
- en: That being said, how exactly do you check CT? Let's use the server at [https://crt.sh](https://crt.sh),
    and search for certificates issued to `example.com`. To do this, browse to [https://crt.sh/?q=example.com](https://crt.sh/?q=example.com)
    (or use your company domain name instead if you are interested).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，您究竟如何检查CT呢？让我们使用[https://crt.sh](https://crt.sh)上的服务器，并搜索颁发给`example.com`的证书。要做到这一点，请浏览[https://crt.sh/?q=example.com](https://crt.sh/?q=example.com)（如果您感兴趣，也可以使用您的公司域名）。
- en: Note that because this is meant as a full audit trail, these certificates will
    often go *back in time*, all the way back to 2013-2014 when CT was still experimental!
    This can make for a great reconnaissance tool that can help you find hosts that
    have expired certificates or are now protected by a wildcard certificate. Old
    `*.example.com` (or `*.yourorganisation.com`). These certificates are meant to
    protect any host under the indicated parent domain (indicated by the `*`). The
    risk in using a wildcard is that if the appropriate material is stolen, perhaps
    from a vulnerable server, any or all hosts in the domain can be impersonated—this
    can, of course, be disastrous! On the other hand, after three to five individual
    certificates have been purchased, it becomes cost-effective to consolidate them
    all to one wildcard certificate that will have a lower cost, but more importantly,
    a single expiry date to keep track of. A side benefit is that using wildcard certificates
    means that reconnaissance using CT becomes much less effective for an attacker.
    The defenders, however, can still see fraudulent certificates, or certificates
    that were purchased and are in use by other departments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为这是一个完整的审计跟踪，这些证书通常会回溯到2013-2014年CT仍处于实验阶段的时候！这可以成为一个很好的侦察工具，可以帮助您找到已过期证书或现在受到通配符证书保护的主机。旧的`*.example.com`（或`*.yourorganisation.com`）。这些证书旨在保护指定父域下的任何主机（由`*`指示）。使用通配符的风险在于，如果适当的材料被盗，可能来自一个脆弱的服务器，域中的任何或所有主机都可以被冒充——这当然是灾难性的！另一方面，购买了三到五个单独的证书之后，将它们全部合并为一个通配符证书变得具有成本效益，而且更重要的是，只有一个到期日期需要跟踪。一个附带的好处是使用通配符证书意味着使用CT进行侦察对攻击者来说变得不那么有效。然而，防御者仍然可以看到欺诈证书，或者其他部门购买并正在使用的证书。
- en: We've covered a lot of ground in this chapter. Now that we've got a firm grasp
    on the place of certificates in a modern infrastructure, let's explore how we
    can use modern applications and protocols to automate the whole certificate process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。现在我们对现代基础设施中证书的位置有了牢固的掌握，让我们探讨如何使用现代应用程序和协议来自动化整个证书过程。
- en: Certificate automation and the ACME protocol
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书自动化和ACME协议
- en: In recent years, the automation of CAs has seen some serious uptake. Let's Encrypt
    in particular has fueled this change, by offering free public-certificate services.
    They've reduced the cost of this service by using automation, in particular using
    the **ACME protocol** (*RFC 8737*/*RFC 8555*) and the **Certbot** services for
    verification of CSR information, as well as for issuing and delivering certificates.
    For the most part, this service and protocol focuses on providing automated certificates
    to web servers, but that is being scaled out to cover other use cases.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，CA的自动化得到了一些严重的推广。特别是Let's Encrypt通过提供免费的公共证书服务推动了这一变化。他们通过使用自动化，特别是使用ACME协议（RFC
    8737/RFC 8555）和Certbot服务来验证CSR信息，以及颁发和交付证书，降低了这项服务的成本。在很大程度上，这项服务和协议侧重于为Web服务器提供自动化证书，但正在扩展到其他用例。
- en: 'Implementations such as Smallstep, which uses the ACME protocol for automating
    and issuing certificate requests, have extended this concept to include the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Smallstep等实现使用ACME协议来自动化和颁发证书请求，已将这一概念扩展到包括以下内容：
- en: '**Open Authorization (OAuth)/OpenID Connect (OIDC**) provisioning, using identity
    tokens for authentication, allowing **single sign-on** (**SSO**) integration for
    G Suite, Okta, **Azure Active Directory** (**Azure AD**), and any other OAuth
    provider'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用身份令牌进行身份验证的开放授权（OAuth）/OpenID Connect（OIDC）配置，允许G Suite、Okta、Azure Active
    Directory（Azure AD）和任何其他OAuth提供商进行单点登录（SSO）集成
- en: API provisioning using APIs from **Amazon Web Services** (**AWS**), **Google
    Cloud Platform** (**GCP**), or Azure
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自Amazon Web Services（AWS）、Google Cloud Platform（GCP）或Azure的API进行API配置
- en: '**JavaScript Object Notation (JSON) Web Key** (**JWK**) and **JSON Web Token**
    (**JWT**) integration, allowing one-time tokens to be used for authentication
    or to leverage subsequent certificate issuance'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法（JSON）Web密钥**（**JWK**）和**JSON Web令牌**（**JWT**）集成，允许一次性令牌用于身份验证或利用后续证书颁发'
- en: Because certificates issued using the ACME protocol are generally free, they're
    also prime targets for malicious actors. For instance, malware often takes advantage
    of the free certificates available with Let's Encrypt to encrypt **command-and-control**
    (**C2**) operations or data exfiltration. Even for internal ACME servers such
    as Smallstep, any lapse in attention to detail could mean that malicious actors
    are able to compromise all encryption in an organization. For this reason, ACME-based
    servers typically issue only short-lived certificates, with the understanding
    that automation will "pick up the slack" by removing the increased administrative
    overhead completely. Let's Encrypt is the most well-known public CA that uses
    ACME—its certificates are valid for 90 days. Smallstep goes to the extreme, with
    the default certificate duration being 24 hours. Note that a 24-hour expiry is
    extreme, and this can have a severe impact on mobile workstations that may not
    be on the internal network each day, so a longer interval is usually set.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用ACME协议颁发的证书通常是免费的，它们也是恶意行为者的主要目标。例如，恶意软件经常利用Let's Encrypt提供的免费证书来加密**命令和控制**（**C2**）操作或数据外泄。即使对于Smallstep等内部ACME服务器，对细节的疏忽也可能意味着恶意行为者能够破坏组织中的所有加密。因此，基于ACME的服务器通常只颁发短期证书，并且自动化将通过完全消除增加的管理开销来“弥补不足”。Let's
    Encrypt是使用ACME的最知名的公共CA，其证书有效期为90天。Smallstep则采取极端措施，默认证书有效期为24小时。请注意，24小时的到期时间是极端的，这可能会严重影响可能每天不在内部网络上的移动工作站，因此通常会设置更长的间隔。
- en: Previously to ACME, **Simple Certificate Enrollment Protocol** (**SCEP**) was
    used for automation, in particular for providing machine certificates. SCEP is
    still widely used in **mobile device management** (**MDM**) products to provision
    enterprise certificates to mobile phones and other mobile devices. SCEP is also
    still very much in use in Microsoft's **Network Device Enrollment Service** (**NDES**)
    component, in their **Active Directory** (**AD**)-based certificate service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在ACME之前，**简单证书注册协议**（**SCEP**）用于自动化，特别是用于提供机器证书。SCEP仍然广泛用于**移动设备管理**（**MDM**）产品，以向移动电话和其他移动设备提供企业证书。SCEP在Microsoft的**网络设备注册服务**（**NDES**）组件中仍然被广泛使用，在其基于**Active
    Directory**（**AD**）的证书服务中也是如此。
- en: Speaking of Microsoft, their free certificate service does auto-enrollment of
    workstation and user certificates, all under Group Policy control. This means
    that as workstation and user-automated authentication requirements ramp up, so
    it seems does the use of the Microsoft CA service.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到微软，他们的免费证书服务会自动注册工作站和用户证书，都受到组策略控制。这意味着随着工作站和用户自动化身份验证要求的增加，微软CA服务的使用似乎也在增加。
- en: The overall trend in Linux-based CA services is to automate the issuing of certificates
    as much as possible. The underlying certificate principles, however, remain exactly
    the same as we've discussed in this chapter. As the *winners* in this trend start
    to emerge, you should have the tools in hand to understand how any CA should work
    in your environment, no matter the frontend or automation methods that may be
    in use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的CA服务的整体趋势是尽可能自动化证书的颁发。然而，底层的证书原则与本章讨论的完全相同。随着这一趋势中的*赢家*开始出现，您应该掌握工具，以了解在您的环境中任何CA应该如何工作，无论使用的是前端还是自动化方法。
- en: With automation done, we've covered the main certificate operations and configurations
    that you'll see in a modern infrastructure. Before we wrap up the topic though,
    it's often useful to have a short "cookbook-style" set of commands to use for
    certificate operations. Since OpenSSL is our main tool for this, we've put together
    a list of common commands that should hopefully make these complex operations
    simpler to complete.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自动化的完成，我们已经涵盖了您在现代基础设施中看到的主要证书操作和配置。然而，在结束这个话题之前，通常有一个简短的“食谱式”命令集是很有用的，用于证书操作。由于OpenSSL是我们的主要工具，我们已经整理了一份常见命令的列表，希望这些命令能够使这些复杂的操作更简单完成。
- en: OpenSSL cheat sheet
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL备忘单
- en: To start this section, let me say that this covers the commands used in this
    chapter, as well as many of the commands you might use in checking, requesting,
    and issuing certificates. Some remote debugging commands are also demonstrated.
    OpenSSL has hundreds of options, so as always, the man page is your friend to
    more fully explore its capabilities. In a pinch, if you google `OpenSSL` `cheat
    sheet`, you'll find hundreds of pages showing common OpenSSL commands.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本节，让我说一下，这涵盖了本章中使用的命令，以及您可能在检查、请求和颁发证书时使用的许多命令。还演示了一些远程调试命令。OpenSSL有数百个选项，因此像往常一样，man页面是您更全面地探索其功能的朋友。在紧要关头，如果您搜索`OpenSSL`
    `cheat sheet`，您会发现数百页显示常见OpenSSL命令的页面。
- en: 'Here are some steps and commands that are common in certificate creation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在证书创建中常见的一些步骤和命令：
- en: 'To create a private key for a new certificate (on the applicant), run the following
    command:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为新证书（申请人）创建私钥，请运行以下命令：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create a CSR for a new certificate (on the applicant), run the following
    command:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为新证书（申请人）创建CSR，请运行以下命令：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To verify a CSR signature, run the following command:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证CSR签名，请运行以下命令：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To check CSR content, run the following command:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查CSR内容，请运行以下命令：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To sign a CSR (on the CA server), run the following command:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要签署CSR（在CA服务器上），请运行以下命令：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To create a self-signed certificate (not normally a best practice), run the
    following command:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自签名证书（通常不是最佳做法），运行以下命令：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are some commands used when checking certificate status:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在检查证书状态时使用的一些命令：
- en: 'To check a standard `x.509` certificate file, run the following command:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查标准的`x.509`证书文件，请运行以下命令：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To check a `PKCS#12` file (this combines the certificate and private key into
    a single file, usually with a `pfx` or `p12` suffix), run the following command:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查`PKCS#12`文件（这将证书和私钥合并为一个文件，通常带有`pfx`或`p12`后缀），运行以下命令：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To check a private key, run the following command:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查私钥，请运行以下命令：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here are some common commands used in remote debugging of certificates:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是远程调试证书中常用的一些命令：
- en: 'To check a certificate on a remote server, run the following command:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查远程服务器上的证书，请运行以下命令：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To check certificate revocation status using the OCSP protocol (note that this
    is a procedure, so we''ve numbered the steps), proceed as follows:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OCSP协议检查证书吊销状态（请注意，这是一个过程，因此我们已编号了步骤），请按以下步骤进行：
- en: 'First, collect the public certificate and strip out the `BEGIN` and `END` lines,
    as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，收集公共证书并去除`BEGIN`和`END`行，如下所示：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, check if there''s a OCSP **Uniform Resource Identifier** (**URI**) in
    the certificate, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查证书中是否有OCSP**统一资源标识符**（**URI**），如下所示：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If there is, you can make a request at this point, as shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，您可以在此时发出请求，如下所示：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If there is no URI in the public certificate, we''ll need to get the certificate
    chain (that is, the chain to the issuer) then the issuer''s root CA, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果公共证书中没有URI，我们需要获取证书链（即到发行者的链），然后获取发行者的根CA，如下所示：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This usually creates a large amount of output—to extract just the certificate
    chain to a file (in this case, `chain.pem`), run the following command:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这通常会产生大量输出-要提取证书链到文件（在本例中为`chain.pem`），请运行以下命令：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are some OpenSSL commands used to convert between file formats:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些OpenSSL命令，用于在文件格式之间进行转换：
- en: 'To convert a `-----BEGIN CERTIFICATE-----`):'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要转换`-----BEGIN CERTIFICATE-----`：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To convert a DER file (`.crt`, `.cer`, or `.der`) to a PEM file, run the following
    command:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将DER文件（`.crt`，`.cer`或`.der`）转换为PEM文件，请运行以下命令：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To convert a `PKCS#12` file (`.pfx`, `.p12`) containing a private key and certificates
    to a PEM file, run the following command:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要转换包含私钥和证书的`PKCS#12`文件（`.pfx`，`.p12`）为PEM文件，请运行以下命令：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: OpenSLL commands are also used to convert a PEM certificate file and a private
    key to `PKCS#12` (`.pfx`, `.p12`).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSLL命令也用于将PEM证书文件和私钥转换为`PKCS#12`（`.pfx`，`.p12`）。
- en: '`PKCS#12` format files are often required if an identity certificate is needed
    for a service but there is no CSR to provide the private key information during
    the installation. In that situation, using a **Personal Exchange Format** (**PFX**)
    file or a **Public Key Cryptography Standard #12** (**P12**) file provides all
    the information required (private key and public certificate) in one file. An
    example command is shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务需要身份证书，但在安装过程中没有CSR提供私钥信息，则通常需要`PKCS#12`格式文件。在这种情况下，使用**个人交换格式**（**PFX**）文件或**公钥密码标准#12**（**P12**）文件提供所需的所有信息（私钥和公共证书）在一个文件中。示例命令如下：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Hopefully this short "cookbook" has helped demystify certificate operations
    and helped simplify reading the various files involved in your certificate infrastructure.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这本简短的“食谱”有助于揭秘证书操作，并简化阅读涉及您证书基础设施的各种文件。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this discussion complete, you should know the basics of installing and
    configuring a certificate server using OpenSSL. You should also know the basic
    concepts needed to request a certificate and sign a certificate. The basic concepts
    and tools across different CA implementations remain the same. You should also
    have an understanding of the basic OpenSSL commands used for checking certificate
    material or debugging certificates on remote servers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本讨论，您应该了解使用OpenSSL安装和配置证书服务器的基础知识。您还应该了解请求证书和签署证书所需的基本概念。不同CA实现中的基本概念和工具保持不变。您还应该了解用于检查证书材料或在远程服务器上调试证书的基本OpenSSL命令。
- en: You should further understand the factors involved in securing your certificate
    infrastructure. This includes the use of CT for inventory and reconnaissance,
    for both defensive and offensive purposes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该进一步了解保护您的证书基础设施所涉及的因素。这包括使用CT进行库存和侦察，无论是防御性还是进攻性。
- en: In [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153), *RADIUS Services
    for Linux*, we'll build on this by adding RADIUS authentication services to our
    Linux host. You'll see that in the more advanced configurations, RADIUS can use
    your certificate infrastructure to secure your wireless network, where the certificate
    will be used both for two-way authentication and for encryption.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153)，*Linux的RADIUS服务*，我们将在此基础上添加RADIUS认证服务到我们的Linux主机。您将看到在更高级的配置中，RADIUS可以使用您的证书基础设施来保护您的无线网络，证书将用于双向认证和加密。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一些问题列表，供您测试对本章材料的了解。您将在*附录*的*评估*部分找到答案：
- en: What are the two functions that a certificate facilitates in communication?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证书在通信中发挥了哪两个功能？
- en: What is the `PKCS#12` format, and where might it be used?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`PKCS#12`格式，它可能在哪里使用？
- en: Why is CT important?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CT为什么重要？
- en: Why is it important for your CA server to track the details of certificates
    that are issued?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您的CA服务器跟踪已发行证书的详细信息很重要？
- en: Further reading
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the subject, refer to the following material:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于主题的信息，请参考以下材料：
- en: 'Certificates on Ubuntu (in particular, building a CA): [https://ubuntu.com/server/docs/security-certificates](https://ubuntu.com/server/docs/security-certificates)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu上的证书（特别是构建CA）：[https://ubuntu.com/server/docs/security-certificates](https://ubuntu.com/server/docs/security-certificates)
- en: 'OpenSSL home page: [https://www.openssl.org/](https://www.openssl.org/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL主页：[https://www.openssl.org/](https://www.openssl.org/)
- en: '*Network Security with OpenSSL*: [https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X](https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用OpenSSL进行网络安全*: [https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X](https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X)'
- en: 'CT: [https://certificate.transparency.dev](https://certificate.transparency.dev)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CT: [https://certificate.transparency.dev](https://certificate.transparency.dev)'
- en: 'CA operations on OpenSUSE (using YaST): [https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html](https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenSUSE上的CA操作（使用YaST）：[https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html](https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html)
- en: 'CA operations on Red Hat-based-distributions (using Certificate Manager): [https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs](https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Red Hat的CA操作（使用证书管理器）：[https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs](https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs)
- en: 'Easy-RSA: [https://github.com/OpenVPN/easy-rsa](https://github.com/OpenVPN/easy-rsa)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Easy-RSA：[https://github.com/OpenVPN/easy-rsa](https://github.com/OpenVPN/easy-rsa)
- en: 'ACME-enabled CAs:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持ACME的CA：
- en: 'Smallstep CA: [https://smallstep.com/](https://smallstep.com/)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'Smallstep CA: [https://smallstep.com/](https://smallstep.com/)'
- en: 'Boulder CA: [https://github.com/letsencrypt/boulder](https://github.com/letsencrypt/boulder)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'Boulder CA: [https://github.com/letsencrypt/boulder](https://github.com/letsencrypt/boulder)'
