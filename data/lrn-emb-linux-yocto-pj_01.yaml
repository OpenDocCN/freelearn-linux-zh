- en: Chapter 1. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍
- en: In this chapter, you will be presented with the advantages of Linux and open
    source development. There will be examples of systems running embedded Linux,
    which a vast number of embedded hardware platforms support. After this, you will
    be introduced to the architecture and development environment of an embedded Linux
    system, and, in the end, the Yocto Project, where its Poky build system's properties
    and purposes are summarized.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解Linux和开源开发的优势。将介绍运行嵌入式Linux的系统的示例，许多嵌入式硬件平台都支持。之后，您将介绍嵌入式Linux系统的架构和开发环境，最后介绍Yocto项目，总结其Poky构建系统的属性和目的。
- en: Advantages of Linux and open source systems
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux和开源系统的优势
- en: 'Most of the information available in this book, and the examples presented
    as exercises, have one thing in common: the fact that they are freely available
    for anyone to access. This book tries to offer guidance to you on how to interact
    with existing and freely available packages that could help an embedded engineer,
    such as you, and at the same time, also try to arouse your curiosity to learn
    more.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中大部分可获得的信息和作为练习呈现的示例有一个共同点：它们都是任何人都可以自由访问的。本书试图为您提供如何与现有的和免费可用的软件包进行交互的指导，这些软件包可以帮助像您这样的嵌入式工程师，并且同时也试图激发您的好奇心，让您学到更多。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: More information on open source can be gathered from the **Open Source Initiative**
    (**OSI**) at [http://opensource.org/](http://opensource.org/).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有关开源的更多信息可以从**开源倡议**（**OSI**）[http://opensource.org/](http://opensource.org/)获取。
- en: The main advantage of open source is represented by the fact that it permits
    developers to concentrate more on their products and their added value. Having
    an open source product offers access to a variety of new possibilities and opportunities,
    such as reduced costs of licensing, increased skills, and knowledge of a company.
    The fact that a company uses an open source product that most people have access
    to, and can understand its working, implies budget savings. The money saved could
    be used in other departments, such as hardware or acquisitions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的主要优势在于它允许开发人员更专注于他们的产品和附加值。拥有开源产品可以获得各种新的可能性和机会，比如减少许可成本、增加公司的技能和知识。使用大多数人都可以访问并理解其工作原理的开源产品意味着预算节省。节省下来的资金可以用于其他部门，比如硬件或收购。
- en: 'Usually, there is a misconception about open source having little or no control
    over a product. However, the opposite is true. The open source system, in general,
    offers full control over software, and we are going to demonstrate this. For any
    software, your open source project resides on a repository that offers access
    for everyone to see. Since you''re the person in charge of a project, and its
    administrator as well, you have all the right in the world to accept the contributions
    of others, which lends them the same right as you, and this basically gives you
    the freedom to do whatever you like. Of course, there could be someone who is
    inspired by your project and could do something that is more appreciated by the
    open source community. However, this is how progress is made, and, to be completely
    honest, if you are a company, this kind of scenario is almost invalid. Even in
    this case, this situation does not mean the death of your project, but an opportunity
    instead. Here, I would like to present the following quote:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们对开源产品有很少或没有控制权的误解。然而，事实恰恰相反。开源系统一般来说提供了对软件的完全控制，我们将证明这一点。对于任何软件，您的开源项目都驻留在一个允许每个人查看的存储库中。由于您是项目的负责人，也是其管理员，您有权接受他人的贡献，这使他们和您拥有同样的权利，基本上给了您想做任何事情的自由。当然，可能会有人受到您的项目的启发，做出了开源社区更受欢迎的事情。然而，这就是进步的方式，坦率地说，如果您是一家公司，这种情况几乎是无效的。即使在这种情况下，这种情况也并不意味着您的项目的失败，而是一个机会。在这里，我想引用以下引用：
- en: '|   | *"If you want to build an open source project, you can''t let your ego
    stand in the way. You can''t rewrite everybody''s patches, you can''t second-guess
    everybody, and you have to give people equal control."* |   |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果你想建立一个开源项目，你不能让自己的自尊挡住你的路。你不能重写每个人的补丁，你不能对每个人进行第二次猜测，你必须给人们平等的控制权。"*
    |   |'
- en: '|   | --*– Rasmus Lerdorf* |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   | --*– Rasmus Lerdorf* |'
- en: Allowing access to others, having external help, modifications, debugging, and
    optimizations performed on your open source software implies a longer life for
    the product and better quality achieved over time. At the same time, the open
    source environment offers access to a variety of components that could easily
    be integrated in your product if there's a requirement for them. This permits
    a quick development process, lower costs, and also shifts a great deal of the
    maintenance and development work from your product. Also, it offers the possibility
    to support a particular component to make sure that it continues to suit your
    needs. However, in most instances, you would need to take some time and build
    this component for your product from zero.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 允许他人访问、获得外部帮助、对您的开源软件进行修改、调试和优化意味着产品的寿命更长，随着时间的推移，质量也得到了提高。同时，开源环境提供了各种组件的访问，如果需要，这些组件可以轻松地集成到您的产品中。这可以实现快速的开发过程，降低成本，并且还可以将大部分的维护和开发工作从您的产品中转移出去。此外，它还提供了支持特定组件的可能性，以确保它继续满足您的需求。然而，在大多数情况下，您需要花一些时间从零开始为您的产品构建这个组件。
- en: This brings us to the next benefit of open source, which involves testing and
    quality assurance for our product. Besides the lesser amount of work that is needed
    for testing, it is also possible to choose from a number of options before deciding
    which components fits best for our product. Also, it is cheaper to use open source
    software, than buying and evaluating proprietary products. This takes and gives
    back process, visible in the open source community, is the one that generates
    products of a higher quality and more mature ones. This quality is even greater
    than that of other proprietary or closed source similar products. Of course, this
    is not a generally valid affirmation and only happens for mature and widely used
    products, but here appears the term community and foundation into play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到开源的下一个好处，涉及我们产品的测试和质量保证。除了测试所需的工作量较少之外，还可以在决定哪个组件最适合我们的产品之前从多个选项中进行选择。此外，使用开源软件比购买和评估专有产品更便宜。这种接受和回馈的过程，在开源社区中可见，是产生更高质量和更成熟产品的过程。这种质量甚至比其他专有或闭源类似产品的质量更高。当然，这并不是一个普遍有效的断言，只发生在成熟和广泛使用的产品上，但在这里出现了社区和基金会这个术语。
- en: In general, open source software is developed with the help of communities of
    developers and users. This system offers access to a greater support on interaction
    with the tools directly from developers - the sort of thing that does not happen
    when working with closed source tools. Also, there is no restriction when you're
    looking for an answer to your questions, no matter whether you work for a company
    or not. Being part of the open source community means more than bug fixing, bug
    reporting, or feature development. It is about the contribution added by the developers,
    but, at the same time, it offers the possibility for engineers to get recognition
    outside their working environment, by facing new challenges and trying out new
    things. It can also be seen as a great motivational factor and a source of inspiration
    for everyone involved in the process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，开源软件是由开发人员和用户社区共同开发的。这个系统提供了直接从开发人员那里获得更大支持的机会——这在使用闭源工具时是不会发生的。此外，无论您是为公司工作与否，寻找问题答案时都没有限制。成为开源社区的一部分意味着不仅仅是修复错误、报告错误或开发功能。它是开发人员所做的贡献，但同时也为工程师提供了在工作环境之外获得认可的可能性，面对新挑战并尝试新事物。它也可以被视为一个巨大的激励因素和所有参与过程的灵感来源。
- en: 'Instead of a conclusion, I would also like to present a quote from the person
    who forms the core of this process, the man who offered us Linux and kept it open
    source:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结论，我还想引用这个过程的核心人物的一句话，他给了我们Linux并使其保持开源：
- en: '|   | *"I think, fundamentally, open source does tend to be more stable software.
    It''s the right way to do things."* |   |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   | *"我认为，从根本上讲，开源软件确实更稳定。这是正确的做事方式。"* |   |'
- en: '|   | --*– Linus Torvalds* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   | --*– Linus Torvalds* |'
- en: Embedded systems
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统
- en: 'Now that the benefits of open source have been introduced to you, I believe
    we can go through a number of examples of embedded systems, hardware, software,
    and their components. For starters, embedded devices are available anywhere around
    us: take a look at your smartphone, car infotainment system, microwave oven, or
    even your MP3 player. Of course, not all of them qualify to be Linux operating
    systems, but they all have embedded components that make it possible for them
    to fulfill their designed functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 既然开源的好处已经向您介绍了，我相信我们可以通过一些嵌入式系统、硬件、软件及其组件的例子。首先，嵌入式设备随处可见：看看您的智能手机、汽车信息娱乐系统、微波炉甚至您的MP3播放器。当然，并非所有这些都符合Linux操作系统的要求，但它们都有嵌入式组件，使它们能够实现其设计功能。
- en: General description
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般描述
- en: For Linux to be run on any device hardware, you will require some hardware-dependent
    components that are able to abstract the work for hardware-independent ones. The
    boot loader, kernel, and toolchain contain hardware-dependent components that
    make the performance of work easier for all the other components. For example,
    a BusyBox developer will only concentrate on developing the required functionalities
    for his application, and will not concentrate on hardware compatibility. All these
    hardware-dependent components offer support for a large variety of hardware architectures
    for both 32 and 64 bits. For example, the U-Boot implementation is the easiest
    to take as an example when it comes to source code inspection. From this, we can
    easily visualize how support for a new device can be added.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在任何设备硬件上运行Linux，您将需要一些能够将硬件相关组件抽象为硬件无关组件的硬件相关组件。引导加载程序、内核和工具链包含使所有其他组件的工作更容易的硬件相关组件。例如，BusyBox开发人员只会专注于为他的应用程序开发所需的功能，而不会专注于硬件兼容性。所有这些硬件相关组件都支持32位和64位的各种硬件架构。例如，U-Boot实现是最容易作为源代码检查的例子。从中，我们可以很容易地想象如何添加对新设备的支持。
- en: We will now try to do some of the little exercises presented previously, but
    before moving further, I must present the computer configuration on which I will
    continue to do the exercises, to make sure that that you face as few problems
    as possible. I am working on an Ubuntu 14.04 and have downloaded the 64-bit image
    available on the Ubuntu website at [http://www.ubuntu.com/download/desktop](http://www.ubuntu.com/download/desktop)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试做一些之前介绍的小练习，但在继续之前，我必须介绍我将继续进行练习的计算机配置，以确保您尽可能少遇到问题。我正在使用Ubuntu 14.04，并已从Ubuntu网站[http://www.ubuntu.com/download/desktop](http://www.ubuntu.com/download/desktop)下载了64位镜像。
- en: 'Information relevant to the Linux operation running on your computer can be
    gathered using this command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令可以收集有关在计算机上运行的Linux操作的信息：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command generates this output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了这个输出：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next command to gather the information relevant to the Linux operation
    is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 收集与Linux操作相关的信息的下一个命令如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command generates this output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了这个输出：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Examples
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Now, moving on to exercises, the first one requires you fetch the `git` repository
    sources for the U-Boot package:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到练习，第一个要求您获取U-Boot软件包的`git`存储库源代码：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the sources are available on your machine, you can try to take a look
    inside the `board` directory; here, a number of development board manufacturers
    will be present. Let's take a look at `board/atmel/sama5d3_xplained`, `board/faraday/a320evb`,
    `board/freescale/imx`, and `board/freescale/b4860qds`. By observing each of these
    directories, a pattern can be visualized. Almost all of the boards contain a `Kconfig`
    file, inspired mainly from kernel sources because they present the configuration
    dependencies in a clearer manner. A `maintainers` file offers a list with the
    contributors to a particular board support. The base `Makefile` file takes from
    the higher-level makefiles the necessary object files, which are obtained after
    a board-specific support is built. The difference is with `board/freescale/imx`
    which only offers a list of configuration data that will be later used by the
    high-level makefiles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上可用源代码之后，您可以尝试查看`board`目录内部；在这里，将出现许多开发板制造商。让我们看看`board/atmel/sama5d3_xplained`，`board/faraday/a320evb`，`board/freescale/imx`和`board/freescale/b4860qds`。通过观察这些目录，可以看到一种模式。几乎所有的板都包含一个`Kconfig`文件，主要受到内核源的启发，因为它们以更清晰的方式呈现配置依赖关系。一个`maintainers`文件提供了对特定板支持的贡献者列表。基本的`Makefile`文件从更高级别的makefiles中获取必要的对象文件，这些对象文件是在构建特定板支持后获得的。与`board/freescale/imx`的区别在于，它只提供了一个配置数据列表，这些数据将在高级别makefiles中使用。
- en: At the kernel level, the hardware-dependent support is added inside the `arch`
    file. Here, for each specific architecture besides `Makefile` and `Kconfig`, various
    numbers of subdirectories could also be added. These offer support for different
    aspects of a kernel, such as the boot, kernel, memory management, or specific
    applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核级别，硬件相关的支持添加到`arch`文件中。在这里，除了`Makefile`和`Kconfig`之外，还可以添加各种数量的子目录。这些子目录为内核的不同方面提供支持，例如引导、内核、内存管理或特定应用程序。
- en: 'By cloning the kernel sources, the preceding information can be easily visualized
    by using this code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过克隆内核源代码，可以使用以下代码轻松可视化前面的信息：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some of the directories that can be visualized are `arch`/`arc` and `arch`/`metag`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以可视化的目录是`arch`/`arc`和`arch`/`metag`。
- en: 'From the toolchain point of view, the hardware-dependent component is represented
    by the GNU C Library, which is, in turn, usually represented by `glibc`. This
    provides the system call interface that connects to the kernel architecture-dependent
    code and further provides the communication mechanism between these two entities
    to user applications. System calls are presented inside the `sysdeps` directory
    of the `glibc` sources if the `glibc` sources are cloned, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从工具链的角度来看，硬件相关的组件由GNU C库表示，通常由`glibc`表示。这提供了系统调用接口，连接到内核架构相关的代码，并进一步为用户应用程序提供这两个实体之间的通信机制。如果克隆了`glibc`源代码，系统调用将显示在`glibc`源代码的`sysdeps`目录中，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding information can be verified using two methods: the first one
    involves opening the `sysdeps/arm` directory, for example, or by reading the `ChangeLog.old-ports-arm`
    library. Although it''s old and has nonexistent links, such as ports directory,
    which disappeared from the newer versions of the repository, the latter can still
    be used as a reference point.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种方法验证前面的信息：第一种方法涉及打开`sysdeps/arm`目录，例如，或者阅读`ChangeLog.old-ports-arm`库。尽管它已经过时，且存在不存在的链接，比如从存储库的新版本中消失的ports目录，但后者仍然可以用作参考点。
- en: 'These packages are also very easily accessible using the Yocto Project''s `poky`
    repository. As mentioned at [https://www.yoctoproject.org/about](https://www.yoctoproject.org/about):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件包也可以通过Yocto项目的`poky`存储库非常容易地访问。如[https://www.yoctoproject.org/about](https://www.yoctoproject.org/about)所述：
- en: '*"The Yocto Project is an open source collaboration project that provides templates,
    tools and methods to help you create custom Linux-based systems for embedded products
    regardless of the hardware architecture. It was founded in 2010 as a collaboration
    among many hardware manufacturers, open-source operating systems vendors, and
    electronics companies to bring some order to the chaos of embedded Linux development."*'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Yocto项目是一个开源协作项目，提供模板、工具和方法，帮助您创建嵌入式产品的自定义Linux系统，无论硬件架构如何。它成立于2010年，是许多硬件制造商、开源操作系统供应商和电子公司之间的合作，旨在为嵌入式Linux开发的混乱带来一些秩序。”
- en: 'Most of the interaction anyone has with the Yocto Project is done through the
    Poky build system, which is one of its core components that offers the features
    and functionalities needed to generate fully customizable Linux software stacks.
    The first step needed to ensure interaction with the repository sources would
    be to clone them:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与Yocto项目的大多数交互都是通过Poky构建系统完成的，这是其核心组件之一，提供了生成完全可定制的Linux软件堆栈所需的功能和功能。确保与存储库源进行交互的第一步是克隆它们：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the sources are present on your computer, a set of recipes and configuration
    files need to be inspected. The first location that can be inspected is the U-Boot
    recipe, available at `meta/recipes-bsp/u-boot/u-boot_2013.07.bb`. It contains
    the instructions necessary to build the U-Boot package for the corresponding selected
    machine. The next place to inspect is in the recipes available in the kernel.
    Here, the work is sparse and more package versions are available. It also provides
    some `bbappends` for available recipes, such as meta`/recipes-kernel/linux/linux-yocto_3.14.bb`
    and `meta-yocto-bsp/recipes-kernel/linux/linux-yocto_3.10.bbappend`. This constitutes
    a good example for one of the kernel package versions available when starting
    a new build using BitBake.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上存在源代码之后，需要检查一组配方和配置文件。可以检查的第一个位置是U-Boot配方，位于`meta/recipes-bsp/u-boot/u-boot_2013.07.bb`。它包含构建相应选定机器的U-Boot软件包所需的指令。下一个要检查的地方是内核中可用的配方。在这里，工作是稀疏的，有更多的软件包版本可用。它还为可用的配方提供了一些`bbappends`，例如`meta/recipes-kernel/linux/linux-yocto_3.14.bb`和`meta-yocto-bsp/recipes-kernel/linux/linux-yocto_3.10.bbappend`。这构成了使用BitBake开始新构建时可用的内核软件包版本的一个很好的例子。
- en: Toolchain construction is a big and important step for host generated packages.
    To do this, a set of packages are necessary, such as `gcc`, `binutils`, `glibc`
    `library`, and `kernel headers`, which play an important role. The recipes corresponding
    to this package are available inside the `meta/recipes-devtools/gcc/`, `meta/recipes-devtools/binutils`,
    and `meta/recipes-core/glibc` paths. In all the available locations, a multitude
    of recipes can be found, each one with a specific purpose. This information will
    be detailed in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链的构建对于主机生成的软件包来说是一个重要的步骤。为此，需要一组软件包，如`gcc`、`binutils`、`glibc`库和`内核头文件`，它们起着重要的作用。对应于这些软件包的配方可在`meta/recipes-devtools/gcc/`、`meta/recipes-devtools/binutils`和`meta/recipes-core/glibc`路径中找到。在所有可用的位置，都可以找到大量的配方，每个配方都有特定的目的。这些信息将在下一章中详细介绍。
- en: The configurations and options for the selection of one package version in favor
    of another is mainly added inside the machine configuration. One such example
    is the Freescale `MPC8315E-rdb` low-power model supported by Yocto 1.6, and its
    machine configuration is available inside the `meta-yocto-bsp/conf/machine/mpc8315e-rdb.conf`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个软件包版本而不是另一个的配置和选项主要添加在机器配置中。一个这样的例子是Yocto 1.6支持的Freescale `MPC8315E-rdb`低功耗型号，其机器配置可在`meta-yocto-bsp/conf/machine/mpc8315e-rdb.conf`文件中找到。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on this development board can be found at [http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8315E](http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8315E).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此开发板的更多信息，请访问[http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8315E](http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8315E)。
- en: Introducing GNU/Linux
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GNU/Linux
- en: GNU/Linux, or Linux as it's commonly known, represents a name that has a long
    line of tradition behind it, and is one of the most important unions of open source
    software. Shortly, you will be introduced to the history of what is offered to
    people around the world today and the choice available in terms of selecting personal
    computer operating systems. Most of all, we will look at what is offered to hardware
    developers and the common ground available for the development of platforms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GNU/Linux，或者通常所说的Linux，代表着一个悠久的传统，是开源软件中最重要的联盟之一。不久，您将会了解到今天为全世界人们提供的历史以及在选择个人计算机操作系统方面的选择。最重要的是，我们将看看硬件开发人员提供的内容以及可用于平台开发的共同基础。
- en: GNU/Linux consists of the Linux kernel and has a collection of user space applications
    that are put on top of GNU C Library; this acts as a computer operating system.
    It may be considered as one of the most prolific instances of open source and
    free software available, which is still in development. Its history started in
    1983 when Richard Stallman founded the GNU Project with the goal of developing
    a complete Unix-like operating system, which could be put together only from free
    software. By the beginning of the 1990s, GNU already offered a collection of libraries,
    Unix-like shells, compilers, and text editors. However, it lacked a kernel. They
    started developing their own kernel, the Hurd, in 1990\. The kernel was based
    on a Mach micro-kernel design, but it proved to be difficult to work with and
    had a slow development process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GNU/Linux由Linux内核和一系列用户空间应用程序组成，这些应用程序放在GNU C库之上；这充当了计算机操作系统。它可以被认为是最多产的开源和免费软件之一，仍在发展中。它的历史始于1983年，当时Richard
    Stallman创立了GNU项目，旨在开发一个完整的类Unix操作系统，只能使用免费软件组装。到了1990年代初，GNU已经提供了一系列库、类Unix shell、编译器和文本编辑器。然而，它缺少一个内核。他们在1990年开始开发自己的内核Hurd。该内核基于Mach微内核设计，但证明难以使用，并且开发过程缓慢。
- en: 'Meanwhile, in 1991, a Finnish student started working on another kernel as
    a hobby while attending the University of Helsinki. He also got help from various
    programmers who contributed to the cause over the Internet. That student''s name
    was Linus Torvalds and, in 1992, his kernel was combined with the GNU system.
    The result was a fully functional operating system called GNU/Linux that was free
    and open source. The most common form of the GNU system is usually referred to
    as a *GNU/Linux system*, or even a *Linux distribution*, and is the most popular
    variant of GNU. Today, there are a great number of distributions based on GNU
    and the Linux kernel, and the most widely used ones are: Debian, Ubuntu, Red Hat
    Linux, SuSE, Gentoo, Mandriva, and Slackware. This image shows us how the two
    components of Linux work together:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，1991年，一位芬兰学生在赫尔辛基大学上学时开始了另一个内核的业余工作。他还得到了来自互联网上各种程序员的帮助。那位学生的名字叫Linus Torvalds，在1992年，他的内核与GNU系统结合在一起。结果是一个名为GNU/Linux的完全功能的操作系统，它是免费和开源的。GNU系统的最常见形式通常被称为*GNU/Linux系统*，甚至是*Linux发行版*，是GNU的最流行的变体。今天，有许多基于GNU和Linux内核的发行版，其中最广泛使用的有：Debian、Ubuntu、Red
    Hat Linux、SuSE、Gentoo、Mandriva和Slackware。这张图片向我们展示了Linux的两个组件是如何一起工作的：
- en: '![Introducing GNU/Linux](img/image00299.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![介绍GNU/Linux](img/image00299.jpeg)'
- en: Although not originally envisioned to run on anything else then x86 PCs, today,
    the Linux operating system is the most widespread and portable operating system.
    It can be found on both embedded devices or supercomputers because it offers freedom
    to its users and developers. Having tools to generate customizable Linux systems
    is another huge step forward in the development of this tool. It offers access
    to the GNU/Linux ecosystem to new categories of people who, by using a tool, such
    as BitBake, end up learning more about Linux, its architecture differences, root
    filesystem construction and configuration, toolchains, and many other things present
    in the Linux world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最初并不是为了在x86 PC之外的其他设备上运行，但今天，Linux操作系统是最广泛和可移植的操作系统。它可以在嵌入式设备或超级计算机上找到，因为它为用户和开发人员提供了自由。拥有生成可定制Linux系统的工具是这个工具发展的又一个重大进步。它为新类别的人提供了访问GNU/Linux生态系统的途径，通过使用BitBake等工具，他们最终会了解更多关于Linux、其架构差异、根文件系统的构建和配置、工具链以及Linux世界中的许多其他内容。
- en: Linux is not designed to work on microcontrollers. It will not work properly
    if it has less then 32 MB of RAM, and it will need to have at least 4 MB of storage
    space. However, if you take a look at this requirement, you will notice that it
    is very permissive. Adding to this is the fact that it also offers support for
    a variety of communication peripherals and hardware platforms, which gives you
    a clear image of why it is so widely adopted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Linux并不是设计用于微控制器。如果RAM小于32MB，它将无法正常工作，并且至少需要4MB的存储空间。然而，如果你看一下这个要求，你会发现它非常宽松。另外，它还支持各种通信外围设备和硬件平台，这清楚地说明了为什么它如此广泛地被采用。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Well, it may work on 8MB of RAM, but that depends on the application's size
    as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它可能在8MB的RAM上运行，但这取决于应用程序的大小。
- en: 'Working with a Linux architecture in an embedded environment requires certain
    standards. This is an image that represents graphically an environment which was
    made available on one of free-electrons Linux courses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式环境中使用Linux架构需要遵循一定的标准。这是一个图形化表示的环境，它是在free-electrons Linux课程中提供的：
- en: '![Introducing GNU/Linux](img/image00300.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![介绍GNU/Linux](img/image00300.jpeg)'
- en: 'The preceding image presents the two main components that are involved in the
    development process when working with Linux in the embedded devices world:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了在嵌入式设备世界中使用Linux进行开发过程中涉及的两个主要组件：
- en: '**Host machine**: This is the machine where all the development tools reside.
    Outside the Yocto world, these tools are represented by a corresponding toolchain
    cross-compiled for a specific target and its necessary applications sources and
    patches. However, for an Yocto user, all these packages, and the preparation work
    involved, is reduced to automatized tasks executed before the actual work is performed.
    This, of course, has to be prioritized adequately.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：这是所有开发工具所在的机器。在Yocto世界之外，这些工具由为特定目标交叉编译的相应工具链以及其必要的应用程序源代码和补丁表示。然而，对于Yocto用户，所有这些软件包和所涉及的准备工作都被简化为在实际工作之前执行的自动化任务。当然，这必须得到适当的优先考虑。'
- en: '**Target machine**: This is the embedded system on which the work is done and
    tested. All the software available on the target is usually cross-compiled on
    the host machine, which is a more powerful and more efficient environment. The
    components that are usually necessary for an embedded device to boot Linux and
    operate various application, involve using a bootloader for basic initiation and
    loading of the Linux kernel. This, in turn, initializes drivers and the memory,
    and offers services for applications to interact with through the functions of
    the available C libraries.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标机器**：这是嵌入式系统，用于进行工作和测试。目标上可用的所有软件通常都是在主机上进行交叉编译的，主机是一个更强大、更高效的环境。通常需要用于嵌入式设备引导Linux并运行各种应用程序的组件，包括使用引导加载程序进行基本初始化和加载Linux内核。这反过来初始化驱动程序和内存，并通过可用的C库的功能为应用程序提供服务。'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are also other methods of working with embedded devices, such as cross-canadian
    and native development, but the ones presented here are the most used and offer
    the best results for both developers and companies when it comes to software development
    for embedded devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他与嵌入式设备一起工作的方法，比如交叉加拿大和本地开发，但这里介绍的方法是最常用的，对于开发人员和公司在嵌入式设备的软件开发方面都能够取得最好的结果。
- en: To have a functional Linux operating system on an development board, a developer
    first needs to make sure that the kernel, bootloader, and board corresponding
    drives are working properly before starting to develop and integrate other applications
    and libraries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发板上拥有一个功能完整的Linux操作系统之前，开发人员首先需要确保内核、引导程序和板对应的驱动程序正常工作，然后才能开始开发和集成其他应用程序和库。
- en: Introduction to the Yocto Project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目简介
- en: In the previous section, the benefits of having an open source environment were
    presented. Taking a look at how embedded development was done before the advent
    of the Yocto Project offers a complete picture of the benefits of this project.
    It also gives an answer as to why it was adopted so quickly and in such huge numbers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，介绍了拥有开源环境的好处。回顾Yocto项目出现之前嵌入式开发是如何进行的，可以完整地展现这个项目的好处。它也解释了为什么它被如此迅速地和如此大量地采用。
- en: 'Using the Yocto Project, the whole process gets a bit more automatic, mostly
    because the workflow permitted this. Doing things manually requires a number of
    steps to be taken by developers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yocto项目，整个过程变得更加自动化，主要是因为工作流程允许这样做。手动操作需要开发人员执行一系列步骤：
- en: Select and download the necessary packages and components.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并下载必要的软件包和组件。
- en: Configure the downloaded packages.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置下载的软件包。
- en: Compile the configured packages.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译配置好的软件包。
- en: Install the generated binary, libraries, and so on, on `rootfs` available on
    development machine.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发机上安装生成的二进制文件、库等到`rootfs`上。
- en: Generate the final deployable format.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成最终可部署的格式。
- en: All these steps tend to become more complex with the increase in the number
    of software packages that need to be introduced in the final deployable state.
    Taking this into consideration, it can clearly be stated that manual work is suitable
    only for a small number of components; automation tools are usually preferred
    for large and complex systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤在需要引入最终可部署状态的软件包数量增加时会变得更加复杂。考虑到这一点，可以明确地说，手动工作只适用于少量组件；自动化工具通常更适用于大型和复杂的系统。
- en: In the last ten years, a number of automation tools could be used to generate
    an embedded Linux distribution. All of them were based on the same strategy as
    the one described previously, but they also needed some extra information to solve
    dependency related problems. These tools are all built around an engine for the
    execution of tasks and contain metadata that describes actions, dependencies,
    exceptions, and rules.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，有许多自动化工具可以用来生成嵌入式Linux发行版。它们都基于之前描述的相同策略，但它们还需要一些额外的信息来解决依赖性相关的问题。这些工具都建立在一个用于执行任务的引擎周围，并包含描述操作、依赖关系、异常和规则的元数据。
- en: The most notable solutions are Buildroot, Linux Target Image Builder (LTIB),
    Scratchbox, OpenEmbedded, Yocto, and Angstrom. However, Scratchbox doesn't seem
    to be active anymore, with the last commit being done in April 2012\. LTIB was
    the preferred build tool for Freescale and it has lately moved more toward Yocto;
    in a short span of time, LTIB may become deprecated also.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的解决方案是Buildroot、Linux目标镜像生成器（LTIB）、Scratchbox、OpenEmbedded、Yocto和Angstrom。然而，Scratchbox似乎不再活跃，最后一次提交是在2012年4月。LTIB曾是Freescale的首选构建工具，最近更多地转向Yocto；在短时间内，LTIB也可能被淘汰。
- en: Buildroot
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildroot
- en: Buildroot as a tool tries to simplify the ways in which a Linux system is generated
    using a cross-compiler. Buildroot is able to generate a bootloader, kernel image,
    root filesystem, and even a cross-compiler. It can generate each one of these
    components, although in an independent way, and because of this, its main usage
    has been restricted to a cross-compiled toolchain that generates a corresponding
    and custom root filesystem. It is mainly used in embedded devices and very rarely
    for x86 architectures; its main focus being architectures, such as ARM, PowerPC,
    or MIPS. As with every tool presented in this book, it is designed to run on Linux,
    and certain packages are expected to be present on the host system for their proper
    usage. There are a couple of mandatory packages and some optional ones as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot作为一个工具，试图简化使用交叉编译器生成Linux系统的方式。Buildroot能够生成引导程序、内核映像、根文件系统，甚至交叉编译器。它可以独立生成每一个组件，因此它的主要用途被限制在生成相应的自定义根文件系统的交叉编译工具链上。它主要用于嵌入式设备，很少用于x86架构；它的主要关注点是ARM、PowerPC或MIPS等架构。与本书中介绍的每个工具一样，它都是为Linux设计的，并且期望主机系统上有一些特定的软件包以便正确使用。有一些强制性的软件包和一些可选的软件包。
- en: 'There is a list of mandatory packages that contain the certain packages, and
    are described inside the Buildroot manual available at [http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html).
    These packages are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Buildroot手册中有一份包含特定软件包的强制性软件包列表，可以在[http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)找到。这些软件包如下：
- en: '`which`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`which`'
- en: '`sed`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sed`'
- en: '`make` (version 3.81 or any later ones)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make`（3.81版本或更高版本）'
- en: '`binutils`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binutils`'
- en: '`build-essential` (required for Debian-based systems only)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-essential`（仅适用于基于Debian的系统）'
- en: '`gcc` (version 2.95 or any later ones)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc`（2.95版本或更高版本）'
- en: '`g++` (version 2.95 or any later ones)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g++`（2.95版本或更高版本）'
- en: '`bash`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`'
- en: '`patch`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`'
- en: '`gzip`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gzip`'
- en: '`bzip2`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bzip2`'
- en: '`perl`(version 5.8.7 or any later ones)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perl`（5.8.7版本或更高版本）'
- en: '`tar`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar`'
- en: '`cpio`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpio`'
- en: '`python`(version 2.6 or 2.7 ones)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python`（2.6或2.7版本）'
- en: '`unzip`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unzip`'
- en: '`rsync`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rsync`'
- en: '`wget`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget`'
- en: 'Beside these mandatory packages, there are also a number of optional packages.
    They are very useful for the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些强制性软件包外，还有一些可选的软件包。它们对以下方面非常有用：
- en: '**Source fetching tools**: In an official tree, most of the package retrieval
    is done using `wget` from `http`, `https`, or even `ftp` links, but there are
    also a couple of links that need a version control system or another type of tool.
    To make sure that the user does not have a limitation to fetch a package, these
    tools can be used:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源获取工具**：在官方树中，大多数软件包的检索都是使用`wget`从`http`、`https`甚至`ftp`链接进行的，但也有一些链接需要使用版本控制系统或其他类型的工具。为了确保用户没有获取软件包的限制，可以使用以下工具：'
- en: '`bazaar`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bazaar`'
- en: '`cvs`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cvs`'
- en: '`git`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git`'
- en: '`mercurial`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mercurial`'
- en: '`rsync`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rsync`'
- en: '`scp`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scp`'
- en: '`subversion`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subversion`'
- en: '**Interface configuration dependencies**: They are represented by the packages
    that are needed to ensure that the tasks, such as kernel, BusyBox, and U-Boot
    configuration, are executed without problems:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口配置依赖**：它们由需要确保内核、BusyBox和U-Boot配置等任务能够顺利执行的软件包表示：'
- en: '`ncurses5` is used for the menuconfig interface'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncurses5`用于menuconfig界面'
- en: '`qt4` is used for the `xconfig` interface'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qt4`用于`xconfig`界面'
- en: '`glib2`, `gtk2`, and `glade2` are used for the `gconfig` interface'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glib2`，`gtk2`和`glade2`用于`gconfig`界面'
- en: '**Java related package interaction**: This is used to make sure that when a
    user wants to interact with the Java Classpath component, that it will be done
    without any hiccups:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与Java相关的软件包交互**：这用于确保当用户想要与Java类路径组件进行交互时，可以顺利进行：'
- en: '`javac`: this refers to the Java compiler'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`：这是指Java编译器'
- en: '`jar`: This refers to the Java archive tool'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar`：这是指Java存档工具'
- en: '**Graph generation tools**: The following are the graph generation tools:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形生成工具**：以下是图形生成工具：'
- en: '`graphviz` to use `graph-depends` and `<pkg>-graph-depends`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphviz`用于使用`graph-depends`和`<pkg>-graph-depends`'
- en: '`python-matplotlib` to use `graph-build`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-matplotlib`用于使用`graph-build`'
- en: '**Documentation generation tools**: The following are the tools necessary for
    the documentation generation process:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档生成工具**：以下是文档生成过程中所需的工具：'
- en: '`asciidoc`, version 8.6.3 or higher'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asciidoc`，版本8.6.3或更高版本'
- en: '`w3m`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w3m`'
- en: '`python` with the `argparse` module (which is automatically available in 2.7+
    and 3.2+ versions)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python`与`argparse`模块（在2.7+和3.2+版本中自动可用）'
- en: '`dblatex` (necessary for pdf manual generation only)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dblatex`（仅用于pdf手册生成）'
- en: Buildroot releases are made available to the open source community at [http://buildroot.org/downloads/](http://buildroot.org/downloads/)
    every three months, specifically in February, May, August, and November, and the
    release name has the `buildroot-yyyy-mm` format. For people interested in giving
    Buildroot a try, the manual described in the previous section should be the starting
    point for installing and configuration. Developers interested in taking a look
    at the Buildroot source code can refer to [http://git.buildroot.net/buildroot/](http://git.buildroot.net/buildroot/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot发布每三个月一次，具体在2月、5月、8月和11月，并且发布名称采用`buildroot-yyyy-mm`格式。对于有兴趣尝试Buildroot的人来说，前一节中描述的手册应该是安装和配置的起点。对于有兴趣查看Buildroot源代码的开发人员，可以参考[http://git.buildroot.net/buildroot/](http://git.buildroot.net/buildroot/)。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before cloning the Buildroot source code, I suggest taking a quick look at [http://buildroot.org/download](http://buildroot.org/download).
    It could help out anyone who works with a proxy server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在克隆Buildroot源代码之前，建议快速查看[http://buildroot.org/download](http://buildroot.org/download)。这可能会帮助那些使用代理服务器的人。
- en: Next, there will be presented a new set of tools that brought their contribution
    to this field and place on a lower support level the Buildroot project. I believe
    that a quick review of the strengths and weaknesses of these tools would be required.
    We will start with Scratchbox and, taking into consideration that it is already
    deprecated, there is not much to say about it; it's being mentioned purely for
    historical reasons. Next on the line is LTIB, which constituted the standard for
    Freescale hardware until the adoption of Yocto. It is well supported by Freescale
    in terms of **Board Support Packages** (**BSPs**) and contains a large database
    of components. On the other hand, it is quite old and it was switched with Yocto.
    It does not contain the support of new distributions, it is not used by many hardware
    providers, and, in a short period of time, it could very well become as deprecated
    as Scratchbox. Buildroot is the last of them and is easy to use, having a `Makefile`
    base format and an active community behind it. However, it is limited to smaller
    and simpler images or devices, and it is not aware of partial builds or packages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将介绍一组新的工具，它们为这一领域做出了贡献，并将Buildroot项目放在了较低的支持级别上。我相信有必要快速回顾一下这些工具的优势和劣势。我们将从Scratchbox开始，考虑到它已经被弃用，关于它的内容并不多；它之所以被提及纯粹是出于历史原因。接下来是LTIB，它构成了Freescale硬件的标准，直到采用Yocto为止。它在**板支持包**（**BSPs**）方面得到了Freescale的良好支持，并包含了大量的组件数据库。另一方面，它相当古老，已经被Yocto取代。它不包含对新发行版的支持，也不被许多硬件供应商使用，在短时间内，它很可能会像Scratchbox一样被弃用。Buildroot是它们中的最后一个，它易于使用，采用`Makefile`基本格式，并有一个活跃的社区支持。然而，它仅限于较小和较简单的镜像或设备，并不支持部分构建或软件包。
- en: OpenEmbedded
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenEmbedded
- en: The next tools to be introduced are very closely related and, in fact, have
    the same inspiration and common ancestor, the OpenEmbedded project. All three
    projects are linked by the common engine called Bitbake and are inspired by the
    Gentoo Portage build tool. OpenEmbedded was first developed in 2001 when the Sharp
    Corporation launched the ARM-based PDA, and SL-5000 Zaurus, which run Lineo, an
    embedded Linux distribution. After the introduction of Sharp Zaurus, it did not
    take long for Chris Larson to initiate the OpenZaurus Project, which was meant
    to be a replacement for SharpROM, based on Buildroot. After this, people started
    to contribute many more software packages, and even the support of new devices,
    and, eventually, the system started to show its limitations. In 2003, discussions
    were initiated around a new build system that could offer a generic build environment
    and incorporate the usage models requested by the open source community; this
    was the system to be used for embedded Linux distributions. These discussions
    started showing results in 2003, and what has emerged today is the Openembedded
    project. It had packages ported from OpenZaurus by people, such as Chris Larson,
    Michael Lauer, and Holger Schurig, according to the capabilities of the new build
    system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要介绍的工具非常相关，并且实际上具有相同的灵感和共同的祖先，即OpenEmbedded项目。这三个项目都由一个称为Bitbake的共同引擎连接，并受到Gentoo
    Portage构建工具的启发。OpenEmbedded最初是在2001年开发的，当时夏普公司推出了基于ARM的PDA和SL-5000 Zaurus，运行Lineo，一个嵌入式Linux发行版。在夏普Zaurus推出后不久，Chris
    Larson发起了OpenZaurus项目，旨在取代基于Buildroot的SharpROM。之后，人们开始贡献更多的软件包，甚至支持新设备，最终系统开始显示其局限性。2003年，开始讨论一个新的构建系统，可以提供一个通用的构建环境，并结合开源社区所需的使用模型；这是用于嵌入式Linux发行版的系统。这些讨论在2003年开始显示结果，今天出现的就是Openembedded项目。它有从OpenZaurus移植过来的软件包，如Chris
    Larson、Michael Lauer和Holger Schurig等人，根据新构建系统的能力。
- en: 'The Yocto Project is the next evolutionary stage of the same project and has
    the Poky build system as its core piece, which was created by Richard Purdie.
    The project started as a stabilized branch of the OpenEmbedded project and only
    included a subset of the numerous recipes available on OpenEmbedded; it also had
    a limited set of devices and support of architectures. Over time, it became much
    more than this: it changed into a software development platform that incorporated
    a fakeroot replacement, an Eclipse plug-in, and QEMU-based images. Both the Yocto
    Project and OpenEmbedded now coordinate around a core set of metadata called **OpenEmbedded-Core**
    (**OE-Core**).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目是同一项目的下一个演进阶段，其核心部分是Poky构建系统，由Richard Purdie创建。该项目最初是OpenEmbedded项目的一个稳定分支，只包括OpenEmbedded上可用的众多recipes的子集；它还具有有限的设备和架构支持。随着时间的推移，它变得更多：它变成了一个软件开发平台，集成了fakeroot替代品、Eclipse插件和基于QEMU的镜像。现在Yocto项目和OpenEmbedded围绕一个称为**OpenEmbedded-Core**（**OE-Core**）的核心元数据进行协调。
- en: The Yocto Project is sponsored by the Linux Foundation, and offers a starting
    point for developers of Linux embedded systems who are interested in developing
    a customized distribution for embedded products in a **hardware-agnostic environment**.
    The Poky build system represents one of its core components and is also quite
    complex. At the center of all this lies Bitbake, the engine that powers everything,
    the tool that processes metadata, downloads corresponding source codes, resolves
    dependencies, and stores all the necessary libraries and executables inside the
    build directory accordingly. Poky combines the best from OpenEmbedded with the
    idea of layering additional software components that could be added or removed
    from a build environment configuration, depending on the needs of the developer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目由Linux基金会赞助，为对开发定制嵌入式产品的Linux开发人员提供了一个**硬件无关环境**的起点。Poky构建系统代表了其核心组件之一，也非常复杂。在所有这些中心是Bitbake，它驱动一切的引擎，处理元数据的工具，下载相应的源代码，解决依赖关系，并相应地存储所有必要的库和可执行文件在构建目录中。Poky结合了OpenEmbedded的优点，以分层的方式添加或删除构建环境配置中的额外软件组件，具体取决于开发人员的需求。
- en: 'Poky is build system that is developed with the idea of keeping simplicity
    in mind. By default, the configuration for a test build requires very little interaction
    from the user. Based on the clone made in one of the previous exercises, we can
    do a new exercise to emphasize this idea:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Poky是一个以简单性为理念开发的构建系统。默认情况下，测试构建的配置需要用户很少的交互。基于之前练习中的克隆，我们可以进行一个新的练习来强调这个理念：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in this example, it is easy to obtain a Linux image that can be later
    used for testing inside a QEMU environment. There are a number of images footprints
    available that will vary from a shell-accessible minimal image to an LSB compliant
    image with GNOME Mobile user interface support. Of course, that these base images
    can be imported in new ones for added functionalities. The layered structure that
    Poky has is a great advantage because it adds the possibility to extend functionalities
    and to contain the impact of errors. Layers could be used for all sort of functionalities,
    from adding support for a new hardware platform to extending the support for tools,
    and from a new software stack to extended image features. The sky is the limit
    here because almost any recipe can be combined with another.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本例所示，很容易获得一个Linux镜像，以便在QEMU环境中进行测试。有许多可用的镜像足迹，从可以通过shell访问的最小镜像到具有GNOME Mobile用户界面支持的LSB兼容镜像都有。当然，这些基本镜像可以导入到新的镜像中以获得额外的功能。Poky具有分层结构是一个巨大的优势，因为它增加了扩展功能的可能性，并且包含了错误的影响。层可以用于各种功能，从为新的硬件平台添加支持到扩展工具的支持，从新的软件堆栈到扩展的镜像功能。这里的可能性是无限的，因为几乎任何recipe都可以与另一个组合。
- en: 'All this is possible because of the Bitbake engine, which, after the environment
    setup and the tests for minimal systems requirements are met, based on the configuration
    files and input received, identifies the interdependencies between tasks, the
    execution order of tasks, generates a fully functional cross-compilation environment,
    and starts building the necessary native and target-specific packages tasks exactly
    as they were defined by the developer. Here is an example with a list of the available
    tasks for a package:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是可能的，因为Bitbake引擎，它在环境设置和满足最小系统要求的测试之后，根据配置文件和接收到的输入，识别任务之间的相互依赖关系，任务的执行顺序，生成一个完全功能的交叉编译环境，并开始构建必要的本地和目标特定的软件包任务，就像它们被开发人员定义的那样。这里有一个示例，列出了一个软件包的可用任务列表：
- en: '![OpenEmbedded](img/image00301.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![OpenEmbedded](img/image00301.jpeg)'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about Bitbake and its baking process can be found in *Embedded
    Linux Development with Yocto Project*, by Otavio Salvador and Daiane Angolini.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Bitbake及其烘烤过程的更多信息，请参阅《使用Yocto项目进行嵌入式Linux开发》，作者是Otavio Salvador和Daiane Angolini。
- en: The metadata modularization is based on two ideas—the first one refers to the
    possibility of prioritizing the structure of layers, and the second refers to
    the possibility of not having the need for duplicate work when a recipe needs
    changes. The layers are overlapping. The most general layer is meta, and all the
    other layers are usually stacked over it, such as `meta-yocto` with Yocto-specific
    recipes, machine specific board support packages, and other optional layers, depending
    on the requirements and needs of developers. The customization of recipes should
    be done using `bbappend` situated in an upper layer. This method is preferred
    to ensure that the duplication of recipes does not happen, and it also helps to
    support newer and older versions of them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据模块化基于两个想法——第一个是关于优先考虑层的结构的可能性，第二个是关于当一个配方需要更改时不需要重复工作的可能性。这些层是重叠的。最一般的层是meta，所有其他层通常都堆叠在其上，比如`meta-yocto`与Yocto特定的配方、机器特定的板支持包，以及其他可选层，取决于开发人员的需求和需求。应该使用位于上层的`bbappend`来定制配方。这种方法更受青睐，以确保不会重复配方，并且还有助于支持更新和旧版本。
- en: 'An example of the organization of layers is found in the previous example that
    specified the list of the available tasks for a package. If a user is interested
    in identifying the layers used by the `test` build setup in the previous exercise
    that specified the list of the available tasks for a package, the `bblayers.conf`
    file is a good source of inspiration. If `cat` is done on this file, the following
    output will be visible:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面指定软件包的可用任务列表的示例中，可以找到层的组织示例。如果用户有兴趣识别在前面的练习中指定软件包的可用任务列表的`test`构建设置使用的层，`bblayers.conf`文件是一个很好的灵感来源。如果在此文件上执行`cat`命令，将看到以下输出：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The complete command for doing this is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的完整命令是：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is a visual mode for the layered structure of a more generic build directory:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更通用的构建目录的分层结构的可视模式：
- en: '![OpenEmbedded](img/image00302.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![OpenEmbedded](img/image00302.jpeg)'
- en: 'Yocto as a project offers another important feature: the possibility of having
    an image regenerated in the same way, no matter what factors change on your host
    machine. This is a very important feature, taking into consideration not only
    that, in the development process, changes to a number of tools, such as `autotools`,
    `cross-compiler`, `Makefile`, `perl`, `bison`, `pkgconfig`, and so on, could occur,
    but also the fact that parameters could change in the interaction process with
    regards to a repository. Simply cloning one of the repository branches and applying
    corresponding patches may not solve all the problems. The solution that the Yocto
    Project has to these problems is quite simple. By defining parameters prior to
    any of the steps of the installation as variables and configuration parameters
    inside recipes, and by making sure that the configuration process is also automated,
    will minimize the risks of manual interaction are minimized. This process makes
    sure that image generation is always done as it was the first time.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto作为一个项目提供了另一个重要的功能：无论主机机器上发生了什么变化，都可以以相同的方式重新生成镜像。这是一个非常重要的功能，不仅考虑到在开发过程中，一些工具的更改，如`autotools`、`交叉编译器`、`Makefile`、`perl`、`bison`、`pkgconfig`等，可能会发生，还考虑到与仓库的交互过程中参数可能会发生变化。简单地克隆一个仓库分支并应用相应的补丁可能无法解决所有问题。Yocto项目对这些问题的解决方案非常简单。通过在任何安装步骤之前定义变量和配置参数，并确保配置过程也是自动化的，将最小化手动交互的风险。这个过程确保了镜像生成总是像第一次那样进行。
- en: Since the development tools on the host machine are prone to change, Yocto usually
    compiles the necessary tools for the development process of packages and images,
    and only after their build process is finished, the Bitbake build engine starts
    building the requested packages. This isolation from the developer's machine helps
    the development process by guaranteeing the fact that updates from the host machine
    do not influence or affect the processes of generating the embedded Linux distribution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主机上的开发工具容易发生变化，Yocto通常会编译用于软件包和镜像开发过程的必要工具，只有在它们的构建过程完成后，Bitbake构建引擎才开始构建所请求的软件包。这种与开发人员机器的隔离有助于开发过程，保证了主机机器的更新不会影响或影响生成嵌入式Linux发行版的过程。
- en: 'Another critical point that was elegantly solved by the Yocto Project is represented
    by the way that the toolchain handles the inclusion of headers and libraries;
    because this could bring later on not only compilation but also execution errors
    that are very hard to predict. Yocto resolves these problems by moving all the
    headers and libraries inside the corresponding `sysroots` directory, and by using
    the `sysroot` option, the build process makes sure that no contamination is done
    with the native components. An example will emphasize this information better:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目优雅解决的另一个关键问题是工具链处理头文件和库的方式；因为这可能不仅会带来编译错误，还会带来非常难以预测的执行错误。 Yocto通过将所有头文件和库移动到相应的`sysroots`目录中，并使用`sysroot`选项，构建过程确保不会与本地组件发生污染来解决这些问题。一个例子将更好地强调这一信息：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Yocto project contributes to making reliable embedded Linux development
    and because of its dimensions, it is used for lots of things, ranging from board
    support packages by hardware companies to new software solutions by software development
    companies. Yocto is not a perfect tool and it has certain drawbacks:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目有助于实现可靠的嵌入式Linux开发，由于其规模，它被用于许多事情，从硬件公司的板支持包到软件开发公司的新软件解决方案。 Yocto并不是一个完美的工具，它有一定的缺点：
- en: Requirements for disk space and machine usage are quite high
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间和机器使用要求相当高
- en: Documentation for advanced usage is lacking
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏高级用法的文档
- en: Tools, such as Autobuilder and Eclipse plug-ins, now have functionality problems
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具，如Autobuilder和Eclipse插件，现在存在功能问题
- en: There are also other things that bother developers, such as `ptest` integration
    and SDK sysroot's lack of extensibility, but a part of them are solved by the
    big community behind the project, and until the project shows its limitations,
    a new one will still need to wait to take its place. Until this happens, Yocto
    is the framework to use to develop custom embedded Linux distribution or products
    based in Linux.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些困扰开发人员的事情，比如`ptest`集成和SDK sysroot的缺乏可扩展性，但其中一部分问题已经被项目背后的大社区解决，直到项目显示出其局限性，新的问题仍然需要等待来取代它。在此之前，Yocto是开发基于Linux的自定义嵌入式Linux发行版或产品的框架。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were presented with the advantages of open source, and
    examples of how open source helped the Linux kernel, Yocto Project, OpenEmbedded,
    and Buildroot for the development and growth of projects, such as LTIB and Scratchbox;
    the lack of open source contribution meant the deprecation and disappearance of
    them over time. The information presented to you will be in the form of examples,
    which will give you a clearer idea of the concepts in this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解开源的优势，以及开源如何帮助Linux内核、Yocto项目、OpenEmbedded和Buildroot等项目的发展和增长，例如LTIB和Scratchbox；缺乏开源贡献意味着它们随着时间的推移被淘汰和消失。向您呈现的信息将以示例的形式呈现，这将让您更清楚地了解本书中的概念。
- en: In the next chapter, there will be more information on toolchains and its constituent
    components. Exercises that give you a better idea of toolchains will be generated
    using both the manual and automatic approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将会有更多关于工具链及其组成部分的信息。使用手动和自动方法生成让您更好地了解工具链的练习。
