- en: '*Chapter 10*: Keeping Your System Hardened with SELinux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用SELinux保护系统'
- en: In this chapter, we are going to familiarize ourselves with SELinux. SELinux
    has been around for a while, but a lack of understanding regarding how it works
    leads many people to suggest disabling it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将熟悉SELinux。SELinux已经存在一段时间了，但对其工作原理的不了解导致许多人建议禁用它。
- en: This is not something we want, as it would be similar to telling a user to forego
    a password because it is hard to remember.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的，因为这就像告诉用户放弃密码因为难记一样。
- en: We will introduce the origins of SELinux, and what the default modes and policies
    are. Then, we will understand how SELinux applies to our files, folders, and processes,
    and how to restore them to the system defaults.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍SELinux的起源，以及默认模式和策略是什么。然后，我们将了解SELinux如何应用于我们的文件、文件夹和进程，以及如何将它们恢复到系统默认值。
- en: 'Additionally, we will explore how to fine-tune the policies using Booleans
    and troubleshoot common issues with the help of the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将探讨如何使用布尔值对策略进行微调，并通过以下部分的帮助解决常见问题：
- en: SELinux usage in enforcing and permissive modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制和宽松模式下的SELinux使用
- en: Reviewing the SELinux context for files and processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查文件和进程的SELinux上下文
- en: Tweaking the policy with semanage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用semanage调整策略
- en: Restoring changed file contexts to the default policy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改的文件上下文恢复为默认策略
- en: Using SELinux Boolean settings to enable services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SELinux布尔设置启用服务
- en: SELinux troubleshooting and common fixes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux故障排除和常见修复
- en: By the end, we will better understand how to use SELinux properly and how to
    benefit from the additional protection that it provides to our system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更好地了解如何正确使用SELinux以及如何从它为我们的系统提供的额外保护中受益。
- en: During the chapter, there will be detailed explanations of how SELinux works
    to aid our understanding of the way it operates, even if using it, in reality,
    is a lot simpler. We will also use these examples to illustrate cases where SELinux
    prevents attacks or misconfigurations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将详细解释SELinux的工作原理，以帮助我们了解它的运作方式，即使在现实中使用它也要简单得多。我们还将使用这些示例来说明SELinux防止攻击或配置错误的情况。
- en: Let's get hands-on with SELinux!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们亲自动手使用SELinux！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is possible to continue the practice of using the virtual machine created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text and can be downloaded from [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以继续使用本书开头创建的虚拟机[*第1章*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014)中的练习，*安装RHEL8*。本章所需的任何额外软件包都将在文本旁边标明，并可从[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration)下载。
- en: SELinux usage in enforcing and permissive modes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制和宽松模式下的SELinux使用
- en: '**Security-Enhanced Linux** (**SELinux**) was introduced in December of 2000
    via the Linux-Kernel mailing list as a product started by the **National Security
    Agency** (**NSA**) to improve the security of the operating system by means of
    mandatory access controls and role-based access control, as opposed to the traditional
    discretionary access controls that were available in the system.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全增强型Linux**（**SELinux**）于2000年12月通过Linux-Kernel邮件列表推出，是由**国家安全局**（**NSA**）启动的产品，旨在通过强制访问控制和基于角色的访问控制来提高操作系统的安全性，而不是系统中可用的传统自主访问控制。'
- en: Before SELinux was introduced in the Linux kernel, discussions took place regarding
    the proper way to do it, and finally, a kernel framework named **Linux Security
    Modules (LSM)** was introduced and SELinux was implemented using it so that other
    approaches could use LSM, too, and not just SELinux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核引入SELinux之前，关于正确的实施方式进行了讨论，最终引入了一个名为**Linux安全模块（LSM）**的内核框架，并使用它实施了SELinux，以便其他方法也可以使用LSM，而不仅仅是SELinux。
- en: SELinux provides security improvements to Linux as access to files made by users,
    processes, or even other resources can be controlled in a very granular way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux为Linux提供了安全改进，用户、进程甚至其他资源对文件的访问可以以非常精细的方式进行控制。
- en: 'Let''s take one example to make it clearer when SELinux comes into play: when
    a web server is serving pages from users, it reads files from the user''s home
    directory inside the `public_html` or `www` folders (the most standard ones).
    Being able to read files from the user''s home directory can reveal the contents
    in the event that the web server process is hijacked by an attacker, and this
    precise moment is when SELinux comes into play, as it will automatically block
    access to files that should not be accessible for a web server.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子来更清楚地说明SELinux何时发挥作用：当Web服务器从用户中提供页面时，它会从用户的主目录中的`public_html`或`www`文件夹（最常见的文件夹）读取文件。能够从用户的主目录中读取文件可能会在Web服务器进程被攻击者劫持时泄露内容，而正是在这一刻，SELinux发挥作用，因为它将自动阻止对Web服务器不应访问的文件的访问。
- en: SELinux then confines the processes and services to only perform what they are
    supposed to, and only using the resources that are authorized. This is a really
    important feature that keeps things under control, even in the event of software
    bugs that may lead to unexpected files or resources being accessed. SELinux will
    block it if it has not been authorized by the active policy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，SELinux限制进程和服务只执行它们应该执行的操作，并且只使用经授权的资源。这是一个非常重要的功能，即使在可能导致访问意外文件或资源的软件错误的情况下也能保持控制。如果没有经活动策略授权，SELinux将阻止它。
- en: Important tip
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: SELinux permissions always arise following regular **Discretionary Access Controls**
    (**DAC**) if a user has no access to a file because of improper file permissions.
    SELinux has nothing to do there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户由于不正确的文件权限而无法访问文件，那么SELinux权限总是在常规**自主访问控制**（**DAC**）之后出现。SELinux在这里无能为力。
- en: 'By default, the system installation should deploy it in `enforcing` mode and
    using the `targeted` policy. It is possible to check your current system status
    via execution of `sestatus`, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，系统安装应该以“强制执行”模式部署，并使用“定向”策略。可以通过执行`sestatus`来检查当前系统状态，如下面的屏幕截图所示：
- en: '![Figure 10.1 – Output of sestatus for our system'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 我们系统的sestatus输出'
- en: '](img/B16799_10_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_001.jpg)'
- en: Figure 10.1 – Output of sestatus for our system
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 我们系统的sestatus输出
- en: As we can see, our system has SELinux `enabled`, using the `targeted` policy,
    and is currently `enforcing`. Let's learn about what this means.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的系统已经启用了SELinux，并使用了“定向”策略，目前处于“强制执行”状态。让我们了解一下这意味着什么。
- en: SELinux works by defining a `dnf list selinux-policy-*` in your system, with
    `targeted` and `mls` being the most common ones.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux通过在系统中定义`dnf list selinux-policy-*`来工作，“定向”和“mls”是最常见的。
- en: We will focus on the targeted policy, but to make an analogy regarding `mls`,
    the `su` or `sudo`, they would still have the original label attached so permissions
    could be reduced if the root login happened over a local terminal or a remote
    connection and `sudo` execution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于定向策略，但为了对“mls”进行类比，`su`或`sudo`，它们仍然会附加原始标签，因此如果通过本地终端或远程连接进行根登录和`sudo`执行，权限可能会降低。
- en: The mode, listed as `enforcing`, means that the policy is currently being enforced,
    which is the opposite of `permissive`. We can consider this as being active and
    offering protection, while permissive entails being active but only providing
    a warning, and not offering protection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列为“强制执行”的模式意味着当前正在执行策略，这与“宽松”相反。我们可以将其视为处于活动状态并提供保护，而“宽松”则意味着处于活动状态但只提供警告，不提供保护。
- en: Why do we have `permissive` instead of just disabling it? This question is a
    bit tricky, so let's explain a bit more about how it works to provide a better
    answer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有“宽松”而不是只禁用呢？这个问题有点棘手，所以让我们更详细地解释一下它的工作原理，以提供更好的答案。
- en: SELinux uses extended attributes in the filesystem to store the labels. Each
    time a file is created, a label is assigned based on the policy, but this only
    happens while SELinux is active, so this makes SELinux `disabled` different from
    SELinux `permissive`, because the first one will not create those labels for the
    new files created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux使用文件系统中的扩展属性来存储标签。每次创建文件时，都会根据策略分配一个标签，但只有在SELinux处于活动状态时才会发生这种情况，因此这使得SELinux“禁用”与SELinux“宽松”不同，因为前者不会为新创建的文件创建这些标签。
- en: Additionally, SELinux in `permissive` mode allows us to see the errors that
    will be raised if a program has not received a good policy for it or if a file
    has no proper labels.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SELinux在“宽松”模式下允许我们查看如果程序没有得到良好的策略或文件没有适当的标签将会引发的错误。
- en: 'It is really easy to switch from `enforcing` to `permissive` and vice versa
    and always via the `setenforce` command, while we can use `getenforce` to retrieve
    the current status, as we can see in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从“强制执行”切换到“宽松”和反之都非常容易，始终通过`setenforce`命令进行，而我们可以使用`getenforce`来检索当前状态，如下面的屏幕截图所示：
- en: '![Figure 10.2 – Changing SELinux enforcing status'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – 改变SELinux强制执行状态'
- en: '](img/B16799_10_002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_002.jpg)'
- en: Figure 10.2 – Changing SELinux enforcing status
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 改变SELinux强制执行状态
- en: It might look basic, but it really is as easy as that, a matter of running a
    command. However, if the status was disabled, it would be a completely different
    story.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很基础，但实际上就是这么简单，只是运行一个命令而已。但是，如果状态被禁用，情况将完全不同。
- en: SELinux status is configured by editing the `/etc/selinux/config` file, but
    changes only take effect after a system reboot; that is, we can switch from `enforcing`
    to `permissive` in real time or from permissive to enforcing, but when changing
    the policy from `disabling` to `enabling`, or vice versa, SELinux will require
    us to reboot the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux状态通过编辑`/etc/selinux/config`文件进行配置，但更改只有在系统重新启动后才会生效；也就是说，我们可以实时从“强制执行”切换到“宽松”，或从“宽松”切换到“强制执行”，但当从“禁用”切换到“启用”，或反之，则需要重新启动系统。
- en: The general advice is to leave SELinux in enforcing mode, but if, for whatever
    reason, it was disabled, the recommendation is to switch SELinux to `permissive`
    as the first step when moving from `disabled`. This will allow us to check that
    the system actually works without being locked out of it because of a kernel blocking
    access to files and resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议是将SELinux保持在强制执行模式，但如果出于任何原因它被禁用，建议在从“禁用”切换时首先将SELinux切换到“宽松”。这将使我们能够检查系统是否实际上可以正常工作，而不会因为内核阻止对文件和资源的访问而被锁定在外面。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: During the reboot after switching from `disabled` to `permissive` or `enforcing`,
    the system will force a relabeling of the filesystem based on the policy. This
    is accomplished by the creation of a file in the root folder of our filesystem
    named `/.autorelabel`, which will trigger the process and reboot again afterward.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在从“禁用”切换到“宽松”或“强制执行”后的重新启动过程中，系统将根据策略强制重新标记文件系统。这是通过在我们文件系统的根文件夹中创建一个名为`/.autorelabel`的文件来实现的，这将触发该过程，并在之后再次重启。
- en: But why opt for disabling instead of `permissive`? For example, some software
    might require to set it in disabled mode even if later, it can be re-enabled for
    operations or for other reasons, but bear in mind that SELinux is a security feature
    that protects your system and should be kept.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么选择禁用而不是“宽松”？例如，一些软件可能需要将其设置为禁用模式，即使以后可以重新启用以进行操作或出于其他原因，但请记住SELinux是一项保护系统的安全功能，应该保留。
- en: Keep in mind that SELinux uses `/var/log/audit/audit.log` file as well as system
    journals, and yes, it's a cache, so rules are not checked as frequently so as
    to speed up operations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，SELinux使用`/var/log/audit/audit.log`文件以及系统日志，是一个缓存，因此规则不会被频繁检查，以加快操作速度。
- en: Let's go back to the idea of the filesystem storing labels and let's jump into
    the next section to see how they relate to processes, files, and the RBAC provided
    by SELinux.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到文件系统存储标签的概念，并跳转到下一节，看看它们与进程、文件以及SELinux提供的RBAC之间的关系。
- en: Reviewing the SELinux context for files and processes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查文件和进程的SELinux上下文
- en: 'SELinux uses labels, also referred to as the security context attached to each
    file, and defines several aspects. Let''s check one example in our home folder
    with the `ls –l` command, but with a special modifier, `Z`, that will show SELinux
    attributes as well, as we can see in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux使用标签，也称为附加到每个文件的安全上下文，并定义了几个方面。让我们用`ls –l`命令在我们的home文件夹中检查一个示例，但使用一个特殊的修饰符`Z`，它也会显示SELinux属性，如下截图所示：
- en: '![Figure 10.3 – File listing showing SELinux attributes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 显示SELinux属性的文件列表'
- en: '](img/B16799_10_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_003.jpg)'
- en: Figure 10.3 – File listing showing SELinux attributes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 显示SELinux属性的文件列表
- en: 'Let''s focus on the output for one of the files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于其中一个文件的输出：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The SELinux attributes are the ones listed as `unconfined_u:object_r:admin_home_t:s0`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux属性是列为`unconfined_u:object_r:admin_home_t:s0`的属性：
- en: '`unconfined_u`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfined_u`'
- en: '`object_r`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object_r`'
- en: '`admin_home_t`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin_home_t`'
- en: '`s0` in multi-level security and multi-category security'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s0`在多级安全和多类别安全中'
- en: 'Something similar happens with processes, and similarly, we can append `Z`
    to many of the common commands to get the contexts, for example, with `ps Z`,
    as we can see in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 进程也会发生类似的情况，同样，我们可以在许多常见命令后添加`Z`来获取上下文，例如，使用`ps Z`，如下截图所示：
- en: '![Figure 10.4 – ps output with SELinux contexts'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 带有SELinux上下文的ps输出'
- en: '](img/B16799_10_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_004.jpg)'
- en: Figure 10.4 – ps output with SELinux contexts
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 带有SELinux上下文的ps输出
- en: 'Again, let''s examine one of the lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们检查其中一行：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, we can see the same approach: user, role, type, and level for multi-level
    security and multi-category security.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到相同的方法：用户、角色、类型和多级安全和多类别安全。
- en: Now that we've introduced what it looks like, let's focus on how it works in
    the targeted policy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了它的外观，让我们专注于它在有针对性的策略中的工作方式。
- en: The targeted policy allows everything to run as if SELinux was not enabled in
    the system, except for the services targeted by it. This makes a good compromise
    between security and usability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有针对性的策略允许所有东西都可以像系统中没有启用SELinux一样运行，除了它所针对的服务。这在安全性和可用性之间取得了很好的平衡。
- en: During development of the policy, new services are added, while others are refined,
    and many of the most common services have policies written for protecting them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略开发过程中，会添加新的服务，同时对其他服务进行改进，并且对许多最常见的服务编写了保护它们的策略。
- en: SELinux also features something named **transitions**. A transition allows one
    process started by a user, with a binary with some specific role, to transition
    via the execution into some other role, which is used later to define what the
    permissions are for it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux还具有名为**转换**的功能。转换允许由用户启动的一个进程，具有某个特定角色的二进制文件，通过执行转换为其他角色，后者用于定义其权限。
- en: 'As you might imagine, our user also has a SELinux context, and similarly, we
    can use the `id -Z` command for checking it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，我们的用户也有一个SELinux上下文，同样，我们可以使用`id -Z`命令来检查它：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, going back to the first example, Apache Web Server is provided by the `httpd`
    package, which can be installed via `dnf –y install httpd`. Once installed, let's
    start it with `systemctl start httpd` and enable it with `systemctl enable httpd`,
    and then open the firewall with `firewall-cmd --add-service=http` and `firewall-cmd
    --add-service=https`, as we've done with other services in previous chapters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到第一个例子，Apache Web服务器由`httpd`软件包提供，可以通过`dnf –y install httpd`进行安装。安装后，让我们使用`systemctl
    start httpd`启动它，并使用`systemctl enable httpd`启用它，然后使用`firewall-cmd --add-service=http`和`firewall-cmd
    --add-service=https`打开防火墙，就像我们在前几章中对其他服务所做的那样。
- en: 'Previous commands can be found in the following script: [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的命令可以在以下脚本中找到：[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh)。
- en: 'Let''s see how all that comes into play in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图中所有这些是如何发挥作用的：
- en: '![Figure 10.5 – Web server SELinux contexts'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – Web服务器SELinux上下文'
- en: '](img/B16799_10_005.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_005.jpg)'
- en: Figure 10.5 – Web server SELinux contexts
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – Web服务器SELinux上下文
- en: Here, we can see how the executable on disk has the context `httpd_exec_t`,
    the process is `httpd_t`, and the files/folder served by it is `httpd_sys_content_t`,
    and it works!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到磁盘上的可执行文件具有上下文`httpd_exec_t`，进程是`httpd_t`，它提供的文件/文件夹是`httpd_sys_content_t`，它可以工作！
- en: 'Let''s now create an `index.htm` file in our `home` folder and move it to the
    `Apache Web Root` folder as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`home`文件夹中创建一个`index.htm`文件，并将其移动到`Apache Web Root`文件夹中，如下所示：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see what happens when we try to access the files as shown in the following
    screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们尝试访问文件时会发生什么，如下截图所示：
- en: '![Figure 10.6 – Apache behavior with the generated files'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 – Apache生成文件的行为'
- en: '](img/B16799_10_006.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_006.jpg)'
- en: Figure 10.6 – Apache behavior with the generated files
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Apache生成文件的行为
- en: As we can see, each file has one SELinux context, but on top of that, Apache
    is denying access to the one we moved (`index1.htm`), but showing the contents
    for the one we copied (`index2.htm`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个文件都有一个SELinux上下文，但除此之外，Apache拒绝访问我们移动的文件(`index1.htm`)，但显示我们复制的文件(`index2.htm`)的内容。
- en: What has happened here? We copied one file and move the other, out of the same
    source, but they got two different SELinux contexts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们复制了一个文件并移动了另一个文件，来自同一个源，但它们具有两个不同的SELinux上下文。
- en: 'Let''s extend the test as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展测试，如下截图所示：
- en: '![Figure 10.7 – Retrying with SELinux in permissive mode'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 在SELinux的宽容模式下重试'
- en: '](img/B16799_10_007.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_007.jpg)'
- en: Figure 10.7 – Retrying with SELinux in permissive mode
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 在SELinux的宽容模式下重试
- en: As we can see in the preceding screenshot, we are now able to access file contents,
    so you could say *"What is wrong with SELinux that does not allow my site to work?"*,
    but the right way to express it would be *"Look how SELinux has protected us from
    disclosing a personal file on a website"*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所看到的，我们现在能够访问文件内容，所以你可以说：“SELinux有什么问题，不允许我的网站工作？”，但正确的表达方式应该是：“看看SELinux如何保护我们不让个人文件在网站上泄露”。
- en: If, instead of directly moving a file into the Apache's `/var/www/html`), it
    was an attacker trying to reach our home folder files, SELinux would have denied
    those accesses by default. The `httpd_t` process cannot access the `admin_home_t`
    context.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是直接将文件移动到Apache的`/var/www/html`，而是攻击者试图访问我们的家庭文件夹文件，SELinux将默认拒绝这些访问。`httpd_t`进程无法访问`admin_home_t`上下文。
- en: A similar thing happens when we try to get Apache or any other service under
    the targeted policy to listen on a port that is not the one configured by default,
    and the best way to get familiar with what we can or cannot do is to learn about
    the `semanage` utility.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试让Apache或任何其他受目标策略约束的服务监听默认配置的端口之外的端口时，类似的事情会发生，了解我们可以或不可以做什么的最佳方法是学习`semanage`实用程序。
- en: Using `semanage`, we can list, edit, add, or delete the different values in
    the policy, and even export and import our customizations, so let's use it to
    learn a bit more about it using our example with `httpd`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`semanage`，我们可以列出、编辑、添加或删除策略中的不同值，甚至导出和导入我们的自定义内容，所以让我们使用它来通过我们的`httpd`示例学习更多关于它的知识。
- en: Let's learn about `semanage` in the following section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节学习关于`semanage`的知识。
- en: Tweaking the policy with semanage
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用semanage调整策略
- en: As we introduced earlier, the targeted policy contains some configurations that
    are enforced for the services it has defined, allowing the protection of those
    services while not interfering with the ones it does not know about.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前介绍的，目标策略包含一些为其定义的服务强制执行的配置，允许保护这些服务，同时不干扰它不知道的服务。
- en: Still, sometimes we need to tweak a number of settings, such as allowing `http`
    or the `ssh` daemon to listen on alternate ports or accessing some other file
    types, but without losing the additional layer of protection provided by SELinux.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要调整一些设置，比如允许`http`或`ssh`守护程序监听备用端口或访问其他文件类型，但又不失去SELinux提供的额外保护层。
- en: First, let's ensure that `policycoreutils` and `policycoreutils-python-utils`
    are installed in our system with `dnf –y install policycoreutils-python-utils
    policycoreutils` as they provide the tools we will use in this and the next sections
    of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保在我们的系统中安装了`policycoreutils`和`policycoreutils-python-utils`，使用`dnf –y
    install policycoreutils-python-utils policycoreutils`，因为它们提供了我们将在本章和下一节中使用的工具。
- en: 'Let''s learn with the help of an example. Let''s see which ports `httpd_t`
    can access with `semanage port -l|grep http`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来学习。让我们看看`httpd_t`可以访问哪些端口，使用`semanage port -l|grep http`命令：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, `http_port_t`, used by Apache Daemon, is allowed, by default,
    to use the ports `80`, `81`, `443`, `488`, `8008`, `9009`, `8443`, and `9000`
    via `tcp`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`http_port_t`，由Apache守护程序使用，默认情况下允许使用`tcp`的端口`80`、`81`、`443`、`488`、`8008`、`9009`、`8443`和`9000`。
- en: That means that if we want to run Apache on any of those ports, no changes to
    policy will be required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想在这些端口中的任何一个上运行Apache，不需要对策略进行任何更改。
- en: 'If we repeat the command but for `ssh`, we only see port `22` opened (executing
    `semanage port -l|grep ssh`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复这个命令，但是对于`ssh`，我们只看到端口`22`被打开（执行`semanage port -l|grep ssh`）：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, we might want to add another port, let''s say `2222`, to the list
    of possible ports, so that we hide the standard one being tested by port scanners.
    We will be able to do it via `semanage port -a -p tcp -t ssh_port_t 2222` and
    then validate with the prior command `semanage port –l|grep ssh`, which now shows
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要添加另一个端口，比如`2222`，到可能端口的列表中，以便隐藏标准端口被端口扫描器测试。我们可以通过`semanage port -a
    -p tcp -t ssh_port_t 2222`来实现，然后使用先前的命令`semanage port –l|grep ssh`进行验证，现在显示如下：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, port `2222` has been added to the list of available ports for
    the `ssh_port_t` type, and that enables the `ssh` daemon to start listening on
    it (this, of course, requires additional configuration for the `ssh` daemon configuration
    and to the firewall before we get a working service).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，端口`2222`已经添加到`ssh_port_t`类型的可用端口列表中，这使得`ssh`守护程序可以开始监听它（当然，这需要在我们获得可用服务之前对`ssh`守护程序配置和防火墙进行额外的配置）。
- en: In the same way, for example, some web services require writing to specific
    folders for storing configurations, but by default, the context on `/var/www/html`
    is `httpd_sys_content_t`, which does not allow writing to disk.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，例如，一些网络服务需要写入特定文件夹以存储配置，但默认情况下，`/var/www/html`上的上下文是`httpd_sys_content_t`，不允许写入磁盘。
- en: 'We can check the available file contexts with `semanage fcontext –l` in a similar
    way to what we did with the ports, but the list of files is huge, as a web server
    might use common locations such as `logs` and `cgi-bin`, as well as filesystem
    files for certificates, configuration, and home directories, and extensions such
    as PHP and others. When you check the contexts with the preceding command, pay
    attention to the different types that are available and what the structure is
    for one listing, for example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`semanage fcontext –l`检查可用的文件上下文，类似于我们对端口所做的方式，但是文件列表很长，因为Web服务器可能使用常见位置，如`logs`和`cgi-bin`，以及用于证书、配置和家目录的文件系统文件，以及PHP等扩展名。当您使用前面的命令检查上下文时，注意可用的不同类型以及一个列表的结构是什么，例如：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, there is a regular expression that matches the files in the `wp-content`
    folder inside the `/var/www/html` path applying to all files and sets a SELinux
    context of `httpd_sys_rw_content_t`, which allows read-write access. This folder
    is used by the popular blog software **WordPress**, so the policy is already prepared
    for covering some of the most popular services, folders, and requirements without
    requiring system administrators to write them ad hoc.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有一个正则表达式匹配`/var/www/html`路径内`wp-content`文件夹中的文件，适用于所有文件，并设置了`httpd_sys_rw_content_t`的SELinux上下文，这允许读写访问。这个文件夹被流行的博客软件**WordPress**使用，因此策略已经准备好覆盖一些最受欢迎的服务、文件夹和要求，而无需系统管理员自行编写。
- en: 'When invoking `semanage`, it will output that it has some subcommands we can
    use, such as the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`semanage`时，它将输出一些我们可以使用的子命令，例如以下内容：
- en: '`import`: This allows the importing of local modifications.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`：这允许导入本地修改。'
- en: '`export`: This allows the exporting of local changes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export`：这允许导出本地更改。'
- en: '`login`: This allows the login and SELinux user associations to be managed.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：这允许管理登录和SELinux用户关联。'
- en: '`user`: This manages SELinux users with roles and levels.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这管理具有角色和级别的SELinux用户。'
- en: '`port`: This manages port definitions and types.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：这管理端口定义和类型。'
- en: '`ibpkey`: This manages InfiniBand definitions.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ibpkey`：这管理InfiniBand定义。'
- en: '`ibendport`: This manages end port InfiniBand definitions.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ibendport`：这管理InfiniBand端口定义。'
- en: '`interface`: This defines network interface definitions.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`：这定义了网络接口定义。'
- en: '`module`: This manages policy modules for SELinux.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`：这管理SELinux的策略模块。'
- en: '`node`: This manages definitions of network nodes.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`：这管理网络节点的定义。'
- en: '`fcontext`: This manages file context definitions.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fcontext`：这管理文件上下文定义。'
- en: '`boolean`: This manages Booleans for tweaking policies.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：这管理用于调整策略的布尔值。'
- en: '`permissive`: This manages the enforcing mode.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permissive`：这管理强制模式。'
- en: '`dontaudit`: This manages the `dontaudit` rules in the policy.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dontaudit`：这管理策略中的`dontaudit`规则。'
- en: For each one of the preceding commands, we can use the `-h` argument to list,
    help, and learn about the extra arguments that can be used for each one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述每个命令，我们可以使用`-h`参数来列出、帮助和了解可以用于每个命令的额外参数。
- en: For the day-to-day use case, most of the time we'll be using `port` and `fcontext`
    as those will cover extending or tuning the available services that come with
    Red Hat Enterprise Linux, like the example we have showcased with `ssh` listening
    on an additional port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日常使用情况，大多数时候我们将使用`port`和`fcontext`，因为它们将涵盖扩展或调整Red Hat Enterprise Linux提供的可用服务，就像我们在`ssh`监听额外端口的示例中展示的那样。
- en: Important tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Traditionally, `semanage`, `regexp` for the path that will be used. When following
    this approach, if the filesystem is relabeled or the context restored, the application
    will continue to work.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，`semanage`，`regexp`用于将要使用的路径。遵循这种方法时，如果文件系统重新标记或恢复上下文，应用程序将继续工作。
- en: Let's see how to manually set the context for files and how to restore the defaults
    in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何手动设置文件的上下文以及如何在下一节中恢复默认值。
- en: Restoring changed file contexts to the default policy
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将更改的文件上下文恢复为默认策略
- en: In the previous section, we mentioned how `semanage` enables us to perform changes
    to the policy, which is the recommended way to perform changes and to persist
    them for future files and folders, but that is not the only way we can perform
    operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们提到了`semanage`如何使我们能够对策略进行更改，这是执行更改并将其持久化到未来文件和文件夹的推荐方式，但这并不是我们执行操作的唯一方式。
- en: From the command line, we can use the `chcon` utility to change the context
    for a file. This will allow us to define the user, the role, and the type for
    the file we want to alter, and similar to other filesystem utilities such as `chmod`
    or `chown`, we can also affect files recursively, so it's easy to set a full folder
    hierarchy to the desired context.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，我们可以使用`chcon`实用程序来更改文件的上下文。这将允许我们为要更改的文件定义用户、角色和类型，并且与其他文件系统实用程序（如`chmod`或`chown`）类似，我们也可以递归地影响文件，因此很容易将整个文件夹层次结构设置为所需的上下文。
- en: One feature that I always found very interesting is the ability to copy the
    context of a file via the `--reference` flag, so that the same context as the
    referenced file is applied to the target one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直觉得非常有趣的一个功能是能够通过`--reference`标志复制文件的上下文，以便将引用文件的相同上下文应用于目标文件。
- en: 'When we were introducing the example of `httpd` earlier in this chapter, we
    did a test with two files, `index1.htm` and `index2.htm`, that were moved and
    copied to the `/var/www/html` folder. To go deeper into this example, we will
    make additional copies of `index1.htm` to demonstrate in the next screenshot the
    usage of `chcon`. Bear in mind that creating the files directly in the `/var/www/html`
    folder will set the files to have the proper context, so we need to create them
    at `/root` and then move them to the target folder, as we can see in the following
    screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章前面介绍`httpd`的示例时，我们对`index1.htm`和`index2.htm`进行了测试，它们被移动并复制到`/var/www/html`文件夹中。为了深入探讨这个例子，我们将额外复制`index1.htm`，以便在下一张截图中演示`chcon`的用法。请记住，直接在`/var/www/html`文件夹中创建文件将设置文件具有适当的上下文，因此我们需要在`/root`中创建它们，然后将它们移动到目标文件夹，正如我们在下一张截图中所看到的：
- en: '![Figure 10.8 – Demonstrating chcon usage'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – 演示chcon用法'
- en: '](img/B16799_10_008.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_008.jpg)'
- en: Figure 10.8 – Demonstrating chcon usage
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 演示chcon用法
- en: As we can see, both the `index1.htm` and `index3.htm` files now have the proper
    context, in the first case, using the reference, and in the second, defining the
    type to use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`index1.htm`和`index3.htm`文件现在都具有适当的上下文，在第一种情况下，使用引用，在第二种情况下，定义要使用的类型。
- en: 'Of course, this is not the only method. As we indicated earlier, the recommended
    way for setting context for applications is to define the `regexps` path via `semanage`,
    and this empowers us to use the `restorecon` command to apply the right context,
    according to the configuration, to the files. Let''s check how it operates in
    the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是唯一的方法。正如我们之前所指出的，为应用程序设置上下文的推荐方法是通过`semanage`定义`regexps`路径，这使我们能够使用`restorecon`命令根据配置将正确的上下文应用于文件。让我们看看下面的截图中它是如何操作的：
- en: '![Figure 10.9 – Using restorecon to restore context'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 – 使用restorecon恢复上下文'
- en: '](img/B16799_10_009.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_009.jpg)'
- en: Figure 10.9 – Using restorecon to restore context
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 使用restorecon恢复上下文
- en: As we can see, we used `restorecon –vR /var/www/html/` and it automatically
    changed the `index3.htm` file into `httpd_sys_content_t`, which is defined for
    that folder as we saw when we were testing `semanage` to list the contexts. The
    arguments used, `v` and `R`, make the utility report the changes (verbose) and
    work recursively on the paths provided.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们使用了`restorecon –vR /var/www/html/`，它自动将`index3.htm`文件更改为`httpd_sys_content_t`，这是我们在测试`semanage`列出上下文时看到的该文件夹的定义。使用的参数`v`和`R`使实用程序报告更改（详细信息）并在提供的路径上递归工作。
- en: 'Let''s say we have messed the system up by running `chcon` over the root filesystem.
    What would be the way to fix it? In this case, as we mentioned earlier, we should
    do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过在根文件系统上运行`chcon`来搞乱了系统。修复的方法是什么？在这种情况下，正如我们之前提到的，我们应该执行以下操作：
- en: Set the operation mode to `permissive` to not block further access via `setenforce
    0`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作模式设置为`permissive`以通过`setenforce 0`不阻止进一步访问。
- en: Put the marker to have the filesystem relabeled via `touch /.autorelabel`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置标记以通过`touch /.autorelabel`重新标记文件系统。
- en: Modify the `/etc/selinux/config` file to set the boot mode to `permissive`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`/etc/selinux/config`文件以将引导模式设置为`permissive`。
- en: Reboot the system to let relabeling happen.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动系统以进行重新标记。
- en: Once the system reboots, edit `/etc/selinux/config` again to define the operation
    mode as `enforcing`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统重新启动后，再次编辑`/etc/selinux/config`，将操作模式定义为`enforcing`。
- en: By operating in this way, instead of just running `restorecon -R /`, we are
    making sure that the system is operational and will continue to operate after
    reboot and a full relabel is applied to the filesystem, so it is left ready to
    re-enable the `enforcing` mode safely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式操作，而不仅仅是运行`restorecon -R /`，我们确保系统是可操作的，并且在重新启动和对文件系统应用完整的重新标记后将继续运行，因此可以安全地重新启用`enforcing`模式。
- en: In the next section, let's see how to tune the policy within itself, using the
    Booleans to tune how it works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看如何在策略内部调整策略，使用布尔值来调整其工作方式。
- en: Using SELinux Boolean settings to enable services
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SELinux布尔设置来启用服务
- en: Many services have a wide range of configuration options for many common cases,
    but not always the same. For example, the `http` server should not access user
    files, but at the same time, it's a common way of operation to enable personal
    websites from the `www` or `public_html` folders in each user's home directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务具有许多常见情况的广泛配置选项，但并非总是相同。例如，`http`服务器不应访问用户文件，但与此同时，从每个用户的主目录中的`www`或`public_html`文件夹启用个人网站是一种常见的操作方式。
- en: To overcome that use case and, at the same time, provide enhanced security,
    the SELinux policy makes use of Booleans.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种情况，并同时提供增强的安全性，SELinux策略使用布尔值。
- en: 'A Boolean is a tunable that can be set by the administrator that can enable
    or disable conditionals in the policy code. Let''s see, for example, a list of
    Booleans available for `httpd` by executing `getsebol -a|grep ^http` (list reduced):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是管理员可以设置的可调整的条件，可以在策略代码中启用或禁用条件。例如，通过执行`getsebol -a|grep ^http`（缩小列表）来查看`httpd`可用的布尔值：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This list is a reduced subset of the Booleans available, but it does give us
    an idea of what it can accomplish; for example, `http`, by default, cannot use
    the network to connect to other hosts, or send an email (usually done in PHP scripts),
    or can't even access home folders for users.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表是可用布尔值的缩小子集，但它确实给了我们一个它可以实现的想法；例如，默认情况下，`http`不能使用网络连接到其他主机，或发送电子邮件（通常在PHP脚本中完成），甚至不能访问用户的主目录。
- en: 'For example, if we want to enable users in a system to publish their personal
    web pages from the `www` folder in their home directory, that is `/home/user/www/`,
    we will have to enable the `httpd_enable_homedirs` Boolean by running the following
    command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在系统中启用用户从其主目录中的`www`文件夹发布其个人网页，即`/home/user/www/`，我们将不得不通过运行以下命令启用`httpd_enable_homedirs`布尔值：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will tweak the policy to enable `http` to access the user's home directory
    to serve the pages there. If, additionally, the servers will be stored on a **Network
    FileSystem** (**NFS**) or **Common Internet FileSystem** (**CIFS**) mount, additional
    Booleans will be required. We're still using the same targeted policy, but we've
    enabled the internal conditionals to permit that the accesses are not to be blocked
    by SELinux.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调整策略以使`http`能够访问用户的主目录以在那里提供页面。如果服务器还存储在**网络文件系统**（**NFS**）或**公共互联网文件系统**（**CIFS**）挂载上，将需要额外的布尔值。我们仍然使用相同的有针对性的策略，但我们已经启用了内部条件，以允许访问不会被SELinux阻止。
- en: Important tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `–P` parameter to `setsebool` is required to make the change *permanent*.
    That means writing the change so that it is persisted; without it, the change
    will be lost once we restart our server.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`-P`参数对于`setsebool`是必需的，以使更改*永久*。这意味着写入更改以使其持久化；如果没有它，一旦重新启动服务器，更改将丢失。'
- en: 'As we''ve seen, `getsebool` and `setsebool` allow us to query and to set the
    values for the Booleans that tune the policy, but also, `semanage boolean -l`
    can help here, as we can see in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`getsebool`和`setsebool`允许我们查询和设置调整策略的布尔值，而`semanage boolean -l`也可以帮助我们，正如我们在下面的截图中所看到的：
- en: '![Figure 10.10 – Using semanage to manage Booleans'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – 使用semanage管理布尔值'
- en: '](img/B16799_10_010.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_010.jpg)'
- en: Figure 10.10 – Using semanage to manage Booleans
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 - 使用semanage管理布尔值
- en: In the previous screenshot, we can see not only the Boolean we edited using
    `setsebool`, but also a description of the intended behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们不仅可以看到使用`setsebool`编辑的布尔值，还可以看到预期行为的描述。
- en: One of the benefits is that `semanage`, as we introduced, allows us to export
    and import the local changes to the policy, so any customization made can be exported
    and imported to another system to ease the setup of similar server profiles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个好处是，正如我们介绍的，`semanage`允许我们导出和导入对策略的本地更改，因此可以将进行的任何自定义导出并导入到另一个系统，以便轻松设置类似的服务器配置文件。
- en: All the possible Booleans in the policy can be checked with `semanage boolean
    –l`, similar to what we did to list the binding ports for applications in our
    `http` example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 策略中的所有可能的布尔值都可以使用`semanage boolean –l`进行检查，类似于我们在`http`示例中列出应用程序的绑定端口时所做的。
- en: We have learned about using Booleans to tune how the policy is adapting to some
    specific but pretty common cases. Next, we will explore probably the most frequently
    used part for administrators, that is, troubleshooting, but with the focus on
    SELinux.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了使用布尔值来调整策略如何适应一些特定但相当常见的情况。接下来，我们将探索管理员可能最常用的部分，即故障排除，但重点是SELinux。
- en: SELinux troubleshooting and common fixes
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux故障排除和常见修复
- en: 'One of the main problems in getting used to SELinux is that many people who
    are not familiar with it blame it for things not working; however, this argument
    is getting a bit outdated: SELinux was introduced in Red Hat Enterprise Linux
    4, which was back in 2005\.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 适应SELinux的主要问题之一是，许多不熟悉它的人会因为事情无法正常工作而责怪它；然而，这个论点已经有点过时了：SELinux是在2005年推出的Red
    Hat Enterprise Linux 4中引入的。
- en: Most of the time, issues with SELinux and our systems are related to changed
    file contexts and changing ports for services, and fewer time issues with the
    policy itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，与SELinux和我们的系统有关的问题都与更改文件上下文和更改服务端口有关，与策略本身有关的问题较少。
- en: First of all, there are several places where we can check for errors, but in
    our list we should start with the audit log or the system messages. For example,
    we can start with the `/var/log/audit/audit.log` file that we introduced earlier
    in this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几个地方可以检查错误，但在我们的列表中，我们应该从审计日志或系统消息开始。例如，我们可以从我们在本章前面介绍的`/var/log/audit/audit.log`文件开始。
- en: Also bear in mind that SELinux **Mandatory Access Control** (**MAC**) only plays
    once we have cleared access from regular **Discretionary Access Controls** (**DAC**),
    that is, if we've no permission to check a file (for example, mode 400 and our
    user not being the owner). In this case, it's highly unlikely that SELinux is
    blocking access.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，SELinux**强制访问控制**（**MAC**）只有在我们从常规**自主访问控制**（**DAC**）中获得了访问权限后才起作用，也就是说，如果我们没有权限检查文件（例如，模式400和我们的用户不是所有者），那么SELinux几乎不可能阻止访问。
- en: Most of the time, our system will have installed the `setroubleshoot-server`
    and `setroubleshoot-plugins` packages that provide several tools, including `sealert`,
    to query the received SELinux messages and many times, also, to suggest changes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们的系统将安装`setroubleshoot-server`和`setroubleshoot-plugins`软件包，提供多个工具，包括`sealert`，用于查询接收到的SELinux消息，并且很多时候也会建议更改。
- en: 'Let''s cover some of the basics that we should always validate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们应该始终验证的一些基础知识：
- en: Review all the other controls (user and group ownership and permissions are
    properly set).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查所有其他控件（用户和组所有权和权限是否设置正确）。
- en: Do not disable SELinux.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要禁用SELinux。
- en: If a program is not working properly and it was shipped with the OS, it might
    be a bug and should be reported via a support case or Bugzilla at [https://bugzilla.redhat.com](https://bugzilla.redhat.com).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序无法正常工作，并且是随操作系统一起发布的，那可能是一个错误，应该通过支持案例或Bugzilla报告给[https://bugzilla.redhat.com](https://bugzilla.redhat.com)。
- en: Only if a program is not working properly might it be made to run unconfined,
    but leaving all remaining system services protected via the targeted policy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当程序无法正常工作时，才可能使其运行不受限制，但通过定向策略保护所有其余系统服务。
- en: Think about what was done before the error happened if this is an existing program.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是一个现有程序，请考虑错误发生之前做了什么。
- en: Perhaps files were moved instead of copied or created upon reaching their destination,
    or perhaps the ports or folders for the software were changed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 也许文件被移动而不是复制或创建，或者也许软件的端口或文件夹被更改了。
- en: 'Having arrived at this point, we should check `audit.log` for relevant messages.
    For example, as regards the example we mentioned regarding the wrong context with
    the files in `/var/www/html/`, an example audit entry would be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这一点后，我们应该检查`audit.log`以获取相关消息。例如，关于我们提到的关于`/var/www/html/`中文件错误上下文的示例，审计条目如下：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It looks strange, but if we check the parameters, we see the path of the affected
    file, the PID, the source context (`scontext`), and the target context (`tcontext`),
    so in brief, we can see that `httpd_t` tried to access (get attributes) for a
    target context `admin_home_t` and that was denied.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很奇怪，但如果我们检查参数，我们会看到受影响文件的路径、PID、源上下文（`scontext`）和目标上下文（`tcontext`），因此简而言之，我们可以看到`httpd_t`尝试访问（获取属性）目标上下文`admin_home_t`并且被拒绝的情况。
- en: 'At the same time, if we''re using `setroubleshoot`, we will get a message like
    this in the system journal:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们正在使用`setroubleshoot`，我们将在系统日志中收到这样的消息：
- en: '![Figure 10.11 – setroubleshoot logging in the system journal'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 - 在系统日志中记录setroubleshoot'
- en: '](img/B16799_10_011.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_10_011.jpg)'
- en: Figure 10.11 – setroubleshoot logging in the system journal
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 - 在系统日志中记录setroubleshoot
- en: As we can see in the preceding screenshot, it already identified that one of
    the plugins suggests applying the command `restorecon` over the file, as it's
    not matching the one for the folder it's in, and even suggests the exact command
    to use for restoring the label.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，它已经确定其中一个插件建议对文件应用`restorecon`命令，因为它与所在文件夹不匹配，并且甚至建议使用确切的命令来恢复标签。
- en: 'Another plugin suggests generating a custom policy using the following two
    commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个插件建议使用以下两个命令生成自定义策略：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, this kind of recommendation should be taken with knowledge of what
    is being done, which means that the preceding commands will fix `httpd_t` in terms
    of getting access to the `home_admin_t` file. We can learn about what would happen
    by only running the first command, together with the `audit2allow` pipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种建议应该在了解正在进行的操作的情况下进行，这意味着前面的命令将修复`httpd_t`以便访问`home_admin_t`文件。我们可以通过仅运行第一个命令以及`audit2allow`管道来了解会发生什么。
- en: Running `ausearch –c 'httpd' --raw | audit2allow –M my-httpd` creates several
    files named `my-httpd` in the current folder, one named `my-httpd.te`, and another
    named `my-httpd.pp`. The second command that we will *not use* installs the modified
    policy, but please, don't ever do that until you have an understanding of what's
    going on, as we will see in the following lines.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ausearch –c 'httpd' --raw | audit2allow –M my-httpd`在当前文件夹中创建了几个名为`my-httpd`的文件，一个名为`my-httpd.te`，另一个名为`my-httpd.pp`。我们将不使用第二个命令来安装修改后的策略，请在了解发生了什么之前，永远不要这样做，因为我们将在接下来的行中看到。
- en: 'The interesting file for us now is the `my-httpd.te` one (where *te* means
    *type enforcement*):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对我们来说有趣的文件是`my-httpd.te`（其中*te*表示*类型强制*）：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From there, we can see that it uses a requirements session for the types involved,
    and later, the rule itself, which allows `httpd_t` access to `admin_home_t` files
    for using the `getattr` function, nothing else, nothing more.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以看到它使用了一个要求会话来处理涉及的类型，以及稍后的规则本身，这允许`httpd_t`访问`admin_home_t`文件以使用`getattr`函数，没有其他东西，也没有更多东西。
- en: As has been said previously, will this fix our issue? It will effectively allow
    `httpd_t` to obtain access to the `index3.html` file, so there will no longer
    be any errors, but this comes with a significant cost. From that point, `httpd_t`
    could also read home directory files without any complaints.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，这将解决我们的问题吗？它将有效地允许`httpd_t`访问`index3.html`文件，因此将不再出现任何错误，但这将付出巨大的代价。从那时起，`httpd_t`也可以读取主目录文件而不会有任何投诉。
- en: Important note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I don't know how many times this fact needs to be reinforced, but think twice
    before acting on a system. SELinux is a protection mechanism for increasing the
    safety of your system; do not disable it, do not blindly accept `audit2allow`
    created policies without some initial investigation and understanding of what
    the issue might be and what the proposed resolution does, as it may almost be
    equivalent to disabling SELinux.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道这个事实需要强调多少次，但在对系统采取行动之前三思。SELinux是一种增加系统安全性的保护机制；不要禁用它，不要盲目接受`audit2allow`创建的策略，而没有对问题进行初步调查和了解提出的解决方案可能是什么，因为这几乎等同于禁用SELinux。
- en: 'If, at this point, we have installed that module, we can use `semodule` to
    do the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这一点上，我们已经安装了该模块，我们可以使用`semodule`来执行以下操作：
- en: List `semodule -l`.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出`semodule -l`。
- en: Install `semodule -i $MODULE_NAME`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`semodule -i $MODULE_NAME`。
- en: Remove `semodule –r $MODULE_NAME`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`semodule –r $MODULE_NAME`。
- en: With the preceding commands, we can check or alter the current status for the
    policy-loaded modules.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的命令，我们可以检查或更改已加载策略模块的当前状态。
- en: 'Going back to reviewing system logs, we may realize that something is actually
    failing sometime after it began, but not from the very beginning, so using `ausearch`
    or passing the full logs to `audit2allow` might not prove helpful; however, we
    can use the command suggested by `setroubleshootd` to list them:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾系统日志后，我们可能会意识到某些事情实际上是在开始后的某个时候失败的，但不是从一开始就失败，因此使用`ausearch`或将完整日志传递给`audit2allow`可能没有帮助；但是，我们可以使用`setroubleshootd`建议的命令来列出它们：
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we execute `sealert –l <ID>`, we will receive the output provided by the
    different plugins to fix the issue as well as context information similar to what
    is shown in *Figure 10.11*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`sealert –l <ID>`，我们将收到不同插件提供的输出，以修复问题以及类似于*图10.11*中显示的上下文信息。
- en: 'In the case of new software being deployed that has no SELinux support, we
    can do the following checks the other way around in a test system:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署不支持SELinux的新软件的情况下，我们可以在测试系统中以相反的方式进行以下检查：
- en: Set SELinux to `permissive` mode.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SELinux设置为`permissive`模式。
- en: Deploy the software.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署软件。
- en: Analyze all the alerts received to see whether anything is unexpected.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析收到的所有警报，看看是否有什么意外情况。
- en: Contact software vendors and initiate a support case with Red Hat to work on
    a policy.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与软件供应商联系，并启动与Red Hat合作解决策略的支持案例。
- en: 'In case we''re getting locked out of our system because SELinux is enforcing
    and we have badly messed the labels up, for example, by running a bad `chcon`
    command recursively against our root folder (for example, scripting a context
    change depending on a variable and that variable being empty), we still have the
    following ways to get out of trouble:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们因为SELinux正在执行并且我们已经严重搞乱了标签而被系统锁定，例如通过递归运行错误的`chcon`命令来针对我们的根文件夹（例如，根据一个变量编写上下文更改的脚本，而该变量为空），我们仍然有以下方法来摆脱麻烦：
- en: Use `setenforce 0` to put SELinux in `permissive` mode.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setenforce 0`将SELinux置于`permissive`模式。
- en: Run `touch /.autorelabel`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`touch /.autorelabel`。
- en: Reboot the host so that at the next boot, SELinux restores the appropriate labels
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动主机，以便在下次启动时，SELinux恢复适当的标签
- en: If we are in a really bad situation and, for example, are unable to use `setenforce
    0` or the system cannot even boot or perform relabeling correctly, there is still
    hope, but some additional steps are required.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于一个非常糟糕的情况，例如无法使用`setenforce 0`或系统甚至无法正确引导或执行重标记，仍然有希望，但需要一些额外的步骤。
- en: When a system is rebooting, we can see the list of installed kernels at the
    grub prompt and use it to edit the kernel boot parameters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统重新启动时，我们可以在grub提示符下看到已安装内核的列表，并使用它来编辑内核引导参数。
- en: Using the `selinux=0` parameter, we completely disable SELinux, and this is
    something we don't want, but we can use `enforcing=0` to accomplish having SELinux
    enabled, but in `permissive` mode.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`selinux=0`参数，我们完全禁用了SELinux，这是我们不想要的，但我们可以使用`enforcing=0`来实现启用SELinux，但处于`permissive`模式。
- en: Once we have our system booting into `permissive` mode, we can repeat the previous
    procedure to get back to the previous behavior and continue debugging the situation
    within the system itself with the prior indications given (checking system logs,
    and others).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的系统启动进入`permissive`模式，我们可以重复之前的过程，恢复到先前的行为，并继续在系统内部调试情况（检查系统日志等）。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has introduced SELinux, how it works, how we can check the processes,
    files, and ports, and how to fine-tune them either by adding new options or using
    Booleans. We also covered several initial troubleshooting skills that we should
    explore further to enhance our knowledge and experience.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了SELinux的工作原理，以及如何检查进程、文件和端口，以及如何通过添加新选项或使用布尔值来对它们进行微调。我们还介绍了一些初始的故障排除技能，我们应该进一步探索以增强我们的知识和经验。
- en: SELinux, as we've seen, is a powerful tool for keeping our system secured with
    an extra layer that protects our system even from unknown issues that might come
    from defects in the software itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，SELinux是一个强大的工具，可以通过额外的层保护我们的系统，即使是来自软件本身缺陷的未知问题。
- en: We have covered how to find the SELinux context in files and processes, how
    those are applied via the policy, and how to tune it so that our system is protected
    and still able to provide the expected service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在文件和进程中找到SELinux上下文，以及这些上下文是如何通过策略应用的，以及如何调整它以使我们的系统受到保护，同时仍能提供预期的服务。
- en: Troubleshooting SELinux is a skill that will help us in adapting the software
    that doesn't come with Red Hat Enterprise Linux to still perform properly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 排除SELinux故障是一项技能，将帮助我们适应不带Red Hat Enterprise Linux的软件，以便仍能正常运行。
- en: In the next chapter, we will learn about security profiles with OpenSCAP to
    continue keeping our system safe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用OpenSCAP的安全配置文件，以继续保持我们的系统安全。
