- en: Architecting a Storage Cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计存储集群
- en: Software-defined storage has changed the way we store our data; with increased
    functionality comes increased requirements when designing the right solution.
    A significant amount of variables need to be considered when architecting a storage
    cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件定义的存储已经改变了我们存储数据的方式；随着功能的增加，设计正确解决方案时需要考虑的要求也在增加。在设计存储集群时需要考虑大量的变量。
- en: This chapter explores the different design aspects of implementing software-defined
    storage solutions using GlusterFS and its various components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了使用GlusterFS及其各种组件实现软件定义存储解决方案的不同设计方面。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: GlusterFS compute requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlusterFS计算需求
- en: Using the right storage size
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的存储大小
- en: Defining performance needs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义性能需求
- en: Deciding the right approach for high availability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定高可用性的正确方法
- en: Establishing how the workload ties everything together
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定工作负载如何联系在一起
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we''ll use the documentation for GlusterFS available on the
    following URLs:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用以下网址上提供的GlusterFS文档：
- en: '[https://www.gluster.org/](https://www.gluster.org/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gluster.org/](https://www.gluster.org/)'
- en: '[https://github.com/gluster/glusterfs](https://github.com/gluster/glusterfs)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/gluster/glusterfs](https://github.com/gluster/glusterfs)'
- en: GlusterFS compute requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlusterFS计算需求
- en: As with any software, GlusterFS has a set of requirements that are defined by
    the developers to ensure that it works as expected. The actual requirements described
    in the documentation are relatively low, and pretty much every computer sold in
    the last 10 years can run GlusterFS. This is probably not at the best possible
    level of performance, but it still shows the flexibility of being able to run
    it in mixed conditions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何软件一样，GlusterFS有一组由开发人员定义的要求，以确保其按预期工作。文档中描述的实际要求相对较低，几乎每台在过去10年中销售的计算机都可以运行GlusterFS。这可能不是最佳性能水平，但它仍然显示了在混合条件下运行的灵活性。
- en: 'For compute requirements, we mainly have the following two resources that we
    need to consider when designing a solution with GlusterFS:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算需求，我们主要有以下两个资源需要考虑在设计使用GlusterFS的解决方案时：
- en: RAM
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: CPU
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: RAM
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: With memory, the choice is relatively straightforward—use as much as possible.
    Unfortunately, there is no such thing as infinite memory, but the statement of
    using as much as possible couldn't be more real, since GlusterFS uses RAM as a
    read cache for each of the nodes, and at the same time the Linux kernel uses memory
    for the read-ahead cache to speedup reads on frequently accessed files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存，选择相对简单——尽可能多地使用。不幸的是，没有无限的内存，但尽可能多地使用内存这一说法是非常真实的，因为GlusterFS使用RAM作为每个节点的读取缓存，同时Linux内核使用内存作为预读缓存，以加快对频繁访问的文件的读取速度。
- en: Depending on the brick layout and filesystem chosen, available memory plays
    a significant role in read performance. As an example of bricks using the advanced ZFS filesystem,
    where it uses RAM for its **Adaptive Replacement Cache** (**ARC**). This adds
    an extra layer of caching sitting on high-speed RAM. The downside is that it consumes
    as much as it has available, so selecting a server that provides considerable
    amount of memory helps a lot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据砖块布局和选择的文件系统，可用内存在读取性能中起着重要作用。以使用高级ZFS文件系统的砖块为例，它使用RAM作为其自适应替换缓存（ARC）。这增加了一个额外的缓存层，位于高速RAM上。缺点是它会消耗尽可能多的内存，因此选择提供大量内存的服务器会有很大帮助。
- en: GlusterFS does not require terabytes of RAM—having 32 GB or more per node assures
    that caches are big enough to allocate frequently accessed files, and if the cluster
    grows in size by adding more bricks to each node, adding more RAM should be considered
    in order to increase the available memory for caching.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GlusterFS并不需要大量的内存——每个节点拥有32GB或更多的内存可以确保缓存足够大，以分配频繁访问的文件，如果通过在每个节点上添加更多的砖块来扩展集群的规模，那么应该考虑增加更多的内存，以增加缓存的可用内存。
- en: Why is cache important?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么缓存很重要？
- en: 'Consider the following: even old RAM technology such as DDR2 can deliver throughput
    in the GBps and latencies around the several nanoseconds. On the other hand, reading
    from regular spinning media (hard disk drives) throughput peaks at 150 MBps in
    most cases, and latency is in the several hundred milliseconds.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下：即使是旧的DDR2内存技术也可以提供GBps级的吞吐量和几纳秒的延迟。另一方面，从常规旋转介质（硬盘驱动器）读取的吞吐量在大多数情况下峰值为150MBps，延迟在几百毫秒。
- en: Reading from cache is always faster than going to disk—waiting for the disk
    to move its head, finding the blocks of data requested, then sending it back to
    the controllers and onto the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中读取总是比访问磁盘快——等待磁盘移动其磁头，找到请求的数据块，然后将其发送回控制器并传递到应用程序。
- en: One thing to keep in mind is that cache needs to be warmed up first; this is
    the process of allowing the system to determine which files are regularly being
    accessed and then moving that data to the cache. While it is warming up, requests
    are slower, as they first have to be fetched from disk.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，缓存需要先预热；这是允许系统确定哪些文件经常被访问，然后将数据移动到缓存中的过程。在预热期间，请求会变慢，因为它们首先必须从磁盘中获取。
- en: CPU
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU
- en: Any software requires CPU cycles, and GlusterFS is no exception. CPU requirements
    are moderately low, and depend on the type of volume used, for example, a **replicated
    volume** requires far less CPU than a **dispersed volume**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件都需要CPU周期，GlusterFS也不例外。CPU要求相对较低，并且取决于所使用的卷的类型，例如，**复制卷**比**分散卷**需要更少的CPU。
- en: CPU requirements are also affected by the type of filesystem that the bricks
    use and what features they have. Going back to the ZFS example, if compression
    is enabled this adds increased load to the CPU, and not having enough CPU resources
    decreases performance considerably.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CPU需求也受到砖块使用的文件系统类型和其具有的功能的影响。回到ZFS的例子，如果启用了压缩，这会增加CPU的负载，而没有足够的CPU资源会大大降低性能。
- en: For a simple storage server and no advanced features at the brick level, anything
    with four CPUs or more is sufficient. When enabling filesystem features, such
    as compression, eight or more CPUs are required for optimal performance. Additionally,
    more CPU allows for more concurrent I/O to be done to the cluster. This is of
    utmost importance when designing a storage cluster for **high-performance compute**
    (**HPC**) applications, where thousands of users are performing I/O operations
    at the same time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的存储服务器和在brick级别没有高级功能的情况，任何四个CPU或更多的都足够了。当启用文件系统功能，比如压缩时，需要八个或更多的CPU以获得最佳性能。此外，更多的CPU允许对集群进行更多并发I/O。这在为高性能计算（HPC）应用程序设计存储集群时至关重要，其中成千上万的用户同时进行I/O操作。
- en: 'Use the following rules as general rules of thumb:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下规则作为一般的经验法则：
- en: For highly concurrent workload, go for higher CPU count, above eight CPUs, depending
    on the concurrency level
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于高并发工作负载，选择更多的CPU，超过八个CPU，取决于并发级别
- en: For low-performance requirements and a cost-efficient solution, select a lower
    number of CPUs, for example, four CPUs
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于低性能要求和成本效益的解决方案，选择较少数量的CPU，例如四个CPU
- en: Cloud considerations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云考虑
- en: Many cloud providers have a fixed set of given resources for their virtual machine
    sizes that do not allow for custom vCPU to RAM ratios. Finding the right balance
    depends on which VM size provides the necessary resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多云提供商为其虚拟机大小提供了一组固定的资源，不允许自定义vCPU到RAM的比例。找到合适的平衡取决于哪种VM大小提供了必要的资源。
- en: The concept of GlusterFS in the cloud will be explored in further detail in
    the upcoming chapters. However, get an overview of the concept, let's explore
    VM sizes using Microsoft's Azure offering.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GlusterFS在云中的概念将在接下来的章节中进一步探讨。然而，为了对这个概念有一个概述，让我们使用微软的Azure提供的VM大小来探索一下。
- en: Azure VM families range from general-purpose compute to specific workloads,
    such as GPU. For GlusterFS, we really like the L-series VMs, which are optimized
    for storage workloads. This VM family has a good ratio of vCPU to RAM, and offers
    the highest storage performance to cost ratio of any family.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Azure VM系列从通用计算到特定工作负载，如GPU。对于GlusterFS，我们真的很喜欢L系列VM，这些VM针对存储工作负载进行了优化。这个VM系列具有良好的vCPU到RAM比例，并提供了任何系列中最高的存储性能与成本比。
- en: The general idea can be applied to other cloud vendors. A VM size that provides
    an excellent and cost-effective ratio of vCPU to RAM should be selected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一般的想法可以应用到其他云供应商。应选择提供优秀和具有成本效益的vCPU到RAM比例的VM大小。
- en: How much space do you need?
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要多少空间？
- en: Wouldn't it be nice if we could just use as much space as we need? In reality,
    storage has a cost, and unlimited storage does not exist.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以使用我们需要的空间，那不是很好吗？实际上，存储是有成本的，无限的存储是不存在的。
- en: 'When it comes to sizing available storage, the following factors have to be
    taken into consideration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定可用存储空间时，必须考虑以下因素：
- en: GlusterFS volume type
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlusterFS卷类型
- en: Required space by the application
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要的空间
- en: Projected growth
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期增长
- en: GlusterFS volume type
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlusterFS卷类型
- en: Let's start with some technical considerations. Each GlusterFS volume has characteristics
    when it comes to available space. Depending on the volume type, you can end up
    with less usable space than you initially calculated. We will be exploring the
    space considerations of each volume type we described in [Chapter 2](7a05974e-0554-45d0-a505-921d484942ef.xhtml),
    *Defining GlusterFS Storage*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些技术考虑开始。每个GlusterFS卷在可用空间方面都有特点。根据卷类型，最终可用空间可能比您最初计算的要少。我们将探讨我们在[第2章](7a05974e-0554-45d0-a505-921d484942ef.xhtml)中描述的每种卷类型的空间考虑，*定义GlusterFS存储*。
- en: Distributed
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式
- en: This volume type is reasonably straightforward. The sum of the available space
    from each node is the total space on the global namespace (another name for the
    GlusterFS volume mount).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种卷类型相当简单。每个节点的可用空间之和是全局命名空间（GlusterFS卷挂载的另一个名称）上的总空间。
- en: An example is a request of 50 TB volume where the amount of space needed for
    the bricks is precisely 50 TB. This can be divided into five nodes with 10 TB
    each or two nodes with 25 TB each.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个50TB卷的请求，砖块所需的空间恰好是50TB。这可以分成每个10TB的五个节点或每个25TB的两个节点。
- en: Replicated
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: With replica volumes, half of the available raw brick space goes into the mirroring
    or replication of the data. This means that when sizing this type of volume, you
    need to at least double the storage capacity of what is requested. This depends
    on the specific configuration of the volume. A general rule of thumb is that the
    available capacity is half of the total space on the bricks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复制卷，一半的可用原始砖块空间用于数据的镜像或复制。这意味着在确定这种类型的卷的大小时，您需要至少将所请求的存储容量加倍。这取决于卷的具体配置。一个经验法则是可用容量是砖块上总空间的一半。
- en: For example, if the request is for 50 TB volume, the node configuration should
    have at least 100 TB available in brick space between two nodes with 50 TB each.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果请求的是50TB卷，节点配置应该至少在两个节点之间有100TB的砖块空间。
- en: Dispersed
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分散
- en: Dispersed volumes are trickier to size, as they function similar to a RAID 5,
    where the data is spread across the nodes and a node's worth of capacity is used
    for parity. This depends on the configuration of the volume, but you could expect
    space efficiency to increase with the node count.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分散卷的大小更难确定，因为它们的功能类似于RAID 5，其中数据分布在节点上，并且一个节点的容量用于奇偶校验。这取决于卷的配置，但您可以预期随着节点数的增加，空间利用效率会提高。
- en: To further explain, a request for a 50 TB volume can be configured on six nodes
    with 10 TB each. Note that an extra node was taken into consideration. Selecting
    five nodes with 10 TB each results in a volume of only 40 TB, which falls short
    of the requested size.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步解释，对于一个50 TB的卷的请求，可以在6个节点上配置，每个节点有10 TB。请注意额外考虑了一个节点。选择5个每个10 TB的节点会导致只有40
    TB的卷，这不符合请求的大小。
- en: Space required by the application
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序所需的空间
- en: Each application has its own set of requirements, and storage requirements are
    as necessary as any other requirements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有自己的一套要求，存储要求和其他要求一样重要。
- en: Serving media files require considerably more resources than a website with
    few users and not many media files. Knowing precisely what the intended usage
    of the storage system is permits correct sizing of the solution and prevents situations
    where storage estimates fall short of what was needed from the beginning.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提供媒体文件需要的资源比用户较少且媒体文件不多的网站要多得多。准确了解存储系统的预期使用方式可以正确地确定解决方案的大小，并防止存储估算不足以满足最初需求的情况发生。
- en: Make sure you go through what minimum requirements the application developers
    recommend and understand how it interacts with the storage, as this helps prevent
    headaches.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你了解应用程序开发人员推荐的最低要求，并了解它如何与存储交互，因为这有助于避免头疼的情况。
- en: Projected growth
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期增长
- en: Your job as an architect is to ask the right questions. When it comes to storage,
    make sure the growth rate or change rate is taken into account.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，你的工作是提出正确的问题。在涉及存储时，确保增长率或变化率被考虑在内。
- en: Consider that data growth happens no matter what, and thinking ahead avoids
    complicated situations where there is not enough space, so leaving some margin
    for future utilization is a good practice. Allowing for 10% or more space should
    be a good starting point, so if 50 TB spaces are requested then add 5 TB more
    space to the solution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到数据增长是无法避免的，提前思考可以避免复杂的情况，即没有足够的空间，因此为未来的利用留出一些余地是一个好的做法。允许10%或更多的空间应该是一个很好的起点，所以如果请求50
    TB的空间，那么在解决方案中再增加5 TB的空间。
- en: Go for the most cost-effective route. While GlusterFS allows for seamless expansion,
    try to avoid using this feature as an easy solution and make sure that the right
    size is defined from the start and a buffer is considered for future growth.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最具成本效益的路线。虽然GlusterFS允许无缝扩展，但尽量避免使用这个功能作为简单的解决方案，并确保从一开始就定义了正确的大小，并考虑了未来的增长。
- en: Performance considerations
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Applications that perform poorly are probably worse than applications that don't
    work at all. Having something work half of the time is incredibly frustrating
    and costly to any business.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 性能差的应用程序可能比根本无法工作的应用程序更糟糕。让某些东西一半的时间工作是非常令人沮丧和对任何企业来说成本高昂的。
- en: As an architect, you need to design solutions that perform to the spec or better
    in order to avoid scenarios where problems arise due to poor performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，你需要设计满足规格或更好的解决方案，以避免由于性能不佳而导致问题的情况。
- en: The very first place to start is by defining what the performance requirements
    are. Most of the time, the application developers mention the performance requirements
    in their documentation itself. Not meeting these minimum requirements means that
    the application either doesn't work at all or barely works. Neither is acceptable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是定义性能要求是什么。大多数情况下，应用程序开发人员在他们的文档中提到了性能要求。不满足这些最低要求意味着应用程序要么根本无法工作，要么几乎无法工作。这两种情况都是不可接受的。
- en: 'The following are the things to look out for when designing a performance-oriented
    solution:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 设计面向性能的解决方案时需要注意以下几点：
- en: Throughput
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Latency
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: IOPS
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOPS
- en: I/O size
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O大小
- en: Throughput
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Throughput is a function of a given amount of data over a certain amount of
    time that is typically described in **megabytes per second** (**MBps**). This
    means that every second X amount of data is being sent or received from a storage
    system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量是在一定时间内传输的数据量的函数，通常以兆字节每秒（MBps）描述。这意味着每秒从存储系统发送或接收X数量的数据。
- en: Depending on the workload, the highest throughput might not be possible as the
    application is unable to perform I/O big enough or fast enough. There is no hard
    number to recommend here. Try going for the highest possible throughput, and make
    sure that the storage cluster can sustain the transfer rates necessary for the
    desired level of concurrency.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据工作负载的不同，最高吞吐量可能无法实现，因为应用程序无法执行足够大或足够快的I/O操作。这里没有硬性建议的数字。尽量追求最高可能的吞吐量，并确保存储集群能够维持所需的并发级别所需的传输速率。
- en: Latency
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟
- en: Latency is critical and requires extra care, as some applications are significantly
    sensitive to high latencies or response times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是至关重要的，需要额外小心，因为一些应用程序对高延迟或响应时间非常敏感。
- en: Latency is a measurement of the amount of time I/O operations take to complete
    that is typically measured in milliseconds (1 second is 1,000 milliseconds). High
    latencies or response times cause applications to take longer to respond and even
    stop working altogether.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是衡量I/O操作完成所需的时间的指标，通常以毫秒为单位（1秒等于1000毫秒）。高延迟或响应时间会导致应用程序响应时间变长，甚至完全停止工作。
- en: Aim for the lowest latency possible. This is a case where getting the lowest
    possible number is always the best approach. With latency, there's no such thing
    as not enough, or, in this case, not too short of response time. Consider the
    type of storage medium you used. Traditional hard disk drives have response times
    (or seek times) ranging in the several hundred milliseconds, while newer solid
    state drives can go past the sub-millisecond mark and into microseconds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 力求达到最低的延迟。这是一个情况，其中获得最低可能的数字总是最好的方法。在延迟方面，没有不够的情况，或者在这种情况下，响应时间不够短。考虑你使用的存储介质类型。传统的硬盘驱动器的响应时间（或寻道时间）在几百毫秒范围内，而新型固态硬盘可以达到亚毫秒甚至微秒的水平。
- en: IOPS
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IOPS
- en: Input/output operations per second is a function of a given amount of operations
    over time, in this case, seconds. This is a measurement of how many operations
    can be done over a second, and many applications provide a minimum requirement
    regarding IOPS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒输入/输出操作是一定时间内（在本例中是秒）的一定数量的操作的函数。这是衡量每秒可以执行多少操作的指标，许多应用程序提供了关于IOPS的最低要求。
- en: Most applications provide a requirement of the minimum IOPS needed for it to
    work as expected. Make sure that these are met, as otherwise the application might
    not behave as intended.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序提供了其所需的最低IOPS要求。确保满足这些要求，否则应用程序可能无法按预期运行。
- en: When designing a storage solution, make sure IOPS is considered as a primary
    deciding factor when taking sizing decisions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计存储解决方案时，确保IOPS被视为在制定大小决策时的主要决定因素。
- en: I/O size
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O大小
- en: I/O size is the amount of data that each operation performs. This is dependent
    on the workload type, as each application interacts with the storage system differently.
    The I/O size impacts directly on the previously mentioned aspects of performance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: I/O大小是每个操作执行的数据量。这取决于工作负载类型，因为每个应用与存储系统的交互方式不同。I/O大小直接影响了之前提到的性能方面。
- en: Smaller I/O results in lower throughput, but, if done fast enough, it results
    in higher IOPS with lower latencies. Larger I/O, on the other hand, provides a
    higher throughput, but generally produces lower IOPS as fewer operations are done
    in the same amount of time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的I/O会导致较低的吞吐量，但如果足够快，会导致更高的IOPS和较低的延迟。另一方面，较大的I/O提供更高的吞吐量，但通常会产生较低的IOPS，因为在相同的时间内执行较少的操作。
- en: There is no solid recommendation regarding I/O size. In an ideal, non-realistic
    world, I/O is done big enough and fast enough, which results in high throughput
    and high IOPS. In reality, it's either one or the other. Small I/O ends up being
    slow regarding throughput, but it completes fast enough so that IOPS seem higher.
    With big I/O, the numbers are inverted, and the throughput becomes high, but since
    it takes longer to complete, IOPS goes down.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于I/O大小没有明确的建议。在理想的、不现实的世界中，I/O足够大且足够快，这会导致高吞吐量和高IOPS。但在现实中，要么是一个，要么是另一个。小的I/O在吞吐量方面较慢，但完成得足够快，因此IOPS似乎更高。而大的I/O则相反，吞吐量更高，但由于完成时间较长，IOPS下降。
- en: GlusterFS performance
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlusterFS性能
- en: 'The following aspects need to be taken into consideration when designing a
    GlusterFS storage cluster when it comes to performance:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计GlusterFS存储集群时，需要考虑以下方面，以便提高性能：
- en: Volume type
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷类型
- en: Brick layout
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 砖块布局
- en: Number of nodes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点数量
- en: Tuning parameters
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整参数
- en: Volume type
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷类型
- en: The volume chosen affects the performance in different ways, since GlusterFS
    allocates data differently for each type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的卷以不同的方式影响性能，因为GlusterFS为每种类型分配数据方式不同。
- en: For example, a replicated volume mirrors data across nodes, while a dispersed
    volume tries to maximize node usage and uses them in parallel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，复制卷在节点之间镜像数据，而分散卷试图最大化节点使用并并行使用它们。
- en: If performance is the primary aim for a dispersed or distributed volume, consider
    that distributed volumes offer no redundancy, while a dispersed volume does it
    at the expense of performance degradation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能是分散或分布式卷的主要目标，请考虑分布卷不提供冗余，而分散卷则以性能降级为代价提供冗余。
- en: Brick layout
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 砖块布局
- en: Having a node with all of its disks in a single large brick does not perform
    in the same way as having disks grouped in smaller numbers with several bricks.
    Brick layout is the highest contributing factor to performance, as this directly
    dictates how disks are used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有磁盘都放在一个大的砖块中的节点与将磁盘分组在较小数量的砖块中的节点性能表现不同。砖块布局是性能的最大贡献因素，因为这直接决定了磁盘的使用方式。
- en: If all the disks end up in a single brick, the performance suffers. Generally,
    having more bricks with fewer disks results in better performance and lower latency.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有磁盘最终都放在一个砖块中，性能会受到影响。通常，更多的砖块和较少的磁盘会带来更好的性能和更低的延迟。
- en: Consider configuring a software RAID0 for the disks that make up the bricks.
    For example, you could have 10 disks available and, for simplicity's sake, configure
    all 10 disks in a RAID0 on a single brick. Alternatively, you could go for a more
    efficient route and configure five bricks where each brick is made of two disks
    in a RAID0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为构成砖块的磁盘配置软件RAID0。例如，您可以有10个可用的磁盘，并且为了简单起见，可以在单个砖块上配置所有10个磁盘的RAID0。或者，您可以选择更高效的方式，配置五个砖块，其中每个砖块由RAID0中的两个磁盘组成。
- en: This also allows smoother growth, since adding more bricks with fewer disks
    is considerably easier than adding a large number of disks. You should aim for
    more bricks with fewer disks grouped in smaller RAID configurations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以实现更平稳的增长，因为添加更多砖块并不需要添加大量的磁盘。您应该以更少的磁盘组成更多的砖块为目标。
- en: 'In the following diagram, we can see how each brick is made up of two different
    disks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到每个砖块由两个不同的磁盘组成：
- en: '![](img/35739515-9a3c-4198-a195-e9f0dcae046d.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35739515-9a3c-4198-a195-e9f0dcae046d.png)'
- en: Number of nodes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点数量
- en: Increasing the number of nodes in the cluster allows for higher concurrency.
    While performance gains might not be linear, adding nodes allows for a higher
    number of users and applications accessing the volumes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 增加集群中节点的数量可以实现更高的并发性。虽然性能增益可能不是线性的，但增加节点可以允许更多的用户和应用程序访问卷。
- en: The goal is to have enough nodes for a balance in the available space and concurrency.
    There is no set number here, but your job as an architect is to define, through
    testing, what is the right number of nodes for a specific solution. During the
    POC phase, test with a smaller number of nodes and check whether the performance
    is acceptable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是拥有足够的节点以实现可用空间和并发性的平衡。这里没有固定的数量，但作为架构师，您的工作是通过测试来定义特定解决方案的正确节点数量。在POC阶段，使用较少的节点进行测试，并检查性能是否可接受。
- en: Tuning parameters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整参数
- en: Filesystem tunables, such as block size can play an important role, and the
    goal is to match the workload I/O size, the GlusterFS volume block size, and the
    filesystem block size to the same amount.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可调参数，如块大小，可以发挥重要作用，目标是使工作负载I/O大小、GlusterFS卷块大小和文件系统块大小相匹配。
- en: Typically, 4 K is the most used block size that works for general workloads.
    For a large number of small files, go for a smaller block size. For big files,
    aim for a bigger block size, such as 1 M.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，4K是最常用的块大小，适用于一般工作负载。对于大量的小文件，选择较小的块大小。对于大文件，选择较大的块大小，例如1M。
- en: The best approach for high availability
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高可用性的最佳方法
- en: With GlusterFS, high availability can be delivered through the volume configuration;
    deciding how this is done depends on the application needs, available space, and
    required performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GlusterFS，高可用性可以通过卷配置实现；决定如何实现取决于应用程序需求、可用空间和所需性能。
- en: Since GlusterFS handles high availability, there is no need to configure any
    form of redundancy at the brick level. This is especially true with cloud instances
    and virtual machines, where there are no physical disks that can go bad. For physical
    installations, it is always better to have an extra layer of redundancy by configuring
    the local disks with RAID5 or RAID6 for a balance in performance and resiliency.
    For now, let's stick to cloud deployments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GlusterFS处理高可用性，因此无需在存储单元级别配置任何形式的冗余。特别是在云实例和虚拟机中，没有可以出问题的物理磁盘。对于物理安装，通过为本地磁盘配置RAID5或RAID6来增加额外的冗余层总是更好，以实现性能和弹性的平衡。现在，让我们继续使用云部署。
- en: 'With GlusterFS, only two volume types offer high availability: replicated and
    dispersed. Replicated volumes are reasonably straightforward since data is just
    replicated from one node to another. These offer lower performance, but are considerably
    easier to configure, deploy, and maintain.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GlusterFS时，只有两种卷类型提供高可用性：复制和分散。复制卷相对较简单，因为数据只是从一个节点复制到另一个节点。这提供了较低的性能，但配置、部署和维护都相对容易。
- en: Replicated
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: Choose a replicated volume when there is no need for extreme performance. Select
    the number of replicas based on how many nodes or bricks the volume should tolerate.
    Consider that using a higher replica number will decrease the amount of available
    space, but increase the availability of the volume.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要极端性能时，请选择复制卷。根据卷应该容忍的节点或存储单元数量选择副本的数量。请考虑使用更高的副本数量将减少可用空间的数量，但会增加卷的可用性。
- en: 'The following example shows that losing a node in a replicated volume does
    not disrupt volume operations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示，丢失复制卷中的一个节点不会中断卷的运行：
- en: '![](img/a8e4f5f4-104c-438e-b1f5-f75603c9ae7f.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e4f5f4-104c-438e-b1f5-f75603c9ae7f.png)'
- en: Dispersed
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分散
- en: Dispersed volumes offer a good balance between high availability and performance;
    this should be the go-to volume when both are a requirement. Configuring a dispersed
    volume is a more complicated process since the redundancy is handled as in a RAID5
    setup, where a node is used as parity. The redundancy value can be chosen at the
    time of volume creation which allows for greater flexibility.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分散卷在高可用性和性能之间提供了良好的平衡；当两者都是要求时，这应该是首选卷。配置分散卷是一个更复杂的过程，因为冗余是像RAID5设置一样处理的，其中一个节点被用作奇偶校验。冗余值可以在卷创建时选择，这允许更大的灵活性。
- en: 'In the following diagram, you can see that losing one node does not disrupt
    the volume:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到丢失一个节点不会中断卷的运行：
- en: '![](img/3c573997-afcc-40f2-bfc0-4256e9e2ed63.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c573997-afcc-40f2-bfc0-4256e9e2ed63.png)'
- en: Plan for high availability when there is a specific requirement. Remember that
    volume types can be mixed and matched. For example, a distributed replicated volume
    will have a good mix of available space and redundancy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在特定需求时，请计划高可用性。请记住，卷类型可以混合使用。例如，分布式复制卷将具有良好的可用空间和冗余性的混合。
- en: Geo-replication
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理复制
- en: Geo-replication allows for asynchronous replication of data between different
    sites through local networks or the internet. This provides high availability
    by having a copy of the data in a different geo-location, and ensures disaster
    recovery in case of failures.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 地理复制允许通过本地网络或互联网在不同站点之间进行数据的异步复制。这通过在不同地理位置拥有数据的副本来提供高可用性，并确保在发生故障时进行灾难恢复。
- en: Consider going the geo-replication route when there is a specific use case where
    the added layer of redundancy is needed. Remember that this is asynchronous replication,
    so, in the case of a disaster, consider the RPO and RTO times explained in the
    previous chapters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在需要额外冗余层的特定用例时，考虑使用地理复制路线。请记住，这是异步复制，因此在发生灾难时，请考虑前几章中解释的RPO和RTO时间。
- en: 'The following diagram gives you a general understanding of how geo-replication
    works—**Site A** replicates to **Site B** through the WAN:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表让您对地理复制的工作原理有一个大致的了解——**站点A**通过广域网复制到**站点B**：
- en: '![](img/527d077d-6b1c-4507-be07-2218b47b1479.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/527d077d-6b1c-4507-be07-2218b47b1479.png)'
- en: How the workload defines requirements
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载如何定义需求
- en: Delivering video files to streaming web servers is not the same as hosting a
    large database. I/O is done in an entirely different way, and knowing exactly
    how the workload interacts with the storage system is crucial to successfully
    size and design a robust storage solution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频文件传送到流媒体服务器与托管大型数据库不同。I/O是以完全不同的方式进行的，了解工作负载与存储系统的交互方式对成功地确定和设计强大的存储解决方案至关重要。
- en: Documentation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: The application documentation is your best friend when trying to figure out
    what the storage requirements are. When there's an existing implementation of
    the application, ask the administrators what the software expects for performance
    and how it reacts when it doesn't meet the minimum requirements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试确定存储需求时，应用程序文档是您的最佳伙伴。当应用程序已经存在时，询问管理员软件对性能的期望以及当不满足最低要求时的反应。
- en: System tools
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统工具
- en: 'Using tools such as `iostat` gives a good understanding of how the application
    interacts with the storage, for example, by using the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如`iostat`之类的工具可以很好地了解应用程序与存储的交互方式，例如通过使用以下命令：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code shows per block device usage, the `areq-sz` column (previously
    known as `avgrq-sz`) shows the average request size in kilobytes, making this
    a good starting point to understand the I/O size the application typically uses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了每个块设备的使用情况，`areq-sz`列（以前称为`avgrq-sz`）显示了以千字节为单位的平均请求大小，这是了解应用程序通常使用的I/O大小的良好起点。
- en: 'The output looks similar to the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来类似于以下截图：
- en: '![](img/72cbb4e3-a020-4996-be85-1b99af3b07ed.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72cbb4e3-a020-4996-be85-1b99af3b07ed.png)'
- en: In the preceding image, we could appreciate the block devices and their respective
    performance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以欣赏到块设备及其相应的性能。
- en: File type and size
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型和大小
- en: As an example, designing a storage solution for a media streaming server requires
    the use of large block sizes, as media files tend to be bigger than small text
    files. If you use a larger block size for the bricks, the GlusterFS volume will
    not only make more efficient use of the space but will also allow for faster operations,
    as the transaction size matches the file size.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，为媒体流服务器设计存储解决方案需要使用大块大小，因为媒体文件往往比小文本文件大。如果你为砖块使用更大的块大小，GlusterFS卷不仅会更有效地利用空间，还将允许更快的操作，因为事务大小与文件大小匹配。
- en: On the other hand, a storage server for sensor logging that usually creates
    a large number of small files containing text requires a smaller block size to
    match the size of the files being created. Using a smaller block size avoids allocating
    an entire block, say 4 K, for a file that is only 1 K in size.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，传感器日志记录的存储服务器通常会创建包含文本的大量小文件，因此需要较小的块大小来匹配正在创建的文件的大小。使用较小的块大小可以避免为仅有1K大小的文件分配整个块（例如4K）。
- en: Ask the right questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提出正确的问题
- en: Your goal as an architect is to make sure the workload is very clear. The intended
    use for the storage server defines how many resources need to be allocated. Failing
    to do so could result in resources being wasted that in turn means money being
    wasted, or, in a worst case scenario, could lead to a solution that does not perform
    to spec, which leads to applications failing and users not able to work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，您的目标是确保工作负载非常清晰。存储服务器的预期用途定义了需要分配多少资源。未能这样做可能导致资源浪费，这反过来意味着浪费金钱，或者在最坏的情况下，可能导致解决方案无法按规格执行，从而导致应用程序失败和用户无法工作。
- en: 'Remember from the [Chapter 1](ef6464b0-95db-45b2-95ce-4f9067e2c6c8.xhtml),
    *Introduction to Design Methodology*: ask the right questions. When sizing a storage
    solution, you can ask the following questions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](ef6464b0-95db-45b2-95ce-4f9067e2c6c8.xhtml)中记住，*设计方法论简介*：提出正确的问题。在调整存储解决方案时，您可以问以下问题：
- en: How much space does the current implementation consume (if there's one already
    in place)?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前实施消耗了多少空间（如果已经有一个）？
- en: What are the performance requirements of the application?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的性能要求是什么？
- en: How many users interact with the application?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少用户与应用程序交互？
- en: Is high availability required?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要高可用性？
- en: How does the application store its data?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序如何存储其数据？
- en: Does it create large files and append data to them?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否创建大文件并向其附加数据？
- en: Does it create a large number of small files?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否创建大量小文件？
- en: 'Possible answers to these questions could be the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的可能答案可能是以下内容：
- en: Right now, the application consumes 20 TB, but we expect it to increase 5% each
    month and stabilize at 80 TB.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，该应用程序消耗了20TB，但我们预计每个月增长5%，并稳定在80TB。
- en: The application requires at least 100 MB/s of throughput and a latency no higher
    than 10 ms.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序需要至少100MB/s的吞吐量和不超过10ms的延迟。
- en: Currently, about 300 users have access to the application; concurrently, we've
    seen peaks of 150 users, but we expect the user count to increase significantly.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，大约有300个用户可以访问该应用程序；同时，我们已经看到了150个用户的高峰，但我们预计用户数量将显著增加。
- en: We can sustain not being able to access the storage for some time, but we do
    need to be able to recover from a failure reasonably quickly, and could possibly
    have a copy of the data off-site.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以忍受一段时间无法访问存储，但我们确实需要能够相对快速地从故障中恢复，并且可能在外部有数据的副本。
- en: The application primarily saves its information in small files.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序主要将其信息保存在小文件中。
- en: It does not append data, and if more space is needed, it merely creates more
    small files.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不附加数据，如果需要更多空间，它只是创建更多小文件。
- en: Yes, we've seen several thousands of files created no bigger than 4 KB.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，我们已经看到创建了数千个大小不超过4KB的文件。
- en: From the previous example, you can surmise that the application creates a lot
    of small files, and it can tolerate being down for some time but requires off-site
    replication for smooth disaster recovery. Performance requirements seem to be
    relatively high, so we could opt for a dispersed or distributed volume with geo-replication
    enabled.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，您可以推断出该应用程序创建了大量小文件，并且可以容忍一段时间的停机，但需要外部复制以实现平稳的灾难恢复。性能要求似乎相对较高，因此我们可以选择启用地理复制的分散或分布式卷。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The process of architecting a storage solution requires many variables to be
    known. In this chapter, we defined that deciding how much space is needed depends
    on the GlusterFS volume type, the application requirements, and the estimated
    growth in data utilization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设计存储解决方案的过程需要了解许多变量。在本章中，我们确定了决定需要多少空间取决于GlusterFS卷类型、应用程序要求和数据利用率的预估增长。
- en: Depending on the volume type, the available space is affected, a distributed
    volume aggregates all of the available space making it the most space efficient,
    while a replicated volume uses half of the available raw space for mirroring.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据卷类型，可用空间会受到影响，分布式卷会聚合所有可用空间，使其成为最节省空间的卷，而复制卷使用一半可用原始空间进行镜像。
- en: The application and user base dictate how much space is required. This is because,
    depending on the type of data being served, the storage requirements change. Thinking
    ahead and planning for storage growth avoids the potential to run out of resources,
    and allows for at least a 10% buffer when sizing should fit most situations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和用户群决定了需要多少空间。这是因为，根据所提供的数据类型，存储需求会发生变化。提前考虑并规划存储增长可以避免资源耗尽的潜在风险，并且在大小确定时至少留出10%的缓冲区应该适应大多数情况。
- en: With the performance requirements, we defined the concepts of throughput, latency,
    IOPS, and I/O size and how these interact with each other. We defined what variables
    come into play when configuring GlusterFS for optimal performance, how each volume
    has its performance characteristics, and how the brick layout plays an important
    role when trying to optimize a GlusterFS volume.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过性能要求，我们定义了吞吐量、延迟、IOPS和I/O大小的概念，以及它们如何相互作用。我们定义了在为GlusterFS配置最佳性能时涉及的变量，每个卷都具有其性能特征，以及在尝试优化GlusterFS卷时砖块布局起着重要作用。
- en: We also defined how high availability requirements affect sizing and how each
    volume provides different levels of HA. When disaster recovery is needed, GlusterFS
    geo-replication adds the required level of availability by replicating data to
    another physical region, which allows the smooth recovery of services in case
    of a disaster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了高可用性要求如何影响大小，以及每个卷提供不同级别的HA。当需要灾难恢复时，GlusterFS地理复制通过将数据复制到另一个物理区域提供所需的可用性级别，从而在发生灾难时平稳恢复服务。
- en: Finally, we went through how the workload defines how the solution is designed
    and how using tools to verify how the application interacts with the storage allows
    for the correct configuration of the storage cluster. We also found out how file
    types and sizes define performance behavior and space utilization, and how asking
    the right questions allows for a better understanding of the workload, which results
    in a more efficient and optimized solution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了工作负载如何定义解决方案的设计，以及如何使用工具来验证应用程序与存储的交互方式，从而正确配置存储集群。我们还了解了文件类型和大小如何定义性能行为和空间利用率，以及如何提出正确的问题可以更好地理解工作负载，从而实现更高效和优化的解决方案。
- en: The main takeaway is to always ask how the application and workload interact
    with its resources. This allows for the most efficient design possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要始终询问应用程序和工作负载如何与其资源交互。这可以实现最高效的设计。
- en: In the next chapter, we'll go through the actual configuration needed for GlusterFS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍GlusterFS所需的实际配置。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the compute requirements for GlusterFS?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GlusterFS的计算要求是什么？
- en: How does GlusterFS use RAM?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GlusterFS如何使用RAM？
- en: What is a cache?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是缓存？
- en: How does concurrency affect CPU sizing?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发性如何影响CPU大小？
- en: How do GlusterFS volumes affect available space?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GlusterFS卷如何影响可用空间？
- en: How much space does the application need?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序需要多少空间？
- en: What is projected growth?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是预期增长？
- en: What is throughput, latency IOPS, and I/O size?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是吞吐量、延迟IOPS和I/O大小？
- en: What is brick layout?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是砖块布局？
- en: What is geo-replication?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是地理复制？
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Architecting Data-Intensive Applications* by Anuj Kumar'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*架构数据密集型应用* by Anuj Kumar'
- en: '*Microsoft Azure Storage Essentials* by Chukri Soueidi'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Microsoft Azure存储基础* by Chukri Soueidi'
- en: '*Azure for Architects* by Ritesh Modi'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ritesh Modi的Azure架构师*'
