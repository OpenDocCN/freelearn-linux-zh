["```\nreader@ubuntu:~$ cd /dev/fd/\nreader@ubuntu:/dev/fd$ ls -l\ntotal 0\nlrwx------ 1 reader reader 64 Nov  5 18:54 0 -> /dev/pts/0\nlrwx------ 1 reader reader 64 Nov  5 18:54 1 -> /dev/pts/0\nlrwx------ 1 reader reader 64 Nov  5 18:54 2 -> /dev/pts/0\nlrwx------ 1 reader reader 64 Nov  5 18:54 255 -> /dev/pts/0\n```", "```\n# SSH connection 1\nreader@ubuntu:~/scripts/chapter_12$ ls -l /dev/fd/\ntotal 0\nlrwx------ 1 reader reader 64 Nov  5 19:06 0 -> /dev/pts/0\nlrwx------ 1 reader reader 64 Nov  5 19:06 1 -> /dev/pts/0\nlrwx------ 1 reader reader 64 Nov  5 19:06 2 -> /dev/pts/0\n\n# SSH connection 2\nreader@ubuntu:/dev/fd$ ls -l\ntotal 0\nlrwx------ 1 reader reader 64 Nov  5 18:54 0 -> /dev/pts/1\nlrwx------ 1 reader reader 64 Nov  5 18:54 1 -> /dev/pts/1\nlrwx------ 1 reader reader 64 Nov  5 18:54 2 -> /dev/pts/1\n\n# Virtual machine terminal\nreader@ubuntu:/dev/fd$ ls -l\ntotal 0\nlrwx------ 1 reader reader 64 Nov  5 19:08 0 -> /dev/tty/1\nlrwx------ 1 reader reader 64 Nov  5 19:08 1 -> /dev/tty/1\nlrwx------ 1 reader reader 64 Nov  5 19:08 2 -> /dev/tty/1\n```", "```\ncommand > output-file\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ls -l /var/log/dpkg.log \n-rw-r--r-- 1 root root 737150 Nov  5 18:49 /var/log/dpkg.log\nreader@ubuntu:~/scripts/chapter_12$ cat /var/log/dpkg.log > redirected-file.log\nreader@ubuntu:~/scripts/chapter_12$ ls -l\ntotal 724\n-rw-rw-r-- 1 reader reader 737150 Nov  5 19:45 redirected-file.log\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ diff /var/log/dpkg.log redirected-file.log \nreader@ubuntu:~/scripts/chapter_12$ echo $?\n0\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ vim redirect-to-file.sh \nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.sh \n#!/bin/bash\n\n#####################################\n# Author: Sebastiaan Tammer\n# Version: v1.0.0\n# Date: 2018-11-05\n# Description: Redirect user input to file.\n# Usage: ./redirect-to-file.sh\n#####################################\n\n# Capture the users' input.\nread -p \"Type anything you like: \" user_input\n\n# Save the users' input to a file.\necho ${user_input} > redirect-to-file.txt\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ bash redirect-to-file.sh \nType anything you like: I like dogs! And cats. Maybe a gecko?\nreader@ubuntu:~/scripts/chapter_12$ ls -l\ntotal 732\n-rw-rw-r-- 1 reader reader 737150 Nov  5 19:45 redirected-file.log\n-rw-rw-r-- 1 reader reader    383 Nov  5 19:58 redirect-to-file.sh\n-rw-rw-r-- 1 reader reader     38 Nov  5 19:58 redirect-to-file.txt\nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.txt\nI like dogs! And cats. Maybe a gecko?\n```", "```\nreader@ubuntu:~/scripts$ bash chapter_12/redirect-to-file.sh\nType anything you like: Hello\nreader@ubuntu:~/scripts$ ls -l\n<SNIPPED>\ndrwxrwxr-x 2 reader reader 4096 Nov  5 19:58 chapter_12\n-rw-rw-r-- 1 reader reader    6 Nov  5 20:02 redirect-to-file.txt\nreader@ubuntu:~/scripts$ bash chapter_12/redirect-to-file.sh\nType anything you like: Bye\nreader@ubuntu:~/scripts$ ls -l\n<SNIPPED>\ndrwxrwxr-x 2 reader reader 4096 Nov  5 19:58 chapter_12\n-rw-rw-r-- 1 reader reader    4 Nov  5 20:02 redirect-to-file.txt\n```", "```\nreader@ubuntu:~/scripts$ vim chapter_12/redirect-to-file.sh \nreader@ubuntu:~/scripts$ cat chapter_12/redirect-to-file.sh \n#!/bin/bash\n\n#####################################\n# Author: Sebastiaan Tammer\n# Version: v1.1.0\n# Date: 2018-11-05\n# Description: Redirect user input to file.\n# Usage: ./redirect-to-file.sh\n#####################################\n\n# Since we're dealing with paths, set current working directory.\ncd $(dirname $0)\n\n# Capture the users' input.\nread -p \"Type anything you like: \" user_input\n\n# Save the users' input to a file. > for overwrite, >> for append.\necho ${user_input} >> redirect-to-file.txt\n```", "```\nreader@ubuntu:~/scripts$ cd /tmp/\nreader@ubuntu:/tmp$ cat /home/reader/scripts/chapter_12/redirect-to-file.txt \nI like dogs! And cats. Maybe a gecko?\nreader@ubuntu:/tmp$ bash /home/reader/scripts/chapter_12/redirect-to-file.sh\nType anything you like: Definitely a gecko, those things are awesome!\nreader@ubuntu:/tmp$ cat /home/reader/scripts/chapter_12/redirect-to-file.txt \nI like dogs! And cats. Maybe a gecko?\nDefinitely a gecko, those things are awesome!\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.txt \nI like dogs! And cats. Maybe a gecko?\nDefinitely a gecko, those things are awesome!\nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.txt > /dev/pts/0\nI like dogs! And cats. Maybe a gecko?\nDefinitely a gecko, those things are awesome!\nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.txt > /dev/fd/1\nI like dogs! And cats. Maybe a gecko?\nDefinitely a gecko, those things are awesome!\nreader@ubuntu:~/scripts/chapter_12$ cat redirect-to-file.txt > /dev/fd/2\nI like dogs! And cats. Maybe a gecko?\nDefinitely a gecko, those things are awesome!\n```", "```\nreader@ubuntu:/tmp$ cat /root/\ncat: /root/: Permission denied\nreader@ubuntu:/tmp$ cat /root/ 1> error-file\ncat: /root/: Permission denied\nreader@ubuntu:/tmp$ ls -l\n-rw-rw-r-- 1 reader reader    0 Nov  5 20:35 error-file\nreader@ubuntu:/tmp$ cat /root/ 2> error-file\nreader@ubuntu:/tmp$ ls -l\n-rw-rw-r-- 1 reader reader   31 Nov  5 20:35 error-file\nreader@ubuntu:/tmp$ cat error-file \ncat: /root/: Permission denied\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ vim stderr.c \nreader@ubuntu:~/scripts/chapter_12$ cat stderr.c \n#include <stdio.h>\nint main()\n{\n  // Print messages to stdout and stderr.\n  fprintf(stdout, \"This is sent to stdout.\\n\");\n  fprintf(stderr, \"This is sent to stderr.\\n\");\n  return 0;\n}\n\nreader@ubuntu:~/scripts/chapter_12$ gcc stderr.c -o stderr\nreader@ubuntu:~/scripts/chapter_12$ ls -l\ntotal 744\n-rw-rw-r-- 1 reader reader 737150 Nov  5 19:45 redirected-file.log\n-rw-rw-r-- 1 reader reader    501 Nov  5 20:09 redirect-to-file.sh\n-rw-rw-r-- 1 reader reader     84 Nov  5 20:13 redirect-to-file.txt\n-rwxrwxr-x 1 reader reader   8392 Nov  5 20:46 stderr\n-rw-rw-r-- 1 reader reader    185 Nov  5 20:46 stderr.c\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ bash stderr\nstderr: stderr: cannot execute binary file\nreader@ubuntu:~/scripts/chapter_12$ chmod +x stderr\nreader@ubuntu:~/scripts/chapter_12$ ./stderr \nThis is sent to stdout.\nThis is sent to stderr.\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ./stderr > /tmp/stdout\nThis is sent to stderr.\nreader@ubuntu:~/scripts/chapter_12$ cat /tmp/stdout \nThis is sent to stdout.\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ./stderr 2> /tmp/stderr\nThis is sent to stdout.\nreader@ubuntu:~/scripts/chapter_12$ cat /tmp/stderr \nThis is sent to stderr.\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ./stderr\nThis is sent to stdout.\nThis is sent to stderr.\nreader@ubuntu:~/scripts/chapter_12$ ./stderr &> /tmp/output\nreader@ubuntu:~/scripts/chapter_12$ cat /tmp/output\nThis is sent to stderr.\nThis is sent to stdout.\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ./stderr &> /root/file\n-bash: /root/file: Permission denied\nreader@ubuntu:~/scripts/chapter_12$ echo $?\n1\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ ./stderr &> /dev/null \nreader@ubuntu:~/scripts/chapter_12$ echo $?\n0\nreader@ubuntu:~/scripts/chapter_12$ cat /dev/null \nreader@ubuntu:~/scripts/chapter_12$\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ vim find.sh \nreader@ubuntu:~/scripts/chapter_12$ cat find.sh \n#!/bin/bash\n\n#####################################\n# Author: Sebastiaan Tammer\n# Version: v1.0.0\n# Date: 2018-11-06\n# Description: Find a file.\n# Usage: ./find.sh <file-name>\n#####################################\n\n# Check for the current number of arguments.\nif [[ $# -ne 1 ]]; then\n  echo \"Wrong number of arguments!\"\n  echo \"Usage: $0 <file-name>\"\n  exit 1\nfi\n\n# Name of the file to search for.\nfile_name=$1\n\n# Redirect all errors to /dev/null, so they don't clutter the terminal.\nfind / -name \"${file_name}\" 2> /dev/null\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ find / -name find.sh\nfind: \u2018/etc/ssl/private\u2019: Permission denied\nfind: \u2018/etc/polkit-1/localauthority\u2019: Permission denied\n<SNIPPED>\nfind: \u2018/sys/fs/pstore\u2019: Permission denied\nfind: \u2018/sys/fs/fuse/connections/48\u2019: Permission denied\n/home/reader/scripts/chapter_12/find.sh\nfind: \u2018/data/devops-files\u2019: Permission denied\nfind: \u2018/data/dev-files\u2019: Permission denied\n<SNIPPED>\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ bash find.sh find.sh\n/home/reader/scripts/chapter_12/find.sh\n```", "```\nreader@ubuntu:/tmp$ ls -l\n-rw-rw-r-- 1 reader reader   48 Nov  6 19:26 output\nreader@ubuntu:/tmp$ head -c 1024 /dev/zero > allocated-file\nreader@ubuntu:/tmp$ ls -l\n-rw-rw-r-- 1 reader reader 1024 Nov  6 20:09 allocated-file\n-rw-rw-r-- 1 reader reader   48 Nov  6 19:26 output\nreader@ubuntu:/tmp$ cat allocated-file \nreader@ubuntu:/tmp$ \n```", "```\nreader@ubuntu:/tmp$ fallocate --length 1024 fallocated-file\nreader@ubuntu:/tmp$ ls -l\n-rw-rw-r-- 1 reader reader 1024 Nov  6 20:09 allocated-file\n-rw-rw-r-- 1 reader reader 1024 Nov  6 20:13 fallocated-file\n-rw-rw-r-- 1 reader reader   48 Nov  6 19:26 output\nreader@ubuntu:/tmp$ cat fallocated-file \nreader@ubuntu:/tmp$ \n```", "```\nreader@ubuntu:~$ read -p \"Type something: \" answer\nType something: Something\nreader@ubuntu:~$ echo ${answer}\nsomething\n```", "```\nreader@ubuntu:/tmp$ echo \"Something else\" > answer-file\nreader@ubuntu:/tmp$ read -p \"Type something: \" new_answer < answer-file\nreader@ubuntu:/tmp$ echo ${new_answer}\nSomething else\n```", "```\nreader@ubuntu:/tmp$ head -1 /dev/urandom \n~d=G1\ufffd\ufffd\ufffdRB\ufffd\u04aa\ufffd\ufffd\"@\n                F\ufffd\ufffdOJ2\ufffd%\ufffd=\ufffd8\ufffd#,\ufffdt\ufffd7\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffds\ufffd\ufffdO\u0475\ufffdw\ufffd\ufffdk\ufffdq\u0759\ufffd\ufffd\ufffd\ufffdW\ufffd\ufffdE\ufffdh\ufffd\ufffdQ\"x8\ufffd\ufffdl\ufffdd\ufffd\ufffdP\ufffd,\ufffd.:\ufffdm\ufffd[Lb/A\ufffdJ\ufffd\u0151\ufffdM\ufffdo\ufffdv\ufffd\ufffd\n                                                                                                        \ufffd\nreader@ubuntu:/tmp$ head -1 /dev/urandom \n\ufffd\ufffdo\ufffdu\ufffd\ufffd\ufffd'\ufffd\ufffd+\ufffd)T\ufffdM\ufffd\ufffd\ufffdK\ufffdK\ufffd\ufffd\ufffd\ufffdY\ufffd\ufffdG\ufffdg\".!{R^d8L\ufffd\ufffds5c*\ufffd.\u0111\ufffd\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ vim password-generator.sh \nreader@ubuntu:~/scripts/chapter_12$ cat password-generator.sh \n#!/bin/bash\n\n#####################################\n# Author: Sebastiaan Tammer\n# Version: v1.0.0\n# Date: 2018-11-06\n# Description: Generate a password.\n# Usage: ./password-generator.sh <length>\n#####################################\n\n# Check for the current number of arguments.\nif [[ $# -ne 1 ]]; then\n  echo \"Wrong number of arguments!\"\n  echo \"Usage: $0 <length>\"\n  exit 1\nfi\n\n# Verify the length argument.\nif [[ ! $1 =~ ^[[:digit:]]+$ ]]; then\n  echo \"Please enter a length (number).\"\n  exit 1\nfi\n\npassword_length=$1\n\n# tr grabs readable characters from input, deletes the rest.\n# Input for tr comes from /dev/urandom, via input redirection.\n# echo makes sure a newline is printed.\ntr -dc 'a-zA-Z0-9' < /dev/urandom | head -c ${password_length}\necho\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ cat stderr.c \n#include <stdio.h>\nint main()\n{\n  // Print messages to stdout and stderr.\n  fprintf(stdout, \"This is sent to stdout.\\n\");\n  fprintf(stderr, \"This is sent to stderr.\\n\");\n  return 0;\n}\n\nreader@ubuntu:~/scripts/chapter_12$ grep 'stderr' < stderr.c \n  // Print messages to stdout and stderr.\n  fprintf(stderr, \"This is sent to stderr.\\n\");\nreader@ubuntu:~/scripts/chapter_12$ grep 'stderr' < stderr.c > /tmp/grep-file\nreader@ubuntu:~/scripts/chapter_12$ cat /tmp/grep-file \n  // Print messages to stdout and stderr.\n  fprintf(stderr, \"This is sent to stderr.\\n\");\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ < stderr.c grep 'stdout' > /tmp/grep-file-stdout\nreader@ubuntu:~/scripts/chapter_12$ cat /tmp/grep-file-stdout \n // Print messages to stdout and stderr.\n fprintf(stdout, \"This is sent to stdout.\\n\");\n```", "```\nreader@ubuntu:/tmp$ cat /etc/shadow\ncat: /etc/shadow: Permission denied\nreader@ubuntu:/tmp$ cat /etc/shadow > shadow\ncat: /etc/shadow: Permission denied\nreader@ubuntu:/tmp$ cat shadow \n#Still empty, since stderr wasn't redirected to the file.\nreader@ubuntu:/tmp$ cat /etc/shadow > shadow 2>&1 \n#Redirect fd2 to fd1 (stderr to stdout).\nreader@ubuntu:/tmp$ cat shadow \ncat: /etc/shadow: Permission denied\n```", "```\nreader@ubuntu:/tmp$ head -1 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nreader@ubuntu:/tmp$ head -1 /etc/passwd 2> passwd\nroot:x:0:0:root:/root:/bin/bash\nreader@ubuntu:/tmp$ cat passwd\n#Still empty, since stdout wasn't redirected to the file.\nreader@ubuntu:/tmp$ head -1 /etc/passwd 2> passwd 1>&2\n#Redirect fd1 to fd2 (stdout to stderr).\nreader@ubuntu:/tmp$ cat passwd \nroot:x:0:0:root:/root:/bin/bash\n```", "```\ndirname $0 > directory-file\ncd < directory-file\nrm directory-file\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ vim simple-password-generator.sh \nreader@ubuntu:~/scripts/chapter_12$ cat simple-password-generator.sh \n#!/bin/bash\n\n#####################################\n# Author: Sebastiaan Tammer\n# Version: v1.0.0\n# Date: 2018-11-10\n# Description: Use command substitution with a variable.\n# Usage: ./simple-password-generator.sh\n#####################################\n\n# Write a random string to a variable using command substitution.\nrandom_password=$(tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 20)\n\necho \"Your random password is: ${random_password}\"\n\nreader@ubuntu:~/scripts/chapter_12$ bash simple-password-generator.sh \nYour random password is: T3noJ3Udf8a2eQbqPiad\nreader@ubuntu:~/scripts/chapter_12$ bash simple-password-generator.sh \nYour random password is: wu3zpsrusT5zyvbTxJSn\n```", "```\nreader@ubuntu:~/scripts/chapter_12$ echo \"Your random password is: $(tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 20)\"\nYour random password is: REzCOa11pA2846fvxsa\n```", "``` character (found next to the `1` on English-International keyboards). `$(cd dirname $0)` was previously written as ``cd dirname $0``. While this mostly does the same as the newer (and better) `$(..)` syntax, there are two things that were often an issue with backticks: word splitting and newlines. These are both issues that are caused by whitespace. It is much easier to use the new syntaxes and not have to worry about things like this!\n\n# Process substitution\n\nSomething closely related to command substitution is *process substitution.* The syntax is as follows:\n\n```", "```\n\nIt works very similarly to command substitution, but instead of sending the output of a command as a string somewhere, you can reference the output as a file. This means that some commands, which do not expect a string but instead a reference to a file, can be used with dynamic input as well.\n\nWhile too advanced to discuss in great detail, here's a simple example that should get the point across:\n\n```", "```\n\nThe `diff` command normally compares two files and prints their differences. Now, instead of files, we used process substitution to have `diff` compare the results from `ls /tmp/` and `ls /home/`, using the `<(ls /tmp/)` syntax.\n\n# Pipes\n\nFinally, the moment we've all been waiting for: **pipes**. These near-magical constructs are used so much in Linux/Bash that everyone should know about them. Anything more complex than a single command will almost always use pipes to get to the solution.\n\nAnd now the big reveal: all a pipe really does is connect the `stdout` of a command to the `stdin` of another command.\n\nWait, what?!\n\n# Binding stdout to stdin\n\nYes, that is really all that happens. It might be a little disappointing, now that you know all about input and output redirection. However, just because the concept is simple, that doesn't mean that pipes are not **extremely powerful** and very widely used.\n\nLet's look at an example that shows how we can replace input/output redirection with a pipe:\n\n```", "```\n\nFor the normal redirection, we first write some text to a file (using output redirection), which we then use as input for\u00a0`grep`. Next, we do the exact same functional thing, but without the file as an intermediate step.\n\nBasically, the pipe syntax is as follows:\n\n```", "```\n\nYou can use multiple pipes on a single line, and you can use any combination of pipes and input/output redirection, as long as it makes sense.\n\nOften, when you get to the point of more than two pipes/redirections, you can increase readability with an extra line, perhaps using command substitution to write the intermediate result to a variable. But, technically, you can make it as *complex* as you want; just be vigilant in not making it too *complicated*.\n\nAs stated, pipes bind `stdout` to `stdin`. You might have an idea about the issue coming up: `stderr`! Look at this example of how the separation of output into `stdout` and `stderr` affects pipes:\n\n```", "```\n\nNow, initially this example might confuse you. Let's go through it step by step to figure it out.\n\nFirst, `cat /etc/shadow | grep 'denied'`. We try to `grep` the `stdout` of `cat /etc/shadow` for the word `denied`. We do not actually find it, but we see it printed on our Terminal anyway. Why? Because even though `stdout` is piped to `grep`, `stderr` is sent straight to our Terminal (and **not** through `grep`).\n\nIf you're connecting via SSH to Ubuntu 18.04, you should see color highlighting by default when a `grep` is successful; in this example, you would not encounter this.\n\nThe next command, `cat /etc/shadow | grep 'denied' > /tmp/empty-file`, redirects the `stdout` of **`grep`** to a file. Since `grep` did not process the error message, the file remains empty.\n\nEven if we try to redirect\u00a0`stderr`\u00a0at the end, as can be seen in the `cat /etc/shadow | grep 'denied' 2> /tmp/error-file`\u00a0command,\u00a0we still do not get any output in the file. This is because redirections **are sequential**: the output redirection only applies to the `grep`, not the `cat`.\n\nNow, in the same way output redirections have a way to redirect both `stdout` and `stderr`, so does a pipe with the `|&` syntax. Look at the same example again, now using proper redirections:\n\n```", "```\n\nFor the first command, if you have color syntax enabled, you will see the word `denied` is bold and colored (in our case, red). This means that now that we use `|&`, `grep` did successfully process the output.\n\nNext, when we redirect using the `stdout` of `grep`, we see that we successfully write the output to a file. If we try to redirect it with `2>`, we see it printed in the Terminal again, but not in the file. This is because of the sequential nature of redirects: as soon as `grep` successfully processes the input (which came from `stderr`), `grep` outputs this to `stdout`.\n\n`grep` actually does not know that the input was originally an `stderr` stream; as far as it is concerned, it is just `stdin` to process. And since for `grep` a successful process goes to `stdout`, that's where we find it in the end!\n\nIf we want to be safe and we do not need to split the\u00a0functionality of `stdout` and `stderr`, the safest way would be to use the command like this: `cat /etc/shadow |& grep 'denied' &> /tmp/file`. Since both the pipe and output redirections process `stdout` and `stderr`, we'll always end up with all output where we want it.\n\n# Practical examples\n\nBecause the theory of pipes should now be relatively simple (as we got most of it out of the way when we talked about input and output redirection), we'll present a number of practical examples that really illustrate the power of pipes.\n\nIt is good to remember that pipes only work on commands that accept input from `stdin`; not all do. If you pipe something to a command that totally disregards that input, you'll probably be disappointed with the results.\n\nSince we have now introduced pipes, we'll use them more liberally in the rest of the book. While these examples will present some ways of using pipes, the rest of the book will contain many more!\n\n# Yet another password generator\n\nSo, we've already created two password generators. Since three is the magic number, and this is a really good example to demonstrate chaining pipes, we'll create one more (the last one, promise):\n\n```", "```\n\nFirst, we grab the first 10 lines from `/dev/urandom` (the default behavior for `head`). We send this to `tr`, which trims it to the character sets we want (because it also outputs non-readable characters). Then, when we have a character set that we can use, we grab the first 20 characters from that using `head` again.\n\nIf you run just `head /dev/urandom | tr -dc 'a-zA-Z0-9'` a few times, you'll see that the length differs; this is because of the randomness of the newline byte. By grabbing 10 lines from `/dev/urandom`, the chance of not having enough readable characters to create a 20-character password is very small.\n\n(Challenge to the reader: create a script with a loop that does this long enough to encounter this situation!)\n\nThis example illustrates a few things. Firstly, we can often achieve a lot of things we want to do with a few smart pipes. Secondly, it is not unusual to use the same command multiple times. We could have also chosen `tail -c20` for the final command in the chain, by the way, but this has a nice symmetry to the whole command!\n\nFinally, we have seen three different password generators that do, in reality, the same thing. As always, in Bash there are many ways to accomplish the same goal; it is up to you to decide which is most applicable. Readability and performance should be the two main factors in this decision, as far as we're concerned.\n\n# Setting passwords in a script\n\nAnother task that you may find yourself wanting to script is setting the password for a local user. While this is not always good practice from a security standpoint (especially for personal user accounts), it is something that is used for functional accounts (users that correspond to software, such as the Apache user running the `httpd` processes).\n\nMost of these users do not need a password, but sometimes they do. In this case, we can use pipes with the `chpasswd` command to set their passwords:\n\n```", "```\n\nBefore you run this script, remember that this adds a user to your system with a very simple (bad) password. We updated our input sanitation a bit for this script: we used command substitution to see if the script was running with root privileges. Because `id -u` returns the numerical ID for the user, which should be 0 in the case of the root user or sudo privileges, we can compare it using `-ne 0`.\n\nIf we run the script and the user does not exist, we create the user before setting the password for that user. This is done by sending a `username:password` to the `stdin` of `chpasswd`, via a pipe. Do note that we used `-ne 0` twice, but for very different things: the first time for comparing a user ID, the second time with an exit status.\n\nYou can probably think of multiple improvements for this script. For example, it might be good to be able to specify both the username and password instead of these hardcoded dummy values. Also, a sanity check after the `chpasswd` command is definitely a good idea. In the current iteration, the script does not give **any** feedback to the user; very bad practice.\n\nSee if you can fix these issues, and be sure to remember that any input specified by the user should be checked *thoroughly*! If you really want a challenge, do this for multiple users in a `for` loop, by grabbing the input from a file.\n\nAn important thing to note is that a process, when running, is visible to any user on the system. This is often not that big a problem, but if you're providing usernames and passwords directly to the script as arguments, those are visible to everyone as well. This is often only for\u00a0a very short time, but they will be visible nonetheless. Always keep security in mind when dealing with sensitive issues such as passwords.\n\n# tee\n\nA command that was seemingly created to work in tandem with a pipe is `tee`. The description on the man page should tell most of the story:\n\ntee - read from standard input and write to standard output and files\n\nSo, in essence, sending something to the `stdin` of `tee` (via a pipe!) allows us to save that output to both your Terminal and a file at the same time.\n\nThis is often most useful when using interactive commands; it allows you to follow the output live, but also write it to a (log) file for later review. Updating a system provides a good example for the use case of `tee`:\n\n```", "```\n\nWe can make it even better by sending *all* output to `tee`, including\u00a0`stderr`:\n\n```", "```\n\nThe output will look something like this:\n\n```", "```\n\nThe first line of both the Terminal output and the log file is a `WARNING` which is sent to `stderr`; if you used `|` instead of `|&`, that would not have been written to the log file, only on the screen. If you use `|&` as advised, you will see that the output on your screen and the contents of the file are a perfect match.\n\nBy default, `tee` overwrites the destination file. Like all forms of redirection, `tee` also has a way to append instead of overwrite: the `--append` (`-a`) flag. In our experience, this is often a prudent choice, not dissimilar to `|&`.\n\nWhile `tee` is a great asset for your command-line arsenal, it most definitely has its place in scripting as well. Once your scripts get more complex, you might want to save parts of the output to a file for later review. However, to keep the user updated on the status of a script, printing some to the Terminal might also be a good idea. If these two scenarios overlap, you'll need to use `tee` to get the job done!\n\n# Here documents\n\nThe final concept we'll introduce in this chapter is the *here document*. Here documents, also called heredocs, are used to supply input to certain commands, slightly different to\u00a0`stdin` redirection. Notably, it is an easy way to give multiline input to a command. It works with the following syntax:\n\n```", "```\n\nIf you run this in your Terminal, you'll see the following:\n\n```", "```\n\nThe `<<` syntax lets Bash know you want to use a heredoc. Right after that, you're supplying a *delimiting identifier*. This might seem complicated, but it really means that you supply a string that will terminate the input. So, in our example, we supplied the commonly used `EOF` (short for **e**nd **o**f **f**ile).\n\nNow, if the heredoc encounters a line in the input that exactly matches the delimiting identifier, it stops listening for further input. Here's another example that illustrates this more closely:\n\n```", "```\n\nWhile using this with `cat` illustrates the point, it is not a very practical example. The `wall` command, however, is. `wall` lets you broadcast a message to everyone connected to the server, to their Terminal. When used in combination with a heredoc, it looks a little like this:\n\n```", "```\n\nIn this case, we receive our own broadcast. If you connect multiple times with your user, however, you'll see the broadcast come in there as well.\n\nGive it a try with a Terminal console connection and an SSH connection simultaneously; you'll understand it much better if you see it first-hand.\n\n# Heredocs and variables\n\nA source of confusion when using heredocs often arises from using variables. By default, variables are resolved in a heredoc, as can be seen in the following example:\n\n```", "```\n\nHowever, this might not always be desirable functionality. You might want to use this to write to a file in which the variables should be resolved later.\n\nIn this case, we can quote the delimiting identifier EOF to prevent variables being substituted:\n\n```", "```\n\n# Using heredocs for script input\n\nSince heredocs allow us to simply pass newline-delimited input to a command, we can use this to run an interactive script in a non-interactive manner! We have used this in practice, for instance, on database installer scripts that could only be run interactively. However, once you know the order of the questions and the input you want to supply, you can use the heredoc to supply this input to that interactive script.\n\nEven better, we have already created a script that uses interactive input,\u00a0`/home/reader/scripts/chapter_11/while-interactive.sh`,\u00a0which we can use to show this functionality:\u00a0\n\n```", "```\n\nWe know that the script continues until it gets the right answer, which is either `keyboard` or `Keyboard`. We use the heredoc to send three answers, in order, to the script: `a mouse`, `the sun`, and finally `keyboard`. We can correspond the output to the input quite easily.\n\nFor more verbosity, run the script with heredoc input with a `bash -x`, which will show you definitively that there are three tries to the riddle.\n\nYou might want to use a here document within a nested function (which will be explained in the next chapter) or within a loop. In both cases, you should already be using indentation to improve readability. However, this impacts your heredoc, because the whitespace is considered part of the input. If you find yourself in that situation, heredocs have an extra option: `<<-` instead of `<<`. When supplying the extra `-`, all *tab characters* are ignored. This allows you to indent the heredoc construction with tabs, which maintains both readability and function.\n\n# Here strings\n\nThe last thing we'd like to discuss in this chapter is the *here string*. It is very similar to the here document (hence the name), but it deals with a single string, instead of a document (who would have thought!).\n\nThis construct, which uses the `<<<` syntax, can be used to supply text input to a command that perhaps normally only accepts input from `stdin` or a file. A good example for this is `bc`, which is a simple calculator (part of the GNU Project).\n\nNormally, you use it in one of two ways: sending input to `stdin` via a pipe, or by pointing `bc` to a file:\n\n```", "```\n\nWhen used with `stdin`, `bc` returns the result of the calculation. When used with a file, `bc` opens an interactive session, which we need to manually close by entering `quit`. Both ways seem a little too much work for what we want to achieve.\n\nLet's look at how a here string fixes this:\n\n```"]