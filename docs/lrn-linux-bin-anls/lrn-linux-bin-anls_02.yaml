- en: Chapter 2. The ELF Binary Format
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。ELF二进制格式
- en: In order to reverse-engineer Linux binaries, you must understand the binary
    format itself. ELF has become the standard binary format for Unix and Unix-flavor
    OSes. In Linux, BSD variants, and other OSes, the ELF format is used for executables,
    shared libraries, object files, coredump files, and even the kernel boot image.
    This makes ELF very important to learn for those who want to better understand
    reverse engineering, binary hacking, and program execution. Binary formats such
    as ELF are not generally a quick study, and to learn ELF requires some degree
    of application of the different components that you learn as you go. Real, hands-on
    experience is necessary to achieve proficiency. The ELF format is complicated
    and dry, but can be learned with some enjoyment when applying your developing
    knowledge of it in reverse engineering and programming tasks. ELF is really quite
    an incredible composition of computer science at work, with program loading, dynamic
    linking, symbol table lookups, and many other tightly orchestrated components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要逆向工程Linux二进制文件，您必须了解二进制格式本身。 ELF已成为Unix和类Unix操作系统的标准二进制格式。在Linux、BSD变体和其他操作系统中，ELF格式用于可执行文件、共享库、目标文件、核心转储文件，甚至内核引导映像。这使得学习ELF对于那些想要更好地理解逆向工程、二进制黑客和程序执行的人来说非常重要。诸如ELF之类的二进制格式通常不是一个快速的学习过程，学习ELF需要一定程度的应用，随着学习的进行，需要实际的动手经验才能达到熟练程度。ELF格式复杂而枯燥，但在逆向工程和编程任务中应用您不断发展的对它的知识时，可以带来一些乐趣。ELF实际上是计算机科学的一个令人难以置信的组成部分，包括程序加载、动态链接、符号表查找以及许多其他紧密协调的组件。
- en: I believe that this chapter is perhaps the most important in this entire book
    because it will give the reader a much greater insight into topics pertaining
    to how a program is actually mapped out on disk and loaded into memory. The inner
    workings of program execution are complicated, and understanding it is valuable
    knowledge to the aspiring binary hacker, reverse engineer, or low-level programmer.
    In Linux, program execution implies the ELF binary format.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这一章也许是整本书中最重要的，因为它将使读者对程序实际在磁盘上是如何映射并加载到内存中有更深入的了解。程序执行的内部工作是复杂的，理解它对于有抱负的二进制黑客、逆向工程师或低级程序员来说是宝贵的知识。在Linux中，程序执行意味着ELF二进制格式。
- en: My approach to learning ELF is through investigation of the ELF specifications
    as any Linux reverse engineer should, and then applying each aspect of what we
    learn in a creative way. Throughout this book, you will visit many facets of ELF
    and see how knowledge of it is pertinent to viruses, process-memory forensics,
    binary protection, rootkits, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我的学习ELF的方法是通过调查ELF规范，就像任何Linux逆向工程师应该做的那样，然后以创造性的方式应用我们所学到的每个方面。在本书中，您将了解ELF的许多方面，并看到对病毒、进程内存取证、二进制保护、rootkit等知识的重要性。
- en: 'In this chapter, you will cover the following ELF topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将涵盖以下ELF主题：
- en: ELF file types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELF文件类型
- en: Program headers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序头
- en: Section headers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段头
- en: Symbols
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: Relocations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定位
- en: Dynamic linking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态链接
- en: Coding an ELF parser
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写ELF解析器
- en: ELF file types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF文件类型
- en: 'An ELF file may be marked as one of the following types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ELF文件可以标记为以下类型之一：
- en: '`ET_NONE`: This is an unknown type. It indicates that the file type is unknown,
    or has not yet been defined.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_NONE`：这是一个未知类型。它表示文件类型未知，或者尚未定义。'
- en: '`ET_REL`: This is a relocatable file. ELF type relocatable means that the file
    is marked as a relocatable piece of code or sometimes called an object file. Relocatable
    object files are generally pieces of **Position independent code** (**PIC**) that
    have not yet been linked into an executable. You will often see `.o` files in
    a compiled code base. These are the files that hold code and data suitable for
    creating an executable file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_REL`：这是一个可重定位文件。ELF类型可重定位意味着文件被标记为可重定位的代码片段，有时也称为目标文件。可重定位目标文件通常是尚未链接到可执行文件中的**位置无关代码**（**PIC**）的片段。您经常会在编译代码库中看到`.o`文件。这些文件保存了适用于创建可执行文件的代码和数据。'
- en: '`ET_EXEC`: This is an executable file. ELF type executable means that the file
    is marked as an executable file. These types of files are also called programs
    and are the entry point of how a process begins running.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_EXEC`：这是一个可执行文件。ELF类型可执行意味着文件被标记为可执行文件。这些类型的文件也被称为程序，并且是进程开始运行的入口点。'
- en: '`ET_DYN`: This is a shared object. ELF type dynamic means that the file is
    marked as a dynamically linkable object file, also known as shared libraries.
    These shared libraries are loaded and linked into a program''s process image at
    runtime.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_DYN`：这是一个共享对象。ELF类型动态意味着文件被标记为动态可链接的目标文件，也称为共享库。这些共享库在运行时加载和链接到程序的进程映像中。'
- en: '`ET_CORE`: This is an ELF type core that marks a core file. A core file is
    a dump of a full process image during the time of a program crash or when the
    process has delivered an SIGSEGV signal (segmentation violation). GDB can read
    these files and aid in debugging to determine what caused the program to crash.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_CORE`：这是一个ELF类型的核心文件。核心文件是在程序崩溃时或进程传递了SIGSEGV信号（段错误）时，对完整进程映像的转储。GDB可以读取这些文件，并帮助调试以确定是什么导致程序崩溃。'
- en: 'If we look at an ELF file with the command `readelf -h`, we can view the initial
    ELF file header. The ELF file header starts at the 0 offset of an ELF file and
    serves as a map to the rest of the file. Primarily, this header marks the ELF
    type, the architecture, and the entry point address where execution is to begin,
    and provides offsets to the other types of ELF headers (section headers and program
    headers), which will be explained in depth later. More of the file header will
    be understood once we explain the meaning of section headers and program headers.
    Looking at the ELF(5) man page in Linux shows us the ELF header structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用命令`readelf -h`查看ELF文件，我们可以查看初始ELF文件头。 ELF文件头从ELF文件的偏移0开始，并用作文件的其余部分的映射。主要是，此标头标记了ELF类型，体系结构和执行开始的入口点地址，并提供了到其他类型的ELF标头（部分标头和程序标头）的偏移量，这将在后面深入解释。一旦我们解释了部分标头和程序标头的含义，就会更多地了解文件标头。查看Linux中的ELF(5)
    man页面可以显示ELF标头结构：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later in this chapter, we will see how to utilize the fields in this structure
    to map out an ELF file with a simple C program. First, we will continue looking
    at the other types of ELF headers that exist.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将看到如何利用此结构中的字段来使用简单的C程序映射出ELF文件。首先，我们将继续查看其他存在的ELF标头类型。
- en: ELF program headers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF程序头
- en: ELF program headers are what describe segments within a binary and are necessary
    for program loading. Segments are understood by the kernel during load time and
    describe the memory layout of an executable on disk and how it should translate
    to memory. The program header table can be accessed by referencing the offset
    found in the initial ELF header member called `e_phoff` (program header table
    offset), as shown in the `ElfN_Ehdr` structure in display `1.7`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ELF程序头描述了二进制文件中的段，并且对于程序加载是必要的。在加载时，内核通过段来理解并描述可执行文件在磁盘上的内存布局以及它应该如何转换到内存中。程序头表可以通过引用初始ELF标头成员`e_phoff`（程序头表偏移）中找到的偏移量来访问，如显示`1.7`中的`ElfN_Ehdr`结构所示。
- en: There are five common program header types that we will discuss here. Program
    headers describe the segments of an executable file (shared libraries included)
    and what type of segment it is (that is, what type of data or code it is reserved
    for). First, let's take a look at the `Elf32_Phdr` structure that makes up a program
    header entry in the program header table of a 32-bit ELF executable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有五种常见的程序头类型，我们将在这里讨论。程序头描述可执行文件（包括共享库）的段以及它是什么类型的段（即，它为何保留了什么类型的数据或代码）。首先，让我们看看32位ELF可执行文件的程序头表中组成程序头条目的`Elf32_Phdr`结构。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We sometimes refer to program headers as Phdrs throughout the rest of this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时将程序头称为Phdrs在本书的其余部分。
- en: 'Here''s the `Elf32_Phdr` struct:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Elf32_Phdr`结构：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PT_LOAD
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_LOAD
- en: An executable will always have at least one `PT_LOAD` type segment. This type
    of program header is describing a loadable segment, which means that the segment
    is going to be loaded or mapped into memory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件将始终至少有一个`PT_LOAD`类型段。这种类型的程序头描述了一个可加载段，这意味着该段将被加载或映射到内存中。
- en: 'For instance, an ELF executable with dynamic linking will generally contain
    the following two loadable segments (of type `PT_LOAD`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，具有动态链接的ELF可执行文件通常包含以下两个可加载段（类型为`PT_LOAD`）：
- en: The text segment for program code
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序代码的文本段
- en: And the data segment for global variables and dynamic linking information
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及全局变量和动态链接信息的数据段
- en: The preceding two segments are going to be mapped into memory and aligned in
    memory by the value stored in `p_align`. I recommend reading the ELF man pages
    in Linux to understand all of the members in a Phdr structure as they describe
    the layout of both the segments in the file as well as in memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个段将被映射到内存中，并且将根据`p_align`中存储的值在内存中对齐。我建议在Linux中阅读ELF man页面，以了解Phdr结构中的所有成员，因为它们描述了文件中的段以及内存中的布局。
- en: Program headers are primarily there to describe the layout of a program for
    when it is executing and in memory. We will be utilizing Phdrs later in this chapter
    to demonstrate what they are and how to use them in reverse engineering software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序头主要用于描述程序在执行和内存中的布局。我们将在本章后面使用Phdrs来演示它们是什么以及如何在逆向工程软件中使用它们。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The text segment (also known as the code segment) will generally have segment
    permissions set as `PF_X` | `PF_R` (`READ+EXECUTE`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段（也称为代码段）通常将段权限设置为`PF_X` | `PF_R`（`读+执行`）。
- en: The data segment will generally have segment permissions set to `PF_W` | `PF_R`
    (`READ+WRITE`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数据段通常将段权限设置为`PF_W` | `PF_R`（`读+写`）。
- en: A file infected with a polymorphic virus might have changed these permissions
    in some way such as modifying the text segment to be writable by adding the `PF_W`
    flag into the program header's segment flags (`p_flags`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 受多态病毒感染的文件可能以某种方式更改了这些权限，例如通过将`PF_W`标志添加到程序头的段标志（`p_flags`）中，从而修改文本段为可写。
- en: PT_DYNAMIC – Phdr for the dynamic segment
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_DYNAMIC - 动态段的Phdr
- en: 'The dynamic segment is specific to executables that are dynamically linked
    and contains information necessary for the dynamic linker. This segment contains
    tagged values and pointers, including but not limited to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 动态段是特定于动态链接的可执行文件，包含动态链接器所需的信息。此段包含标记值和指针，包括但不限于以下内容：
- en: List of shared libraries that are to be linked at runtime
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在运行时链接的共享库列表
- en: The address/location of the **Global offset table** (**GOT**) discussed in the
    *ELF Dynamic Linking* section
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局偏移表**（**GOT**）的地址/位置在*ELF动态链接*部分讨论'
- en: Information about relocation entries
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关重定位条目的信息
- en: 'Following is a complete list of the tag names:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标签名称的完整列表：
- en: '| Tag name | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 标签名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DT_HASH` | Address of symbol hash table |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `DT_HASH` | 符号哈希表的地址 |'
- en: '| `DT_STRTAB` | Address of string table |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `DT_STRTAB` | 字符串表的地址 |'
- en: '| `DT_SYMTAB` | Address of symbol table |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `DT_SYMTAB` | 符号表的地址 |'
- en: '| `DT_RELA` | Address of Rela relocs table |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RELA` | Rela重定位表的地址 |'
- en: '| `DT_RELASZ` | Size in bytes of Rela table |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RELASZ` | Rela表的字节大小 |'
- en: '| `DT_RELAENT` | Size in bytes of a Rela table entry |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RELAENT` | Rela表条目的字节大小 |'
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `DT_STRSZ` | 字符串表的字节大小 |'
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `DT_STRSZ` | 字符串表的字节大小 |'
- en: '| `DT_STRSZ` | Size in bytes of string table |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `DT_STRSZ` | 字符串表的字节大小 |'
- en: '| `DT_SYMENT` | Size in bytes of a symbol table entry |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `DT_SYMENT` | 符号表条目的字节大小 |'
- en: '| `DT_INIT` | Address of the initialization function |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `DT_INIT` | 初始化函数的地址 |'
- en: '| `DT_FINI` | Address of the termination function |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `DT_FINI` | 终止函数的地址 |'
- en: '| `DT_SONAME` | String table offset to name of shared object |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `DT_SONAME` | 共享对象名称的字符串表偏移 |'
- en: '| `DT_RPATH` | String table offset to library search path |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RPATH` | 库搜索路径的字符串表偏移 |'
- en: '| `DT_SYMBOLIC` | Alert linker to search this shared object before the executable
    for symbols |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `DT_SYMBOLIC` | 提醒链接器在可执行文件之前搜索此共享对象的符号 |'
- en: '| `DT_REL` | Address of Rel relocs table |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `DT_REL` | Rel重定位表的地址 |'
- en: '| `DT_RELSZ` | Size in bytes of Rel table |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RELSZ` | Rel表的字节大小 |'
- en: '| `DT_RELENT` | Size in bytes of a Rel table entry |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RELENT` | Rel表条目的字节大小 |'
- en: '| `DT_PLTREL` | Type of reloc the PLT refers (Rela or Rel) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `DT_PLTREL` | PLT引用的重定位类型（Rela或Rel） |'
- en: '| `DT_DEBUG` | Undefined use for debugging |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `DT_DEBUG` | 调试的未定义用途 |'
- en: '| `DT_TEXTREL` | Absence of this indicates that no relocs should apply to a
    nonwritable segment |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `DT_TEXTREL` | 缺少此项表示不可写段不应用任何重定位 |'
- en: '| `DT_JMPREL` | Address of reloc entries solely for the PLT |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `DT_JMPREL` | 仅用于PLT的重定位条目的地址 |'
- en: '| `DT_BIND_NOW` | Instructs the dynamic linker to process all relocs before
    transferring control to the executable |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `DT_BIND_NOW` | 指示动态链接器在将控制转移给可执行文件之前处理所有重定位 |'
- en: '| `DT_RUNPATH` | String table offset to library search path |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `DT_RUNPATH` | 库搜索路径的字符串表偏移 |'
- en: The dynamic segment contains a series of structures that hold relevant dynamic
    linking information. The `d_tag` member controls the interpretation of `d_un`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 动态段包含一系列结构，其中包含相关的动态链接信息。`d_tag`成员控制`d_un`的解释。
- en: 'The 32-bit ELF dynamic struct:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 32位ELF动态结构：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will explore more about **dynamic linking** later in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更多地探讨**动态链接**。
- en: PT_NOTE
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_NOTE
- en: 'A segment of type `PT_NOTE` may contain auxiliary information that is pertinent
    to a specific vendor or system. Following is a definition of `PT_NOTE` from the
    formal ELF specification:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`PT_NOTE`的段可能包含对特定供应商或系统相关的辅助信息。以下是来自正式ELF规范的`PT_NOTE`的定义：
- en: Sometimes a vendor or system builder needs to mark an object file with special
    information that other programs will check for conformance, compatibility, and
    so on. Sections of type `SHT_NOTE` and program header elements of type `PT_NOTE`
    can be used for this purpose. The note information in sections and program header
    elements holds any number of entries, each of which is an array of 4-byte words
    in the format of the target processor. Labels appear below to help explain note
    information organization, but they are not part of the specification.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时供应商或系统构建者需要使用特殊信息标记对象文件，其他程序将检查符合性、兼容性等。`SHT_NOTE`类型的节和`PT_NOTE`类型的程序头元素可用于此目的。节和程序头元素中的注释信息包含任意数量的条目，每个条目都是目标处理器格式的4字节字数组。下面的标签有助于解释注释信息的组织，但它们不是规范的一部分。
- en: 'A point of interest: because of the fact that this segment is only used for
    OS specification information, and is actually not necessary for an executable
    to run (since the system will just assume the executable is native either way),
    this segment becomes an interesting place for virus infection, although not necessarily
    the most practical way to go about it due to size constraints. Some information
    on NOTE segment infections can be found at [http://vxheavens.com/lib/vhe06.html](http://vxheavens.com/lib/vhe06.html).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的地方：由于这个段仅用于OS规范信息，实际上对于可执行文件的运行并不是必需的（因为系统无论如何都会假定可执行文件是本地的），这个段成为病毒感染的有趣地方，尽管由于大小限制，这并不一定是最实际的方法。关于NOTE段感染的一些信息可以在[http://vxheavens.com/lib/vhe06.html](http://vxheavens.com/lib/vhe06.html)找到。
- en: PT_INTERP
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_INTERP
- en: This small segment contains only the location and size to a null terminated
    string describing where the program interpreter is; for instance, `/lib/linux-ld.so.2`
    is generally the location of the dynamic linker, which is also the program interpreter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小段只包含一个指向空终止字符串的位置和大小，描述了程序解释器的位置；例如，`/lib/linux-ld.so.2`通常是动态链接器的位置，也是程序解释器的位置。
- en: PT_PHDR
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_PHDR
- en: This segment contains the location and size of the program header table itself.
    The Phdr table contains all of the Phdr's describing the segments of the file
    (and in the memory image).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此段包含程序头表本身的位置和大小。Phdr表包含文件（以及内存映像中）描述段的所有Phdr。
- en: Consult the ELF(5) man pages or the ELF specification paper to see all possible
    Phdr types. We have covered the most commonly seen ones that are vital to program
    execution or that we will be seeing most commonly in our reverse engineering endeavors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅ELF(5)手册页面或ELF规范文件，以查看所有可能的Phdr类型。我们已经涵盖了最常见的那些对程序执行至关重要的，或者在我们的逆向工程努力中最常见的那些。
- en: 'We can use the `readelf -l <filename>` command to view a file''s Phdr table:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`readelf -l <filename>`命令查看文件的Phdr表：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see the entry point of the executable as well as some of the different
    segment types we just finished discussing. Notice the offsets to the right of
    the permission flags and alignment flags of the two first `PT_LOAD` segments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到可执行文件的入口点，以及我们刚刚讨论过的一些不同的段类型。注意两个第一个`PT_LOAD`段的权限标志和对齐标志右侧的偏移量。
- en: The text segment is `READ+EXECUTE` and the data segment is `READ+WRITE`, and
    both segments have an alignment of `0x1000` or 4,096 which is a page size on a
    32-bit executable, and this is for alignment during program loading.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段是`READ+EXECUTE`，数据段是`READ+WRITE`，两个段的对齐方式都是`0x1000`或4,096，这是32位可执行文件的页面大小，用于程序加载时的对齐。
- en: ELF section headers
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF节头
- en: Now that we've looked at what program headers are, it is time to look at section
    headers. I really want to point out here the distinction between the two; I often
    hear people calling sections, segments, and vice versa. A section is not a segment.
    Segments are necessary for program execution, and within each segment, there is
    either code or data divided up into sections. A section header table exists to
    reference the location and size of these sections and is primarily for linking
    and debugging purposes. Section headers are not necessary for program execution,
    and a program will execute just fine without having a section header table. This
    is because the section header table doesn't describe the program memory layout.
    That is the responsibility of the program header table. The section headers are
    really just complimentary to the program headers. The `readelf –l` command will
    show which sections are mapped to which segments, which helps to visualize the
    relationship between sections and segments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过程序头是什么，是时候看看节头了。我在这里真的想指出两者之间的区别；我经常听到人们将节称为段，将段称为节等等。节不是段。段对于程序执行是必要的，在每个段内，都有被分成节的代码或数据。节头表存在是为了引用这些节的位置和大小，主要用于链接和调试。节头对于程序执行并不是必要的，一个程序没有节头表也可以正常执行。这是因为节头表并不描述程序的内存布局。这是程序头表的责任。节头实际上只是程序头的补充。`readelf
    -l`命令将显示哪些节映射到哪些段，这有助于可视化节和段之间的关系。
- en: If the section headers are stripped (missing from the binary), that doesn't
    mean that the sections are not there; it just means that they can't be referenced
    by section headers and less information is available for debuggers and disassembler
    programs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节头被剥离（在二进制文件中缺失），这并不意味着节不存在；这只是意味着它们不能被节头引用，调试器和反汇编程序的信息就会更少。
- en: Each section contains either code or data of some type. The data could range
    from program data, such as global variables, or dynamic linking information that
    is necessary for the linker. Now, as mentioned previously, every ELF object has
    sections, but not all ELF objects have **section headers**, primarily when someone
    has deliberately removed the section header table, which is not the default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节都包含某种类型的代码或数据。数据可以是程序数据，如全局变量，或者对于链接器而言是必要的动态链接信息。现在，正如之前提到的，每个ELF对象都有节，但并非所有ELF对象都有**节头**，主要是当有人故意删除了节头表时，这不是默认情况。
- en: Usually, this is because the executable has been tampered with (for example,
    the section headers have been stripped so that debugging is harder). All of GNU's
    binutils such as `objcopy`, `objdump`, and other tools such as `gdb` rely on the
    section headers to locate symbol information that is stored in the sections specific
    to containing symbol data. Without section headers, tools such as `gdb` and `objdump`
    are nearly useless.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是因为可执行文件已被篡改（例如，节头已被剥离，使得调试更加困难）。GNU的所有binutils，如`objcopy`，`objdump`，以及`gdb`等其他工具都依赖于节头来定位存储在包含符号数据的节中的符号信息。没有节头，诸如`gdb`和`objdump`之类的工具几乎是无用的。
- en: Section headers are convenient to have for granular inspection over what parts
    or sections of an ELF object we are viewing. In fact, section headers make reverse
    engineering a lot easier since they provide us with the ability to use certain
    tools that require them. For instance, if the section header table is stripped,
    then we can't access a section such as `.dynsym`, which contains imported/exported
    symbols describing function names and offsets/addresses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 节头对于对我们正在查看的ELF对象的部分或节进行细粒度检查非常方便。事实上，节头使得逆向工程变得更加容易，因为它们为我们提供了使用某些需要它们的工具的能力。例如，如果节头表被剥离，那么我们就无法访问`.dynsym`这样的节，其中包含描述函数名称和偏移/地址的导入/导出符号。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if a section header table has been stripped from an executable, a moderate
    reverse engineer can actually reconstruct a section header table (and even part
    of a symbol table) by getting information from certain program headers since these
    will always exist in a program or shared library. We discussed the dynamic segment
    earlier and the different `DT_TAG` that contain information about the symbol table
    and relocation entries. We can use this to reconstruct other parts of the executable
    as shown in [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个可执行文件的节头表被剥离，一个中等的逆向工程师实际上可以通过从某些程序头获取信息来重建节头表（甚至部分符号表），因为这些信息总是存在于程序或共享库中。我们之前讨论过动态段和包含有关符号表和重定位条目信息的不同`DT_TAG`。我们可以使用这些信息来重建可执行文件的其他部分，如[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章。ECFS – 扩展核心文件快照技术")中所示的*ECFS – 扩展核心文件快照技术*。
- en: 'The following is what a 32-bit ELF section header looks like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是32位ELF节头的样子：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's take a look at some of the most important sections and section types,
    once again allowing room to study the ELF(5) man pages and the official ELF specification
    for more detailed information about the sections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看一下一些最重要的节和节类型，同时留出空间来研究ELF(5)手册页和官方ELF规范，以获取有关节的更详细信息。
- en: The .text section
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .text节
- en: The `.text` section is a code section that contains program code instructions.
    In an executable program where there are also Phdr's, this section would be within
    the range of the text segment. Because it contains program code, it is of section
    type `SHT_PROGBITS`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text`部分是包含程序代码指令的代码部分。在可执行程序中，如果还有Phdr''s，此部分将位于文本段的范围内。因为它包含程序代码，所以它是部分类型`SHT_PROGBITS`。'
- en: The .rodata section
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .rodata部分
- en: 'The `rodata` section contains read-only data such as strings from a line of
    C code, such as the following command are stored in this section:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`rodata`部分包含只读数据，例如来自C代码行的字符串，例如以下命令存储在此部分中：'
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This section is read-only and therefore must exist in a read-only segment of
    an executable. So you will find `.rodata` within the range of the text segment
    (not the data segment). Because this section is read-only, it is of type `SHT_PROGBITS`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分是只读的，因此必须存在于可执行文件的只读段中。因此，您将在文本段的范围内找到`.rodata`（而不是数据段）。因为此部分是只读的，所以它是类型`SHT_PROGBITS`。
- en: The .plt section
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .plt部分
- en: The **procedure linkage table** (**PLT**) will be discussed in depth later in
    this chapter, but it contains code necessary for the dynamic linker to call functions
    that are imported from shared libraries. It resides in the text segment and contains
    code, so it is marked as type `SHT_PROGBITS`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程链接表**（**PLT**）将在本章后面深入讨论，但它包含动态链接器调用从共享库导入的函数所需的代码。它位于文本段中，并包含代码，因此标记为类型`SHT_PROGBITS`。'
- en: The .data section
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .data部分
- en: The `data` section, not to be confused with the data segment, will exist within
    the data segment and contain data such as initialized global variables. It contains
    program variable data, so it is marked `SHT_PROGBITS`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`部分，不要与数据段混淆，将存在于数据段中，并包含诸如初始化的全局变量之类的数据。它包含程序变量数据，因此标记为`SHT_PROGBITS`。'
- en: The .bss section
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .bss部分
- en: The `bss` section contains uninitialized global data as part of the data segment
    and therefore takes up no space on disk other than 4 bytes, which represents the
    section itself. The data is initialized to zero at program load time and the data
    can be assigned values during program execution. The `bss` section is marked `SHT_NOBITS`
    since it contains no actual data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`bss`部分包含未初始化的全局数据作为数据段的一部分，因此除了代表该部分本身的4个字节外，在磁盘上不占用任何空间。数据在程序加载时初始化为零，并且数据可以在程序执行期间分配值。`bss`部分标记为`SHT_NOBITS`，因为它不包含实际数据。'
- en: The .got.plt section
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .got.plt部分
- en: The **Global offset table** (**GOT**) section contains the global offset table.
    This works together with the PLT to provide access to imported shared library
    functions and is modified by the dynamic linker at runtime. This section in particular
    is often abused by attackers who gain a pointer-sized write primitive in heap
    or `.bss` exploits. We will discuss this in the *ELF Dynamic Linking* section
    of this chapter. This section has to do with program execution and therefore is
    marked `SHT_PROGBITS`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局偏移表**（**GOT**）部分包含全局偏移表。这与PLT一起工作，以提供对导入的共享库函数的访问，并在运行时由动态链接器修改。这个部分特别经常被攻击者滥用，他们在堆或`.bss`漏洞中获得了指针大小的写入原语。我们将在本章的*ELF动态链接*部分中讨论这一点。这个部分与程序执行有关，因此标记为`SHT_PROGBITS`。'
- en: The .dynsym section
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .dynsym部分
- en: The `dynsym` section contains dynamic symbol information imported from shared
    libraries. It is contained within the text segment and is marked as type `SHT_DYNSYM`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynsym`部分包含从共享库导入的动态符号信息。它包含在文本段中，并标记为类型`SHT_DYNSYM`。'
- en: The .dynstr section
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .dynstr部分
- en: The `dynstr` section contains the string table for dynamic symbols that has
    the name of each symbol in a series of null terminated strings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynstr`部分包含动态符号的字符串表，其中包含一系列以空字符结尾的每个符号的名称。'
- en: The .rel.* section
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .rel.*部分
- en: Relocation sections contain information about how parts of an ELF object or
    process image need to be fixed up or modified at linking or runtime. We will discuss
    more about relocations in the *ELF Relocations* section of this chapter. Relocation
    sections are marked as type `SHT_REL` since they contain relocation data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重定位部分包含有关ELF对象或进程映像的部分需要在链接或运行时进行修复或修改的信息。我们将在本章的*ELF重定位*部分中更多地讨论重定位。重定位部分标记为类型`SHT_REL`，因为它包含重定位数据。
- en: The .hash section
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .hash部分
- en: 'The `hash` section, sometimes called `.gnu.hash`, contains a hash table for
    symbol lookup. The following hash algorithm is used for symbol name lookups in
    Linux ELF:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`部分，有时称为`.gnu.hash`，包含符号查找的哈希表。在Linux ELF中使用以下哈希算法进行符号名称查找：'
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`h = h * 33 + c` is often seen coded as `h = ((h << 5) + h) + c`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = h * 33 + c`经常编码为`h = ((h << 5) + h) + c`'
- en: The .symtab section
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .symtab部分
- en: The `symtab` section contains symbol information of type `ElfN_Sym`, which we
    will analyze more closely in the ELF symbols and relocations section of this chapter.
    The `symtab` section is marked as type `SHT_SYMTAB` as it contains symbol information.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`symtab`部分包含类型为`ElfN_Sym`的符号信息，我们将在本章的ELF符号和重定位部分中更仔细地分析。`symtab`部分标记为类型`SHT_SYMTAB`，因为它包含符号信息。'
- en: The .strtab section
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .strtab部分
- en: The `.strtab` section contains the symbol string table that is referenced by
    the `st_name` entries within the `ElfN_Sym` structs of `.symtab` and is marked
    as type `SHT_STRTAB` since it contains a string table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`.strtab`部分包含由`.symtab`中的`ElfN_Sym`结构的`st_name`条目引用的符号字符串表，并标记为类型`SHT_STRTAB`，因为它包含字符串表。'
- en: The .shstrtab section
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .shstrtab部分
- en: The `shstrtab` section contains the section header string table that is a set
    of null terminated strings containing the names of each section, such as `.text`,
    `.data`, and so on. This section is pointed to by the ELF file header entry called
    `e_shstrndx` that holds the offset of `.shstrtab`. This section is marked `SHT_STRTAB`
    since it contains a string table.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`shstrtab`部分包含节头字符串表，它是一组包含每个节的名称的空字符终止字符串，例如`.text`、`.data`等。这个部分由ELF文件头条目`e_shstrndx`指向，该条目保存了`.shstrtab`的偏移量。这个部分标记为`SHT_STRTAB`，因为它包含一个字符串表。'
- en: The .ctors and .dtors sections
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .ctors和.dtors部分
- en: The `.ctors` (**constructors**) and `.dtors` (**destructors**) sections contain
    function pointers to initialization and finalization code that is to be executed
    before and after the actual `main()` body of program code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ctors`（**构造函数**）和`.dtors`（**析构函数**）部分包含指向初始化和终结代码的函数指针，该代码将在实际`main()`程序代码体之前和之后执行。'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `__constructor__` function attribute is sometimes used by hackers and virus
    writers to implement a function that performs an anti-debugging trick such as
    calling `PTRACE_TRACEME` so that the process traces itself and no debuggers can
    attach to it. This way the anti-debugging code gets executed before the program
    enters into `main()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`__constructor__`函数属性有时被黑客和病毒作者使用，以实现执行反调试技巧的函数，例如调用`PTRACE_TRACEME`，以便进程跟踪自身，没有调试器可以附加到它。这样，反调试代码在程序进入`main()`之前执行。'
- en: There are many other section names and types, but we have covered most of the
    primary ones found in a dynamically linked executable. One can now visualize how
    an executable is laid out with both `phdrs` and `shdrs`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他部分名称和类型，但我们已经涵盖了大多数在动态链接可执行文件中找到的主要部分。现在可以通过`phdrs`和`shdrs`来可视化可执行文件的布局。
- en: 'The text segments will be as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段将如下：
- en: '`[.text]`: This is the program code'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.text】：这是程序代码
- en: '`[.rodata]`: This is read-only data'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.rodata】：这是只读数据
- en: '`[.hash]`: This is the symbol hash table'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.hash】：这是符号哈希表
- en: '`[.dynsym ]`: This is the shared object symbol data'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.dynsym】：这是共享对象符号数据
- en: '`[.dynstr ]`: This is the shared object symbol name'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.dynstr】：这是共享对象符号名称
- en: '`[.plt]`: This is the procedure linkage table'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.plt】：这是过程链接表
- en: '`[.rel.got]`: This is the G.O.T relocation data'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.rel.got】：这是G.O.T重定位数据
- en: 'The data segments will be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据段将如下：
- en: '`[.data]`: These are the globally initialized variables'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.data】：这些是全局初始化变量
- en: '`[.dynamic]`: These are the dynamic linking structures and objects'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.dynamic】：这些是动态链接结构和对象
- en: '`[.got.plt]`: This is the global offset table'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.got.plt】：这是全局偏移表
- en: '`[.bss]`: These are the globally uninitialized variables'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 【.bss】：这些是全局未初始化变量
- en: 'Let''s take a look at an `ET_REL` file (object file) section header with the
    `readelf –S` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下带有`readelf –S`命令的`ET_REL`文件（目标文件）部分头：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are 12 section headers, starting at offset 0 x 124:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是12个部分头，从偏移0x124开始：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No program headers exist in relocatable objects (ELF files of type `ET_REL`)
    because `.o` files are meant to be linked into an executable, but not meant to
    be loaded directly into memory; therefore, readelf -l will yield no results on
    `test.o`. Linux loadable kernel modules are actually `ET_REL` objects and are
    an exception to the rule because they do get loaded directly into kernel memory
    and relocated on the fly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位对象（类型为`ET_REL`的ELF文件）中不存在程序头，因为`.o`文件是用来链接到可执行文件的，而不是直接加载到内存中；因此，`readelf
    -l`在`test.o`上不会产生结果。Linux可加载内核模块实际上是`ET_REL`对象，并且是一个例外，因为它们确实直接加载到内核内存中，并且在运行时重新定位。
- en: 'We can see that many of the sections we talked about are present, but there
    are also some that are not. If we compile `test.o` into an executable, we will
    see that many new sections have been added, including `.got.plt`, `.plt`, `.dynsym`,
    and other sections that are related to dynamic linking and runtime relocations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们讨论过的许多部分都存在，但也有一些不存在。如果我们将`test.o`编译成可执行文件，我们将看到许多新的部分已被添加，包括`.got.plt`、`.plt`、`.dynsym`和其他与动态链接和运行时重定位相关的部分：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are 30 section headers, starting at offset 0 x 1140:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是30个部分头，从偏移0x1140开始：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As observed, a number of sections have been added, most notably the ones related
    to dynamic linking and constructors. I strongly suggest that the reader follows
    the exercise of deducing which sections have been changed or added and what purpose
    the added sections serve. Consult the ELF(5) man pages or the ELF specifications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如观察到的，已经添加了许多部分，其中最重要的是与动态链接和构造函数相关的部分。我强烈建议读者跟随推断哪些部分已更改或添加以及添加部分的目的的练习。请参阅ELF(5)手册页或ELF规范。
- en: ELF symbols
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF符号
- en: 'Symbols are a symbolic reference to some type of data or code such as a global
    variable or function. For instance, the `printf()` function is going to have a
    symbol entry that points to it in the dynamic symbol table `.dynsym`. In most
    shared libraries and dynamically linked executables, there exist two symbol tables.
    In the `readelf -S` output shown previously, you can see two sections: `.dynsym`
    and `.symtab`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是对某种类型的数据或代码的符号引用，例如全局变量或函数。例如，`printf()`函数将在动态符号表`.dynsym`中有一个指向它的符号条目。在大多数共享库和动态链接的可执行文件中，存在两个符号表。在先前显示的`readelf
    -S`输出中，您可以看到两个部分：`.dynsym`和`.symtab`。
- en: The `.dynsym` contains global symbols that reference symbols from an external
    source, such as `libc` functions like `printf`, whereas the symbols contained
    in `.symtab` will contain all of the symbols in `.dynsym`, as well as the local
    symbols for the executable, such as global variables, or local functions that
    you have defined in your code. So `.symtab` contains all of the symbols, whereas
    `.dynsym` contains just the dynamic/global symbols.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dynsym`包含引用外部源的全局符号，例如`libc`函数如`printf`，而`.symtab`中包含所有`.dynsym`中的符号，以及可执行文件中的本地符号，例如全局变量，或者您在代码中定义的本地函数。因此，`.symtab`包含所有符号，而`.dynsym`只包含动态/全局符号。'
- en: 'So the question is: Why have two symbol tables if `.symtab` already contains
    everything that''s in `.dynsym`? If you check out the `readelf -S` output of an
    executable, you will see that some sections are marked **A** (**ALLOC**) or **WA**
    (**WRITE/ALLOC**) or **AX** (**ALLOC/EXEC**). If you look at `.dynsym`, you will
    see that it is marked ALLOC, whereas `.symtab` has no flags.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是：如果`.symtab`已经包含了`.dynsym`中的所有内容，为什么还要有两个符号表？如果您查看可执行文件的`readelf -S`输出，您会发现一些部分被标记为**A**（**ALLOC**）或**WA**（**WRITE/ALLOC**）或**AX**（**ALLOC/EXEC**）。如果您查看`.dynsym`，您会发现它被标记为ALLOC，而`.symtab`没有标志。
- en: ALLOC means that the section will be allocated at runtime and loaded into memory,
    and `.symtab` is not loaded into memory because it is not necessary for runtime.
    The `.dynsym` contains symbols that can only be resolved at runtime, and therefore
    they are the only symbols needed at runtime by the dynamic linker. So, while the
    `.dynsym` symbol table is necessary for the execution of dynamically linked executables,
    the `.symtab` symbol table exists only for debugging and linking purposes and
    is often stripped (removed) from production binaries to save space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ALLOC表示该部分将在运行时分配并加载到内存中，`.symtab`不会加载到内存中，因为对于运行时来说是不必要的。`.dynsym`包含只能在运行时解析的符号，因此它们是动态链接器在运行时所需的唯一符号。因此，虽然`.dynsym`符号表对于动态链接可执行文件的执行是必要的，但`.symtab`符号表仅用于调试和链接目的，并且通常会从生产二进制文件中剥离以节省空间。
- en: 'Let''s take a look at what an ELF symbol entry looks like for 64-bit ELF files:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看64位ELF文件的ELF符号条目是什么样子的：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Symbol entries are contained within the `.symtab` and `.dynsym` sections, which
    is why the `sh_entsize` (section header entry size) for those sections are equivalent
    to `sizeof(ElfN_Sym)`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 符号条目包含在`.symtab`和`.dynsym`部分中，这就是为什么这些部分的`sh_entsize`（部分头条目大小）等于`sizeof(ElfN_Sym)`。
- en: st_name
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_name
- en: The `st_name` contains an offset into the symbol table's string table (located
    in either `.dynstr` or `.strtab`), where the name of the symbol is located, such
    as `printf`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`st_name`包含符号表字符串表（位于`.dynstr`或`.strtab`中）中符号名称的偏移量，比如`printf`。'
- en: st_value
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_value
- en: The `st_value` holds the value of the symbol (either an address or offset of
    its location).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`st_value`保存符号的值（地址或位置的偏移量）。'
- en: st_size
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_size
- en: The `st_size` contains the size of the symbol, such as the size of a global
    function `ptr`, which would be 4 bytes on a 32-bit system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`st_size`包含符号的大小，比如全局函数`ptr`的大小，在32位系统上为4字节。'
- en: st_other
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_other
- en: This member defines the symbol visibility.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员定义了符号的可见性。
- en: st_shndx
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_shndx
- en: Every symbol table entry is *defined* in relation to some section. This member
    holds the relevant section header table index.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个符号表条目都与某个部分*定义*相关。该成员保存相关部分头表索引。
- en: st_info
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: st_info
- en: The `st_info` specifies the symbol type and binding attributes. For a complete
    list of these types and attributes, consult the **ELF(5) man page**. The symbol
    types start with STT whereas the symbol bindings start with STB. As an example,
    a few common ones are as explained in the next sections.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`st_info`指定符号类型和绑定属性。有关这些类型和属性的完整列表，请参阅**ELF(5) man page**。符号类型以STT开头，而符号绑定以STB开头。例如，一些常见的如下部分所述。'
- en: Symbol types
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号类型
- en: 'We''ve got the following symbol types:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下符号类型：
- en: '`STT_NOTYPE`: The symbols type is undefined'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STT_NOTYPE`：符号类型未定义'
- en: '`STT_FUNC`: The symbol is associated with a function or other executable code'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STT_FUNC`：符号与函数或其他可执行代码相关联'
- en: '`STT_OBJECT`: The symbol is associated with a data object'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STT_OBJECT`：符号与数据对象相关联'
- en: Symbol bindings
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号绑定
- en: 'We''ve got the following symbol bindings:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下符号绑定：
- en: '`STB_LOCAL`: Local symbols are not visible outside the object file containing
    their definition, such as a function declared static.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STB_LOCAL`：局部符号对包含其定义的目标文件之外不可见，比如声明为静态的函数。'
- en: '`STB_GLOBAL`: Global symbols are visible to all object files being combined.
    One file''s definition of a global symbol will satisfy another file''s undefined
    reference to the same symbol.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STB_GLOBAL`：全局符号对于所有被合并的目标文件都是可见的。一个文件对全局符号的定义将满足另一个文件对相同符号的未定义引用。'
- en: '`STB_WEAK`: Similar to global binding, but with less precedence, meaning that
    the binding is weak and may be overridden by another symbol (with the same name)
    that is not marked as `STB_WEAK`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STB_WEAK`：类似于全局绑定，但优先级较低，意味着绑定是弱的，可能会被另一个未标记为`STB_WEAK`的符号（具有相同名称）覆盖。'
- en: 'There are macros for packing and unpacking the binding and type fields:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有用于打包和解包绑定和类型字段的宏：
- en: '`ELF32_ST_BIND(info)` or `ELF64_ST_BIND(info)` extract a binding from an `st_info`
    value'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELF32_ST_BIND(info)`或`ELF64_ST_BIND(info)`从`st_info`值中提取绑定'
- en: '`ELF32_ST_TYPE(info)` or `ELF64_ST_TYPE(info)` extract a type from an `st_info`
    value'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELF32_ST_TYPE(info)`或`ELF64_ST_TYPE(info)`从`st_info`值中提取类型'
- en: '`ELF32_ST_INFO(bind, type)` or `ELF64_ST_INFO(bind, type)` convert a binding
    and a type into an `st_info` value'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELF32_ST_INFO(bind, type)`或`ELF64_ST_INFO(bind, type)`将绑定和类型转换为`st_info`值'
- en: 'Let''s look at the symbol table for the following source code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下源代码的符号表：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the command to see the symbol table entries for functions
    `foochu` and `func1`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是查看函数`foochu`和`func1`的符号表条目的命令：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that the `foochu` function is a value of `0x80480da`, and is a function
    (`STT_FUNC`) that has a local symbol binding (`STB_LOCAL`). If you recall, we
    talked a little bit about `LOCAL` bindings, which mean that the symbol cannot
    be seen outside the object file it is defined it, which is why `foochu` is local,
    since we declared it with the **static keyword** in our source code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`foochu`函数的值为`0x80480da`，是一个函数（`STT_FUNC`），具有局部符号绑定（`STB_LOCAL`）。如果你还记得，我们稍微谈到了`LOCAL`绑定，这意味着该符号在定义它的目标文件之外是不可见的，这就是为什么`foochu`是局部的，因为我们在源代码中使用了**static关键字**声明它。
- en: 'Symbols make life easier for everyone; they are a part of ELF objects for the
    purpose of linking, relocation, readable disassembly, and debugging. This brings
    me to the topic of a useful tool that I coded in 2013, named `ftrace`. Similar
    to, and in the same spirit of `ltrace` and `strace`, `ftrace` will trace all of
    the function calls made within the binary and can also show other branch instructions
    such as jumps. I originally designed `ftrace` to help in reversing binaries for
    which I didn''t have the source code while at work. The `ftrace` is considered
    to be a dynamic analysis tool. Let''s take a look at some of its capabilities.
    We compile a binary with the following source code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 符号对每个人都更容易，它们是ELF对象的一部分，用于链接、重定位、可读的反汇编和调试。这让我想到了一个我在2013年编写的有用工具的话题，名为`ftrace`。类似于`ltrace`和`strace`，`ftrace`将跟踪二进制文件中进行的所有函数调用，并且还可以显示其他分支指令，比如跳转。我最初设计`ftrace`是为了帮助我在工作中没有源代码的情况下对二进制文件进行逆向。`ftrace`被认为是一种动态分析工具。让我们来看一下它的一些功能。我们用以下源代码编译一个二进制文件：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, assuming that we don''t have the preceding source code and we want to
    know the inner workings of the binary that it compiles into, we can run `ftrace`
    on it. First let''s look at the synopsis:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们没有前面的源代码，我们想知道它编译成的二进制文件的内部工作原理，我们可以在其上运行`ftrace`。首先让我们看一下概要：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The usage is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 用法如下：
- en: '`[-p]`: This traces by PID'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-p]`：这按PID进行跟踪'
- en: '`[-t]`: This is for the type detection of function args'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-t]`：这是用于函数参数类型检测'
- en: '`[-s]`: This prints string values'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-s]`：这会打印字符串值'
- en: '`[-v]`: This gives a verbose output'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-v]`：这提供详细输出'
- en: '`[-e]`: This gives miscellaneous ELF information (symbols, dependencies)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-e]`：这提供杂项ELF信息（符号、依赖项）'
- en: '`[-S]`: This shows function calls with stripped symbols'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-S]`：这显示带有剥离符号的函数调用'
- en: '`[-C]`: This completes the control flow analysis'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-C]`：这完成控制流分析'
- en: 'Let''s give it a try:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A clever individual might now be asking: What happens if a binary''s symbol
    table has been stripped? That''s right; you can strip a binary of its symbol table;
    however, a dynamically linked executable will always retain `.dynsym` but will
    discard `.symtab` if it is stripped, so only the imported library symbols will
    show up.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聪明的人现在可能会问：如果二进制文件的符号表被剥离了会发生什么？没错，你可以剥离二进制文件的符号表；但是，动态链接的可执行文件将始终保留`.dynsym`，但如果被剥离，将丢弃`.symtab`，因此只有导入的库符号会显示出来。
- en: If a binary is compiled statically (`gcc-static`) or without `libc` linking
    (`gcc-nostdlib`), and it is then stripped with the `strip` command, a binary will
    have no symbol table at all since the dynamic symbol table is no longer imperative.
    The `ftrace` behaves differently with the `–S` flag that tells `ftrace` to show
    every function call even if there is no symbol attached to it. When using the
    `–S` flag, `ftrace` will display function names as `SUB_<address_of_function>`,
    similar to how IDA pro will show functions that have no symbol table reference.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二进制文件是静态编译的（`gcc-static`）或没有`libc`链接（`gcc-nostdlib`），然后用`strip`命令剥离，二进制文件将不再有符号表，因为动态符号表不再是必要的。`ftrace`在使用`-S`标志时的行为与众不同，该标志告诉`ftrace`即使没有符号附加到它，也要显示每个函数调用。使用`-S`标志时，`ftrace`将显示函数名称为`SUB_<address_of_function>`，类似于IDA
    pro将显示没有符号表引用的函数。
- en: 'Let''s look at the following very simple source code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下非常简单的源代码：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding source code simply calls the `foo()` function and exits. The
    reason we are using `_start()` instead of `main()` is because we compile it with
    the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的源代码只是调用了`foo()`函数然后退出。我们使用`_start()`而不是`main()`的原因是因为我们用以下方式编译它：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `gcc` flag `-nostdlib` directs the linker to omit standard `libc` linking
    conventions and to simply compile the code that we have and nothing more. The
    default entry point is a symbol called `_start()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`标志`-nostdlib`指示链接器省略标准的`libc`链接约定，只需编译我们拥有的代码，而不多余的东西。默认的入口点是一个名为`_start()`的符号：'
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now notice that `foo()` function has been replaced by `sub_400144()`, which
    shows that the function call is happening at address `0x400144`. Now if we look
    at the binary `test2` before we stripped the symbols, we can see that `0x400144`
    is indeed where `foo()` is located:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在注意到`foo()`函数已被`sub_400144()`替换，这表明函数调用发生在地址`0x400144`。现在如果我们在剥离符号之前看`test2`二进制文件，我们可以看到`0x400144`确实是`foo()`所在的地方：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, to give you a really good idea of how helpful symbols can be to reverse
    engineers (when we have them), let''s take a look at the `test2` binary, this
    time without symbols to demonstrate how it becomes slightly less obvious to read.
    This is primarily because branch instructions no longer have a symbol name attached
    to them, so analyzing the control flow becomes more tedious and requires more
    annotation, which some disassemblers like IDA-pro allow us to do as we go:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为了让你真正了解符号对逆向工程师（当我们拥有它们时）有多么有帮助，让我们看看`test2`二进制文件，这次没有符号，以演示它变得稍微不那么容易阅读。这主要是因为分支指令不再附有符号名称，因此分析控制流变得更加繁琐，需要更多的注释，而一些反汇编器如IDA-pro允许我们在进行时进行注释：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only thing to give us an idea where a new function starts is by examining
    the **procedure prologue**, which is at the beginning of every function, unless
    (`gcc -fomit-frame-pointer`) has been used, in which case it becomes less obvious
    to identify.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能让我们知道新函数从哪里开始的方法是检查**过程序言**，它位于每个函数的开头，除非使用了(`gcc -fomit-frame-pointer`)，在这种情况下，识别起来就不那么明显了。
- en: This book assumes that the reader already has some knowledge of assembly language,
    since teaching x86 asm is not the goal of this book, but notice the preceding
    emboldened procedure prologue, which helps denote the start of each function.
    The procedure prologue just sets up the stack frame for each new function that
    has been called by backing up the base pointer on the stack and setting its value
    to the stack pointers before the stack pointer is adjusted to make room for local
    variables. This way variables can be referenced as positive offsets from a fixed
    address stored in the base pointer register `ebp/rbp`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者已经对汇编语言有一些了解，因为教授x86汇编不是本书的目标，但请注意前面加粗的过程序言，它有助于标明每个函数的开始。过程序言只是为每个被调用的新函数设置堆栈帧，通过在堆栈上备份基指针并将其值设置为在调整堆栈指针之前的堆栈指针的值。这样变量可以作为基指针寄存器`ebp/rbp`中存储的固定地址的正偏移来引用。
- en: Now that we've gotten a grasp on symbols, the next step is to understand relocations.
    We will see in the next section how symbols, relocations, and sections are all
    closely tied together and live at the same level of abstraction within the ELF
    format.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对符号有了一定的了解，下一步是理解重定位。在下一节中，我们将看到符号、重定位和部分如何紧密地联系在一起，并在ELF格式中处于相同的抽象层级。
- en: ELF relocations
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF重定位
- en: 'From the ELF(5) man pages:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 来自ELF(5)手册页：
- en: '*Relocation is the process of connecting symbolic references with symbolic
    definitions. Relocatable files must have information that describes how to modify
    their section contents, thus allowing executable and shared object files to hold
    the right information for a process''s program image. Relocation entries are these
    data.*'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*重定位是将符号引用与符号定义连接起来的过程。可重定位文件必须具有描述如何修改其部分内容的信息，从而允许可执行文件和共享对象文件保存进程的程序映像所需的正确信息。重定位条目就是这些数据。*'
- en: 'The process of relocation relies on symbols and sections, which is why we covered
    symbols and sections first. In relocations, there are *relocation records*, which
    essentially contain information about how to patch the code related to a given
    symbol. Relocations are literally a mechanism for binary patching and even hot-patching
    in memory when the dynamic linker is involved. The linker program: `/bin/ld` that
    is used to create executable files, and shared libraries must have some type of
    metadata that describes how to patch certain instructions. This metadata is stored
    as what we call relocation records. I will further explain relocations by using
    an example.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 重定位的过程依赖于符号和部分，这就是为什么我们首先介绍符号和部分。在重定位中，有*重定位记录*，它们基本上包含了有关如何修补与给定符号相关的代码的信息。重定位实际上是一种用于二进制修补甚至在动态链接器涉及时在内存中进行热修补的机制。链接器程序：`/bin/ld`用于创建可执行文件和共享库，必须具有描述如何修补某些指令的元数据。这些元数据被存储为我们所谓的重定位记录。我将通过一个例子进一步解释重定位。
- en: Imagine having two object files linked together to create an executable. We
    have `obj1.o` that contains the code to call a function named `foo()` that is
    located in `obj2.o`. Both obj1.o and `obj2.o` are analyzed by the linker program
    and contain relocation records so that they may be linked to create a fully working
    executable program. Symbolic references will be resolved into symbolic definitions,
    but what does that even mean? Object files are relocatable code, which means that
    it is code that is meant to be relocated to a location at a given address within
    an executable segment. Before the relocation process happens, the code has symbols
    and code that will not properly function or cannot be properly referenced without
    first knowing their location in memory. These must be patched after the position
    of the instruction or symbol within the executable segment is known by the linker.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有两个目标文件链接在一起创建可执行文件。我们有`obj1.o`包含调用名为`foo()`的函数的代码，该函数位于`obj2.o`中。链接器程序分析了`obj1.o`和`obj2.o`，并包含了重定位记录，以便它们可以链接在一起创建一个完全可工作的可执行程序。符号引用将被解析为符号定义，但这究竟是什么意思呢？目标文件是可重定位代码，这意味着它是代码，旨在被重定位到可执行段内的给定地址。在重定位过程发生之前，代码具有符号和代码，这些符号和代码在不知道它们在内存中的位置之前将无法正常工作或无法正确引用。这些必须在链接器首先知道它们在可执行段内的位置之后进行修补。
- en: 'Let''s take a quick look at a 64-bit relocation entry:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下64位重定位条目：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And some relocation entries require an addend:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有些重定位条目需要一个加数：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `r_offset` points to the location that requires the relocation action. A
    relocation action describes the details of how to patch the code or data contained
    at `r_offset`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`r_offset`指向需要进行重定位操作的位置。重定位操作描述了如何修补`r_offset`处包含的代码或数据的详细信息。'
- en: The `r_info` gives both the symbol table index with respect to which the relocation
    must be made and the type of relocation to apply.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`r_info`给出了必须进行重定位的符号表索引以及要应用的重定位类型。'
- en: The `r_addend` specifies a constant addend used to compute the value stored
    in the relocatable field.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`r_addend`指定了用于计算可重定位字段中存储的值的常数加数。'
- en: The relocation records for 32-bit ELF files are the same as for 64-bit, but
    use 32-bit integers. The following example for are object file code will be compiled
    as 32-bit so that we can demonstrate **implicit addends**, which are not as commonly
    used in 64-bit. An implicit addend occurs when the relocation records are stored
    in ElfN_Rel type structures that don't contain an `r_addend` field and therefore
    the addend is stored in the relocation target itself. The 64-bit executables tend
    to use the `ElfN_Rela` structs that contain an **explicit addend**. I think it
    is worth understanding both scenarios, but implicit addends are a little more
    confusing, so it makes sense to bring light to this area.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 32位ELF文件的重定位记录与64位相同，但使用32位整数。以下示例将编译为32位的目标文件代码，以便我们可以演示**隐式加数**，这在64位中不常用。当重定位记录存储在不包含`r_addend`字段的ElfN_Rel类型结构中时，隐式加数就会发生，因此加数存储在重定位目标本身中。64位可执行文件倾向于使用包含**显式加数**的`ElfN_Rela`结构。我认为值得理解这两种情况，但隐式加数有点更令人困惑，因此有必要对这一领域进行阐明。
- en: 'Let''s take a look at the source code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下源代码：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We see that it calls the `foo()` function. However, the `foo()` function is
    not located directly within that source code file; so, upon compiling, there will
    be a relocation entry created that is necessary for later satisfying the symbolic
    reference:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它调用了`foo()`函数。但是，`foo()`函数并不直接位于该源代码文件中；因此，在编译时，将创建一个重定位条目，以满足以后对符号引用的需求：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, the call to `foo()` is highlighted and it contains the value
    `0xfffffffc`, which is the *implicit addend*. Also notice the `call 7`. The number
    `7` is the offset of the relocation target to be patched. So when `obj1.o` (which
    calls `foo()` located in `obj2.o`) is linked with `obj2.o` to make an executable,
    a relocation entry that points at offset `7` is processed by the linker, telling
    it which location (offset 7) needs to be modified. The linker then patches the
    4 bytes at offset 7 so that it will contain the real offset to the `foo()` function,
    after `foo()` has been positioned somewhere within the executable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，对`foo()`的调用被突出显示，并包含值`0xfffffffc`，这是*隐式加数*。还要注意`call 7`。数字`7`是要修补的重定位目标的偏移量。因此，当`obj1.o`（调用位于`obj2.o`中的`foo()`）与`obj2.o`链接以生成可执行文件时，链接器会处理指向偏移量`7`的重定位条目，告诉它需要修改的位置（偏移量7）。然后，链接器会修补偏移量7处的4个字节，使其包含`foo()`函数的真实偏移量，`foo()`在可执行文件中的某个位置。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call instruction `e8 fc ff ff ff` contains the implicit addend and is important
    to remember for this lesson; the value `0xfffffffc` is `-(4)` or `-(sizeof(uint32_t))`.
    A dword is 4 bytes on a 32-bit system, which is the size of this relocation target.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用指令`e8 fc ff ff ff`包含隐式加数，对于这节课很重要；值`0xfffffffc`是`-(4)`或`-(sizeof(uint32_t))`。在32位系统上，一个双字是4个字节，这是重定位目标的大小。
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, a relocation field at offset 7 is specified by the relocation
    entry's `r_offset` field.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，偏移量为7的重定位字段由重定位条目的`r_offset`字段指定。
- en: '`R_386_PC32` is the relocation type. To understand all of these types, read
    the ELF specs. Each relocation type requires a different computation on the relocation
    target being modified. `R_386_PC32` modifies the target with `S + A – P`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R_386_PC32`是重定位类型。要了解所有这些类型，请阅读ELF规范。每种重定位类型都需要对被修改的重定位目标进行不同的计算。`R_386_PC32`使用`S
    + A - P`修改目标。'
- en: '`S` is the value of the symbol whose index resides in the relocation entry.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`是重定位条目中索引的符号的值。'
- en: '`A` is the addend found in the relocation entry.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`是在重定位条目中找到的加数。'
- en: '`P` is the place (section offset or address) of the storage unit being relocated
    (computed using `r_offset`).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`是被重定位的存储单元的位置（段偏移量或地址）（使用`r_offset`计算）。'
- en: 'Let''s look at the final output of our executable after compiling `obj1.o`
    and `obj2.o` on a 32-bit system:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在32位系统上编译`obj1.o`和`obj2.o`后，我们的可执行文件的最终输出：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can see that the call instruction **(the relocation target) at 0x80480de**
    has been modified with the 32-bit offset value of `5`, which points `foo()`. The
    value `5` is the result of the `R386_PC_32` relocation action:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，调用指令**(重定位目标)在0x80480de**处已被修改为32位偏移值`5`，指向`foo()`。值`5`是`R386_PC_32`重定位操作的结果：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `0xfffffffc` is the same as `–4` if a signed integer, so the calculation
    can also be seen as:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`0xfffffffc`与有符号整数中的`-4`相同，因此计算也可以看作：'
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To calculate an offset into a virtual address, use the following computation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算虚拟地址的偏移量，请使用以下计算：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Which in this case is `0x80480de + 5 + 5 = 0x80480e8`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下是`0x80480de + 5 + 5 = 0x80480e8`。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to this computation as it is important to remember and can be
    used when calculating offsets to addresses frequently.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这个计算，因为它很重要并且在频繁计算地址偏移时可以使用。
- en: 'An address may also be computed into an offset with the following computation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 地址也可以通过以下计算得出偏移量：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As mentioned previously, the ELF specs cover ELF relocations in depth, and we
    will be visiting some of the types used in dynamic linking in the next section,
    such as `R386_JMP_SLOT` relocation entries.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ELF规范详细介绍了ELF重定位，并且我们将在下一节中讨论一些在动态链接中使用的类型，例如`R386_JMP_SLOT`重定位条目。
- en: Relocatable code injection-based binary patching
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于可重定位代码注入的二进制修补
- en: Relocatable code injection is a technique that hackers, virus writers, or anyone
    who wants to modify the code in a binary may utilize as a way to relink a binary
    after it's already been compiled and linked into an executable. That is, you can
    inject an object file into an executable, update the executable's symbol table
    to reflect newly inserted functionality, and perform the necessary relocations
    on the injected object code so that it becomes a part of the executable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位代码注入是黑客、病毒作者或任何想要修改二进制代码的人可能利用的一种技术，作为一种在编译和链接为可执行文件之后重新链接二进制文件的方式。也就是说，您可以将一个目标文件注入到可执行文件中，更新可执行文件的符号表以反映新插入的功能，并对注入的目标代码执行必要的重定位，使其成为可执行文件的一部分。
- en: A complicated virus might use this technique rather than just appending position-independent
    code. This technique requires making room in the target executable to inject the
    code, followed by applying the relocations. We will cover binary infection and
    code injection more thoroughly in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的病毒可能会使用这种技术，而不仅仅是附加位置无关代码。这种技术需要在目标可执行文件中腾出空间来注入代码，然后应用重定位。我们将在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中更全面地介绍二进制感染和代码注入，*ELF病毒技术- Linux/Unix病毒*。
- en: As mentioned in [Chapter 1](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985
    "Chapter 1. The Linux Environment and Its Tools"), *The Linux Environment and
    Its Tools*, there is an amazing tool called *Eresi* ([http://www.eresi-project.org](http://www.eresi-project.org)),
    which is capable of relocatable code injection (aka `ET_REL` injection). I also
    designed a custom reverse engineering tool for ELF, namely, **Quenya**. It is
    very old but can be found at [http://www.bitlackeys.org/projects/quenya_32bit.tgz](http://www.bitlackeys.org/projects/quenya_32bit.tgz).
    Quenya has many features and capabilities, and one of them is to inject object
    code into an executable. This can be very useful for patching a binary by hijacking
    a given function. Quenya is only a prototype and was never developed to the extent
    that the *Eresi* project was. I am only using it as an example because I am more
    familiar with it; however, I will say that for more reliable results, it may be
    desirable to either use *Eresi* or write your own tooling.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985 "第1章。Linux环境及其工具")中所述，*Linux环境及其工具*，有一个名为*Eresi*（[http://www.eresi-project.org](http://www.eresi-project.org)）的神奇工具，它能够进行可重定位代码注入（又称`ET_REL`注入）。我还设计了一个用于ELF的自定义逆向工程工具，名为**Quenya**。它非常古老，但可以在[http://www.bitlackeys.org/projects/quenya_32bit.tgz](http://www.bitlackeys.org/projects/quenya_32bit.tgz)上找到。Quenya具有许多功能和能力，其中之一就是将目标代码注入到可执行文件中。这对于通过劫持给定函数来修补二进制文件非常有用。Quenya只是一个原型，从未像*Eresi*项目那样得到发展。我之所以使用它作为示例，是因为我对它更熟悉；然而，我会说，为了更可靠的结果，也许最好使用*Eresi*或编写自己的工具。
- en: 'Let us pretend we are an attacker and we want to infect a 32-bit program that
    calls `puts()` to print `Hello World`. Our goal is to hijack `puts()` so that
    it calls `evil_puts()`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假装我们是攻击者，我们想要感染一个调用`puts()`打印`Hello World`的32位程序。我们的目标是劫持`puts()`，使其调用`evil_puts()`：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we compile `evil_puts.c` into `evil_puts.o` and inject it into our program
    called `./hello_world`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`evil_puts.c`编译成`evil_puts.o`并将其注入到名为`./hello_world`的程序中：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This program calls the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序调用以下内容：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now use `Quenya` to inject and relocate our `evil_puts.o` file into `hello_world`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`Quenya`将我们的`evil_puts.o`文件注入和重定位到`hello_world`中：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see, the `write()` function from our `evil_puts.o` object file has
    been relocated and assigned an address at `0x804861e` in the executable file `hello_world`.
    The next command hijack overwrites the global offset table entry for `puts()`
    with the address of `evil_puts()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，来自我们的`evil_puts.o`目标文件的`write()`函数已经被重定位，并在可执行文件`hello_world`中分配了一个地址`0x804861e`。下一个命令劫持并覆盖了`puts()`的全局偏移表条目，将其地址替换为`evil_puts()`的地址：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And Whammi!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就成功了！
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have successfully relocated an object file into an executable and modified
    the executable's control flow so that it executes the code that we injected. If
    we use `readelf -s` on `hello_world`, we can actually now see a symbol for `evil_puts()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将一个目标文件重定位到一个可执行文件中，并修改了可执行文件的控制流，使其执行我们注入的代码。如果我们在`hello_world`上使用`readelf
    -s`，我们现在实际上可以看到一个`evil_puts()`的符号。
- en: 'For your interest, I have included a small snippet of code that contains the
    ELF relocation mechanics in Quenya; it may be a little bit obscure without seeing
    the rest of the code base, but it is also somewhat straightforward if you have
    retained what we learned about relocations:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的兴趣，我已经包含了一个包含Quenya ELF重定位机制的小代码片段；如果没有看到代码库的其余部分，它可能有点晦涩，但如果您记住了我们学到的关于重定位的知识，它也是相当直接的。
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the preceding code, the relocation target that `RelocPtr` points
    to is modified according to the relocation action requested by the relocation
    type (such as `R_386_32`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`RelocPtr`指向的重定位目标将根据重定位类型（如`R_386_32`）请求的重定位操作进行修改。
- en: Although relocatable code binary injection is a good example of the idea behind
    relocations, it is not a perfect example of how a linker actually performs it
    with multiple object files. Nevertheless, it still retains the general idea and
    application of a relocation action. Later on we will talk about shared library
    (`ET_DYN`) injection, which brings us now to the topic of dynamic linking.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可重定位代码二进制注入是重定位背后思想的一个很好的例子，但它并不完美地展示了链接器如何在多个目标文件中实际执行。尽管如此，它仍然保留了重定位操作的一般思想和应用。接下来我们将讨论共享库（`ET_DYN`）注入，这将引出动态链接的话题。
- en: ELF dynamic linking
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF动态链接
- en: In the old days, everything was statically linked. If a program used external
    library functions, the entire library was compiled directly into the executable.
    ELF supports dynamic linking, which is a much more efficient way to go about handling
    shared libraries.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，一切都是静态链接的。如果程序使用外部库函数，整个库将直接编译到可执行文件中。ELF支持动态链接，这是一种更高效的处理共享库的方式。
- en: When a program is loaded into memory, the dynamic linker also loads and binds
    the shared libraries that are needed to that process address space. The topic
    of dynamic linking is rarely understood by people in any depth as it is a relatively
    complex procedure and seems to work like magic under the hood. In this section,
    we will demystify some of its complexities and reveal how it works and also how
    it can be abused by attackers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序加载到内存中时，动态链接器还会将需要的共享库加载到该进程的地址空间并绑定。动态链接的主题很少被人深入理解，因为它是一个相对复杂的过程，在底层似乎像魔术一样工作。在本节中，我们将揭示一些其复杂性并揭示它的工作原理，以及它如何被攻击者滥用。
- en: Shared libraries are compiled as position-independent and can therefore be easily
    relocated into a process address space. A shared library is a dynamic ELF object.
    If you look at `readelf -h lib.so`, you will see that the `e_type` (**ELF file
    type**) is called `ET_DYN`. Dynamic objects are very similar to executables. They
    do not typically have a `PT_INTERP` segment since they are loaded by the program
    interpreter, and therefore will not be invoking a program interpreter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库被编译为位置无关，因此可以很容易地重定位到进程地址空间中。共享库是一个动态ELF对象。如果你查看`readelf -h lib.so`，你会看到`e_type`（**ELF文件类型**）被称为`ET_DYN`。动态对象与可执行文件非常相似。它们通常没有`PT_INTERP`段，因为它们是由程序解释器加载的，因此不会调用程序解释器。
- en: When a shared library is loaded into a process address space, it must have any
    relocations satisfied that reference other shared libraries. The dynamic linker
    must modify the GOT (Global offset table) of the executable (located in the section
    `.got.plt`), which is a table of addresses located in the data segment. It is
    in the data segment because it must be writeable (at least initially; see read-only
    relocations as a security feature). The dynamic linker patches the GOT with resolved
    shared library addresses. We will explain the process of **lazy linking** shortly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个共享库被加载到进程地址空间时，必须满足引用其他共享库的任何重定位。动态链接器必须修改可执行文件的GOT（全局偏移表）（位于`.got.plt`部分），这是一个位于数据段中的地址表。它位于数据段中，因为它必须是可写的（至少最初是这样；请参阅只读重定位作为安全功能）。动态链接器使用已解析的共享库地址修补GOT。我们将很快解释**延迟链接**的过程。
- en: The auxiliary vector
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助向量
- en: 'When a program gets loaded into memory by the `sys_execve()` syscall, the executable
    is mapped in and given a stack (among other things). The stack for that process
    address space is set up in a very specific way to pass information to the dynamic
    linker. This particular setup and arrangement of information is known as the **auxiliary
    vector** or **auxv**. The bottom of the stack (which is its highest memory address
    since the stack grows down on x86 architecture) is loaded with the following information:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序通过`sys_execve()`系统调用加载到内存时，可执行文件被映射并分配一个堆栈（以及其他内容）。该进程地址空间的堆栈被设置为以非常特定的方式传递信息给动态链接器。这种特定的设置和信息排列被称为**辅助向量**或**auxv**。堆栈的底部（因为堆栈在x86架构上向下增长，所以它的最高内存地址）加载了以下信息：
- en: '![The auxiliary vector](img/00003.jpeg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![辅助向量](img/00003.jpeg)'
- en: '*[argc][argv][envp][auxiliary][.ascii data for argv/envp]*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*[argc][argv][envp][auxiliary][.ascii data for argv/envp]*'
- en: The auxiliary vector (or auxv) is a series of ElfN_auxv_t structs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助向量（或auxv）是一系列ElfN_auxv_t结构。
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `a_type` describes the auxv entry type, and the a_val provides its value.
    The following are some of the most important entry types that are needed by the
    dynamic linker:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`a_type`描述了auxv条目类型，`a_val`提供了它的值。以下是动态链接器需要的一些最重要的条目类型：'
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The dynamic linker retrieves information from the stack about the executing
    program. The linker must know where the program headers are, the entry point of
    the program, and so on. I listed only a few of the auxv entry types previously,
    taken from `/usr/include/elf.h`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器从堆栈中检索有关正在执行的程序的信息。链接器必须知道程序头的位置，程序的入口点等。我之前列出了一些auxv条目类型，取自`/usr/include/elf.h`。
- en: The auxiliary vector gets set up by a kernel function called `create_elf_tables()`
    that resides in the Linux source code `/usr/src/linux/fs/binfmt_elf.c`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助向量是由一个名为`create_elf_tables()`的内核函数设置的，该函数位于Linux源代码`/usr/src/linux/fs/binfmt_elf.c`中。
- en: 'In fact, the execution process from the kernel looks something like the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从内核的执行过程看起来像下面这样：
- en: '`sys_execve()` →.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sys_execve()` →。'
- en: Calls `do_execve_common()` →.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`do_execve_common()` →。
- en: Calls `search_binary_handler()` →.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`search_binary_handler()` →。
- en: Calls `load_elf_binary()` →.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`load_elf_binary()` →。
- en: Calls `create_elf_tables()` →.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`create_elf_tables()` →。
- en: 'The following is some of the code from `create_elf_tables()` in `/usr/src/linux/fs/binfmt_elf.c`
    that adds auxv entries:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`/usr/src/linux/fs/binfmt_elf.c`中`create_elf_tables()`的一些代码，用于添加auxv条目：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, the ELF entry point and the address of the program headers,
    among other values, are placed onto the stack with the `NEW_AUX_ENT()` macro in
    the kernel.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，ELF入口点和程序头的地址等数值是使用内核中的`NEW_AUX_ENT()`宏放置到堆栈上的。
- en: Once a program is loaded into memory and the auxiliary vector has been filled
    in, control is passed to the dynamic linker. The dynamic linker resolves symbols
    and relocations for shared libraries that are linked into the process address
    space. By default, an executable is dynamically linked with the GNU C library
    `libc.so`. The `ldd` command will show you the shared library dependencies of
    a given executable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序加载到内存中并且辅助向量已经填充，控制就会传递给动态链接器。动态链接器解析链接到进程地址空间中的共享库的符号和重定位。默认情况下，可执行文件与GNU
    C库`libc.so`动态链接。`ldd`命令将显示给定可执行文件的共享库依赖关系。
- en: Learning about the PLT/GOT
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解PLT/GOT
- en: The PLT (procedure linkage table) and GOT (Global offset table) can be found
    in executable files and shared libraries. We will be focusing specifically on
    the PLT/GOT of an executable program. When a program calls a shared library function
    such as `strcpy()` or `printf()`, which are not resolved until runtime, there
    must exist a mechanism to dynamically link the shared libraries and resolve the
    addresses to the shared functions. When a dynamically linked program is compiled,
    it handles shared library function calls in a specific way, far differently from
    a simple `call` instruction to a local function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: PLT（过程链接表）和GOT（全局偏移表）可以在可执行文件和共享库中找到。我们将专门关注可执行程序的PLT/GOT。当程序调用共享库函数，例如`strcpy()`或`printf()`时，这些函数直到运行时才被解析，必须存在一种机制来动态链接共享库并解析共享函数的地址。当动态链接程序被编译时，它以一种特定的方式处理共享库函数调用，与对本地函数的简单`call`指令完全不同。
- en: 'Let''s take a look at a call to the libc.so function `fgets()` in a 32-bit
    compiled ELF executable. We will use a 32-bit executable in our examples because
    the relationship with the GOT is easier to visualize since IP relative addressing
    is not used, as it is in 64-bit executables:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看32位编译的ELF可执行文件中libc.so函数`fgets()`的调用。我们将在示例中使用32位可执行文件，因为与GOT的关系更容易可视化，因为不使用IP相对寻址，就像在64位可执行文件中一样。
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The address `0x8048360` corresponds to the PLT entry for `fgets()`. Let''s
    take a look at that address in our executable:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 地址`0x8048360`对应于`fgets()`的PLT条目。让我们在可执行文件中查看该地址：
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So the call to `fgets()` leads to 8048360, which is the PLT jump table entry
    for `fgets()`. As we can see, there is an indirect jump to the address stored
    at `0x804a000` in the preceding disassembled code output. This address is a GOT
    (Global offset table) entry that holds the address to the actual `fgets()` function
    in the libc shared library.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对`fgets()`的调用导致8048360，这是`fgets()`的PLT跳转表条目。正如我们所看到的，在上文反汇编代码输出中，有一个间接跳转到存储在`0x804a000`处的地址。这个地址是GOT（全局偏移表）条目，其中存储了libc共享库中实际`fgets()`函数的地址。
- en: However, the first time a function is called, its address has not yet been resolved
    by the dynamic linker, when the default behavior lazy linking is being used. Lazy
    linking implies that the dynamic linker should not resolve every function at program
    loading time. Instead, it will resolve the functions as they are called, which
    is made possible through the `.plt` and `.got.plt` sections (which correspond
    to the Procedure linkage table, and the Global offset table, respectively). This
    behavior can be changed to what is called strict linking with the `LD_BIND_NOW`
    environment variable so that all dynamic linking happens right at program loading
    time. Lazy linking increases performance at load time, which is why it is the
    default behavior, but it also can be unpredictable since a linking error may not
    occur until after the program has been running for some time. I have actually
    only experienced this myself one time over the course of years. It is also worth
    noting that some security features, namely, read-only relocations cannot be applied
    unless strict linking is enabled because the `.plt.got` section (among others)
    is marked read-only; this can only occur after the dynamic linker has finished
    patching it, and thus strict linking must be used.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一次调用函数时，如果使用的是默认行为懒惰链接，那么动态链接器尚未解析其地址。懒惰链接意味着动态链接器不应在程序加载时解析每个函数。相反，它将在调用时解析函数，这是通过`.plt`和`.got.plt`部分（分别对应过程链接表和全局偏移表）实现的。可以通过`LD_BIND_NOW`环境变量将此行为更改为所谓的严格链接，以便所有动态链接都发生在程序加载时。懒惰链接增加了加载时间的性能，这就是为什么它是默认行为，但它也可能是不可预测的，因为链接错误可能要等到程序运行一段时间后才会发生。在多年的经验中，我只遇到过一次这种情况。值得注意的是，一些安全功能，即只读重定位，除非启用了严格链接，否则无法应用，因为`.plt.got`部分（以及其他部分）被标记为只读；这只能在动态链接器完成修补后发生，因此必须使用严格链接。
- en: 'Let''s take a look at the relocation entry for `fgets()`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`fgets()`的重定位条目：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`R_386_JUMP_SLOT` is a relocation type for PLT/GOT entries. On `x86_64`, it
    is called `R_X86_64_JUMP_SLOT`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`R_386_JUMP_SLOT`是PLT/GOT条目的重定位类型。在`x86_64`上，它被称为`R_X86_64_JUMP_SLOT`。'
- en: Notice that the relocation offset is the address 0x804a000, the same address
    that the `fgets()` PLT jumps into. Assuming that `fgets()` is being called for
    the first time, the dynamic linker has to resolve the address of `fgets()` and
    place its value into the GOT entry for `fgets()`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重定位偏移量是地址0x804a000，与`fgets()` PLT跳转到的相同地址。假设`fgets()`是第一次被调用，动态链接器必须解析`fgets()`的地址，并将其值放入`fgets()`的GOT条目中。
- en: 'Let''s take a look at the GOT in our test program:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们测试程序中的GOT：
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The address `0x08048366` is highlighted in the preceding and is found at `0x804a000`
    in the GOT. Remember that little endian reverses the byte order, so it appears
    as `66 83 04 08`. This address is not the address to the `fgets()` function since
    it has not yet been resolved by the linker, but instead points back down into
    the PLT entry for `fgets()`. Let''s look at the PLT entry for `fgets()` again:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 地址`0x08048366`在上文中被突出显示，并且在GOT中的`0x804a000`处找到。请记住，小端序颠倒了字节顺序，因此它显示为`66 83 04
    08`。这个地址不是`fgets()`函数的地址，因为它尚未被链接器解析，而是指向`fgets()`的PLT条目。让我们再次看一下`fgets()`的PLT条目：
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, `jmp *0x804a000` jumps to the contained address there within `0x8048366`,
    which is the `push $0x0` instruction. That push instruction has a purpose, which
    is to push the GOT entry for `fgets()` onto the stack. The GOT entry offset for
    `fgets()` is 0x0, which corresponds to the first GOT entry that is reserved for
    a shared library symbol value, which is actually the fourth GOT entry, GOT[3].
    In other words, the shared library addresses don't get plugged in starting at
    GOT[0] and they begin at GOT[3] (the fourth entry) because the first three are
    reserved for other purposes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`jmp *0x804a000` 跳转到`0x8048366`中包含的地址，这是`push $0x0`指令。该push指令有一个目的，即将`fgets()`的GOT条目推送到堆栈上。`fgets()`的GOT条目偏移为0x0，对应于保留给共享库符号值的第一个GOT条目，实际上是第四个GOT条目，即GOT[3]。换句话说，共享库地址不是从GOT[0]开始插入的，而是从GOT[3]开始（第四个条目），因为前三个条目是为其他目的保留的。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take note of the following GOT offsets:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下GOT偏移：
- en: GOT[0] contains an address that points to the dynamic segment of the executable,
    which is used by the dynamic linker for extracting dynamic linking-related information
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOT[0]包含一个地址，指向可执行文件的动态段，动态链接器用于提取与动态链接相关的信息
- en: GOT[1] contains the address of the `link_map` structure that is used by the
    dynamic linker to resolve symbols
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOT[1]包含了动态链接器用于解析符号的`link_map`结构的地址。
- en: GOT[2] contains the address to the dynamic linkers `_dl_runtime_resolve()` function
    that resolves the actual symbol address for the shared library function
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOT[2]包含动态链接器`_dl_runtime_resolve()`函数的地址，用于解析共享库函数的实际符号地址。
- en: The last instruction in the `fgets()` PLT stub is a jmp 8048350\. This address
    points to the very first PLT entry in every executable, known as PLT-0.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets()` PLT存根中的最后一条指令是jmp 8048350。该地址指向每个可执行文件中的第一个PLT条目，称为PLT-0。'
- en: '**PLT-0** from our executable contains the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**PLT-0** 中包含我们可执行文件的以下代码：'
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first `pushl` instruction pushes the address of the second GOT entry, GOT[1],
    onto the stack, which, as noted earlier, contains the address of the `link_map`
    structure.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`pushl`指令将第二个GOT条目GOT[1]的地址推送到堆栈上，正如前面所述，其中包含`link_map`结构的地址。
- en: The `jmp *0x8049ffc` performs an indirect jmp into the third GOT entry, GOT[2],
    which contains the address to the dynamic linkers `_dl_runtime_resolve()` function,
    therefore transferring control to the dynamic linker and resolving the address
    for `fgets()`. Once `fgets()` has been resolved, all future calls to the PLT entry
    `forfgets()` will result in a jump to the `fgets()` code itself, rather than pointing
    back into the PLT and going through the lazy linking process again.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp *0x8049ffc` 执行对第三个GOT条目GOT[2]的间接跳转，其中包含动态链接器`_dl_runtime_resolve()`函数的地址，因此将控制权转移到动态链接器并解析`fgets()`的地址。一旦`fgets()`被解析，对`forfgets()`的所有未来调用都将导致跳转到`fgets()`代码本身，而不是指向PLT并再次进行延迟链接过程。'
- en: 'The following is a summary of what we have just covered:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚讨论的内容的总结：
- en: Call `fgets@PLT` (to call the `fgets` function).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fgets@PLT`（调用`fgets`函数）。
- en: PLT code does an indirect `jmp` to the address in the GOT.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLT代码执行对GOT中地址的间接`jmp`。
- en: The GOT entry contains the address that points back into PLT at the `push` instruction.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GOT条目包含指向PLT中`push`指令的地址。
- en: The `push $0x0` instruction pushes the offset of the `fgets()` GOT entry onto
    the stack.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`push $0x0`指令将`fgets()`的GOT条目的偏移推送到堆栈上。'
- en: The final `fgets()` PLT instruction is a jmp to the PLT-0 code.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`fgets()` PLT指令是跳转到PLT-0代码。
- en: The first instruction of PLT-0 pushes the address of GOT[1] onto the stack that
    contains an offset into the `link_map` struct for `fgets()`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLT-0的第一条指令将GOT[1]的地址推送到堆栈上，其中包含`fgets()`的`link_map`结构的偏移。
- en: The second instruction of PLT-0 is a jmp to the address in GOT[2] that points
    to the dynamic linker's `_dl_runtime_resolve()`, which then handles the `R_386_JUMP_SLOT`
    relocation by adding the symbol value (memory address) of `fgets()` to its corresponding
    GOT entry in the `.got.plt` section.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLT-0的第二条指令是跳转到GOT[2]中的地址，该地址指向动态链接器的`_dl_runtime_resolve()`，然后通过将`fgets()`的符号值（内存地址）添加到`.got.plt`部分中相应的GOT条目来处理`R_386_JUMP_SLOT`重定位。
- en: The next time `fgets()` is called, the PLT entry will jump directly to the function
    itself rather than having to perform the relocation procedure again.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次调用`fgets()`时，PLT条目将直接跳转到函数本身，而不必再执行重定位过程。
- en: The dynamic segment revisited
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新访问动态段
- en: I earlier referenced the dynamic segment as a section named `.dynamic`. The
    dynamic segment has a section header referencing it, but it also has a program
    header referencing it because it must be found during runtime by the dynamic linker;
    since section headers don't get loaded into memory, there has to be an associated
    program header for it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到动态段被命名为`.dynamic`。动态段有一个引用它的段头，但它也有一个引用它的程序头，因为动态链接器必须在运行时找到它；由于段头不会被加载到内存中，因此必须有一个相关的程序头。
- en: 'The dynamic segment contains an array of structs of type `ElfN_Dyn`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 动态段包含了类型为`ElfN_Dyn`的结构数组：
- en: '[PRE48]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `d_tag` field contains a tag that matches one of the numerous definitions
    that can be found in the ELF(5) man pages. I have listed some of the most important
    ones used by the dynamic linker.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_tag`字段包含一个标签，与ELF(5)手册中可以找到的众多定义之一匹配。我列出了动态链接器使用的一些最重要的定义。'
- en: DT_NEEDED
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DT_NEEDED
- en: This holds the string table offset to the name of a needed shared library.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了所需共享库的名称的字符串表偏移。
- en: DT_SYMTAB
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DT_SYMTAB
- en: This contains the address of the dynamic symbol table also known by its section
    name `.dynsym`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了动态符号表的地址，也被称为`.dynsym`部分。
- en: DT_HASH
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DT_HASH
- en: This holds the address of the symbol hash table, also known by its section name
    `.hash` (or sometimes named `.gnu.hash`).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了符号哈希表的地址，也被称为`.hash`部分（有时也被命名为`.gnu.hash`）。
- en: DT_STRTAB
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DT_STRTAB
- en: This holds the address of the symbol string table, also known by its section
    name `.dynstr`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了符号字符串表的地址，也被称为`.dynstr`部分。
- en: DT_PLTGOT
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DT_PLTGOT
- en: This holds the address of the global offset table.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这保存了全局偏移表的地址。
- en: Note
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding dynamic tags demonstrate how the location of certain sections
    can be found through the dynamic segment that can aid in the forensics reconstruction
    task of rebuilding a section header table. If the section header table has been
    stripped, a clever individual can rebuild parts of it by getting information from
    the dynamic segment (that is, the .dynstr, .dynsym, and .hash, among others).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的动态标签演示了如何通过动态段找到某些部分的位置，这些部分可以帮助在取证重建任务中重建段头表。如果段头表已被剥离，一个聪明的人可以通过从动态段（即.dynstr、.dynsym和.hash等）获取信息来重建部分内容。
- en: Other segments such as text and data can yield information that you need as
    well (such as for the `.text` and `.data` sections).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 其他段，如文本和数据，也可以提供所需的信息（例如`.text`和`.data`部分）。
- en: The `d_val` member of `ElfN_Dyn` holds an integer value that has various interpretations
    such as being the size of a relocation entry to give one instance.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElfN_Dyn`的`d_val`成员保存一个整数值，有各种解释，比如作为重定位条目的大小。'
- en: The `d_ptr` member holds a virtual memory address that can point to various
    locations needed by the linker; a good example would be the address to the symbol
    table for the `d_tag` `DT_SYMTAB`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_ptr`成员保存一个虚拟内存地址，可以指向链接器需要的各种位置；一个很好的例子是`d_tag` `DT_SYMTAB`的符号表地址。'
- en: The dynamic linker utilizes the `ElfN_Dyn` `d_tags` to locate the different
    parts of the dynamic segment that contain a reference to a part of the executable
    through the `d_tag` such as `DT_SYMTAB`, which has a `d_ptr` to give the virtual
    address to the symbol table.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器利用`ElfN_Dyn`的`d_tags`来定位动态段的不同部分，这些部分通过`d_tag`（例如`DT_SYMTAB`）指向可执行文件的某个部分，其中`d_ptr`给出了符号表的虚拟地址。
- en: When the dynamic linker is mapped into memory, it first handles any of its own
    relocations if necessary; remember that the linker is a shared library itself.
    It then looks at the executable program's dynamic segment and searches for the
    `DT_NEEDED` tags that contain pointers to the strings or pathnames of the necessary
    shared libraries. When it maps a needed shared library into the memory, it accesses
    the library's dynamic segment (yes, they too have dynamic segments) and adds the
    library's symbol table to a chain of symbol tables that exists to hold the symbol
    tables for each mapped library.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当动态链接器映射到内存中时，如果有必要，它首先处理自己的任何重定位；请记住，链接器本身也是一个共享库。然后，它查看可执行程序的动态段，并搜索包含指向所需共享库的字符串或路径名的`DT_NEEDED`标签。当它将所需的共享库映射到内存时，它访问库的动态段（是的，它们也有动态段），并将库的符号表添加到存在的用于保存每个映射库的符号表的链中。
- en: 'The linker creates a struct `link_map` entry for each shared library and stores
    it in a linked list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器为每个共享库创建一个`link_map`结构条目，并将其存储在一个链表中：
- en: '[PRE49]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once the linker has finished building its list of dependencies, it handles the
    relocations on each library, similar to the relocations we discussed earlier in
    this chapter, as well as fixing up the GOT of each shared library. **Lazy linking**
    still applies to the PLT/GOT of shared libraries as well, so GOT relocations (of
    type `R_386_JMP_SLOT`) won't happen until the point when a function has actually
    been called.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链接器完成了构建其依赖项列表，它会处理每个库的重定位，类似于本章前面讨论的重定位，以及修复每个共享库的GOT。**懒惰链接**仍然适用于共享库的PLT/GOT，因此GOT重定位（类型为`R_386_JMP_SLOT`）直到实际调用函数时才会发生。
- en: For more detailed information on ELF and dynamic linking, read the ELF specification
    online or take a look at some of the interesting glibc source code available.
    Hopefully, dynamic linking has become less of a mystery and more of an intrigue
    at this point. In [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics* we will be
    covering PLT/GOT poisoning techniques to redirect shared library function calls.
    A very fun technique is to subvert dynamic linking.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ELF和动态链接的更详细信息，请阅读在线的ELF规范，或查看一些有趣的glibc源代码。希望到这一点，动态链接已经不再是一个神秘，而是一个引人入胜的东西。在[第7章](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "第7章。进程内存取证")*进程内存取证*中，我们将介绍PLT/GOT中毒技术，以重定向共享库函数调用。一个非常有趣的技术是颠覆动态链接。
- en: Coding an ELF Parser
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ELF解析器
- en: 'To help summarize some of what we have learned, I have included some simple
    code that will print the program headers and section names of a 32-bit ELF executable.
    Many more examples of ELF-related code (and much more interesting ones) will be
    shown throughout this book:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助总结我们所学到的一些知识，我包含了一些简单的代码，将打印出一个32位ELF可执行文件的程序头和段名称。本书中将展示更多与ELF相关的代码示例（以及更有趣的示例）：
- en: '[PRE50]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt Publishing图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have explored ELF, I urge the reader to continue to explore the
    format. You will encounter a number of projects throughout this book that will
    hopefully inspire you to do so. It has taken years of passion and exploration
    to learn what I have. I am grateful to be able to share what I have learned and
    present it in a way that will help the reader learn this difficult material in
    a fun and creative way.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了ELF，我敦促读者继续探索这种格式。在本书中，您将遇到许多项目，希望能激发您的兴趣。学习这些知识需要多年的热情和探索，我很感激能够分享我所学到的知识，并以一种有趣和创造性的方式呈现给读者，帮助他们学习这些困难的材料。
