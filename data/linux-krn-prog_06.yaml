- en: Writing Your First Kernel Module - LKMs Part 2
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写您的第一个内核模块-LKMs第2部分
- en: This chapter is the second half of our coverage regarding the **Loadable Kernel
    Module** (**LKM**) framework and how to write kernel modules using it.To get the
    most out of it, I expect you to complete the previous chapter and try out the
    code and questions there before tackling this one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于**可加载内核模块**（**LKM**）框架及如何使用它编写内核模块的覆盖的后半部分。为了充分利用它，我希望您在阅读本章之前完成上一章，并尝试那里的代码和问题。
- en: In this chapter, we continue from the point where we left off in the previous
    one. Here, we cover making use of a 'better' Makefile for LKMs, cross-compiling
    a kernel module for the ARM platform (as a typical example), what module stacking
    is and how to do it, and how to set up and use module parameters. Along the way,
    among several other things, you will learn about the kernel API/ABI stability
    (or rather, the lack thereof!), the key differences between writing userspace
    and kernel code, auto-loading a kernel module at system boot, and security concerns
    and how they can be addressed. We end with information on the kernel documentation
    (including coding style) and contributing to mainline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续上一章的内容。在这里，我们将介绍如何使用“更好”的Makefile来编写LKMs，为ARM平台交叉编译内核模块（作为典型示例），模块堆叠是什么以及如何执行，以及如何设置和使用模块参数。在此过程中，除其他事项外，您还将了解内核API/ABI的稳定性（或者说，缺乏稳定性！），编写用户空间和内核代码之间的关键区别，系统启动时自动加载内核模块以及安全性问题以及如何解决它们。最后，我们将介绍内核文档（包括编码风格）和对主线的贡献。
- en: 'In brief, we will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: A "better" Makefile template for your kernel modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“更好”的内核模块Makefile模板
- en: Cross-compiling a kernel module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译内核模块
- en: Gathering minimal system information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集最小系统信息
- en: Licensing kernel modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可内核模块
- en: Emulating "library-like" features for kernel modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为内核模块模拟“类库”功能
- en: Passing parameters to a kernel module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向内核模块传递参数
- en: Floating point not allowed in the kernel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核中不允许浮点数
- en: Auto-loading modules on system boot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统启动时自动加载模块
- en: Kernel modules and security - an overview
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块和安全性-概述
- en: Coding style guidelines for kernel developers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核开发人员的编码风格指南
- en: Contributing to the mainline kernel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为主线内核做出贡献
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements – the software packages required – for this chapter
    are identical to what was shown in the *Technical requirements* section in [Chapter
    4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml), *Writing Your First Kernel Module
    – LKMs Part 1*; please refer to it. As always, you can find the source code for
    this chapter in this book''s GitHub repository. Clone it with the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求——所需的软件包——与[第4章](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml)中的*技术要求*部分所示的内容相同，请参考。您可以在本书的GitHub存储库中找到本章的源代码。使用以下命令进行克隆：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code displayed in the book is often just a relevant snippet. Follow along
    with the full source code from the repository. For this chapter (and those that
    follow), more on the technical requirements is found in the following section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 书中显示的代码通常只是相关片段。请跟随存储库中的完整源代码。对于本章（以及随后的章节），有关技术要求的更多信息请参阅以下部分。
- en: A "better" Makefile template for your kernel modules
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个“更好”的内核模块Makefile模板
- en: The preceding chapter introduced you to the Makefile used to generate the kernel
    module from source, to install and clean it up. However, as we briefly mentioned
    there, I will now introduce what is, in my opinion, a superior, a "better" Makefile,
    and explain how it's better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了用于从源代码生成内核模块、安装和清理的Makefile。然而，正如我们在那里简要提到的，我现在将介绍我认为更好的“更好”的Makefile，并解释它为什么更好。
- en: Ultimately, we all have to write better and more secure code – both user and
    kernel-space. The good news is, there are several tools that help improve your
    code's robustness and security posture, static and dynamic analyzers being among
    them (as several have already been mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),* Kernel
    Workspace Setup,* I won't repeat them here).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们都必须编写更好、更安全的代码——无论是用户空间还是内核空间。好消息是，有几种工具可以帮助改进代码的健壮性和安全性，其中包括静态和动态分析器（在[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)中已经提到了几种，*内核工作空间设置*，我就不在这里重复了）。
- en: 'I have devised a simple yet useful Makefile "template" of sorts for kernel
    modules that includes several targets that help you run these tools. These targets
    allow you to perform valuable checks and analysis very easily; *stuff you might
    otherwise forget or ignore or put off for ever!* These targets include the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计了一个简单但有用的内核模块Makefile“模板”，其中包括几个目标，可帮助您运行这些工具。这些目标使您可以非常轻松地执行有价值的检查和分析；*可能是您会忘记、忽视或永远推迟的事情！*
    这些目标包括以下内容：
- en: The "usual" ones – the `build`, `install`, and `clean` targets.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通常”的目标——`build`、`install`和`clean`。
- en: Kernel coding style generation and checking (via `indent(1)` and the kernel's `checkpatch.pl` script,
    respectively).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核编码风格生成和检查（通过`indent(1)`和内核的`checkpatch.pl`脚本，分别）。
- en: Kernel static analysis targets (`sparse`, `gcc`, and `flawfinder`), with a mention
    of **Coccinelle**.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核静态分析目标（`sparse`、`gcc`和`flawfinder`），并提到**Coccinelle**。
- en: A couple of "dummy" kernel dynamic analysis targets (`KASAN` and `LOCKDEP /
    CONFIG_PROVE_LOCKING`), encouraging you to configure, build, and use a "debug"
    kernel for all your test cases.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对“虚拟”的内核动态分析目标（`KASAN`和`LOCKDEP / CONFIG_PROVE_LOCKING`），鼓励您为所有测试用例配置、构建和使用“调试”内核。
- en: A simple `tarxz-pkg` target that tars and compresses the source files into the
    preceding directory. This enables you to transfer the compressed `tar-xz` file
    to any other Linux system, and extract and build the LKM there.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的`tarxz-pkg`目标，将源文件打包并压缩到前一个目录。这使您可以将压缩的`tar-xz`文件传输到任何其他Linux系统，并在那里提取和构建LKM。
- en: A "dummy" dynamic analysis target, pointing out how you should invest time in
    configuring and building a "debug" kernel and using it to catch bugs! (More on
    this follows shortly.)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“虚拟”的动态分析目标，指出您应该投入时间来配置和构建一个“调试”内核，并使用它来捕捉错误！（稍后将更多内容）
- en: 'You can find the code (along with a `README` file as well) in the `ch5/lkm_template`
    directory. To help you understand its use and power and to help you get started,
    the following figure simply shows a screenshot of the output the code produces
    when run with its `help` target:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch5/lkm_template`目录中找到代码（以及`README`文件）。为了帮助您理解其用途和功能，并帮助您入门，以下图简单地显示了当运行其`help`目标时代码产生的输出的屏幕截图：
- en: '![](img/e357b706-c9dd-4dee-8bad-ac4ef8eb037a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e357b706-c9dd-4dee-8bad-ac4ef8eb037a.png)'
- en: Figure 5.1 – The output of the helptarget from our "better" Makefile
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 来自我们“更好”的Makefile的helptarget的输出
- en: In *Figure 5.1*, we first do `make`, followed by pressing the *Tab* key twice,
    thus having it display all available targets. Do study this carefully and use
    it! For example, running `make sa` will cause it to run all its **static analysis**
    (`sa`) targets on your code!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.1*中，我们首先执行`make`，然后按两次*Tab*键，这样它就会显示所有可用的目标。请仔细研究并使用它！例如，运行`make sa`将导致它在您的代码上运行所有**静态分析**（`sa`）目标！
- en: It's also important to note that using this Makefile will require you to have
    installed a few packages/ apps on the system; these include (for a base Ubuntu
    system) `indent(1)`, `linux-headers-$(uname -r)`, `sparse(1)`, `flawfinder(1)`,
    `cppcheck(1)`, and `tar(1)`. ([Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, already specified that these should be installed.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，使用这个Makefile将需要您在系统上安装一些软件包/应用程序；这些包括（对于基本的Ubuntu系统）`indent(1)`，`linux-headers-$(uname
    -r)`，`sparse(1)`，`flawfinder(1)`，`cppcheck(1)`和`tar(1)`。（[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核工作区设置*，已经指出这些应该被安装）。
- en: Also, note that the so-called **dynamic analysis** (`da`) targets mentioned in
    the Makefile are merely dummy targets that don't do anything other than print
    a message. They are there *to **remind you *to thoroughly test your code by running
    it on an appropriately configured "debug" kernel!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，Makefile中所谓的**动态分析**（`da`）目标仅仅是不做任何事情，只是打印一条消息的虚拟目标。它们只是*提醒您*通过在适当配置的“调试”内核上运行代码来彻底测试您的代码！
- en: Speaking of a 'debug' kernel, the next section shows you how to configure one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 说到“调试”内核，下一节将向您展示如何配置一个。
- en: Configuring a "debug" kernel
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置“调试”内核
- en: (For details on configuring and building the kernel, look back to [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: （有关配置和构建内核的详细信息，请参阅[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)，*从源代码构建5.x
    Linux内核-第1部分*，和[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x Linux内核-第2部分*）。
- en: 'Running your code on a *debug kernel* can help you uncover hard-to-spot bugs
    and issues. I highly recommend doing so, typically during development and testing! Here,
    I minimally expect you to configure your custom 5.4 kernel to have the following
    kernel debug config options turned on (within the `make menuconfig` UI, you will
    find most of them under the `Kernel Hacking` sub-menu; the following list is with
    respect to Linux 5.4.0):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*调试内核*上运行代码可以帮助您发现难以发现的错误和问题。我强烈建议在开发和测试期间这样做！在这里，我至少希望您配置您的自定义5.4内核，使以下内核调试配置选项打开（在`make
    menuconfig`界面中，您会发现大多数选项在`Kernel Hacking`子菜单下；以下列表是针对Linux 5.4.0的）：
- en: '`CONFIG_DEBUG_INFO`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_INFO`'
- en: '`CONFIG_DEBUG_FS` (the `debugfs` pseudo filesystem)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_FS`（`debugfs`伪文件系统）'
- en: '`CONFIG_MAGIC_SYSRQ` (the Magic SysRq hotkeys feature)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_MAGIC_SYSRQ`（Magic SysRq热键功能）'
- en: '`CONFIG_DEBUG_KERNEL`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_KERNEL`'
- en: '`CONFIG_DEBUG_MISC`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_MISC`'
- en: 'Memory debugging:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存调试：
- en: '`CONFIG_SLUB_DEBUG`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_SLUB_DEBUG`。'
- en: '`CONFIG_DEBUG_MEMORY_INIT`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_MEMORY_INIT`。'
- en: '`CONFIG_KASAN`: this is the **Kernel Address Sanitizer** port; however, as
    of the time of writing, it only works on 64-bit systems.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KASAN`：这是**内核地址消毒剂**端口；但是，截至撰写本文时，它仅适用于64位系统。'
- en: '`CONFIG_DEBUG_SHIRQ`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_SHIRQ`'
- en: '`CONFIG_SCHED_STACK_END_CHECK`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_SCHED_STACK_END_CHECK`'
- en: 'Lock debugging:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁调试：
- en: '`CONFIG_PROVE_LOCKING`: the very powerful `lockdep` feature to catch locking
    bugs! This turns on several other lock debug configs as well, explained in [Chapter
    13](4cdb6ffc-0afc-4031-a20e-1f1a0170a163.xhtml), *Kernel Synchronization - Part
    2*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PROVE_LOCKING`：非常强大的`lockdep`功能来捕获锁定错误！这将打开其他几个锁调试配置，详细说明在[第13章](4cdb6ffc-0afc-4031-a20e-1f1a0170a163.xhtml)，*内核同步-第2部分*。'
- en: '`CONFIG_LOCK_STAT`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_LOCK_STAT`'
- en: '`CONFIG_DEBUG_ATOMIC_SLEEP`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_ATOMIC_SLEEP`'
- en: '`CONFIG_STACKTRACE`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_STACKTRACE`'
- en: '`CONFIG_DEBUG_BUGVERBOSE`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_BUGVERBOSE`'
- en: '`CONFIG_FTRACE` (`ftrace`: within its sub-menu, turn on at least a couple of
    "tracers")'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_FTRACE`（`ftrace`：在其子菜单中，至少打开一些“跟踪器”）'
- en: '`CONFIG_BUG_ON_DATA_CORRUPTION`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_BUG_ON_DATA_CORRUPTION`'
- en: '`CONFIG_KGDB` (kernel GDB; optional)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB`（内核GDB；可选）'
- en: '`CONFIG_UBSAN`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_UBSAN`'
- en: '`CONFIG_EARLY_PRINTK`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_EARLY_PRINTK`'
- en: '`CONFIG_DEBUG_BOOT_PARAMS`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_BOOT_PARAMS`'
- en: '`CONFIG_UNWINDER_FRAME_POINTER` (selects `FRAME_POINTER` and `CONFIG_STACK_VALIDATION`)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_UNWINDER_FRAME_POINTER`（选择`FRAME_POINTER`和`CONFIG_STACK_VALIDATION`）'
- en: 'A couple of things to note:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几件事：
- en: a) Don't worry too much right now if you don't get what all the previously mentioned
    kernel debug config options do; by the time you're done with this book, most of
    them will be clear.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: a) 如果您现在不明白先前提到的所有内核调试配置选项的作用，也不要太担心；在您完成本书时，大多数选项都会变得清晰起来。
- en: b) Turning on some `Ftrace` tracers (or plugins), such as `CONFIG_IRQSOFF_TRACER`,
    would be useful as we actually make use of it in our *Linux Kernel Programming
    (Part 2)* book in the *Handling Hardware Interrupts* chapter; (note that though
    Ftrace itself may be enabled by default, all its tracers aren't).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: b) 打开一些`Ftrace`跟踪器（或插件），例如`CONFIG_IRQSOFF_TRACER`，这在我们的*Linux内核编程（第2部分）*书中的*处理硬件中断*章节中实际上会有用；（请注意，尽管Ftrace本身可能默认启用，但并非所有跟踪器都是默认启用的）。
- en: 'Note that turning on these config options *does* entail a performance hit,
    but that''s okay. We''re running a "debug" kernel of this sort for the express
    purpose of *catching errors and bugs *(especially the hard-to-uncover kind!).
    It can indeed be a life-saver! On your project, *your workflow should involve
    your code being tested and run on both of the following*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打开这些配置选项*确实*会带来性能损失，但没关系。我们正在运行这种“调试”内核，目的是*捕捉错误和漏洞*（尤其是难以发现的种类！）。它确实可以拯救生命！在你的项目中，*你的工作流程应该涉及你的代码在以下两者上进行测试和运行*：
- en: The *debug* kernel system, where all required kernel debug config options are
    turned on (as previously shown minimally)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*内核系统，其中所有必需的内核调试配置选项都已打开（如先前所示的最小配置）'
- en: The *production* kernel system (where all or most of the preceding kernel debug
    options will be turned off)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产*内核系统（在其中所有或大部分先前的内核调试选项将被关闭）'
- en: Needless to say, we will be using the preceding Makefile style in all the subsequent
    LKM code in this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，我们将在本书中所有后续的LKM代码中使用先前的Makefile风格。
- en: Alright, now that you're all set, let's dive into an interesting and practical
    scenario – compiling your kernel module(s) for another target (typically ARM).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你已经准备好了，让我们来探讨一个有趣且实际的场景-为另一个目标（通常是ARM）编译你的内核模块。
- en: Cross-compiling a kernel module
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译内核模块
- en: In [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x
    Linux Kernel from Source - Part 2*, in the *Kernel build for the Raspberry Pi*
    section,we showed how you can cross-compile the Linux kernel for a "foreign" target
    architecture (such as ARM, PowerPC, MIPS, and so on). Essentially, the same can
    be done for a kernel module as well; you can easily cross-compile a kernel module
    by setting up the "special" `ARCH` and `CROSS_COMPILE` environment variables appropriately.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中，*从源代码构建5.x Linux内核-第2部分*，在*为树莓派构建内核*部分，我们展示了如何为“外部”目标架构（如ARM、PowerPC、MIPS等）交叉编译Linux内核。基本上，对于内核模块也可以做同样的事情；通过适当设置“特殊”的`ARCH`和`CROSS_COMPILE`环境变量，可以轻松地交叉编译内核模块。
- en: For example, let's imagine we are working on an embedded Linux product; the
    target device on which our code will run has an AArch32 (ARM-32) CPU. Why not
    take an actual example. Let's cross-compile our *Hello, world* kernel module for
    the Raspberry Pi 3 **Single-Board Computer** (**SBC**)!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在开发一个嵌入式Linux产品；我们的代码将在一个具有AArch32（ARM-32）CPU的目标设备上运行。为什么不举一个实际的例子。让我们为树莓派3
    *单板计算机*（**SBC**）交叉编译我们的*Hello, world*内核模块！
- en: This is interesting. You will find that although it appears simple and straightforward,
    we will end up taking four iterations before we succeed. Why? Read on to find
    out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。你会发现，尽管看起来简单直接，但我们最终会进行四次迭代才成功。为什么？继续阅读以了解详情。
- en: Setting up the system for cross-compilation
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为交叉编译设置系统
- en: 'The prerequisites to cross-compile a kernel module are quite clear:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译内核模块的先决条件非常明确：
- en: 'We need the *kernel source tree for the target system* installed as part of
    the workspace on our host system, typically an x86_64 desktop (for our example,
    using the Raspberry Pi as a target, please refer to the official Raspberry Pi
    documentation here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为目标系统安装*内核源树*，作为主机系统工作空间的一部分，通常是x86_64台式机（对于我们的示例，使用树莓派作为目标，请参考官方树莓派文档：[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)）。
- en: We now need a cross toolchain. Typically, the host system is an x86_64 and here,
    as the target is an ARM-32, we will need an *x86_64-to-ARM32 cross toolchain*.
    Again, as is clearly mentioned in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building
    the 5.x Linux Kernel from Source - Part 2*, *Kernel Build for the Raspberry Pi*, you
    must download and install the Raspberry Pi-specific x86_64-to-ARM toolchain as
    part of the host system workspace (refer to [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*, to learn how to install
    the toolchain).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们需要一个交叉工具链。通常，主机系统是x86_64，而目标是ARM-32，因此我们需要一个*x86_64到ARM32的交叉工具链*。同样，正如在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中明确提到的，*从源代码构建5.x
    Linux内核-第2部分*，*为树莓派构建内核*，你必须下载并安装Raspberry Pi特定的x86_64到ARM工具链作为主机系统工作空间的一部分（请参考[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x
    Linux内核-第2部分*，了解如何安装工具链）。
- en: 'Okay, from this point on, I will assume that you have an x86_64-to-ARM cross
    toolchain installed. I will also assume the *toolchain prefix* is  `arm-linux-gnueabihf-`; we
    can quickly check that the toolchain is installed and its binaries added to the
    path by trying to invoke the `gcc` cross-compiler:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，从这一点开始，我将假设你已经安装了x86_64到ARM交叉工具链。我还将假设*工具链前缀*是`arm-linux-gnueabihf-`；我们可以通过尝试调用`gcc`交叉编译器来快速检查工具链是否已安装并将其二进制文件添加到路径中：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It works – it's just that we have not passed any C program as a parameter to
    compile, hence it complains.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作-只是我们没有传递任何C程序作为编译参数，因此它会报错。
- en: You can certainly look up the compiler version as well with the `arm-linux-gnueabihf-gcc
    --version` command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`arm-linux-gnueabihf-gcc --version`命令查看编译器版本。
- en: Attempt 1 – setting the "special" environment variables
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试1-设置“特殊”的环境变量
- en: 'Actually, cross-compiling the kernel module is very easy (or so we think!).
    Just ensure that you set the "special" `ARCH` and `CROSS_COMPILE` environment
    variables appropriately. Follow along with the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，交叉编译内核模块非常容易（或者我们认为是这样！）。只需确保适当设置“特殊”的`ARCH`和`CROSS_COMPILE`环境变量。按照以下步骤进行：
- en: 'Let''s re-build our very first *Hello, world* kernel module for the Raspberry
    Pi target. Here''s how to build it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新为树莓派目标构建我们的第一个*Hello, world*内核模块。以下是构建方法：
- en: To do so without corrupting the original code, we make a new folder called `cross` with
    a copy of the (`helloworld_lkm`) code from [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml), *Writing
    your First Kernel Module - LKMs Part 1*, to begin with.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不破坏原始代码，我们创建一个名为`cross`的新文件夹，其中包含从[第4章](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml)复制的（helloworld_lkm）代码，*编写你的第一个内核模块
    - LKMs第1部分*。
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `<dest-dir>` is the root of the book's GitHub source tree.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<dest-dir>`是书的GitHub源树的根目录。
- en: 'Now, run the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But it doesn''t work (or it may work; please see the following info box) straight
    off the bat. We get compile failures, as seen here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并不会立即起作用（或者可能会起作用；请参阅以下信息框）。我们会得到编译失败，如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Why did it fail?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么失败了？
- en: Assuming all tools are set up as per the technical requirements discussed earlier,
    the cross-compile should work. This is because the `Makefile` provided in the
    book's repository is a proper working one, the Raspberry Pi kernel has been correctly
    configured and built, the device is booted off this kernel, and the kernel module
    is compiled against it. The purpose here, in this book, is to explain the details;
    thus, we begin with no assumptions, and guide you through the process of correctly
    performing the cross-compilation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有工具都按照之前讨论的技术要求设置好，交叉编译应该可以工作。这是因为书中提供的`Makefile`是一个正确工作的，树莓派内核已经正确配置和构建，设备已经引导到这个内核，并且内核模块已经针对它进行了编译。在这本书中，这里的目的是解释细节；因此，我们从没有假设开始，并引导您正确执行交叉编译的过程。
- en: 'The clue as to why the preceding cross-compilation attempt failed lies in the
    fact that it is attempting to use – *build against* – the kernel source of the
    current *host system* and not the target''s kernel source tree. So, *we need to
    modify the* *Makefile to point it to the correct kernel source tree for the target*.
    It''s really quite easy to do so. In the following code, we see the typical way
    that the (corrected) Makefile code is written:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的交叉编译尝试失败的线索在于，它试图使用 - *构建对* - 当前*主机系统*的内核源，而不是目标的内核源树。因此，*我们需要修改* *Makefile*
    *以指向目标的正确内核源树*。这样做真的很容易。在下面的代码中，我们看到了（已更正的）Makefile代码的典型写法：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Look carefully at the (new and "better," as explained in the preceding section) Makefile and
    you will see how it works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看（在前一节中解释的新的和“更好”的）Makefile，您将看到它是如何工作的：
- en: Most importantly, we conditionally set the `KDIR` variable to point to the correct
    kernel source tree, depending on the value of the `ARCH` environment variable (of
    course, I've used some pathname to kernel source trees for  the ARM[64] and PowerPC
    as examples; do substitute the pathname with the actual path to your kernel source
    trees)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，我们有条件地设置`KDIR`变量，根据`ARCH`环境变量的值指向正确的内核源树（当然，我已经用一些内核源树的路径名作为ARM[64]和PowerPC的示例；请用实际的内核源树路径替换路径名）
- en: As usual, we set `obj-m += <module-name>.o`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像往常一样，我们设置`obj-m += <module-name>.o`。
- en: We also set `CFLAGS_EXTRA` to add the `DEBUG` symbol (so that the `DEBUG` symbol is
    defined in our LKM and even the `pr_debug()/pr_devel()` macros work).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还设置`CFLAGS_EXTRA`以添加`DEBUG`符号（这样`DEBUG`符号就在我们的LKM中定义了，甚至`pr_debug()/pr_devel()`宏也可以工作）。
- en: The `@echo '<...>'` line is equivalent to the shell's `echo` command; it just
    emits some useful information while building (the `@` prefix hides the echo statement
    itself from displaying).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@echo ''<...>''`行等同于shell的`echo`命令；它只是在构建时发出一些有用的信息（`@`前缀隐藏了echo语句本身的显示）。'
- en: 'Finally, we have the "usual" Makefile targets: `all`, `install`, and `clean` –
    these are the same as earlier *except for* this important change: **we make it
    change directory** (via the `-C` switch) to the value of `KDIR`!'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有“通常”的Makefile目标：`all`，`install`和`clean` - 这些与之前相同，*除了*这个重要的变化：**我们让它改变目录**（通过`-C`开关）到`KDIR`的值！
- en: Though not shown in the preceding code, this "better" Makefile has several additional
    useful targets. You should definitely take the time to explore and use them (as
    explained in the preceding section; to start, simply type `make help`, study the
    output and try things out).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在上述代码中没有显示，但这个“更好”的Makefile有几个额外有用的目标。您应该花时间去探索和使用它们（如前一节所述；首先，只需输入`make help`，研究输出并尝试一些东西）。
- en: Having done all this, let's retry the cross-compile with this version and see
    how it goes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，让我们使用这个版本重试交叉编译并看看结果如何。
- en: Attempt 2 – pointing the Makefile to the correct kernel source tree for the
    target
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试2 - 将Makefile指向目标的正确内核源树
- en: 'So now, with the *enhanced* Makefile described in the previous section, it
    *should* work. In our new directory where we will try this out – `cross` (as we''re
    cross-compiling, not that we''re angry!) – follow along with these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了前一节中描述的*增强*Makefile，它*应该*可以工作。在我们将尝试这个的新目录中 - `cross`（因为我们是交叉编译，不是因为我们生气！）
    - 请按照以下步骤操作：
- en: 'Attempt the build (for a second time) with the `make` command appropriate for
    cross-compilation:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适用于交叉编译的`make`命令尝试构建（第二次）。
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The actual reason it failed is that the Raspberry Pi kernel that we're compiling
    our kernel module against is still in a "virgin" state. It does not even have
    the `.config` file present (among other required headers, as the preceding output
    informs us) in its root directory, which it requires to (at least) be configured.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际失败的原因是，我们正在编译内核模块的树莓派内核仍处于“原始”状态。它甚至没有`.config`文件（以及其他所需的头文件，如前面的输出所告知的）存在于其根目录中，它需要（至少）被配置。
- en: 'To fix this, switch to the root of your Raspberry Pi kernel source tree and
    follow these steps:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，请切换到您的树莓派内核源树的根目录，并按照以下步骤操作：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that these steps are really quite equivalent to performing a partial
    build of the Raspberry Pi kernel! Indeed, if you have already built (cross-compiled)
    this kernel as explained earlier in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building
    the 5.x Linux Kernel from Source - Part 2*, then the kernel module cross-compilation
    should just work without the intervening steps seen here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些步骤实际上与执行树莓派内核的部分构建非常相似！实际上，如果您已经按照[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中所述的方式构建（交叉编译）了内核，*从源代码构建5.x
    Linux内核 - 第2部分*，那么内核模块的交叉编译应该可以在这里看到的中间步骤无需工作。
- en: Attempt 3 – cross-compiling our kernel module
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试3 - 交叉编译我们的内核模块
- en: 'Now that we have a configured Raspberry Pi kernel source tree (on the host
    system) and the enhanced Makefile (see the *Attempt 2 – pointing the Makefile
    to the correct kernel source tree for the target* section), it *should* work.
    Let''s retry:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在主机系统上有一个配置好的树莓派内核源树和增强的Makefile（参见*尝试2 - 将Makefile指向目标的正确内核源树*部分），它*应该*可以工作。让我们重试一下：
- en: 'We (again) attempt to build (cross-compile) the kernel. Issue the `make` command,
    passing along the `ARCH` and `CROSS_COMPILE` environment variables as usual:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们（再次）尝试构建（交叉编译）内核。像往常一样，发出`make`命令，同时传递`ARCH`和`CROSS_COMPILE`环境变量：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The build is successful! The `helloworld_lkm.ko` kernel module has indeed been
    cross-compiled for the ARM architecture (using the Raspberry Pi cross toolchain
    and kernel source tree).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功！`helloworld_lkm.ko`内核模块确实已经针对ARM架构进行了交叉编译（使用树莓派交叉工具链和内核源树）。
- en: We can ignore the preceding warning regarding the `Module.symvers` file for
    now. It isn't present as (here) the entire Raspberry Pi kernel hasn't been built.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以忽略关于`Module.symvers`文件的前面警告。因为（在这里）整个树莓派内核尚未构建。
- en: 'Also, FYI, on recent hosts running GCC 9.x or later and kernel versions 4.9
    or later, there are some compiler attribute warnings emitted. When I tried cross-compiling
    this kernel module using `arm-linux-gnueabihf-gcc` version 9.3.0 and the Raspberry
    Pi kernel version 4.14.114, warnings such as this were emitted:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得一提的是，在运行GCC 9.x或更高版本和内核版本为4.9或更高版本的最近主机上，会发出一些编译器属性警告。当我尝试使用`arm-linux-gnueabihf-gcc`版本9.3.0和树莓派内核版本4.14.114交叉编译这个内核模块时，会发出诸如此类的警告：
- en: '`./include/linux/module.h:131:6: warning: ‘init_module’ specifies less restrictive
    attribute than its target ‘helloworld_lkm_init’: ‘cold’ [-Wmissing-attributes]`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: './include/linux/module.h:131:6: 警告：''init_module''指定的属性比其目标''helloworld_lkm_init''更少限制：''cold''
    [-Wmissing-attributes]'
- en: Miguel Ojeda points this out ([https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/](https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/))
    and has even generated a patch to handle this issue ([https://github.com/ojeda/linux/commits/compiler-attributes-backport](https://github.com/ojeda/linux/commits/compiler-attributes-backport)).
    As of the time of writing, the patch is applied in the kernel mainline and in *recent *Raspberry
    Pi kernels (so, the `rpi-5.4.y` branch works fine but earlier ones such as the
    `rpi-4.9.y` branch don't seem to have it)! Hence the compiler warnings... effectively,
    if you do see these warnings, update the Raspberry Pi branch to `rpi-5.4.y` or
    later (or, for now, just ignore them).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Miguel Ojeda指出了这一点（[https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/](https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/)），甚至生成了一个处理此问题的补丁（[https://github.com/ojeda/linux/commits/compiler-attributes-backport](https://github.com/ojeda/linux/commits/compiler-attributes-backport)）。截至撰写本文时，该补丁已应用于内核主线和*最近的*树莓派内核（因此，`rpi-5.4.y`分支可以正常工作，但较早的分支，如`rpi-4.9.y`分支似乎没有）！因此会出现编译器警告...实际上，如果您看到这些警告，请将树莓派分支更新到`rpi-5.4.y`或更高版本（或者暂时忽略它们）。
- en: 'The proof of the pudding is in the eating though. So, we fire up our Raspberry
    Pi, `scp(1)` across our cross-compiled kernel module object file to it, and, as
    follows (within an `ssh(1)` session on the Raspberry Pi), try it out (the following
    output is directly from the device):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，实践出真知。因此，我们启动树莓派，通过`scp(1)`将交叉编译的内核模块对象文件传输到它，然后在树莓派上的`ssh(1)`会话中尝试它（以下输出直接来自设备）：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Clearly, `insmod(8)` in the preceding code fails! *It's important to understand
    why.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，前面代码中的`insmod(8)`失败了！*重要的是要理解为什么。*
- en: It's really to do with a *mismatch in the kernel version* that we're attempting
    to load the module on and the kernel version the module has been compiled against.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上与我们试图加载模块的内核版本不匹配以及模块已编译的内核版本有关。
- en: 'While logged in to the Raspberry Pi, print out the current Raspberry Pi kernel
    version we''re running on and use the `modinfo(8)` utility to print out details
    regarding the kernel module itself:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树莓派上登录后，打印出我们正在运行的当前树莓派内核版本，并使用`modinfo(8)`实用程序打印出有关内核模块本身的详细信息：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding output, clearly, here we're running the `4.19.75-v7+` kernel
    on the Raspberry Pi. This, in fact, is the kernel I inherited when I installed
    the *default *Raspbian OS on the device's microSD card (it's a deliberate scenario
    introduced here, at first *not* using the 5.4 kernel we built earlier for the
    Raspberry Pi). The kernel module, on the other hand, reveals that it's been compiled
    against the `5.4.51-v7+` Linux kernel (the `vermagic` string from `modinfo(8)`
    reveals this). *Clearly, there's a mismatch.* Well, so what?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，很明显，我们在树莓派上运行`4.19.75-v7+`内核。实际上，这是我在设备的microSD卡上安装*默认*Raspbian OS时继承的内核（这是一个故意引入的场景，最初*不*使用我们为树莓派早期构建的5.4内核）。另一方面，内核模块显示它已经针对`5.4.51-v7+`
    Linux内核进行了编译（来自`modinfo(8)`的`vermagic`字符串显示了这一点）。*很明显，存在不匹配。*那又怎样呢？
- en: 'The Linux kernel has a rule, part of the *kernel* **Application Binary Interface** (**ABI**):
    **it will only ever insert a kernel module into kernel memory if that kernel module
    has been built against it** – the precise kernel version, build flags, and even
    the kernel configuration options matter!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核有一个规则，是*内核* **应用二进制接口**（**ABI**）的一部分：**只有当内核模块构建在它上面时，它才会将内核模块插入内核内存**
    - 精确的内核版本，构建标志，甚至内核配置选项都很重要！
- en: The *built against* kernel is the kernel whose source location you specified
    in the Makefile (we did so via the `KDIR` variable previously).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的内核是您在Makefile中指定的内核源位置（我们之前通过`KDIR`变量这样做）。
- en: In other words, kernel modules are **not binary-compatible with kernels other
    than the one they have been built against***. *For example, if we build a kernel
    module on, say, an Ubuntu 18.04 LTS box, then it will *only* *work on a system
    running this precise environment* (libraries, kernel, or toolchain)! It will *not*
    work on a Fedora 29 or an RHEL 7.x, a Raspberry Pi, and so on. Now – and again,
    think about this – this does not mean that kernel modules are completely incompatible.
    No, they are *source-compatible across different architectures *(at least they
    can or *should* be written that way). So, assuming you have the source code, you
    can always *rebuild* a kernel module on a given system and then it will work on
    that system. It's just that the *binary image *(the `.ko` file) is incompatible
    with kernels other than the precise one it's built against.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，内核模块与其构建的内核之外的内核**不兼容**。例如，如果我们在Ubuntu 18.04 LTS上构建一个内核模块，那么它将*只*在运行这个精确环境的系统上工作（库，内核或工具链）！它将*不*在Fedora
    29或RHEL 7.x，树莓派等上工作。现在 - 再次思考一下 - 这并不意味着内核模块完全不兼容。不，它们在不同架构之间是*源代码兼容*的（至少它们可以或者*应该*被编写成这样）。因此，假设你有源代码，你总是可以在给定的系统上*重新构建*一个内核模块，然后它将在该系统上工作。只是*二进制映像*（`.ko`文件）与其构建的精确内核之外的内核不兼容。
- en: 'Relax, this issue is actually easy to spot. Look up the kernel log:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 放松，这个问题实际上很容易发现。查看内核日志：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On the device, the currently running kernel is this: `4.19.75-v7+`. The kernel
    literally tells us that our kernel module has been built against the `5.4.51-v7+` kernel
    version (it also shows some of the expected kernel config) and what it should
    be. There is a mismatch! Hence the failure to insert the kernel module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上，当前运行的内核是：`4.19.75-v7+`。内核直接告诉我们，我们的内核模块已经构建在`5.4.51-v7+`内核版本上（它还显示了一些预期的内核配置）以及它应该是什么。存在不匹配！因此无法插入内核模块。
- en: 'Though we don''t use this approach here, there is a way to ensure the successful
    build and deployment of third-party out-of-tree kernel modules (as long as their
    source code is available), via a framework called **DKMS** (**Dynamic Kernel Module
    Support**)*.* The following is a quote directly from it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里不使用这种方法，但是有一种方法可以确保成功构建和部署第三方的内核模块（只要它们的源代码是可用的），通过一个名为**DKMS**（**动态内核模块支持**）的框架。以下是直接从中引用的一句话：
- en: <q>Dynamic Kernel Module Support (DKMS) is a program/framework that enables
    generating Linux kernel modules </q><q>whose sources generally reside outside
    the kernel source tree. The concept is to have DKMS modules </q><q>automatically
    rebuilt when a new kernel is installed.</q>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <q>动态内核模块支持（DKMS）是一个启用生成Linux内核模块的程序/框架</q><q>其源代码通常驻留在内核源树之外。其概念是在安装新内核时自动重建DKMS模块。</q>
- en: As an example of DKMS usage, the Oracle VirtualBox hypervisor (when running
    on a Linux host) uses DKMS to auto-build and keep up to date its kernel modules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为DKMS使用的一个例子，Oracle VirtualBox hypervisor（在Linux主机上运行时）使用DKMS自动构建和保持其内核模块的最新状态。
- en: Attempt 4  – cross-compiling our kernel module
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试4 - 交叉编译我们的内核模块
- en: 'So, now that we understand the issue, there are two possible solutions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了问题，有两种可能的解决方案：
- en: We must use the required custom configured kernel for the product and build
    all our kernel modules against it.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用产品所需的自定义配置内核，并构建所有我们的内核模块。
- en: Alternatively, we could rebuild the kernel module to match the current kernel the
    device happens to be running.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以重建内核模块以匹配当前运行的内核设备。
- en: Now, in typical embedded Linux projects, you will almost certainly have a custom
    configured kernel for the target device, one that you must work with. All kernel
    modules for the product will/must be built against it. Thus, we follow the first
    approach – we must boot the device with our custom configured and built (5.4!)
    kernel, and since our kernel module is built against it, it should certainly work
    now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在典型的嵌入式Linux项目中，您几乎肯定会为目标设备拥有一个自定义配置的内核，您必须与之一起工作。产品的所有内核模块将/必须构建在其上。因此，我们遵循第一种方法
    - 我们必须使用我们自定义配置和构建的（5.4！）内核引导设备，因为我们的内核模块是构建在其上的，现在它应该肯定可以工作。
- en: We (briefly) covered the kernel build for the Raspberry Pi in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2.* Refer back there for the
    details if required.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们（简要地）在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中涵盖了树莓派的内核构建，*从源代码构建5.x
    Linux内核 - 第2部分*。如果需要，可以返回那里查看详细信息。
- en: Okay, I will have to assume that you've followed the steps (covered in [Chapter
    3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x Linux Kernel
    from Source - Part 2*) and have by now configured and built a 5.4 kernel for the
    Raspberry Pi. The nitty-gritty details regarding how to copy our custom `zImage`
    onto the microSD card of the device and so on is not covered here. I refer you
    to the official Raspberry Pi documentation here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我将假设您已经按照[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中涵盖的步骤，并且现在已经为树莓派配置和构建了一个5.4内核。关于如何将我们的自定义`zImage`复制到设备的microSD卡等细节在这里没有涵盖。我建议您查看官方的树莓派文档：[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。
- en: 'Nevertheless, we will point out a convenient way to switch between kernels
    on the device (here, I assume the device is a Raspberry Pi 3B+ running a 32-bit
    kernel):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们将指出一种方便的方法来在设备上切换内核（这里，我假设设备是运行32位内核的树莓派3B+）：
- en: Copy your custom-built `zImage` kernel binary into the device's microSD card's
    `/boot` partition. Save the original Raspberry Pi kernel image – the Raspbian
    one – as `kernel7.img.orig`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您定制构建的`zImage`内核二进制文件复制到设备的microSD卡的`/boot`分区。将原始的Raspberry Pi内核映像 - Raspbian内核映像
    - 保存为`kernel7.img.orig`。
- en: Copy (`scp`) the just-cross-compiled kernel module (`helloworld_lkm.ko` for
    ARM, done in the previous section) from your host system onto the microSD card
    (typically into `/home/pi`).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主机系统上复制（`scp`）刚刚交叉编译的内核模块（ARM上的`helloworld_lkm.ko`，在上一节中完成）到microSD卡（通常是`/home/pi`）。
- en: 'Next, again on the device''s microSD card, edit the `/boot/config.txt` file,
    setting the kernel to boot via the `kernel=xxx` line. A snippet from this file
    on the device shows this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次在设备的microSD卡上，编辑`/boot/config.txt`文件，通过`kernel=xxx`行设置内核引导。设备上的此文件片段显示了这一点：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once saved and rebooted, we log in to the device and retry our kernel module.
    Figure 5.2 is a screenshot showing the just-cross-compiled `helloworld_lkm.ko` LKM
    being used on the Raspberry Pi device:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新启动后，我们登录到设备并重试我们的内核模块。图5.2是一个屏幕截图，显示了刚刚交叉编译的`helloworld_lkm.ko`内核模块在树莓派设备上的使用：
- en: '![](img/0d9aae0b-cd43-4afc-9080-0936ceeb5098.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d9aae0b-cd43-4afc-9080-0936ceeb5098.png)'
- en: Figure 5.2 – The cross-compiled LKM being used on a Raspberry Pi
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 在树莓派上使用的交叉编译的LKM
- en: Ah, it worked! Notice how, this time, the current kernel version (`5.4.51-v7+`)
    precisely matches that of the kernel the module was built against – in the `modinfo(8)` output,
    we can see that the `vermagic` string shows it's `5.4.51-v7+`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，成功了！请注意，这次当前内核版本（`5.4.51-v7+`）与模块构建时的内核版本完全匹配 - 在`modinfo(8)`输出中，我们可以看到`vermagic`字符串显示为`5.4.51-v7+`。
- en: If you do see an issue with `rmmod(8)` throwing a non-fatal error (though the
    cleanup hook is still called), the reason is that you haven't yet fully set up
    the newly built kernel on the device. You will have to copy in all the kernel
    modules (under `/lib/modules/<kernel-ver>`) and run the `depmod(8)` utility there.
    Here, we will not delve further into these details – as mentioned before, the
    official documentation for the Raspberry Pi covers all these steps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`rmmod(8)`出现非致命错误（尽管清理钩子仍然被调用），原因是您尚未完全在设备上设置新构建的内核。您将不得不复制所有内核模块（位于`/lib/modules/<kernel-ver>`下）并在那里运行`depmod(8)`实用程序。在这里，我们不会深入探讨这些细节
    - 如前所述，树莓派的官方文档涵盖了所有这些步骤。
- en: Of course, the Raspberry Pi is a pretty powerful system; you can install the
    (default) Raspbian OS along with development tools and kernel headers and thus
    compile kernel modules on the board itself! (No cross-compile required.) Here,
    though, we have followed the cross-compile approach as this is typical when working
    on embedded Linux projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，树莓派是一个非常强大的系统；您可以在树莓派上安装（默认的）Raspbian操作系统以及开发工具和内核头文件，从而在板上编译内核模块！（无需交叉编译。）然而，在这里，我们遵循了交叉编译的方法，因为这在嵌入式Linux项目中很典型。
- en: The LKM framework is a rather large piece of work. Plenty more remains to be
    explored. Let's get to it. In the next section, we will examine how you can obtain
    some minimal system information from within a kernel module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: LKM框架是一个相当庞大的工作。还有很多需要探索的地方。让我们开始吧。在下一节中，我们将研究如何从内核模块中获取一些最小的系统信息。
- en: Gathering minimal system information
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集最小的系统信息
- en: 'In our simple demo from the previous section (`ch5/cross/helloworld_lkm.c`),
    we have hard-coded a `printk()` to emit a `"Hello/Goodbye, Raspberry Pi world\n"` string, regardless
    of whether or not the kernel module actually runs on a Raspberry Pi device. For
    a better, though still quite simplistic, way to "detect" some system details (such
    as the CPU or OS), we refer you to our sample `ch5/min_sysinfo/min_sysinfo.c` kernel
    module. In the following code snippet, we show only the relevant function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一节的简单演示中（`ch5/cross/helloworld_lkm.c`），我们已经硬编码了一个`printk()`来发出一个`"Hello/Goodbye,
    Raspberry Pi world\n"`字符串，无论内核模块是否真的在树莓派设备上运行。为了更好地“检测”一些系统细节（如CPU或操作系统），我们建议您参考我们的样本`ch5/min_sysinfo/min_sysinfo.c`内核模块。在下面的代码片段中，我们只显示相关函数：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (Additional details that this LKM shows you - like the size of various primitive
    data types plus word ranges - is not shown here; please do refer to the source
    code from our GitHub repository and try it out for yourself.) The preceding kernel
    module code is instructive as it helps demonstrate how you can write portable
    code. Remember, the kernel module itself is a binary non-portable object file,
    but its source code could (perhaps, should, depending on your project) be written
    in such a manner so that it's portable across various architectures. A simple
    build on (or for) the target architecture would then have it ready for deployment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （此LKM显示的其他细节 - 如各种原始数据类型的大小和字范围 - 这里没有显示；请参考我们的GitHub存储库中的源代码并自行尝试。）前面的内核模块代码是有益的，因为它有助于演示如何编写可移植的代码。请记住，内核模块本身是一个二进制的不可移植的目标文件，但它的源代码可能（也许应该，取决于您的项目）以这样一种方式编写，以便在各种架构上都是可移植的。然后在目标架构上进行简单的构建（或为目标架构构建）将使其准备好部署。
- en: For now, please ignore the `EXPORT_SYMBOL()` macro used here. We will cover
    its usage shortly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请忽略此处使用的`EXPORT_SYMBOL()`宏。我们将很快介绍其用法。
- en: 'Building and running it on our now familiar x86_64 Ubuntu 18.04 LTS guest,
    we get this output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现在熟悉的x86_64 Ubuntu 18.04 LTS客户机上构建并运行它，我们得到了这个输出：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Great! Similarly (as demonstrated earlier), we can *cross-compile* this kernel
    module for ARM-32 (Raspberry Pi), then transfer (`scp(1)`) the cross-compiled
    kernel module to our Raspberry Pi target and run it there (the following output
    is from a Raspberry Pi 3B+ running the 32-bit Raspbian OS):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！类似地（如前面演示的），我们可以为ARM-32（树莓派）*交叉编译*这个内核模块，然后将交叉编译的内核模块传输（`scp(1)`）到我们的树莓派目标并在那里运行（以下输出来自运行32位Raspbian
    OS的树莓派3B+）：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This, in fact, reveals something interesting; the Raspberry Pi 3B+ has a native
    *64-bit CPU*, but by default (as of the time of writing) runs a 32-bit OS, hence
    the preceding output. We will leave it to you to install a 64-bit Linux OS on
    a Raspberry Pi (or other) device and re-run this kernel module.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这揭示了一些有趣的事情；树莓派3B+拥有本地*64位CPU*，但默认情况下（截至撰写本文时）运行32位操作系统，因此出现了前面的输出。我们将留给你在树莓派（或其他设备）上安装64位Linux操作系统，并重新运行这个内核模块。
- en: The powerful *Yocto Project* ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))
    is one (industry-standard) way to generate a 64-bit OS for the Raspberry Pi. Alternatively
    (and much easier to quickly try), Ubuntu provides a custom Ubuntu 64-bit kernel
    and root filesystem for the device ([https://wiki.ubuntu.com/ARM/RaspberryPi](https://wiki.ubuntu.com/ARM/RaspberryPi)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的*Yocto项目*（[https://www.yoctoproject.org/](https://www.yoctoproject.org/)）是一种（行业标准）生成树莓派64位操作系统的方法。另外（也更容易快速尝试），Ubuntu为该设备提供了自定义的Ubuntu
    64位内核和根文件系统（[https://wiki.ubuntu.com/ARM/RaspberryPi](https://wiki.ubuntu.com/ARM/RaspberryPi)）。
- en: Being a bit more security-aware
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更加注重安全性
- en: Security, of course, is a key concern these days. Professional developers are
    expected to write secure code. In recent years, there have been many known exploits
    against the Linux kernel (see the *Further reading* section for more on this).
    In parallel, many efforts toward improving Linux kernel security are in place.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，安全性是当今的一个关键问题。专业开发人员被期望编写安全的代码。近年来，针对Linux内核已经有许多已知的漏洞利用（有关更多信息，请参阅*进一步阅读*部分）。与此同时，许多工作正在进行中，以改进Linux内核的安全性。
- en: 'In our preceding kernel module (`ch5/min_sysinfo/min_sysinfo.c`), be wary of
    using older-style routines (like the `sprintf`, `strlen`, and so on; yes, they''re
    present within the kernel)! *Static analyzers* can greatly aid in catching potential
    security-related and other bugs; we highly recommend you use them. [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),*Kernel*
    *Workspace Setup*, mentions several useful static analysis tools for the kernel.
    In the following code, we use one of the `sa` targets within our our "better" Makefile to
    run a relatively simple static analyzer: `flawfinder(1)` (written by David Wheeler):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的内核模块（`ch5/min_sysinfo/min_sysinfo.c`）中，要注意使用旧式的例程（比如`sprintf`、`strlen`等等；是的，在内核中存在这些）！*静态分析器*可以在捕获潜在的与安全相关的和其他错误方面大有裨益；我们强烈建议您使用它们。[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核工作区设置*，提到了内核的几种有用的静态分析工具。在下面的代码中，我们使用了我们“更好”的`Makefile`中的`sa`目标之一来运行一个相对简单的静态分析器：`flawfinder(1)`（由David
    Wheeler编写）：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Look carefully at the warning emitted by `flawfinder(1)` regarding the `strlen()` function
    (among the many it generates!). It is indeed the case we face here! Remember, uninitialized local
    variables (such as our `msg` buffer) have *random content* when declared. Thus,
    the `strlen()` function may or may not yield the value we expect.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下`flawfinder(1)`发出的警告，特别是关于`strlen()`函数的警告（它生成了许多警告！）。在这里我们确实面临这种情况！记住，未初始化的局部变量（比如我们的`msg`缓冲区）在声明时具有*随机内容*。因此，`strlen()`函数可能会产生我们期望的值，也可能不会。
- en: 'The output of `flawfinder` even mentions the **CWE** number (here, CWE-126)
    of the *generalized class *of security issue that is being seen here; (do google
    it and you will see the details. In this instance, CWE-126 represents the buffer
    over-read issue: [https://cwe.mitre.org/data/definitions/126.html](https://cwe.mitre.org/data/definitions/126.html)).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`flawfinder`的输出甚至提到了**CWE**编号（在这里是CWE-126），表示在这里看到的*一般类*的安全问题；（搜索一下你会看到详细信息。在这种情况下，CWE-126代表缓冲区过读问题：[https://cwe.mitre.org/data/definitions/126.html](https://cwe.mitre.org/data/definitions/126.html)）。'
- en: Similarly, we avoid the use of `strncat()` and replace it with the `strlcat()`
    function. So, taking security concerns into account, we rewrite the code of the `llkd_sysinfo()` function
    as `llkd_sysinfo2()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们避免使用`strncat()`，并用`strlcat()`函数替换它。因此，考虑到安全性问题，我们将`llkd_sysinfo()`函数的代码重写为`llkd_sysinfo2()`。
- en: We also add a few lines of code to show the *range *(min, max) of both unsigned
    and signed variables on the platform (in both base 10 and 16). We leave it to
    you to read through. As a simple assignment, run this kernel module on your Linux
    box(es) and verify the output.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些代码行，以显示平台上无符号和有符号变量的*范围*（最小值、最大值）（以10进制和16进制表示）。我们留给你来阅读。作为一个简单的任务，运行这个内核模块在你的Linux设备上，并验证输出。
- en: Now, let's move on to discuss a little bit regarding the licensing of the Linux
    kernel and kernel module code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论一下Linux内核和内核模块代码的许可问题。
- en: Licensing kernel modules
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许可内核模块
- en: 'As is well known, the Linux kernel code base itself is licensed under the GNU
    GPL v2 (aka GPL-2.0; **GPL** stands for **General Public License**), and as far
    as most people are concerned, will remain that way. As briefly mentioned before,
    in [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),* Writing Your First
    Kernel Module – LKMs Part 1, *licensing your kernel code is required and important.
    Essentially, what the discussion, at least for our purposes, boils down to is
    this: if your intention is to directly use kernel code and/or contribute your
    code upstream into the mainline kernel (a few notes on this follow), you *must *release
    the code under the same license that the Linux kernel is released under: the GNU
    GPL-2.0\. For a kernel module, the situation is still a bit "fluid," shall we
    say. No matter, to engage the kernel community and have them help (a huge plus),
    you should, or are expected to, release the code under the GNU GPL-2.0 license
    (though dual-licensing is certainly possible and acceptable).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Linux内核代码本身是根据GNU GPL v2（也称为GPL-2.0；GPL代表通用公共许可证）许可的，就大多数人而言，将保持这种状态。如前所述，在[第4章](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml)中，*编写您的第一个内核模块
    - LKMs第1部分*，许可您的内核代码是必需且重要的。基本上，至少对于我们的目的来说，讨论的核心是：如果您的意图是直接使用内核代码和/或向主线内核贡献您的代码（接下来会有一些说明），您*必须*以与Linux内核发布的相同许可证发布代码：GNU
    GPL-2.0。对于内核模块，情况仍然有点“灵活”，我们可以这么说。无论如何，为了与内核社区合作并得到他们的帮助（这是一个巨大的优势），您应该或者预期将代码发布为GNU
    GPL-2.0许可证（尽管双重许可证当然是可能和可接受的）。
- en: 'The license(s) is specified using the `MODULE_LICENSE()` macro. The following
    comment reproduced from the `include/linux/module.h` kernel header clearly shows
    what license "idents" are acceptable (notice the dual-licensing). Obviously, the
    kernel community would highly recommend releasing your kernel module under the
    GPL-2.0 (GPL v2) and/or another, such as BSD/MIT/MPL. If you are intending to
    contribute code upstream to the kernel mainline, it goes without saying that the
    GPL-2.0 alone *is* the license to release under:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MODULE_LICENSE()`宏来指定许可证。从内核头文件`include/linux/module.h`中复制的以下注释清楚地显示了哪些许可证“标识”是可接受的（请注意双重许可）。显然，内核社区强烈建议将内核模块发布为GPL-2.0（GPL
    v2）和/或其他许可证，如BSD/MIT/MPL。如果您打算向内核主线贡献代码，毫无疑问，单独的GPL-2.0就是要发布的许可证：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'FYI, the kernel source tree has a `LICENSES/` directory under which you will
    find detailed information on licenses; a quick `ls` on this folder reveals the
    sub-folders therein:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，内核源代码树有一个`LICENSES/`目录，在其中您将找到有关许可证的详细信息；在这个文件夹上快速执行`ls`命令会显示其中的子文件夹：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll leave it to you to take a look, and with this, will leave the discussion
    on licensing at that; the reality is that it's a complex topic requiring legal
    knowledge. You would be well advised to consult specialist legal staff (lawyers)
    within your company (or hire them) with regard to getting the legal angle right
    for your product or service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留给您去查看，并且将讨论许可证的内容到此为止；现实情况是，这是一个需要法律知识的复杂话题。您最好咨询公司内的专业法律人员（律师）（或者雇佣他们）以确保您的产品或服务的法律角度正确。
- en: 'While on the topic, in order to be consistent, recent kernels have a rule:
    every single source file''s first line must be an SPDX license identifier (see
    [https://spdx.org/](https://spdx.org/) for details). Of course, scripts will require
    the first line to specify the interpreter. Also, some answers to FAQs on the GPL
    license are addressed here: [https://www.gnu.org/licenses/gpl-faq.html](https://www.gnu.org/licenses/gpl-faq.html).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个话题上，为了保持一致，最近的内核有一个规定：每个单独的源文件的第一行必须是一个SPDX许可证标识符（详见[https://spdx.org/](https://spdx.org/)）。当然，脚本需要第一行指定解释器。此外，一些关于GPL许可证的常见问题的答案可以在这里找到：[https://www.gnu.org/licenses/gpl-faq.html](https://www.gnu.org/licenses/gpl-faq.html)。
- en: More on licensing models, not abusing the `MODULE_LICENSE` macro, and particularly
    the multi-licensing/dual-licensing one, can be found at the link provided in the
    *Further reading* section of this chapter. Now, let's get back to the technical
    stuff. The next section explains how you can effectively emulate a library-like
    feature in kernel space.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关许可模型、不滥用`MODULE_LICENSE`宏，特别是多许可证/双许可证的更多信息，请参阅本章“进一步阅读”部分提供的链接。现在，让我们回到技术方面。下一节将解释如何在内核空间有效地模拟类库功能。
- en: Emulating "library-like" features for kernel modules
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核模块中模拟“类库”功能
- en: 'One of the major differences between user-mode and kernel-mode programming
    is the complete absence of the familiar "library" concept in the latter. Libraries
    are essentially a collection or archive of APIs, conveniently allowing developers
    to meet the important goals, typically: *do not reinvent the wheel, software reuse,
    modularity*, and the like. But within the Linux kernel, libraries just do not
    exist.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式和内核模式编程之间的一个主要区别是后者完全没有熟悉的“库”概念。库本质上是API的集合或存档，方便开发人员实现重要目标，通常包括：*不要重复造轮子、软件重用、模块化*等。但在Linux内核中，库根本不存在。
- en: 'The good news, though, is that broadly speaking, there are two techniques by
    which you can achieve a "library-like" functionality in kernel space for our kernel
    modules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好消息是，大体上说，有两种技术可以在内核空间为我们的内核模块实现“类库”功能：
- en: 'The first technique: explicitly "link in" multiple source files – including
    the "library" code – to your kernel module object.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种技术：显式“链接”多个源文件（包括“库”代码）到您的内核模块对象中。
- en: The second is called module stacking.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个被称为模块堆叠。
- en: 'Do read on as we discuss these techniques in more detail. A spoiler, perhaps,
    but useful to know right away: the first of the preceding techniques is often
    superior to the second. Then again, it does depend on the project. Do read the
    details in the next section; we list out some pros and cons as we go along.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续阅读，我们将更详细地讨论这些技术。也许有点剧透，但立即了解的话会很有用：前面的技术中的第一种通常优于第二种。不过，这取决于项目。请在下一节中阅读详细信息；我们将在进行时列出一些优缺点。
- en: Performing library emulation via multiple source files
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过多个源文件执行库模拟
- en: So far, we have dealt with very simple kernel modules that have had exactly
    one C source file. What about the (quite typical) real-world situation where there
    is *more than one C source file for a single kernel module*? All source files
    will have to be compiled and then linked together as a single `.ko` binary object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理的内核模块都只有一个C源文件。那么对于（相当典型的）现实世界中存在*多个C源文件的单个内核模块*的情况呢？所有源文件都必须被编译，然后链接在一起成为一个`.ko`二进制对象。
- en: 'For example, say we''re building a kernel module project called `projx`. It
    consists of three C source files: `prj1.c, prj2.c`, and `prj3.c`. We want the
    final kernel module to be called `projx.ko`. The Makefile is where you specify
    these relationships, as shown:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在构建一个名为`projx`的内核模块项目。它由三个C源文件组成：`prj1.c, prj2.c`和`prj3.c`。我们希望最终的内核模块被称为`projx.ko`。Makefile是您指定这些关系的地方，如下所示：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, note how the `projx` label has been used after the `obj-m`
    directive *and* as the prefix for the
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意`projx`标签在`obj-m`指令*之后*和作为前缀使用的情况
- en: '`-objs` directive on the next line. Of course, you can use any label. Our preceding
    example will have the kernel build system compile the three individual C source
    files into individual object (`.o`) files, and will then *link them all together
    to form the final binary kernel module object file,* `projx.ko`, just as we desire.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`-objs`指令在下一行。当然，您可以使用任何标签。我们之前的示例将使内核构建系统将三个单独的C源文件编译为单独的目标（`.o`）文件，然后将它们*链接*在一起，形成最终的二进制内核模块对象文件，`projx.ko`，正如我们所期望的那样。'
- en: 'We can leverage this mechanism in building a small "library" of routines within
    our book''s source tree (the source files for this ''kernel library'' are in the
    root of the source tree here: `klib_llkd.h` and `klib_llkd.c`). The idea is that
    other kernel modules can use the functions within here by linking into them! For
    example, in the upcoming [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml)*,
    Memory Management Internals - Essentials, *we have our `ch7/lowlevel_mem/lowlevel_mem.c` kernel
    module code invoke a function that resides in our library code, `../../klib_llkd.c`. 
    The "linking into" our so-called "library" code is achieved by putting the following
    into the `lowlevel_mem` kernel module''s Makefile:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种机制在我们书籍的源树中构建一个小的例程“库”（此处的“内核库”源文件位于源树的根目录中：`klib_llkd.h`和`klib_llkd.c`）。其想法是其他内核模块可以通过链接到这里的函数来使用这里的函数！例如，在即将到来的[第7章](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml)*，内存管理内部
    - 基本知识*中，我们的`ch7/lowlevel_mem/lowlevel_mem.c`内核模块代码调用了我们库代码中的一个函数，`../../klib_llkd.c`。所谓的“链接到”我们所谓的“库”代码是通过将以下内容放入`lowlevel_mem`内核模块的Makefile中实现的：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The second line specifies the source files to build (into object files); they
    are the code of the `lowlevel_mem.c` kernel module and the `../../klib_llkd` library
    code. Then, it *links *both into a single binary kernel module, `lowlevel_mem_lib.ko`,
    achieving our objective. (Why not work on the assignment 5.1 specified in the
    *Questions* section at the end of this chapter.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行指定要构建的源文件（成为目标文件）；它们是`lowlevel_mem.c`内核模块的代码和`../../klib_llkd`库代码。然后，将它们链接成一个单一的二进制内核模块，`lowlevel_mem_lib.ko`，实现我们的目标。（为什么不在本章末尾的*问题*部分中处理指定的作业5.1。）
- en: Understanding function and variable scope in a kernel module
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解内核模块中的函数和变量作用域
- en: 'Before delving further, a quick re-look at some basics is a good idea. When
    programming with C, you should understand the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前，快速回顾一些基础知识是个好主意。在使用C进行编程时，您应该了解以下内容：
- en: Variables declared locally within a function are obviously local to it and only have
    scope within that function.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内声明的变量显然只在函数内部可见，并且仅在该函数内部具有作用域。
- en: Variables and functions prefixed with the `static` qualifier have scope only
    within the current "unit"; effectively, the file they have been declared within.
    This is good as it helps reduce namespace pollution. Static (and global) data
    variables retain their value within that function.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`static`限定符前缀的变量和函数仅在当前“单元”内具有作用域；实际上是在它们被声明的文件内。这很好，因为它有助于减少命名空间污染。静态（和全局）数据变量在该函数内保留其值。
- en: 'Prior to 2.6 Linux (that is, <= 2.4.x, ancient history now), kernel module
    static and global variables, as well as all functions, were automatically visible
    throughout the kernel. This was, in retrospect, obviously not a great idea. The
    decision was reversed from 2.5 (and thus 2.6 onward, modern Linux): **all kernel
    module variables (static and global data) and functions are by default scoped
    to be private to their kernel module only, and are thus invisible outside it**.
    So, if two kernel modules, `lkmA` and `lkmB`  have a global named `maya`, it''s
    unique to each of them; there is no clash.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.6 Linux之前（即<= 2.4.x，现在是古代历史），内核模块的静态和全局变量以及所有函数都会自动在整个内核中可见。回顾起来，这显然不是一个好主意。从2.5开始（因此2.6及以后的现代Linux）决定反转：**所有内核模块变量（静态和全局数据）和函数默认范围仅限于其内核模块，并且因此在外部不可见**。因此，如果两个内核模块`lkmA`和`lkmB`有一个名为`maya`的全局变量，它对每个模块都是唯一的；不会发生冲突。
- en: To change the scope, the LKM framework provides the `EXPORT_SYMBOL()` macro.
    Using it, you can declare a data item or function to be *global* in scope – in
    effect, visible to all other kernel modules as well as to the kernel core.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改作用域，LKM框架提供了`EXPORT_SYMBOL()`宏。使用它，您可以声明数据项或函数为*全局*作用域 - 实际上，对所有其他内核模块以及内核核心可见。
- en: 'Let''s take a simple example. We have a kernel module called `prj_core` that
    contains a global and a function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子。我们有一个名为`prj_core`的内核模块，其中包含一个全局变量和一个函数：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Though both are usable within this kernel module itself, neither can be seen
    outside it. This is intentional. To make them visible outside this kernel module,
    we can *export *them:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两者都可以在这个内核模块内部使用，但在外部都看不到。这是有意为之的。为了使它们在这个内核模块外部可见，我们可以*导出*它们：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, both have scope outside this kernel module (notice how, in the preceding
    code block, the `static` keyword has been deliberately removed). *Other kernel
    modules (as well as the core kernel) can now "see" and use them*. Precisely, this
    idea is leveraged in two broad ways:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两者都在这个内核模块之外具有作用域（请注意，在前面的代码块中，`static`关键字已经被故意删除）。*其他内核模块（以及核心内核）现在可以“看到”并使用它们*。确切地说，这个想法以两种广泛的方式得到了利用：
- en: First, the kernel exports a well-thought-out subset of global variables and
    functions that form a part of its core functionality, as well as that of other
    subsystems. Now, these globals and functions are visible and thus usable from
    kernel modules! We will see some sample uses shortly.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，内核导出了一个经过深思熟虑的全局变量和函数的子集，这些变量和函数构成了其核心功能的一部分，也是其他子系统的一部分。现在，这些全局变量和函数是可见的，因此可以从内核模块中使用！我们很快将看到一些示例用法。
- en: Second, kernel module authors (often device drivers) use this very notion to
    export certain data and/or functionality so that other kernel modules, at a higher
    abstraction level, perhaps, can leverage this design and use this data and/or
    functionality – this concept is called *module stacking *and we will delve into
    it shortly with an example.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，内核模块作者（通常是设备驱动程序）使用这个概念来导出某些数据和/或功能，以便其他内核模块在更高的抽象级别上可以利用这个设计并使用这些数据和/或功能
    - 这个概念被称为*模块堆叠*，我们将很快通过一个例子来深入探讨它。
- en: 'With the first use case, for example, a device driver author might want to
    handle a hardware interrupt from a peripheral device. A common way to do so is
    via the `request_irq()` API, which, in fact, is nothing but a thin (inline) wrapper
    over this API:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于第一个用例，设备驱动程序的作者可能希望处理来自外围设备的硬件中断。通常的做法是通过`request_irq()`API来实现，实际上，这个API只是对这个API的一个薄包装（内联）：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Precisely because the `request_threaded_irq()` function is *exported*,it can be
    called from within a device driver, which is very often written as a kernel module.
    Similarly, developers often require some "convenience" routines – for example,
    string processing ones. The Linux kernel, in `lib/string.c`, provides an implementation
    of several common string processing functions (that you expect to be present): `str[n]casecmp`, `str[n|l|s]cpy`, `str[n|l]cat`, `str[n]cmp`, `strchr[nul]`, `str[n|r]chr`, `str[n]len`,
    and so on. Of course, these are all *exported* via the `EXPORT_SYMBOL()` macro
    so as to make them visible and thus available to module authors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为`request_threaded_irq()`函数是*导出的*，它可以从设备驱动程序中调用，而设备驱动程序往往是作为内核模块编写的。同样，开发人员经常需要一些“便利”例程
    - 例如，字符串处理例程。Linux内核在`lib/string.c`中提供了几个常见字符串处理函数的实现（您期望它们存在）：`str[n]casecmp`、`str[n|l|s]cpy`、`str[n|l]cat`、`str[n]cmp`、`strchr[nul]`、`str[n|r]chr`、`str[n]len`等等。当然，这些都是通过`EXPORT_SYMBOL()`宏*导出*的，以使它们可见，从而可供模块作者使用。
- en: 'Here, we used the `str[n|l|s]cpy` notation to imply that the kernel provides
    the four functions: `strcpy`, `strncpy`, `strlcpy`, and `strscpy`. Note that some
    interfaces may be deprecated (`strcpy()`, `strncpy()`, and `strlcpy()`). In general,
    always avoid using deprecated stuff documented here: *Deprecated Interfaces, Language
    Features, Attributes, and Conventions* ([https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`str[n|l|s]cpy`表示内核提供了四个函数：`strcpy`、`strncpy`、`strlcpy`和`strscpy`。请注意，一些接口可能已被弃用（`strcpy()`、`strncpy()`和`strlcpy()`）。一般来说，始终避免使用此处记录的弃用内容：*弃用接口、语言特性、属性和约定*（[https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)）。
- en: 'On the other hand, let''s glance at a (tiny) bit of the core **CFS** (**Completely
    Fair Scheduler**) scheduling code deep within the kernel core. Here, the `pick_next_task_fair()` function is
    the one invoked by the scheduling code when we need to find another task to context-switch
    to:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，让我们来看一下内核核心深处的**CFS**（**完全公平调度器**）调度代码的一小部分。在这里，当调度代码需要找到另一个任务进行上下文切换时，会调用`pick_next_task_fair()`函数：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We don''t really want to study scheduling here ([Chapter 10](5391e3c1-30ad-4c75-a106-301259064881.xhtml),
    *The CPU Scheduler - Part 1*, and [Chapter 11](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml),
    *The CPU Scheduler - Part 2*, take care of it), the point here is this: as the
    preceding function is *not *marked with the `EXPORT_SYMBOL()` macro, it cannot
    ever be invoked by a kernel module. It remains *private* to the core kernel.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里并不真的想研究调度（[第10章](5391e3c1-30ad-4c75-a106-301259064881.xhtml)，*CPU调度器 - 第1部分*，和[第11章](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml)，*CPU调度器
    - 第2部分*，已经涵盖了它），这里的重点是：由于前面的函数*没有*用`EXPORT_SYMBOL()`宏标记，它永远不能被内核模块调用。它仍然是核心内核的*私有*。
- en: You can also mark data structures as exported with the same macro. Also, it
    should be obvious that only globally scoped data – not local variables – can be
    marked as exported.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用相同的宏将数据结构标记为已导出。此外，显而易见，只有全局范围的数据 - 而不是局部变量 - 可以被标记为已导出。
- en: If you want to see how the `EXPORT_SYMBOL()` macro works, please refer to the *Further
    reading *section of this chapter, which links to the book's GitHub repository.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解`EXPORT_SYMBOL()`宏的工作原理，请参考本章的*进一步阅读*部分，其中链接到了本书的GitHub存储库。
- en: 'Recall our brief discussion on the licensing of kernel modules. The Linux kernel
    has a, shall we say, interesting,proposition: there is also a macro called `EXPORT_SYMBOL_GPL()`.
    It''s just like its cousin, the `EXPORT_SYMBOL()` macro, except that, yes, the
    data item or function exported will only be visible to those kernel modules that
    include the word `GPL` within their `MODULE_LICENSE()` macro! Ah, the sweet revenge
    of the kernel community. It is indeed used in several places in the kernel code
    base. (I''ll leave this as an exercise to you to find occurrences of this macro
    in the code; on the 5.4.0 kernel, a quick search with `cscope(1)` revealed "just"
    14,000 odd usage instances!)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们对内核模块许可的简要讨论。Linux内核有一个，我们可以说，有趣的命题：还有一个名为`EXPORT_SYMBOL_GPL()`的宏。它就像它的表兄弟`EXPORT_SYMBOL()`宏一样，只是，是的，导出的数据项或函数只对那些在他们的`MODULE_LICENSE()`宏中包含`GPL`一词的内核模块可见！啊，内核社区的甜蜜复仇。它确实在内核代码库的几个地方使用。（我会把这留给你作为一个练习，在代码中找到这个宏的出现；在5.4.0内核上，使用`cscope(1)`进行快速搜索，发现“只有”14,000多个使用实例！）
- en: To view all exported symbols, navigate to the root of your kernel source tree
    and issue the `make export_report` command. Note though that this works only upon
    a kernel tree that has been configured and built.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有导出的符号，请导航到内核源树的根目录，并发出`make export_report`命令。请注意，这仅适用于已配置和构建的内核树。
- en: 'Let''s now look at another key approach to realizing a library-like kernel
    feature: module stacking.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下实现类似库的内核特性的另一个关键方法：模块堆叠。
- en: Understanding module stacking
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模块堆叠
- en: The second important idea here – *module stacking* – is what we will now delve
    further into.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个重要想法- *模块堆叠* - 是我们现在将进一步深入研究的。
- en: Module stacking is a concept that provides a "library-like" feature to kernel
    module authors, to a degree. Here, we typically architect our project or product
    design in such a manner that we have one or more "core" kernel modules, whose
    job is to act as a library of sorts. It will include the data structures and functionality
    (functions/APIs) that will be *exported* to other kernel modules (the preceding
    section discussed the exporting of symbols).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 模块堆叠是一个概念，为内核模块作者提供了类似“库”的功能。在这里，我们通常以这样的方式设计我们的项目或产品，有一个或多个“核心”内核模块，其工作是充当某种库。它将包括数据结构和功能（函数/API），这些将被*导出*到其他内核模块（前面的部分讨论了符号的导出）。
- en: 'To better understand this, let''s look at a couple of real examples. To begin
    with, on my host system, an Ubuntu 18.04.3 LTS native Linux system, I ran a guest
    VM(s) over the *Oracle VirtualBox 6.1* hypervisor application*.* Okay, performing
    a quick `lsmod(8)` on the host system while filtering for the string `vbox` reveals
    the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看一些真实的例子。首先，在我的主机系统上，一个Ubuntu 18.04.3 LTS本机Linux系统上，我在*Oracle
    VirtualBox 6.1*虚拟化应用程序上运行了一个或多个客户VM。好的，在主机系统上执行快速的`lsmod(8)`，同时过滤字符串`vbox`，会显示如下内容：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Recall from our earlier discussion that the third column is the *usage count*.
    It's `0` in the first row but has a value of `3` in the third row. Not only that,
    but also the `vboxdrv` kernel module has two kernel modules listed to its right
    (after the usage count column). If any kernel modules show up after the third
    column, they represent **dependencies**; read it this way:the kernel modules displayed
    on the right *depend on* the kernel module on the left.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前的讨论，第三列是*使用计数*。在第一行中是`0`，但在第三行中是`3`。不仅如此，`vboxdrv`内核模块右侧列出了两个内核模块。如果任何内核模块出现在第三列之后，它们代表**依赖关系**；这样读：右侧显示的内核模块*依赖于*左侧的内核模块。
- en: So, in the preceding example, the `vboxnetadp` and `vboxnetflt` kernel modules
    depend on the `vboxdrv` kernel module. *Depend on it* in what way? They use data
    structures and/or functions (APIs) within the `vboxdrv` core kernel module, of
    course! In general, kernel modules showing up on the right of the third column
    imply they are using one or more data structures and/or functions of the kernel
    module on the left (leading to an increment in the usage count; this usage count
    is a good example of a *reference counter* (here, it's actually a 32-bit atomic
    variable)*,* something we delve into in the last chapter). In effect, the `vboxdrv` kernel
    module is akin to a "library" (in a limited sense, with none of the usual userspace
    connotations associated with user-mode libraries except that it provides modular
    functionality). You can see that, in this snapshot, its usage count is `3` and
    the kernel modules that depend on it are stacked on top of it – literally! (You
    can see them in the preceding two lines of `lsmod(1)` output.) Also, notice that
    the `vboxnetflt` kernel module has a positive usage count (`1`) but no kernel
    modules show up on its right; this still implies that something is using it at
    the moment, typically a process or thread.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的例子中，`vboxnetadp`和`vboxnetflt`内核模块依赖于`vboxdrv`内核模块。以什么方式依赖它？当然是使用`vboxdrv`核心内核模块中的数据结构和/或功能（API）！一般来说，出现在第三列右侧的内核模块意味着它们使用左侧内核模块的一个或多个数据结构和/或功能（导致使用计数的增加；这个使用计数是一个*引用计数器*的很好例子（这里，它实际上是一个32位原子变量），这是我们在最后一章中深入讨论的内容）。实际上，`vboxdrv`内核模块类似于一个“库”（在有限的意义上，与用户模式库相关的通常含义除外，除了提供模块化功能）。您可以看到，在这个快照中，它的使用计数是`3`，依赖它的内核模块堆叠在它的上面-字面上！（您可以在`lsmod(1)`输出的前两行中看到它们。）另外，请注意，`vboxnetflt`内核模块有一个正的使用计数（`1`），但在它的右侧没有内核模块显示；这仍然意味着某些东西目前在使用它，通常是一个进程或线程。
- en: FYI, the **Oracle VirtualBox** kernel modules we see in this example are actually
    the implementation of the **VirtualBox Guest Additions**. They are essentially
    a para-virtualization construct, helping to accelerate the working of the guest
    VM. Oracle VirtualBox provides similar functionality for Windows and macOS hosts
    as well (as do all the major virtualization vendors).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: FYI，我们在这个示例中看到的**Oracle VirtualBox**内核模块实际上是**VirtualBox Guest Additions**的实现。它们本质上是一种半虚拟化构造，有助于加速客户VM的工作。Oracle
    VirtualBox也为Windows和macOS主机提供类似的功能（所有主要的虚拟化供应商也是如此）。
- en: 'Another example of module stacking, as promised: running the powerful **LTTng**
    (**Linux Tracing Toolkit next generation**) framework enables you to perform detailed
    system profiling. The LTTng project installs and uses a fairly large number of
    kernel modules (typically 40 or more). Several of these kernel modules are "stacked,"
    allowing the project to leverage precisely the "library-like" feature we have
    been discussing here.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为承诺的模块堆叠的另一个例子：运行强大的**LTTng**（**Linux Tracing Toolkit next generation**）框架使您能够执行详细的系统分析。LTTng项目安装和使用了相当多的内核模块（通常是40个或更多）。其中一些内核模块是“堆叠”的，允许项目精确利用我们在这里讨论的“类似库”的功能。
- en: 'In the following figure (having installed LTTng on a Ubuntu 18.04.4 LTS system),
    see a partial screenshot of the `lsmod | grep --color=auto "^lttng"` output pertaining
    to its kernel modules:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中（在Ubuntu 18.04.4 LTS系统上安装了LTTng后），查看`lsmod | grep --color=auto "^lttng"`输出的部分截图，涉及其内核模块：
- en: '![](img/581dd594-9e25-4e31-a8ea-701dec0f1e30.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/581dd594-9e25-4e31-a8ea-701dec0f1e30.png)'
- en: Figure 5.3 – Heavy module stacking within the LTTng product
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - LTTng产品中的大量模块堆叠
- en: As can be seen, the `lttng_tracer` kernel module has 35 kernel modules on its
    right side, indicating that they are "stacked" upon it, using functionality that
    it provides (similarly, the `lttng_lib_ring_buffer` kernel module has 23 kernel
    modules that "depend" on it).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，`lttng_tracer`内核模块右侧有35个内核模块，表示它们“堆叠”在其上，使用它提供的功能（类似地，`lttng_lib_ring_buffer`内核模块有23个内核模块“依赖”它）。
- en: 'Here''s some quick scripting magic to see all kernel modules whose usage count
    is non-zero (they often – but not always – have some dependent kernel modules
    show up on their right):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些快速的脚本魔法，可以查看所有使用计数非零的内核模块（它们通常 - 但并不总是 - 有一些依赖的内核模块显示在它们的右侧）：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An implication of module stacking: you can only successfully `rmmod(8)` a kernel
    module if its usage count is `0`;  that is, it is not in use. Thus, for the preceding
    first example, we can only remove the `vboxdrv` kernel module after removing the
    two dependent kernel modules that are stacked on it (thus getting the usage count
    down to `0`).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 模块堆叠的一个含义是：只有在使用计数为`0`时，才能成功地`rmmod(8)`一个内核模块；也就是说，它没有在使用中。因此，对于前面的第一个示例，我们只能在移除两个依赖它的内核模块之后（从而将使用计数减少到`0`）才能移除`vboxdrv`内核模块。
- en: Trying out module stacking
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试模块堆叠
- en: 'Let''s architect a very simple proof-of-concept code for module stacking. To
    do so, we will build two kernel modules:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为模块堆叠构建一个非常简单的概念验证代码。为此，我们将构建两个内核模块：
- en: The first we will call `core_lkm`; its job is to act as a "library" of sorts,
    making available to the kernel and other modules a couple of functions (APIs).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个我们将称为`core_lkm`；它的工作是充当一种“库”，为内核和其他模块提供一些函数（API）。
- en: Our second kernel module, `user_lkm`, is the 'user' (or consumer) of the 'library';
    it will simply invoke the functions (and use some data) residing within the first.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第二个内核模块`user_lkm`是“用户”（或消费者）“库”的使用者；它将简单地调用第一个内核模块中的函数（并使用一些数据）。
- en: 'To do so, our pair of kernel modules will need to do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们的一对内核模块需要做到以下几点：
- en: The core kernel module must use the `EXPORT_SYMBOL()` macro to mark some data
    and functions as being *exported*.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心内核模块必须使用`EXPORT_SYMBOL()`宏将一些数据和函数标记为*导出*。
- en: The user kernel module must declare the data and/or functions that it expects
    to use as being external to it, via the C `extern` keyword (remember, exporting
    data or functionality merely sets up the appropriate linkage; the compiler still
    needs to know about the data and/or functions being invoked).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户内核模块必须声明其期望使用的数据和/或函数为外部数据，通过C的`extern`关键字（请记住，导出数据或功能只是设置适当的链接；编译器仍然需要知道被调用的数据和/或函数）。
- en: With recent toolchains, marking the exported function(s) and data items as `static` is
    allowed. A warning results, though; we don't use the `static` keyword for exported
    symbols.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最近的工具链，允许将导出的函数和数据项标记为`static`。但会产生一个警告；我们不使用`static`关键字来导出符号。
- en: Edit the custom Makefile to build both kernel modules.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑自定义Makefile以构建两个内核模块。
- en: 'The code follows; first, the core or library kernel module. To (hopefully)
    make this more interesting, we will copy the code of one of our previous module''s
    functions – `ch5/min_sysinfo/min_sysinfo.c:llkd_sysinfo2()` – into this kernel
    module and *export* it, thus making it visible to our second "user" LKM, which
    will invoke that function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下；首先是核心或库内核模块。为了（希望）使其更有趣，我们将把之前一个模块的函数代码 - `ch5/min_sysinfo/min_sysinfo.c:llkd_sysinfo2()`
    - 复制到这个内核模块中，并*导出*它，从而使其对我们的第二个“用户”LKM可见，后者将调用该函数：
- en: Here, we do not show the full code; you can refer to the book's GitHub repo
    for it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们不显示完整的代码；您可以参考本书的GitHub存储库。
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next is the `user_lkm` kernel module, the one "stacked" on top of the `core_lkm` kernel
    module:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`user_lkm`内核模块，它是“堆叠”在`core_lkm`内核模块之上的一个：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Makefile remains largely identical to our earlier kernel modules, except
    that this time we need two kernel module objects to be built, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile基本上与我们之前的内核模块相同，只是这次我们需要构建两个内核模块对象，如下所示：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Okay, let''s try it out:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们试一下：
- en: 'First, build the kernel modules:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建内核模块：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we're building our kernel modules against our custom 5.4.0 kernel.
    Do notice its full version is `5.4.0-llkd02-kasan`; this is deliberate. This is
    the "debug kernel" that I have built and am using as a test-bed!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在针对我们自定义的5.4.0内核构建我们的内核模块。请注意其完整版本是`5.4.0-llkd02-kasan`；这是故意的。这是我构建并用作测试平台的“调试内核”！
- en: 'Now, let''s perform a quick series of tests to demonstrate the *module stacking *proof
    of concept. Let''s first do it *wrongly*: we will first attempt to insert the `user_lkm`kernel
    module before inserting the `core_lkm`module.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进行一系列快速测试，以演示*模块堆叠*概念的证明。让我们首先*错误地*进行：我们将首先尝试在插入`core_lkm`模块之前插入`user_lkm`内核模块。
- en: 'This will fail – why? You will realize that the exported functionality (and
    data) that the `user_lkm` kernel module depends on is not (yet) available within
    the kernel. More technically, the symbols will not be located within the kernel''s
    symbol table as the `core_lkm`kernel module that has them hasn''t been inserted
    yet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败-为什么？您将意识到`user_lkm`内核模块依赖的导出功能（和数据）尚未（尚未）在内核中可用。更具体地说，符号将不会位于内核的符号表中，因为具有这些符号的`core_lkm`内核模块尚未插入：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As expected, as the required (to-be-exported) symbols are unavailable, `insmod(8)` fails
    (the precise error message you see in the kernel log may vary slightly depending
    on the kernel version and debug config options set).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于所需的（要导出的）符号不可用，`insmod（8）`失败（您在内核日志中看到的精确错误消息可能会略有不同，这取决于内核版本和设置的调试配置选项）。
- en: 'Now, let''s do it right:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们做对：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It works as expected! Check out the modules listing with `lsmod(8)`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它按预期工作！使用`lsmod（8）`检查模块列表：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how, for the `core_lkm` kernel module, the usage countcolumn has incremented
    to `1` *and *we can now see that the `user_lkm` kernel module depends on the `core_lkm` one.
    Recall that the kernel module(s) displayed in the extreme-right columns of `lsmod`'s
    output depend on the one in the extreme-left column.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`core_lkm`内核模块，使用计数列已增加到`1`*并且*现在我们可以看到`user_lkm`内核模块依赖于`core_lkm`。回想一下，在`lsmod`输出的极右列中显示的内核模块依赖于极左列中的内核模块。
- en: 'Now, let''s remove the kernel modules. Removing the kernel modules has an *ordering
    dependency* as well (just as with insertion). Attempting to remove the `core_lkm`one
    first fails, as obviously, there is another module still in kernel memory relying
    upon its code/data; in other words, it''s still in use:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除内核模块。删除内核模块也有*顺序依赖性*（就像插入一样）。首先尝试删除`core_lkm`失败，因为显然，仍然有另一个模块在内核内存中依赖其代码/数据；换句话说，它仍在使用中：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that if the modules are *installed* onto the system, then you could use
    the `modprobe -r <modules...>` command to remove all related modules; we cover
    this topic in the *Auto-loading modules on system boot *section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果模块*安装*到系统上，那么您可以使用`modprobe -r <modules...>`命令来删除所有相关模块；我们将在*系统引导时自动加载模块*部分中介绍这个主题。
- en: 'The preceding `rmmod(8)` failure message is self-explanatory. So, let''s do
    it right:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的`rmmod（8）`失败消息是不言自明的。因此，让我们做对：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There, done!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！
- en: 'You will notice that in the code of the `user_lkm`kernel module, the license
    we release it under is in a conditional `#if` statement:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到在`user_lkm`内核模块的代码中，我们发布的许可是在条件`#if`语句中：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can see that it''s released (by default) under the *Dual MIT/GPL* license;
    well, so what? Think about it: in the code of the `core_lkm`kernel module, we
    have the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它（默认）以*双MIT/GPL*许可发布；那又怎样？想一想：在`core_lkm`内核模块的代码中，我们有以下内容：
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `exp_int` integer is *only visible to those kernel modules that run under
    a GPL license. *So, try this out: change the `#if 1` statement in `core_lkm` to `#if
    0`, thus now releasing it under an MIT-only license. Now, rebuild and retry. It
    *fails* at the build stage itself:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`exp_int`整数*仅对在GPL许可下运行的内核模块可见。*因此，请尝试更改`core_lkm`中的`#if 1`语句为`#if 0`，从而现在仅在MIT许可下发布它。现在，重新构建并重试。它在构建阶段本身*失败*：'
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The license does matter! Before we wind up this section, here''s a quick list
    of things that can go wrong with module stacking; that is, things to check:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 许可确实很重要！在结束本节之前，这里是模块堆叠可能出错的一些事项的快速清单；也就是说，要检查的事项：
- en: The wrong order of kernel modules specified at insertion/at removal
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入/删除时内核模块的错误顺序
- en: 'Attempting to insert an exported routine that is already in kernel memory –
    a namespace collision issue:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试插入已经在内核内存中的导出例程-名称空间冲突问题：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: License issues caused by the usage of the `EXPORT_SYMBOL_GPL()` macro
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用`EXPORT_SYMBOL_GPL（）`宏引起的许可问题
- en: Always look up the kernel log (with `dmesg(1)` or `journalctl(1)`). It often
    helps to show what actually went awry.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 始终查看内核日志（使用`dmesg（1）`或`journalctl（1）`）。它经常有助于显示实际出了什么问题。
- en: 'So, let''s summarize: for emulating a library-like feature within the kernel
    module space, we explored two techniques:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下：为了在内核模块空间中模拟类似库的功能，我们探索了两种技术：
- en: The first technique we used works by *linking multiple source files together
    into a single kernel module*.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的第一种技术通过*将多个源文件链接到单个内核模块中*来工作。
- en: This is as opposed to the *module stacking* technique, where we actually build
    multiple kernel modules and "stack" them on top of each other.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与*模块堆叠*技术相反，后者实际上构建了多个内核模块并将它们“堆叠”在一起。
- en: 'Not only does the first technique work well, it also has these advantages:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术不仅效果很好，而且还具有这些优点：
- en: We do *not* have to explicitly mark (via `EXPORT_SYMBOL()`) every data/function
    symbol that we use as exported.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必明确标记（通过`EXPORT_SYMBOL（）`）我们使用的每个数据/函数符号作为已导出的。
- en: The functions are only available to the kernel module to which it is actually
    linked to (and not the *entire* *kernel, including other modules*). This is a
    good thing! All this at the cost of slightly tweaking the Makefile – well worth
    it.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些功能仅对实际链接到的内核模块可用（而不是*整个*内核，包括其他模块）。这是一件好事！所有这些都是以稍微调整Makefile的代价 - 绝对值得。
- en: 'A downside to the "linking" approach: when linking multiple files, the size
    of the kernel module can grow to be large.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: “链接”方法的一个缺点：在链接多个文件时，内核模块的大小可能会变得很大。
- en: This concludes your learning a powerful feature of kernel programming – the
    ability to link multiple source files together to form one kernel module, and/or
    leveraging the module stacking design, both allowing you to develop more sophisticated
    kernel projects.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您学习内核编程强大功能的结束——将多个源文件链接在一起形成一个内核模块，和/或利用模块堆叠设计，这两者都允许您开发更复杂的内核项目。
- en: In the following section, we dive into the details of how you can pass parameters
    to a kernel module.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨如何向内核模块传递参数。
- en: Passing parameters to a kernel module
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内核模块传递参数
- en: 'A common debugging technique is to *instrument* your code; that is, insert
    prints at appropriate points such that you can follow the path the code takes.
    Within a kernel module, of course, we would use the versatile `printk`function for
    this purpose. So, let''s say we do something like the following (pseudo-code):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的调试技术是*instrument*您的代码；也就是说，在适当的位置插入打印，以便您可以跟踪代码的路径。当然，在内核模块中，我们会使用多功能的`printk`函数来实现这一目的。因此，让我们假设我们做了以下操作（伪代码）：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Okay, great. But we don''t want the debug prints to appear in a production
    (or release) version. That''s precisely why we''re using the `pr_debug()` : it
    emits a printk only when the symbol `DEBUG` is defined! Indeed, but what if, interestingly,
    our customer is an engineering customer and wants to *dynamically turn on or turn
    off these debug prints*? There are several approaches you might take; one is as
    in the following pseudo-code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好。但是我们不希望调试打印出现在生产（或发布）版本中。这正是我们使用`pr_debug()`的原因：它只在定义了符号`DEBUG`时才发出一个printk！确实，但是如果，有趣的是，我们的客户是一个工程客户，并希望*动态打开或关闭这些调试打印*呢？您可能会采取几种方法；其中一种如下伪代码所示：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Ah, that's nice. So, what we're getting at really is this: *what if we can make
    the *`debug_level`* module variable**a parameter to our kernel module?* Then,
    a powerful thing, the user of your kernel module has control over which debug
    messages appear or not.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这很好。那么，我们真正要说的是：*如果我们可以将*`debug_level`*模块变量**作为我们的内核模块的参数*，那将是一个强大的功能，内核模块的用户可以控制哪些调试消息出现或不出现。
- en: Declaring and using module parameters
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和使用模块参数
- en: 'Module parameters are passed to a kernel module as *name=value* pairs at module
    insertion (`insmod`) time. For example, assume we have a *module parameter* named
    `mp_debug_level`; then, we could pass its value at `insmod(8)` time, like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 模块参数作为*name=value*对在模块插入（`insmod`）时传递给内核模块。例如，假设我们有一个名为`mp_debug_level`的*模块参数*，那么我们可以在`insmod(8)`时传递其值，如下所示：
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the `mp` prefix stands for module parameter. It's not required to name
    it that way, of course, it is pedantic, but might  just makes it a bit more intuitive.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mp`前缀代表模块参数。当然，不一定要这样命名，这有点迂腐，但可能会使其更直观一些。
- en: That would be powerful. Now, the end user can decide at exactly what *verbosity* they
    want the *debug-level* messages. We can even easily arrange for the default value
    to be `0`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是强大的。现在，最终用户可以决定*verbosity* 他们希望*debug-level* 消息。我们甚至可以轻松安排默认值为`0`。
- en: 'You might wonder: kernel modules have no `main()` function and hence no conventional `(argc,
    argv)` parameter list, so how exactly, then, do you pass parameters along? The
    fact is, it''s a bit of linker trickery; just do this: declare your intended module
    parameter as a global (`static`) variable, then specify to the build system that
    it''s to be treated as a module parameter by employing the `module_param()` macro.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想：内核模块没有`main()`函数，因此没有常规的`(argc, argv)`参数列表，那么您究竟如何传递参数呢？事实上，这是一种链接器的技巧；只需这样做：将您打算的模块参数声明为全局（静态）变量，然后通过使用`module_param()`宏指定构建系统将其视为模块参数。
- en: 'This is easy to see with our first module parameter''s demo kernel module (as
    usual, the full source code and Makefile can be found in the book''s GitHub repo):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的第一个模块参数的演示内核模块，这一点很容易看出（通常情况下，完整的源代码和`Makefile`可以在本书的GitHub存储库中找到）：
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `static int mp_debug_level;` statement, there is no harm in changing
    it to `static int mp_debug_level = 0; `, thus explicitly initializing the variable
    to 0, right? Well, no: the kernel''s `scripts/checkpatch.pl` script output reveals
    that this is not considered good coding style by the kernel community:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`static int mp_debug_level;`语句中，将其更改为`static int mp_debug_level = 0;`是没有害处的，这样明确地将变量初始化为0，对吗？嗯，不是的：内核的`scripts/checkpatch.pl`脚本输出显示，内核社区并不认为这是良好的编码风格：
- en: '`ERROR: do not initialise statics to 0`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ERROR: do not initialise statics to 0`'
- en: '`#28: FILE: modparams1.c:28:`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`#28: FILE: modparams1.c:28:`'
- en: '`+static int mp_debug_level = 0;`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`+static int mp_debug_level = 0;`'
- en: 'In the preceding code block, we have declared two variables to be module parameters
    via the `module_param()` macro. The `module_param()` macro takes three parameters:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，我们通过`module_param()`宏声明了两个模块参数。`module_param()`宏接受三个参数：
- en: 'The first parameter: the variable name (which we would like treated as a module
    parameter). This should be declared using the `static` qualifier.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数：变量名（我们希望将其视为模块参数）。这应该使用`static`限定符声明。
- en: 'The second parameter: its data type.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数：其数据类型。
- en: 'The third parameter: permissions (really, its visibility via `sysfs`; this
    is explained as follows).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数：权限（实际上，它通过`sysfs`的可见性；这将在下文中解释）。
- en: 'The `MODULE_PARM_DESC()` macro allows us to "describe" what the parameter represents.
    Think about it, this is how you inform the end user of the kernel module (or driver)
    and what parameters are actually available. The lookup is performed via the `modinfo(8)` utility.
    Furthermore, you can specifically print only the information on parameters to
    a module by using the `-p` option switch, as shown:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODULE_PARM_DESC()`宏允许我们“描述”参数代表什么。想想看，这是如何通知内核模块（或驱动程序）的最终用户以及实际可用的参数。查找是通过`modinfo(8)`实用程序执行的。此外，您可以使用`-p`选项开关，仅将参数信息打印到模块，如下所示：'
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `modinfo(8)` output displays available module parameters, if any. Here,
    we can see that our `modparams1.ko` kernel module has two parameters, their name,
    description, and data type (within parentheses; `charp` is character pointer,
    a string) is shown. Right, let''s now give our demo kernel module a quick spin:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`modinfo(8)`输出显示可用的模块参数（如果有的话）。在这里，我们可以看到我们的`modparams1.ko`内核模块有两个参数，它们的名称、描述和数据类型（在括号内；`charp`是字符指针，一个字符串）都显示出来了。好了，现在让我们快速运行一下我们的演示内核模块：'
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we see from the `dmesg(1)` output that, as we did not explicitly pass
    any kernel module parameters, the module variables obviously retain their default
    (original) values. Let''s redo this, this time passing explicit values to the
    module parameters:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`dmesg(1)`输出中看到，由于我们没有显式传递任何内核模块参数，模块变量显然保留了它们的默认（原始）值。让我们重新做一遍，这次传递显式值给模块参数：
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It works as expected. Now that we've seen how to declare and pass along some
    parameters to a kernel module, let's look at retrieving or even modifying them
    at runtime.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。既然我们已经看到了如何声明和传递一些参数给内核模块，现在让我们来看看如何在运行时检索甚至修改它们。
- en: Getting/setting module parameters after insertion
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入后获取/设置模块参数
- en: 'Let''s look carefully at the `module_param()` macro usage in our preceding `modparams1.c`
    source file again:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下我们之前的`modparams1.c`源文件中`module_param()`宏的用法：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice the third parameter, the *permissions* (or *mode*): it''s `0660` (which,
    of course, is an *octal* number, implying read-write access for the owner and
    group and no access for others). It''s a bit confusing until you realize that
    if the permissionsparameter is specified as non-zero, pseudo-file(s) get created
    under the `sysfs` filesystem, representing the kernel module parameter(s), here: `/sys/module/<module-name>/parameters/`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第三个参数，*权限*（或*模式*）：它是`0660`（当然，这是一个*八进制*数，意味着所有者和组有读写访问权限，其他人没有访问权限）。这有点令人困惑，直到你意识到如果指定了*permissions*参数为非零，伪文件将在`sysfs`文件系统下创建，表示内核模块参数，这里是：`/sys/module/<module-name>/parameters/`：
- en: '`sysfs` is usually mounted under `/sys`. Also, by default, all pseudo-files
    will have the owner and group as root.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysfs`通常挂载在`/sys`下。此外，默认情况下，所有伪文件的所有者和组都是root。'
- en: 'So, for our `modparams1` kernel module (assuming it''s loaded into kernel memory),
    let''s look them up:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，对于我们的`modparams1`内核模块（假设它加载到内核内存中），让我们查找它们：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Indeed, there they are! Not only that, the real beauty of it is that these "parameters"
    can now be read and written at will, at any time (though only with root permission,
    of course)!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，它们在那里！不仅如此，它的真正美妙之处在于这些“参数”现在可以随意读取和写入，任何时候（当然只有root权限）！
- en: 'Check it out:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一下：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Yes, the current value of our `mp_debug_level` kernel module parameter is indeed `2`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们的`mp_debug_level`内核模块参数的当前值确实是`2`。
- en: 'Let''s dynamically change it to `0`, implying that no "debug" messages will
    be emitted by the `modparams1` kernel module:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们动态将其更改为`0`，表示`modparams1`内核模块不会发出“调试”消息：
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Voilà, done. You can similarly get and/or set the `mp_strparam` parameter;
    we will leave it to you to try this as a simple exercise. This is powerful stuff:
    you could write simple scripts to control a device (or whatever) behavior via
    kernel module parameters, get (or cut off) debug info, and so on; the possibilities
    are quite endless.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。您可以类似地获取和/或设置`mp_strparam`参数；我们将留给您尝试这个作为一个简单的练习。这是强大的东西：您可以编写简单的脚本来通过内核模块参数控制设备（或其他内容）的行为，获取（或切断）调试信息等等；可能性是相当无限的。
- en: 'Actually, coding the third parameter to `module_param()` as a literal octal
    number (such as `0660`) is not considered best programming practice in some circles.
    Specify the permissions of the `sysfs` pseudo-file via appropriate macros (specified
    in `include/uapi/linux/stat.h`), for example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将`module_param()`的第三个参数编码为字面八进制数（例如`0660`）在某些圈子里不被认为是最佳的编程实践。通过适当的宏（在`include/uapi/linux/stat.h`中指定）指定`sysfs`伪文件的权限，例如：
- en: '[PRE51]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, having said this, our "better" Makefile''s *checkpatch* target (which,
    of course, invokes the kernel''s `scripts/checkpatch.pl` "coding-style" Perl script
    checker) politely informs us that simply using octal permissions is better:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，话虽如此，我们的“更好”的*Makefile*的*checkpatch*目标（当然，调用内核的`scripts/checkpatch.pl`“编码风格”Perl脚本检查器）礼貌地告诉我们，简单地使用八进制权限更好：
- en: '[PRE52]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, the kernel community disagrees. Hence, we will just use the "usual" octal
    number notation of `0660`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内核社区并不同意。因此，我们将只使用“通常”的八进制数表示法`0660`。
- en: Module parameter data types and validation
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块参数数据类型和验证
- en: 'In our preceding simple kernel module, we set up two parameters of the integer
    and string data types (`charp`). What other data types can be used? Several, as
    it turns out: the `moduleparam.h` include file reveals all (within a comment,
    duplicated as follows):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的简单内核模块中，我们设置了整数和字符串数据类型（`charp`）的两个参数。还可以使用哪些数据类型？事实证明有几种，`moduleparam.h`包含文件中都有（在注释中重复显示）：
- en: '[PRE53]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can even define your own data types, if required. Usually, though, the standard
    types more than suffice.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以根据需要定义自己的数据类型。通常，标准类型已经足够了。
- en: Validating kernel module parameters
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证内核模块参数
- en: 'All kernel module parameters are *optional *by default; the user may or may
    not explicitly pass them. But what if our project requires thatthe user *must
    explicitly pass* a value for a given kernel module parameter? We address this
    here: let''s enhance our previous kernel module, creating another (`ch5/modparams/modparams2`),
    the key difference being that we set up an additional parameter called `control_freak`.
    Now, we *require* that the user *must* pass this parameter along at module insertion
    time:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内核模块参数默认都是*可选的*；用户可以选择是否显式传递它们。但是如果我们的项目要求用户*必须显式传递*给定内核模块参数的值怎么办？我们在这里解决这个问题：让我们增强我们之前的内核模块，创建另一个（`ch5/modparams/modparams2`），关键区别在于我们设置了一个名为`control_freak`的额外参数。现在，我们*要求*用户在模块插入时*必须*传递这个参数：
- en: 'Let''s set up the new module parameter in code:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中设置新的模块参数：
- en: '[PRE54]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'How can we achieve this "mandatory passing"? Well, it''s a bit of a hack really:
    just check at insertion time whether the value is the default (`0`, here). If
    so, then abort with an appropriate message (we also do a simple validity check
    to ensure that the integer passed is within a given range). Here''s the init code
    of `ch5/modparams/modparams2/modparams2.c`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现这种“强制传递”呢？嗯，这实际上有点小聪明：只需在插入时检查值是否为默认值（这里是`0`）。如果是，默认值，那么用适当的消息中止（我们还进行了一个简单的有效性检查，以确保传递的整数在给定范围内）。以下是`ch5/modparams/modparams2/modparams2.c`的初始化代码：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Also, as a quick demo, notice how we emit a printk, showing the module parameter
    values only if `mp_debug_level` is positive.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，作为一个快速演示，注意我们如何发出一个`printk`，只有当`mp_debug_level`为正数时才显示模块参数值。
- en: Finally, on this topic, the kernel framework provides a more rigorous way to
    "get/set" kernel (module) parameters and perform validity checking on them via
    the `module_parm_cb()` macro (`cb` for callbacks). We will not delve into this
    here; I refer you to a blog article mentioned in the *Further reading* document
    for details on using it.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在这个话题上，内核框架提供了一种更严格的方式来“获取/设置”内核（模块）参数并对其进行有效性检查，通过`module_parm_cb()`宏（`cb`代表回调）。我们不会在这里深入讨论这个问题；我建议你参考*进一步阅读*文档中提到的博客文章，了解如何使用它的详细信息。
- en: Now, let's move on to how (and why) we can override a module parameter's name.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论如何（以及为什么）覆盖模块参数的名称。
- en: Overriding the module parameter's name
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖模块参数的名称
- en: 'To explain this feature, let''s take an example from the (5.4.0) kernel source
    tree: the direct mapping buffered I/O library driver, `drivers/md/dm-bufio.c`,
    has a need to use the `dm_bufio_current_allocated` variable as a module parameter.
    However, this name is really that of an *internal variable* and is not highly
    intuitive to a user of this driver. The authors of this driver would much prefer
    to use another name – `current_allocated_bytes` – as an *alias* or *name override.*
    Precisely this can be achieved via the `module_param_named()` macro, overriding
    and completely equivalent to the internal variable name, as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个特性，让我们以(5.4.0)内核源代码树中的一个例子来说明：直接映射缓冲I/O库驱动程序`drivers/md/dm-bufio.c`需要使用`dm_bufio_current_allocated`变量作为模块参数。然而，这个名称实际上是一个*内部变量*，对于这个驱动程序的用户来说并不是非常直观的。这个驱动程序的作者更希望使用另一个名称——`current_allocated_bytes`——作为*别名*或*名称覆盖*。可以通过`module_param_named()`宏来实现这一点，通过覆盖并完全等效于内部变量名称的方式，如下所示：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So, when the user performs `insmod` on this driver, they can do stuff like
    the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户对这个驱动程序执行`insmod`时，他们可以做如下的事情：
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Internally, the actual variable, `dm_bufio_current_allocated`, will be assigned
    the value `4096`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，实际变量`dm_bufio_current_allocated`将被赋值为`4096`。
- en: Hardware-related kernel parameters
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与硬件相关的内核参数
- en: 'For security reasons, module or kernel parameters that specify hardware-specific
    values have a separate macro – `module_param_hw[_named|array]()`. David Howells
    submitted a patch series for these new hardware parameters kernel support on 1
    December 2016\. The patch email [[https://lwn.net/Articles/708274/](https://lwn.net/Articles/708274/)]
    mentions the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，指定硬件特定值的模块或内核参数有一个单独的宏——`module_param_hw[_named|array]()`. David Howells于2016年12月1日提交了一系列补丁，用于支持这些新的硬件参数内核。补丁邮件[[https://lwn.net/Articles/708274/](https://lwn.net/Articles/708274/)]提到了以下内容：
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That concludes our discussion on kernel module parameters. Let's move on to
    a peculiar aspect – that of floating-point usage within the kernel.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对内核模块参数的讨论。让我们继续讨论一个特殊的方面——内核中的浮点使用。
- en: Floating point not allowed in the kernel
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核中不允许浮点数
- en: 'Years ago, when working on a temperature sensor device driver, I had an amusing
    experience (though it wasn''t quite so amusing at the time). Attempting to express
    a temperature value in millidegrees Celsius as a "regular" temperature value in
    degrees Celsius, I did something like the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，当我在温度传感器设备驱动程序上工作时，我有过一次有趣的经历（尽管当时并不那么有趣）。试图将毫摄氏度作为“常规”摄氏度值来表达温度值时，我做了类似以下的事情：
- en: '[PRE59]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It all went bad from there!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起一切都变得糟糕了！
- en: The venerable LDD (*Linux Device Drivers*, by *Corbet, Rubini, and G-K-Hartman*)
    book pointed out my error – **floating-point** (FP) arithmetic is not allowed
    in kernel space! It's a conscious design decision – saving processor (FP) state,
    turning on the FP unit, working on and then turning off and restoring the FP state
    is just not considered a worthwhile thing to do while in the kernel. The kernel
    (or driver) developer is well advised *to* just not attempt performing FP work
    while in kernel space.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 备受尊敬的LDD（*Linux设备驱动程序*，作者为*Corbet, Rubini, and G-K-Hartman*）书指出了我的错误——**浮点**（FP）算术在内核空间是不允许的！这是一个有意识的设计决定——保存处理器（FP）状态，打开FP单元，进行操作，然后关闭和恢复FP状态在内核中并不被认为是值得做的事情。内核（或驱动程序）开发人员最好*不要*在内核空间尝试执行FP工作。
- en: 'Well, then, you ask, how can you do the (in my example) temperature conversion?
    Simple: pass the *integer* millidegrees Celsius value *to userspace* and perform
    the FP work there!'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你会问，那你怎么做（以我的例子为例）温度转换呢？简单：将*整数*毫摄氏度值*传递给用户空间*，然后在那里执行FP工作！
- en: 'Having said that, there is apparently a way to force the kernel to perform
    FP: put your floating-point code between the `kernel_fpu_begin()` and `kernel_fpu_end()` macros.
    There are a few places where precisely this technique is used within the kernel
    code base (typically, some code paths covering crypto/AES, CRC, and so on). Regardless,
    the recommendation is that the typical module (or driver) developer *performs
    only integer arithmetic within the kernel*.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，显然有一种方法可以强制内核执行FP：将你的浮点代码放在`kernel_fpu_begin()`和`kernel_fpu_end()`宏之间。在内核代码库中有一些地方确实使用了这种技术（通常是一些涵盖加密/AES、CRC等的代码路径）。不过，建议是典型的模块（或驱动程序）开发人员*只在内核中执行整数算术*。
- en: 'Nevertheless, to test this whole scenario (always remember, *the* *empirical
    approach – actually trying things out – is the only realistic way forward!*)*,* we
    write a simple kernel module that attempts to perform some FP work. The key part
    of the code is shown here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，为了测试整个场景（永远记住，*实证方法 - 实际尝试事物 - 是唯一现实的前进方式！*），我们编写了一个简单的内核模块，试图执行一些FP工作。代码的关键部分在这里显示：
- en: '[PRE60]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It actually works, *until* *we attempt to display the FP value via* `printk()`!
    At that point, it goes quite berserk. See the following screenshot:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上是有效的，*直到* *我们尝试通过* `printk()` *显示FP值*！在那一点上，它变得非常疯狂。请看下面的截图：
- en: '![](img/63160f27-b5bc-47f0-9d4d-2b10782e941b.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63160f27-b5bc-47f0-9d4d-2b10782e941b.png)'
- en: Figure 5.4 – The output of WARN_ONCE() when we try and print an FP number in
    kernel space
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 当我们尝试在内核空间中打印FP数字时，WARN_ONCE()的输出
- en: The key line is `Please remove unsupported %f in format string`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 关键行是`Please remove unsupported %f in format string`。
- en: This tells us the story. The system does not actually crash or panic as this
    is a mere `WARNING`, spat out to the kernel log via the `WARN_ONCE()` macro. Do
    realize, though, that on a production system, the `/proc/sys/kernel/panic_on_warn` pseudo-file will,
    in all probability, be set to the value `1`, causing the kernel to (quite rightly)
    panic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们一个故事。系统实际上并没有崩溃或恐慌，因为这只是一个通过`WARN_ONCE()`宏输出到内核日志的*警告*。但请注意，在生产系统上，`/proc/sys/kernel/panic_on_warn`伪文件很可能被设置为值`1`，导致内核（完全正确地）恐慌。
- en: The section in the preceding screenshot (Figure 5.3) beginning with `Call Trace:`
    is, of course, a peek into the current state of the *kernel-mode stack* of the
    process or thread that was "caught" in the preceding `WARN_ONCE()` code path (hang
    on, you will learn key details regarding the user- and kernel-mode stacks and
    so on in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel Internals
    Essentials – Processes and Threads*). Interpret the kernel stack by reading it
    in a bottom-up fashion; so here, the `do_one_initcall` function called `fp_in_lkm_init`
    (which belongs to the kernel module in square brackets, `[fp_in_lkm_init]`), which
    then calls `printk()`, which then ends up causing all kinds of trouble as it attempts
    to print a FP (floating point) quantity!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图（图5.3）中的部分，从`Call Trace:`开始，当然是对进程或线程的*内核模式堆栈*的当前状态的一瞥，它是在前面的`WARN_ONCE()`代码路径中“捕获”的（稍等，你将在[第6章](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml)中学到关于用户模式和内核模式堆栈等关键细节）。通过自下而上地阅读内核堆栈来解释内核堆栈；所以在这里，`do_one_initcall`函数调用了属于方括号中的内核模块的`fp_in_lkm_init`（`[fp_in_lkm_init]`），然后调用了`printk()`，然后试图打印FP（浮点）数量，结果导致了各种麻烦！
- en: 'The moral is clear: *avoid using floating-point math within kernel space*.
    Let''s now move on to the topic of how you can install and auto-load kernel modules
    on system startup.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的道理是：*避免在内核空间中使用浮点数运算*。现在让我们继续讨论如何在系统启动时安装和自动加载内核模块。
- en: Auto-loading modules on system boot
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在系统启动时自动加载模块
- en: Until now, we have written simple "out-of-tree" kernel modules that reside in
    their own private directories and have to be manually loaded up, typically via
    the `insmod(8)` or `modprobe(8)` utilities. In most real-world projects and products,
    you will require your out-of-tree kernel module(s) *to be* *auto-loaded at boot*.
    This section covers how you can achieve this.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写了简单的“外部”内核模块，它们驻留在自己的私有目录中，并且通常需要通过`insmod(8)`或`modprobe(8)`实用程序手动加载。在大多数真实项目和产品中，你将需要*在启动时自动加载*你的外部内核模块。本节介绍了如何实现这一点。
- en: 'Consider we have a kernel module named `foo.ko`. We assume we have access to
    the source code and Makefile. In order to have it *auto-load *on system boot,
    you need to first *install* the kernel module to a known location on the system.
    To do so, we expect that the Makefile for the module contains an `install` target,
    typically:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`foo.ko`的内核模块。我们假设我们可以访问源代码和Makefile。为了在系统启动时*自动加载*它，你需要首先将内核模块*安装*到系统上已知的位置。为此，我们期望模块的Makefile包含一个`install`目标，通常是：
- en: '[PRE61]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is not something new; we have been placing the `install`target within the
    `Makefile`'s of our demo kernel modules.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么新鲜事；我们一直在我们的演示内核模块的`Makefile`中放置`install`目标。
- en: 'To demonstrate this "auto-load" procedure, we have shown the set of steps to
    follow in order to actually *install and auto-load on boot* our `ch5/min_sysinfo`
    kernel module:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个“自动加载”过程，我们展示了实际*安装和自动加载*我们的`ch5/min_sysinfo`内核模块的步骤：
- en: 'First, change directory to the module''s source directory:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，切换到模块的源目录：
- en: '[PRE62]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, it''s important to first build the kernel module (with `make`), and,
    on success, install it (as you''ll soon see, our ''better'' Makefile makes the
    process simpler by guaranteeing that the build is done first, followed by the
    install and the `depmod`):'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，首先重要的是构建内核模块（使用`make`），并且在成功后安装它（很快你会看到，我们的“更好”的Makefile通过保证先进行构建，然后进行安装和`depmod`来简化这个过程）：
- en: '[PRE63]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Assuming it builds, the `sudo make install` command then *installs* the kernel
    module here, `/lib/modules/<kernel-ver>/extra/`, as expected (do see the following
    info box and tips as well):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它构建成功，`sudo make install`命令然后会在`/lib/modules/<kernel-ver>/extra/`安装内核模块，这是预期的（也请看下面的信息框和提示）：
- en: '[PRE64]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: During `sudo make install`, it's possible you might see (non-fatal) errors regarding
    SSL; they can be safely ignored. They indicate that the system failed to "sign"
    the kernel module. More on this in the note on security coming up.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sudo make install`期间，可能会看到关于SSL的（非致命的）错误；它们可以安全地忽略。它们表明系统未能“签名”内核模块。关于这一点，稍后会有关于安全性的说明。
- en: 'Also, just in case you find that `sudo make install` fails, try the following
    approaches:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你发现`sudo make install`失败，也可以尝试以下方法：
- en: a) Switch to a root shell (`sudo -s`) and within it, run the `make ; make install`
    commands.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: a) 切换到root shell（`sudo -s`）并在其中运行`make ; make install`命令。
- en: 'b) A useful reference: *Makefile: installing external Linux kernel module,
    StackOverflow, June 2016* ([https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module](https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module)).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'b) 一个有用的参考资料：*Makefile: installing external Linux kernel module, StackOverflow,
    June 2016* ([https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module](https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module))。'
- en: 'Another module utility, called `depmod(8)`, is then typically invoked by default
    within `sudo make install` (as can be seen from the preceding output). Just in
    case (for whatever reason) this has not occurred, you can always manually invoke `depmod`:
    its job is essentially to resolve module dependencies (see its man page for details):
    `sudo depmod`. Once you install the kernel module, you can see the effect of `depmod(8)` with
    its `--dry-run` option switch:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通常会在`sudo make install`中默认调用另一个模块实用程序`depmod(8)`（可以从前面的输出中看到）。以防万一（无论出于什么原因），这没有发生，您总是可以手动调用`depmod`：它的工作基本上是解决模块依赖关系（有关详细信息，请参阅其手册页）：`sudo
    depmod`。安装内核模块后，您可以使用其`--dry-run`选项开关查看`depmod(8)`的效果：
- en: '[PRE65]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Auto-load the kernel module on boot: One way is create the `/etc/modules-load.d/<foo>.conf` config
    file (of course, you will need root access to create this file); the simple case:
    just put the kernel module''s `foo` name inside, that''s it. Any line starting
    with a `#` character is treated as a comment and ignored. For our `min_sysinfo`
    example, we have the following:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动时自动加载内核模块：一种方法是创建`/etc/modules-load.d/<foo>.conf`配置文件（当然，您需要root访问权限来创建此文件）；简单情况：只需在其中放入内核模块的`foo`名称，就是这样。任何以`#`字符开头的行都被视为注释并被忽略。对于我们的`min_sysinfo`示例，我们有以下内容：
- en: '[PRE66]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: FYI, another (even simpler) way to inform systemd to load up our kernel module
    is to enter the *name* of the module into the (preexisting) `/etc/modules-load.d/modules.conf` file.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，通知systemd加载我们的内核模块的另一种（甚至更简单的）方法是将模块的*名称*输入到（现有的）`/etc/modules-load.d/modules.conf`文件中。
- en: Reboot the system with `sync; sudo reboot`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sync; sudo reboot`重新启动系统。
- en: 'Once the system is up, use `lsmod(8)` and look up the kernel log (with `dmesg(1)`, perhaps).
    You should see relevant info pertaining to the kernel module loading up (in our
    example, `min_sysinfo`):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动后，使用`lsmod(8)`并查看内核日志（也许可以用`dmesg(1)`）。您应该会看到与内核模块加载相关的相关信息（在我们的示例中是`min_sysinfo`）。
- en: '[PRE67]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There, it''s done: our `min_sysinfo` kernel module has indeed been auto-loaded
    into kernel space on boot!'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，完成了：我们的`min_sysinfo`内核模块确实已经在启动时自动加载到内核空间中！
- en: 'As you just learned, you must first build your kernel module and then perform
    the install; to help automate this, our ''better'' Makefile has the following
    in it''s module installation `install` target:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚刚学到的，您必须首先构建您的内核模块，然后执行安装；为了帮助自动化这一过程，我们的“更好”的Makefile在其模块安装`install`目标中包含以下内容：
- en: '[PRE68]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It ensures that, first, the build is done, followed by the install and (explicitly)
    the `depmod(8)`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 它确保首先进行构建，然后进行安装，（显式地）进行`depmod(8)`。
- en: 'What if your auto-loaded kernel module requires some (module) parameters passed
    at load time? There are two ways to assure that this happens: via a so-called
    modprobe config file (under `/etc/modprobe.d/`) or, if the module''s built-in
    to the kernel, via the kernel command line.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的自动加载的内核模块在加载时需要传递一些（模块）参数，该怎么办？有两种方法可以确保这种情况发生：通过所谓的modprobe配置文件（在`/etc/modprobe.d/`下）或者，如果模块是内核内置的，通过内核命令行。
- en: 'Here we show the first way: simply setup your modprobe configuration file (as
    an example here, we use the name `mykmod` as the name of our LKM; again, you require
    root access to create this file): `/etc/modprobe.d/mykmod.conf`; in it, you can
    pass parameters like this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们展示第一种方法：简单地设置您的modprobe配置文件（在这里作为示例，我们使用`mykmod`作为我们LKM的名称；同样，您需要root访问权限来创建此文件）：`/etc/modprobe.d/mykmod.conf`；在其中，您可以像这样传递参数：
- en: '[PRE69]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As an example, the `/etc/modprobe.d/alsa-base.conf` modprobe config file on
    my x86_64 Ubuntu 20.04 LTS system contains the lines (among several others):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我的x86_64 Ubuntu 20.04 LTS系统上的`/etc/modprobe.d/alsa-base.conf` modprobe配置文件包含以下行（还有其他几行）：
- en: '[PRE70]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A few more points on kernel module auto-loading related items follow.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是有关内核模块自动加载相关项目的一些要点。
- en: Module auto-loading – additional details
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块自动加载-其他详细信息
- en: 'Once a kernel module has been installed on a system (via `sudo make install`,
    as shown previously), you can also insert it into the kernel interactively (or
    via a script) simply by using a "smarter" version of the `insmod(8)` utility,
    called `modprobe(8)`. For our example, we could first `rmmod(8)` the module and
    then do the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内核模块已经通过`sudo make install`安装到系统上（如前所示），您还可以通过一个“更智能”的`insmod(8)`实用程序的版本，称为`modprobe(8)`，将其插入内核交互式地（或通过脚本）。对于我们的示例，我们可以首先`rmmod(8)`模块，然后执行以下操作：
- en: '[PRE71]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As an interesting aside, consider the following. In cases where there are several
    kernel module objects to load (for example, the *module stacking* design), how
    does `modprobe` know the *order* in which to load up kernel modules? When performing
    a build locally, the build process generates a file called `modules.order`. It
    tells utilities such as `modprobe` the order in which to load up kernel modules
    such that all dependencies are resolved. When kernel modules are *installed *into
    the kernel (that is, into the `/lib/modules/$(uname -r)/extra/`, or similar, location),
    the `depmod(8)` utility generates a `/lib/modules/$(uname -r)/modules.dep` file. This
    contains the dependency information – it specifies whether a kernel module depends
    on another. Using this information, modprobe then loads them up in the required
    order. To flesh this out, let''s install our module stacking example:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在有多个内核模块对象要加载的情况下（例如，*模块堆叠*设计），`modprobe`如何知道加载内核模块的*顺序*？在本地进行构建时，构建过程会生成一个名为`modules.order`的文件。它告诉诸如`modprobe`之类的实用程序加载内核模块的顺序，以便解决所有依赖关系。当内核模块被*安装*到内核中（即，到`/lib/modules/$(uname
    -r)/extra/`或类似位置），`depmod(8)`实用程序会生成一个`/lib/modules/$(uname -r)/modules.dep`文件。其中包含依赖信息
    - 它指定一个内核模块是否依赖于另一个。使用这些信息，modprobe然后按照所需的顺序加载它们。为了充实这一点，让我们安装我们的模块堆叠示例：
- en: '[PRE72]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Clearly, the two kernel modules from our module stacking example (`core_lkm.ko`
    and `user_lkm.ko`) are now installed under the expected location, `/lib/modules/$(uname
    -r)/extra/`. Now, check this out:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们模块堆叠示例中的两个内核模块（`core_lkm.ko`和`user_lkm.ko`）现在安装在预期位置`/lib/modules/$(uname
    -r)/extra/`下。现在，来看一下这个：
- en: '[PRE73]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The first line of output after `grep` is relevant: `depmod` has arranged for
    the `modules.dep` file to show that the `extra/user_lkm.ko` kernel module depends
    on the `extra/core_lkm.ko` kernel module (via the `<k1.ko>: <k2.ko>...` notation,
    implying that the `k1.ko` module depends on the `k2.ko` module). Thus, modprobe,
    seeing this, loads them in the required order, avoiding any issues.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`后的第一行输出是相关的：`depmod`已经安排`modules.dep`文件显示`extra/user_lkm.ko`内核模块依赖于`extra/core_lkm.ko`内核模块（通过`<k1.ko>:
    <k2.ko>...`表示，意味着`k1.ko`模块依赖于`k2.ko`模块）。因此，modprobe看到这一点，按照所需的顺序加载它们，避免任何问题。'
- en: (FYI, while on this topic, the generated `Module.symvers` file has information
    on all exported symbols.)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，谈到这个话题，生成的`Module.symvers`文件包含所有导出符号的信息。）
- en: Next, recall the new(ish) `init` framework on Linux, *systemd*. The fact is,
    on modern Linux systems, it's actually systemd that takes care of auto-loading
    kernel modules at system boot, by parsing the content of files such as `/etc/modules-load.d/*` (the
    systemd service responsible for this is `systemd-modules-load.service(8)`. For
    details, refer to the man page on `modules-load.d(5)`).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回想一下Linux上的新（ish）`init`框架，*systemd*。事实上，在现代Linux系统上，实际上是systemd负责在系统启动时自动加载内核模块，通过解析诸如`/etc/modules-load.d/*`之类的文件的内容（负责此操作的systemd服务是`systemd-modules-load.service(8)`。有关详细信息，请参阅`modules-load.d(5)`的man页面）。
- en: 'Conversely, sometimes you might find that a certain auto-loaded kernel module
    is misbehaving – causing lockups or delays, or it simply doesn''t work – and so
    you want to definitely disable loading it. This can be done by *blacklisting*the
    module. You can specify this either on the kernel command line (convenient when
    all else fails!) or within the (previously mentioned) `/etc/modules-load.d/<foo>.conf`
    config file. On the kernel command line, via `module_blacklist=mod1,mod2,...`,
    the kernel docs shows us the syntax/explanation:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有时您可能会发现某个自动加载的内核模块表现不佳 - 导致死机或延迟，或者根本不起作用 - 因此您肯定想要禁用它的加载。这可以通过*黑名单*模块来实现。您可以在内核命令行上指定这一点（当其他方法都失败时很方便！）或者在（前面提到的）`/etc/modules-load.d/<foo>.conf`配置文件中指定。在内核命令行上，通过`module_blacklist=mod1,mod2,...`，内核文档向我们展示了语法/解释：
- en: '[PRE74]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can look up the current kernel command line by doing `cat /proc/cmdline`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行`cat /proc/cmdline`来查找当前的内核命令行。
- en: 'While on the topic of the kernel command line, several other useful options
    exist, enabling us to use the kernel''s help for debugging issues concerned with
    kernel initialization. As an example, among several others, the kernel provides
    the following parameters in this regard (source: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到内核命令行，还存在一些其他有用的选项，使我们能够使用内核的帮助来调试与内核初始化有关的问题。例如，内核在这方面提供了以下参数之一（来源：[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)）：
- en: '[PRE75]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: FYI, and as mentioned earlier in this chapter, there is an alternate framework
    for third-party kernel module auto-rebuilding, called **Dynamic Kernel Module
    Support** (**DKMS**).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，并且正如本章前面提到的，还有一个用于第三方内核模块自动重建的替代框架，称为**动态内核模块支持**（**DKMS**）。
- en: The *Further reading *document for this chapter also provides some helpful links.
    In conclusion, auto-loading kernel modules into memory on system startup is a
    useful and often required functionality in a product. Building high-quality products
    requires a keen understanding of, and the knowledge to build in, *security*; that's
    the topic of the next section.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*进一步阅读*文档还提供了一些有用的链接。总之，在系统启动时将内核模块自动加载到内存中是一个有用且经常需要的功能。构建高质量的产品需要对*安全性*有深刻的理解，并具有构建*安全性*的知识；这是下一节的主题。
- en: Kernel modules and security – an overview
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块和安全性 - 概述
- en: An ironic reality is that enormous efforts spent on improving *user space* security
    considerations have resulted in a pretty large payoff over recent years. A malicious
    user performing a viable **Buffer Overflow** (**BoF**) attack was well within
    the realms of possibility a couple of decades back, but today is really hard to
    do. Why? Because there are many layers of beefed-up security mechanisms to prevent
    many of these attack classes.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 讽刺的现实是，过去几年中，花费大量精力改进*用户空间*安全考虑已经取得了相当大的回报。几十年前，恶意用户进行有效的**缓冲区溢出**（**BoF**）攻击是完全可能的，但今天却很难实现。为什么？因为有许多层加强的安全机制来防止许多这些攻击类别。
- en: 'To quickly name a few countermeasures: compiler protections (`-fstack-protector[...],'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 快速列举一些对策：编译器保护（`-fstack-protector[...]`）
- en: -Wformat-security, -D_FORTIFY_SOURCE=2`, partial/full RELRO, better sanity and
    security checker tools (`checksec.sh`, the address sanitizers, paxtest, static
    analysis tools, and so on), secure libraries, hardware-level protection mechanisms
    (NX, SMEP, SMAP, and so on), [K]ASLR, better testing (fuzzing), and so on.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: -Wformat-security, -D_FORTIFY_SOURCE=2`, partial/full RELRO, better sanity and
    security checker tools (`checksec.sh`, the address sanitizers, paxtest, static
    analysis tools, and so on), secure libraries, hardware-level protection mechanisms
    (NX, SMEP, SMAP, and so on), [K]ASLR, better testing (fuzzing), and so on.
- en: 'The irony is that *kernel-space *attacks have become increasingly common over
    the last few years! It has been demonstrated that revealing even a single valid
    kernel (virtual) address (and it''s corresponding symbol) to a clever attacker
    can allow her to figure the location of some key internal kernel structures, paving
    the way to carry out all kinds of **privilege escalation** (**privesc**) attacks.
    Thus, even revealing a single innocent-looking piece of kernel information (such
    as a kernel address and the symbol it''s associated with) is a potential **information
    leak** (or info-leak) and must be prevented on production systems. Coming up,
    we will enumerate and briefly describe a few security features that the Linux
    kernel provides. However, ultimately, the kernel developer – you! – have a large
    role to play: writing secure code, to begin with! Using our ''better'' Makefile
    is a great way to get started - several targets within it are concerned with security
    (all the static analysis ones, for example).'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 讽刺的是，过去几年中*内核空间*攻击变得越来越常见！已经证明，即使是透露一个有效的内核（虚拟）地址（及其对应的符号）给一个聪明的攻击者，她也可以找到一些关键的内核结构的位置，从而为进行各种**特权升级**（**privesc**）攻击铺平道路。因此，即使是透露一个看似无害的内核信息（如内核地址及其关联的符号）也可能是一个**信息泄漏**（或信息泄漏）并且必须在生产系统上予以防止。接下来，我们将列举并简要描述Linux内核提供的一些安全功能。然而，最终，内核开发人员-也就是您！-在其中扮演了重要角色：首先编写安全的代码！使用我们的“更好”的Makefile是一个很好的开始方式-其中的几个目标与安全有关（例如所有的静态分析目标）。
- en: Proc filesystem tunables affecting the system log
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响系统日志的proc文件系统可调整参数
- en: 'We directly refer you to the man page on `proc(5)` – very valuable! – to glean
    information on these two security-related tunables:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接参考`proc(5)`的手册页面-非常有价值！-以获取有关这两个与安全相关的可调整参数的信息：
- en: '`dmesg_restrict`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dmesg_restrict`'
- en: '`kptr_restrict`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kptr_restrict`'
- en: 'First, `dmesg_restrict`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`dmesg_restrict`：
- en: '[PRE76]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The default (on both our Ubuntu and Fedora platforms) is `0`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值（在我们的Ubuntu和Fedora平台上）是`0`：
- en: '[PRE77]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Linux kernels use the powerful fine-granularity POSIX *capabilities* model.
    The `CAP_SYS_ADMIN` capability essentially is a catch-all for what is traditionally *root
    (superuser/sysadmin) *access. The `CAP_SYSLOG` capability gives the process (or
    thread) the capability to perform privileged `syslog(2)` operations.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用强大的细粒度POSIX *capabilities*模型。`CAP_SYS_ADMIN`能力本质上是传统*root（超级用户/系统管理员）*访问的一个捕捉所有。`CAP_SYSLOG`能力赋予进程（或线程）执行特权`syslog(2)`操作的能力。
- en: 'As already mentioned, "leaking" a kernel address and the symbol it''s associated
    with might result in an info-leak-based attack. To help prevent these, kernel
    and module authors are advised to always print kernel addresses using a new `printf`-style
    format: instead of the familiar `%p` or `%px` to print a kernel address, you should
    use the newer **`%pK`** format specifier for printing an address. (Using the `%px`
    format specifier ensures the actual address is printed; you''ll want to avoid
    this in production). How does this help? Read on...'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，“泄漏”内核地址及其关联的符号可能导致基于信息泄漏的攻击。为了帮助防止这些情况，建议内核和模块的作者始终使用新的`printf`风格格式来打印内核地址：而不是使用熟悉的`%p`或`%px`来打印内核地址，应该使用新的**`%pK`**格式来打印地址。（使用`%px`格式确保实际地址被打印出来；在生产中应避免使用这种格式）。这有什么帮助呢？请继续阅读...
- en: The `kptr_restrict`tunable (2.6.38 onward) affects the `printk()` output when
    printing kernel addresses; doing `printk("&var = **%pK**\n", &var);`
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`kptr_restrict`可调整参数（2.6.38及以上版本）影响`printk()`输出时打印内核地址；使用`printk("&var = **%pK**\n",
    &var);`'
- en: 'and not the good old `printk("&var = %p\n", &var);` is considered a security
    best practice. Understanding how exactly the `kptr_restrict` tunable works is
    key to this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是老旧的`printk("&var = %p\n", &var);`被认为是一种安全最佳实践。了解`kptr_restrict`可调整参数的工作原理对此至关重要：
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The default (on both our recent-enough Ubuntu and Fedora platforms) is `1`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值（在我们最近的Ubuntu和Fedora平台上）是`1`：
- en: '[PRE79]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can – rather, *must* – change these tunables on production systems to a
    secure value (1 or 2) for security. Of course, security measures only work when
    developers make use of them; as of the 5.4.0 Linux kernel, there is a total of
    (just!) 14 uses of the `%pK` format specifier in the entire Linux kernel code
    base (out of a total of about 5,200-odd uses of printk employing the `%p`, and
    around 230 explicitly employing the `%px` format specifier).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统上，您可以-而且*必须*将这些可调整参数更改为安全值（1或2）以确保安全。当然，只有开发人员使用这些安全措施时，安全措施才能发挥作用；截至Linux内核5.4.0版本，整个Linux内核代码库中只有（仅有！）14个使用`%pK`格式指定符，而使用`%p`的使用约为5200多次，显式使用`%px`格式指定符的使用约为230次。
- en: a) As `procfs` is, of course, a volatile filesystem, you can always make the
    changes permanent by using the `sysctl(8)` utility with the `-w` option switch
    (or by directly updating the `/etc/sysctl.conf` file).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: a）由于`procfs`是一个易失性文件系统，您可以始终使用`sysctl(8)`实用程序和`-w`选项开关（或直接更新`/etc/sysctl.conf`文件）使更改永久生效。
- en: b) For the purpose of debugging, if you must print an actual kernel (unmodified)
    address, you're advised to use the `%px` format specifier; do remove these prints
    on production systems!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: b）为了调试的目的，如果必须打印实际的内核（未修改的）地址，建议您使用`%px`格式说明符；在生产系统上，请删除这些打印！
- en: c) Detailed kernel documentation on `printk` format specifiers can be found
    at [https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right](https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right);
    do browse through it.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: c）有关`printk`格式说明符的详细内核文档可以在[https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right](https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right)找到；请浏览一下。
- en: With the advent of hardware-level defects in early 2018 (the now well-known *Meltdown,
    Spectre,* and other processor speculation security issues), there was a sense
    of renewed urgency in *detecting information leakage, *thus enabling developers
    and administrators to block them off.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 随着2018年初硬件级缺陷的出现（现在众所周知的*Meltdown，Spectre*和其他处理器推测安全问题），人们对*检测信息泄漏*产生了一种新的紧迫感，从而使开发人员和管理员能够将其封锁。
- en: A useful Perl script, `scripts/leaking_addresses.pl`, was released in mainline
    in 4.14 (in November 2017; I am happy to have lent a hand in this important work: [https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde](https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde)),
    with more checks being made for detecting leaking kernel addresses.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的Perl脚本`scripts/leaking_addresses.pl`在4.14版中发布（2017年11月；我很高兴能在这项重要工作中提供帮助：[https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde](https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde)），并且正在进行更多的检查以检测泄漏的内核地址。
- en: The cryptographic signing of kernel modules
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块的加密签名
- en: Once a malicious attacker gets a foothold on a system, they will typically attempt
    some kind of privesc vector in order to gain root access. Once this is achieved,
    the typical next step is to install a *rootkit*: essentially, a collection of
    scripts and kernel modules that will pretty much take over the system (by "hijacking"
    system calls, setting up backdoors and keyloggers, and so on).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意攻击者在系统上立足，他们通常会尝试某种特权升级向量，以获得root访问权限。一旦实现了这一点，典型的下一步是安装*rootkit*：基本上是一组脚本和内核模块，它们几乎会接管系统（通过“劫持”系统调用，设置后门和键盘记录器等）。
- en: Of course, it's not easy – the security posture of a modern production quality
    Linux system, replete with **Linux Security Modules** (**LSMs**), and so on, means
    it's not at all a trivial thing to do, but for a skilled and motivated attacker,
    anything's possible. Assuming they have a sufficiently sophisticated rootkit installed,
    the system is now considered compromised.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不容易 - 现代生产质量的Linux系统的安全姿态，包括**Linux安全模块**（**LSMs**）等，意味着这并不是一件微不足道的事情，但对于一个技术娴熟且积极进取的攻击者来说，任何事情都有可能。假设他们安装了足够复杂的rootkit，系统现在被认为是受到了威胁。
- en: 'An interesting idea is this: even with root access, do not allow `insmod(8)`
    (or `modprobe(8)`, or even the underlying `[f]init_module(2)` system calls) to
    insert kernel modules into kernel address space **unless they are cryptographically
    signed with a security key** that is in the kernel''s keyring*.* This powerful
    security feature was introduced with the 3.7 kernel (the relevant commit is here:
    [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7)).'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的想法是：即使具有root访问权限，也不要允许`insmod(8)`（或`modprobe(8)`，甚至底层的`[f]init_module(2)`系统调用）将内核模块插入内核地址空间**除非它们使用安全密钥进行了加密签名**，而该密钥在内核的密钥环中。这一强大的安全功能是在3.7内核中引入的（相关提交在这里：[https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7)）。
- en: The details on performing cryptographic signing of kernel modules is beyond
    the scope of this book; you can refer to the official kernel documentation here: [https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html](https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 有关对内核模块进行加密签名的详细信息超出了本书的范围；您可以在这里参考官方内核文档：[https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html](https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html)。
- en: 'A few relevant kernel configuration options concerned with this feature are
    `CONFIG_MODULE_SIG`, `CONFIG_MODULE_SIG_FORCE`, `CONFIG_MODULE_SIG_ALL`, and so
    on. To help understand what exactly this means, see the `Kconfig ''help''` section
    for the first of them, as follows (from `init/Kconfig`):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此功能的一些相关内核配置选项是`CONFIG_MODULE_SIG`，`CONFIG_MODULE_SIG_FORCE`，`CONFIG_MODULE_SIG_ALL`等。要了解这究竟意味着什么，请参阅第一个选项的`Kconfig
    'help'`部分，如下所示（来自`init/Kconfig`）：
- en: '[PRE80]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `MODULE_SIG_FORCE` kernel config is a Boolean value (defaults to `n`).
    It only comes into play if `MODULE_SIG` is turned on. If `MODULE_SIG_FORCE` is
    set to `y`, then kernel modules *must* have a valid signature in order to be loaded.
    If not, loading will fail. If its value is left as `n`, this implies that even
    kernel modules that aren''t signed will be loaded into the kernel, but the kernel
    will be marked as tainted. This tends to be the default on a typical modern Linux
    distribution. In the following code block, we look up these kernel configs on
    our x86_64 Ubuntu 20.04.1 LTS guest VM:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置`MODULE_SIG_FORCE`是一个布尔值（默认为`n`）。只有在打开`MODULE_SIG`时才会起作用。如果`MODULE_SIG_FORCE`设置为`y`，那么内核模块*必须*具有有效的签名才能加载。如果没有，加载将失败。如果其值保持为`n`，这意味着即使未签名的内核模块也将加载到内核中，但内核将被标记为有瑕疵。这往往是典型现代Linux发行版的默认设置。在以下代码块中，我们查找了我们的x86_64
    Ubuntu 20.04.1 LTS客户VM上的这些内核配置：
- en: '[PRE81]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The cryptographic signing of kernel modules is encouraged on production systems
    (in recent years, with (I)IoT edge devices becoming more prevalent, security is
    a key concern).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统上鼓励对内核模块进行加密签名（近年来，随着（I）IoT边缘设备变得更加普遍，安全性是一个关键问题）。
- en: Disabling kernel modules altogether
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全禁用内核模块
- en: 'Paranoid folks might want to completely disable the loading (and unloading)
    of kernel modules. Rather drastic, but hey, this way you can completely lock down
    the kernel space of a system (as well as render any rootkits pretty much harmless).
    This can be achieved in two broad ways:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 偏执的人可能希望完全禁用内核模块的加载（和卸载）。这相当激烈，但嘿，这样你就可以完全锁定系统的内核空间（以及使任何rootkit基本上无害）。有两种广泛的方法可以实现这一点：
- en: First, by setting the `CONFIG_MODULES` kernel config to off (it's on, of course,
    by default) during kernel config prior to building. Doing this is pretty drastic
    – it makes the decision a permanent one!
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，通过在构建之前的内核配置期间将`CONFIG_MODULES`内核配置设置为关闭（默认情况下是打开的）。这样做相当激烈 – 它使决定成为永久的！
- en: 'Second, assuming `CONFIG_MODULES` is turned on, module loading can be dynamically
    turned off at runtime via the `modules_disabled` `sysctl`tunable; take a look
    at this:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，假设`CONFIG_MODULES`已打开，模块加载可以通过`modules_disabled` `sysctl`可调参数在运行时动态关闭；看一下这个：
- en: '[PRE82]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It''s *off* (`0`) by default, of course. As usual, the man page on `proc(5)` tells
    us the story:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，默认情况下是*关闭*（`0`）。像往常一样，`proc(5)`的man页面告诉了我们这个故事：
- en: '[PRE83]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In conclusion, of course, kernel security hardening and malicious attacks are
    a cat-and-mouse game. For example, (K)ASLR (we talk about what (K)ASLR means in
    the chapters to come on Linux memory management) is quite regularly defeated.
    Also, see this article – *Effectively bypassing kptr_restrict on Android*: [http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html](http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html). Security
    is not easy; it''s always a work in progress. It (almost) goes without saying:
    developers – in both user and kernel space – *must* write code that is security-aware
    and use tools and testing on a continuous basis*.*'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当然，内核安全加固和恶意攻击是一场猫鼠游戏。例如，（K）ASLR（我们将在接下来的Linux内存管理章节中讨论（K）ASLR的含义）经常被打败。另请参阅这篇文章
    – *在Android上有效地绕过kptr_restrict*：[http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html](http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html)。安全并不容易；它总是在不断地进步中。几乎可以说：开发人员
    – 无论是用户空间还是内核空间 – *必须*编写具有安全意识的代码，并且持续使用工具和测试*。*
- en: Let's complete this chapter with topics on coding style guidelines for the Linux
    kernel, accessing kernel documentation, and how you can go about contributing
    to the mainline kernel.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过关于Linux内核编码风格指南、访问内核文档以及如何进行对主线内核的贡献的主题来完成本章。
- en: Coding style guidelines for kernel developers
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核开发人员的编码风格指南
- en: Many large projects specify their own set of coding guidelines; so does the
    Linux kernel community. Adhering to the Linux kernel *coding style* guidelines
    is a really good idea. You can find them officially documented here: [https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html) (please
    do read it!).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型项目都规定了自己的一套编码准则；Linux内核社区也是如此。遵循Linux内核*编码风格*指南是一个非常好的主意。您可以在这里找到官方文档：[https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html)（请务必阅读！）。
- en: 'Furthermore, as part of the (quite exhaustive) code-submission checklist(s)
    for developers like you wanting to upstream your code, you are expected to run
    your patch through a Perl script that checks your code for congruence with the
    Linux kernel coding style: `scripts/checkpatch.pl`.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为想要上游您的代码的开发人员的（相当详尽的）代码提交检查清单的一部分，您应该通过一个Perl脚本运行您的补丁，检查您的代码是否符合Linux内核编码风格：`scripts/checkpatch.pl`。
- en: 'By default, this script only runs on a well-formatted `git` patch. It''s possible
    to run it against standalone C code (as in your out-of-tree kernel module code),
    as follows (as our ''better'' Makefile indeed does):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此脚本仅在格式良好的`git`补丁上运行。可以对独立的C代码（如您的树外内核模块代码）运行它，方法如下（正如我们的“更好”的Makefile确实做到的）：
- en: '[PRE84]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Doing this as a habit on your kernel code is helpful, enabling you to catch
    those annoying little issues – plus more serious ones! – that might otherwise
    hold your patch up. Again, we remind you: our "better" Makefile''s `indent` and
    `checkpatch` targets are geared toward this.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的内核代码中养成这样的习惯是有帮助的，可以帮助您发现那些令人讨厌的小问题 – 以及更严重的问题！ – 否则可能会阻碍您的补丁。再次提醒您：我们的“更好”的Makefile的`indent`和`checkpatch`目标是为此而设计的。
- en: 'Besides coding style guidelines, you will find that every now and then, you
    need to dig into the elaborate and useful kernel documentation. A gentle reminder:
    we covered locating and using the kernel documentation in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),
    *Kernel Workspace Setup*, under the *Locating and Using the Linux Kernel Documentation*
    section.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编码风格指南，您会发现，时不时地，您需要深入研究详细且有用的内核文档。温馨提示：我们在[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)
    *内核工作区设置*的*查找和使用Linux内核文档*部分中介绍了定位和使用内核文档。
- en: 'We will now complete this chapter by making a brief mention of how you can
    get started on a noble objective: contributing code to the mainline Linux kernel
    project.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过简要介绍如何开始一个崇高的目标来完成本章：为主线Linux内核项目贡献代码。
- en: Contributing to the mainline kernel
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为主线内核做贡献
- en: In this book, we typically perform kernel development *outside *the kernel source
    tree, via the LKM framework. What if you are writing code *within *the kernel
    tree, with the explicit goal of *upstreaming* your code to the kernel mainline?
    This is a laudable goal indeed – the whole basis of open source stems from the
    community's willingness to put in work and contribute it upstream to the project.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通常通过LKM框架在内核源树之外进行内核开发。如果您正在内核树中编写代码，并明确目标是将您的代码上游到内核主线，该怎么办呢？这确实是一个值得赞扬的目标
    - 开源的整个基础源自社区愿意付出努力并将其贡献到项目上游。
- en: Getting started with contributing to the kernel
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始为内核做贡献
- en: The most frequently asked question, of course, is *how do I get started*?To
    help with precisely this, a long and very detailed answer lies within the kernel
    documentation here: *HOWTO do Linux kernel development*: [https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development](https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最常见的问题是*我该如何开始*？为了帮助您准确地解决这个问题，内核文档中有一个非常详细的答案：*如何进行Linux内核开发*：[https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development](https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development)。
- en: 'As a matter of fact, you can generate the full Linux kernel documentation (via
    the `make pdfdocs` command, in the root of the kernel source tree); once successful,
    you will find this PDF document here: `<root-of-kernel-source-tree>/Documentation/output/latex/development-process.pdf`.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以通过`make pdfdocs`命令在内核源树的根目录生成完整的Linux内核文档；一旦成功，您将在此找到PDF文档：`<kernel-source-tree>/Documentation/output/latex/development-process.pdf`。
- en: 'It is a very detailed guide to the Linux kernel development process, including
    guidelines for code submission. A cropped screenshot of this document is shown
    here:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Linux内核开发过程的非常详细的指南，包括代码提交的指南。此处显示了该文档的裁剪截图：
- en: '![](img/6b621a0c-964d-4b25-8c8b-9a63ad58ae79.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b621a0c-964d-4b25-8c8b-9a63ad58ae79.png)'
- en: Figure 5.5 – (Partial) screenshot of the kernel development docs just generated
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 - 生成的内核开发文档的（部分）截图
- en: As part of this kernel development process, to maintain quality standards, a
    rigorous and *must-be-followed* checklist – a long recipe of sorts! – is very
    much part of the kernel patch submission process. The official checklist resides
    here: *Linux Kernel patch submission checklist*: [https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist](https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内核开发过程的一部分，为了保持质量标准，一个严格且*必须遵循*的清单 - 一种长长的配方！ - 是内核补丁提交过程的重要部分。官方清单位于此处：*Linux内核补丁提交清单*：[https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist](https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist)。
- en: Though it may seem an onerous task for a kernel newbie, carefully following
    this checklist lends both rigor and credibility to your work and ultimately results
    in superior code. I strongly encourage you to read through the kernel patch submission
    checklist and try out the procedures mentioned therein.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于内核新手来说可能看起来是一项繁重的任务，但仔细遵循这个清单会给您的工作带来严谨性和可信度，并最终产生优秀的代码。我强烈鼓励您阅读内核补丁提交清单并尝试其中提到的程序。
- en: Is there a really practical hands-on tip, an almost guaranteed way to become
    a kernel hacker? Of course, keep reading this book! Ha ha, yes, besides, do partake
    in the simply awesome **Eudyptula Challenge** ([http://www.eudyptula-challenge.org/](http://www.eudyptula-challenge.org/)) Oh,
    hang on, it's – very unfortunately, and as of the time of writing – closed down.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一个真正实用的动手提示，一个几乎可以保证成为内核黑客的方法？当然，继续阅读本书！哈哈，是的，此外，参加简直太棒了的**Eudyptula挑战**（[http://www.eudyptula-challenge.org/](http://www.eudyptula-challenge.org/)）哦，等等，很不幸，截至撰写本文时，它已经关闭了。
- en: Fear not; here's a site with all the challenges (and solutions, but don't cheat!)
    posted. Do check it out and try the challenges. This will greatly accelerate your
    kernel hacking skills: [https://github.com/agelastic/eudyptula](https://github.com/agelastic/eudyptula).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心；这里有一个网站，上面发布了所有挑战（以及解决方案，但不要作弊！）。一定要去看看并尝试这些挑战。这将极大地提升您的内核编程技能：[https://github.com/agelastic/eudyptula](https://github.com/agelastic/eudyptula)。
- en: Summary
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, the second of two on writing a kernel module using the LKM framework,
    we covered several (remaining) areas pertaining to this important topic: among
    them, using a "better" Makefile for your kernel module,  tips on configuring a
    debug kernel (it''s very important!), cross-compiling a kernel module, gathering
    some minimal platform information from within a kernel module, and even a bit
    on the licensing of kernel modules. We also looked at emulating library-like features
    with two different approaches (one - preferred - the linking approach, and two,
    the module stacking approach), using module parameters, avoiding floating-point,
    the auto-loading of your kernel modules, and so on. Security concerns and how
    they can be addressed are important. Finally, we wrapped up this chapter by covering
    kernel coding style guidelines, kernel documentation, and how you can get started
    with contributing to the mainline kernel. So, congratulations! You now know how
    to develop a kernel module and can even get started on the journey to kernel upstream
    contribution.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了使用LKM框架编写内核模块的第二个章节，其中包括与这一重要主题相关的几个（剩余的）领域：其中包括使用“更好”的Makefile来为您的内核模块进行配置，配置调试内核的提示（这非常重要！），交叉编译内核模块，从内核模块中收集一些最小的平台信息，甚至涉及内核模块的许可证问题。我们还探讨了使用两种不同方法（一种是首选的链接方法，另一种是模块堆叠方法）来模拟类似库的特性，使用模块参数，避免浮点运算，内核模块的自动加载等等。安全问题及其解决方法也很重要。最后，我们通过介绍内核编码风格指南、内核文档以及如何开始为主线内核做出贡献来结束了本章。所以，恭喜！您现在知道如何开发内核模块，甚至可以开始迈向内核上游贡献的旅程。
- en: In the next chapter, we will delve into an interesting and necessary topic.
    We will begin our exploration in some depth into the *internals *of both the Linux
    kernel and its memory management subsystem.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨一个有趣且必要的主题。我们将开始深入探讨Linux内核及其内存管理子系统的*内部*。
- en: Questions
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试对本章材料的了解：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。您会在书的GitHub存储库中找到一些问题的答案：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。
- en: Further reading
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To aid you in delving deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times even books)
    in a *Further reading* markdown document – organized by chapter – in this book's
    GitHub repository. The *Further reading* document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您深入研究这个主题并提供有用的材料，我们在这本书的GitHub存储库中提供了一个相当详细的在线参考和链接（有时甚至包括书籍）的*进一步阅读*markdown文档
    - 按章节组织。*进一步阅读*文档在这里可用：[https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md)。
