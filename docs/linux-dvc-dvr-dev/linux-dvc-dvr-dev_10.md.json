["```\n#include <linux/iio/iio.h>    /* mandatory */ \n#include <linux/iio/sysfs.h>  /* mandatory since sysfs is used */ \n#include <linux/iio/events.h> /* For advanced users, to manage iio events */ \n#include <linux/iio/buffer.h> /* mandatory to use triggered buffers */ \n#include <linux/iio/trigger.h>/* Only if you implement trigger in your driver (rarely used)*/ \n```", "```\nstruct iio_dev { \n   [...] \n   int modes; \n   int currentmode; \n   struct device dev; \n\n   struct iio_buffer *buffer; \n   int scan_bytes; \n\n   const unsigned long *available_scan_masks; \n   const unsigned long *active_scan_mask; \n   bool scan_timestamp; \n   struct iio_trigger *trig; \n   struct iio_poll_func *pollfunc; \n\n   struct iio_chan_spec const *channels; \n   int num_channels; \n   const char *name; \n   const struct iio_info *info; \n   const struct iio_buffer_setup_ops *setup_ops; \n   struct cdev chrdev; \n}; \n```", "```\n/* \n * Bitmasks 0x7 (0b111) and 0 (0b000) are allowed. \n * It means one can enable none or all of them. \n * one can't for example enable only channel X and Y \n */ \nstatic const unsigned long my_scan_masks[] = {0x7, 0}; \nindio_dev->available_scan_masks = my_scan_masks; \n```", "```\nstruct iio_buffer_setup_ops { \n    int (* preenable) (struct iio_dev *); \n    int (* postenable) (struct iio_dev *); \n    int (* predisable) (struct iio_dev *); \n    int (* postdisable) (struct iio_dev *); \n    bool (* validate_scan_mask) (struct iio_dev *indio_dev, \n                                 const unsigned long *scan_mask); \n}; \n```", "```\nstruct iio_dev *devm_iio_device_alloc(struct device *dev,  \n\n                                      int sizeof_priv) \n```", "```\nstruct iio_dev *indio_dev; \nstruct my_private_data *data; \nindio_dev = iio_device_alloc(sizeof(*data)); \nif (!indio_dev) \n    return -ENOMEM; \n/*data is given the address of reserved momory for private data */ \ndata = iio_priv(indio_dev); \n```", "```\nint iio_device_register(struct iio_dev *indio_dev) \n```", "```\nvoid iio_device_unregister(struct iio_dev *indio_dev) \n```", "```\nvoid iio_device_free(struct iio_dev *iio_dev) \n```", "```\nstruct my_private_data *the_data = iio_priv(indio_dev); \n```", "```\nstruct iio_info { \n   struct module *driver_module; \n   const struct attribute_group *attrs; \n\n   int (*read_raw)(struct iio_dev *indio_dev, \n               struct iio_chan_spec const *chan, \n               int *val, int *val2, long mask); \n\n   int (*write_raw)(struct iio_dev *indio_dev, \n                struct iio_chan_spec const *chan, \n                int val, int val2, long mask); \n    [...] \n}; \n```", "```\nstatic const struct iio_info iio_dummy_info = { \n    .driver_module = THIS_MODULE, \n    .read_raw = &iio_dummy_read_raw, \n    .write_raw = &iio_dummy_write_raw, \n[...] \n\n/* \n * Provide device type specific interface functions and \n * constant data. \n */ \nindio_dev->info = &iio_dummy_info; \n```", "```\n    struct iio_chan_spec { \n        enum iio_chan_type type; \n        int channel; \n        int channel2; \n        unsigned long address; \n        int scan_index; \n        struct { \n            charsign; \n            u8 realbits; \n            u8 storagebits; \n            u8 shift; \n            u8 repeat; \n            enum iio_endian endianness; \n        } scan_type; \n        long info_mask_separate; \n        long info_mask_shared_by_type; \n        long info_mask_shared_by_dir; \n        long info_mask_shared_by_all; \n        const struct iio_event_spec *event_spec; \n        unsigned int num_event_specs; \n        const struct iio_chan_spec_ext_info *ext_info; \n        const char *extend_name; \n        const char *datasheet_name; \n        unsigned modified:1; \n        unsigned indexed:1; \n        unsigned output:1; \n        unsigned differential:1; \n    }; \n```", "```\nenum iio_chan_info_enum { \n    IIO_CHAN_INFO_RAW = 0, \n    IIO_CHAN_INFO_PROCESSED, \n    IIO_CHAN_INFO_SCALE, \n    IIO_CHAN_INFO_OFFSET, \n    IIO_CHAN_INFO_CALIBSCALE, \n    [...] \n    IIO_CHAN_INFO_SAMP_FREQ, \n    IIO_CHAN_INFO_FREQUENCY, \n    IIO_CHAN_INFO_PHASE, \n    IIO_CHAN_INFO_HARDWAREGAIN, \n    IIO_CHAN_INFO_HYSTERESIS, \n    [...] \n}; \n```", "```\nenum iio_endian { \n    IIO_CPU, \n    IIO_BE, \n    IIO_LE, \n}; \n```", "```\nstatic const char * const iio_direction[] = { \n   [0] = \"in\", \n   [1] = \"out\", \n}; \n```", "```\nstatic const char * const iio_chan_type_name_spec[] = { \n   [IIO_VOLTAGE] = \"voltage\", \n   [IIO_CURRENT] = \"current\", \n   [IIO_POWER] = \"power\", \n   [IIO_ACCEL] = \"accel\", \n   [...] \n   [IIO_UVINDEX] = \"uvindex\", \n   [IIO_ELECTRICALCONDUCTIVITY] = \"electricalconductivity\", \n   [IIO_COUNT] = \"count\", \n   [IIO_INDEX] = \"index\", \n   [IIO_GRAVITY]  = \"gravity\", \n}; \n```", "```\nstatic const char * const iio_modifier_names[] = { \n   [IIO_MOD_X] = \"x\", \n   [IIO_MOD_Y] = \"y\", \n   [IIO_MOD_Z] = \"z\", \n   [IIO_MOD_X_AND_Y] = \"x&y\", \n   [IIO_MOD_X_AND_Z] = \"x&z\", \n   [IIO_MOD_Y_AND_Z] = \"y&z\", \n   [...] \n   [IIO_MOD_CO2] = \"co2\", \n   [IIO_MOD_VOC] = \"voc\", \n}; \n```", "```\n/* relies on pairs of these shared then separate */ \nstatic const char * const iio_chan_info_postfix[] = { \n   [IIO_CHAN_INFO_RAW] = \"raw\", \n   [IIO_CHAN_INFO_PROCESSED] = \"input\", \n   [IIO_CHAN_INFO_SCALE] = \"scale\", \n   [IIO_CHAN_INFO_CALIBBIAS] = \"calibbias\", \n   [...] \n   [IIO_CHAN_INFO_SAMP_FREQ] = \"sampling_frequency\", \n   [IIO_CHAN_INFO_FREQUENCY] = \"frequency\", \n   [...] \n}; \n```", "```\nstatic const struct iio_chan_spec adc_channels[] = { \n        { \n                .type = IIO_VOLTAGE, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n        }, \n} \n```", "```\nstatic const struct iio_chan_spec adc_channels[] = { \n        { \n                .type = IIO_VOLTAGE, \n                .indexed = 1, \n                .channel = 0, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n        }, \n        { \n                .type = IIO_VOLTAGE, \n                .indexed = 1, \n                .channel = 1, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n        }, \n        { \n                .type = IIO_VOLTAGE, \n                .indexed = 1, \n                .channel = 2, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n        }, \n        { \n                .type = IIO_VOLTAGE, \n                .indexed = 1, \n                .channel = 3, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n        }, \n} \n```", "```\nstatic const struct iio_chan_spec mylight_channels[] = { \n        { \n                .type = IIO_INTENSITY, \n                .modified = 1, \n                .channel2 = IIO_MOD_LIGHT_IR, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n                .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ), \n        }, \n        { \n                .type = IIO_INTENSITY, \n                .modified = 1, \n                .channel2 = IIO_MOD_LIGHT_BOTH, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \n                .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ), \n        }, \n        { \n                .type = IIO_LIGHT, \n                .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \n                .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ), \n        }, \n} \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/platform_device.h> \n#include <linux/interrupt.h> \n#include <linux/of.h> \n#include <linux/iio/iio.h> \n#include <linux/iio/sysfs.h> \n#include <linux/iio/events.h> \n#include <linux/iio/buffer.h> \n\n#define FAKE_VOLTAGE_CHANNEL(num)                  \\ \n   {                                               \\ \n         .type = IIO_VOLTAGE,                      \\ \n         .indexed = 1,                             \\ \n         .channel = (num),                         \\ \n         .address = (num),                         \\ \n         .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),   \\ \n         .info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\ \n   } \n\nstruct my_private_data { \n    int foo; \n    int bar; \n    struct mutex lock; \n}; \n\nstatic int fake_read_raw(struct iio_dev *indio_dev, \n                   struct iio_chan_spec const *channel, int *val, \n                   int *val2, long mask) \n{ \n    return 0; \n} \n\nstatic int fake_write_raw(struct iio_dev *indio_dev, \n                   struct iio_chan_spec const *chan, \n                   int val, int val2, long mask) \n{ \n    return 0; \n} \n\nstatic const struct iio_chan_spec fake_channels[] = { \n   FAKE_VOLTAGE_CHANNEL(0), \n   FAKE_VOLTAGE_CHANNEL(1), \n   FAKE_VOLTAGE_CHANNEL(2), \n   FAKE_VOLTAGE_CHANNEL(3), \n}; \n\nstatic const struct of_device_id iio_dummy_ids[] = { \n    { .compatible = \"packt,iio-dummy-random\", }, \n    { /* sentinel */ } \n}; \n\nstatic const struct iio_info fake_iio_info = { \n   .read_raw = fake_read_raw, \n   .write_raw        = fake_write_raw, \n   .driver_module = THIS_MODULE, \n}; \n\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n    struct iio_dev *indio_dev; \n    struct my_private_data *data; \n\n   indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data)); \n   if (!indio_dev) { \n         dev_err(&pdev->dev, \"iio allocation failed!\\n\"); \n         return -ENOMEM; \n   } \n\n   data = iio_priv(indio_dev); \n   mutex_init(&data->lock); \n   indio_dev->dev.parent = &pdev->dev; \n   indio_dev->info = &fake_iio_info; \n   indio_dev->name = KBUILD_MODNAME; \n   indio_dev->modes = INDIO_DIRECT_MODE; \n   indio_dev->channels = fake_channels; \n   indio_dev->num_channels = ARRAY_SIZE(fake_channels); \n   indio_dev->available_scan_masks = 0xF; \n\n    iio_device_register(indio_dev); \n    platform_set_drvdata(pdev, indio_dev); \n    return 0; \n} \n\nstatic void my_pdrv_remove(struct platform_device *pdev) \n{ \n    struct iio_dev *indio_dev = platform_get_drvdata(pdev); \n    iio_device_unregister(indio_dev); \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = my_pdrv_probe, \n    .remove     = my_pdrv_remove, \n    .driver     = { \n        .name     = \"iio-dummy-random\", \n        .of_match_table = of_match_ptr(iio_dummy_ids),   \n        .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\n~# ls -l /sys/bus/iio/devices/\n\nlrwxrwxrwx 1 root root 0 Jul 31 20:26 iio:device0 -> ../../../devices/platform/iio-dummy-random.0/iio:device0\n\nlrwxrwxrwx 1 root root 0 Jul 31 20:23 iio_sysfs_trigger -> ../../../devices/iio_sysfs_trigger\n\n```", "```\n~# ls /sys/bus/iio/devices/iio\\:device0/\n\ndev in_voltage2_raw name uevent\n\nin_voltage0_raw in_voltage3_raw power\n\nin_voltage1_raw in_voltage_scale subsystem\n\n~# cat /sys/bus/iio/devices/iio:device0/name\n\niio_dummy_random\n\n```", "```\nconst struct iio_buffer_setup_ops sensor_buffer_setup_ops = { \n  .preenable    = my_sensor_buffer_preenable, \n  .postenable   = my_sensor_buffer_postenable, \n  .postdisable  = my_sensor_buffer_postdisable, \n  .predisable   = my_sensor_buffer_predisable, \n}; \n```", "```\nirqreturn_t sensor_iio_pollfunc(int irq, void *p) \n{ \n    pf->timestamp = iio_get_time_ns((struct indio_dev *)p); \n    return IRQ_WAKE_THREAD; \n} \n```", "```\nirqreturn_t sensor_trigger_handler(int irq, void *p) \n{ \n    u16 buf[8]; \n    int bit, i = 0; \n    struct iio_poll_func *pf = p; \n    struct iio_dev *indio_dev = pf->indio_dev; \n\n    /* one can use lock here to protect the buffer */ \n    /* mutex_lock(&my_mutex); */ \n\n    /* read data for each active channel */ \n    for_each_set_bit(bit, indio_dev->active_scan_mask, \n                     indio_dev->masklength) \n        buf[i++] = sensor_get_data(bit) \n\n    /* \n     * If iio_dev.scan_timestamp = true, the capture timestamp \n     * will be pushed and stored too, as the last element in the \n     * sample data buffer before pushing it to the device buffers. \n     */ \n    iio_push_to_buffers_with_timestamp(indio_dev, buf, timestamp); \n\n    /* Please unlock any lock */ \n    /* mutex_unlock(&my_mutex); */ \n\n    /* Notify trigger */ \n    iio_trigger_notify_done(indio_dev->trig); \n    return IRQ_HANDLED; \n} \n```", "```\niio_triggered_buffer_setup(indio_dev, sensor_iio_polfunc, \n                           sensor_trigger_handler, \n                           sensor_buffer_setup_ops); \n```", "```\nstatic int my_read_raw(struct iio_dev *indio_dev, \n                     const struct iio_chan_spec *chan, \n                     int *val, int *val2, long mask) \n{ \n      [...] \n      switch (mask) { \n      case IIO_CHAN_INFO_RAW: \n            if (iio_buffer_enabled(indio_dev)) \n                  return -EBUSY; \n      [...]        \n}  \n```", "```\n # echo 2 > add_trigger\n\n```", "```\n $ cat /sys/bus/iio/devices/trigger2/name\n\n sysfstrig2\n\n```", "```\n # echo 2 > remove_trigger\n\n```", "```\n# set trigger2 as current trigger for device0\n# echo sysfstrig2 >    /sys/bus/iio/devices/iio:device0/trigger/current_trigger \n\n```", "```\n# echo \"\" > iio:device0/trigger/current_trigger \n\n```", "```\nstatic struct resource iio_irq_trigger_resources[] = { \n    [0] = { \n        .start = IRQ_NR_FOR_YOUR_IRQ, \n        .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE, \n    }, \n}; \n\nstatic struct platform_device iio_irq_trigger = { \n    .name = \"iio_interrupt_trigger\", \n    .num_resources = ARRAY_SIZE(iio_irq_trigger_resources), \n    .resource = iio_irq_trigger_resources, \n}; \nplatform_device_register(&iio_irq_trigger); \n```", "```\n $ cd /sys/bus/iio/devices/trigger0/\n $ cat name\n\n```", "```\n# echo \"irqtrig85\" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n\n```", "```\nmylabel: my_trigger@0{ \n    compatible = \"iio_interrupt_trigger\"; \n    interrupt-parent = <&gpio4>; \n    interrupts = <30 0x0>; \n}; \n```", "```\n # mkdir /config\n\n  # mount -t configfs none /config\n\n```", "```\n # create a hrtimer trigger\n  $ mkdir /config/iio/triggers/hrtimer/my_trigger_name\n  # remove the trigger\n  $ rmdir /config/iio/triggers/hrtimer/my_trigger_name \n\n```", "```\n      7   6   5   4   3   2   1   0 \n    +---+---+---+---+---+---+---+---+ \n    |D3 |D2 |D1 |D0 | X | X | X | X | (LOW byte, address 0x06) \n    +---+---+---+---+---+---+---+---+ \n      7   6   5   4   3   2   1   0 \n    +---+---+---+---+---+---+---+---+ \n    |D11|D10|D9 |D8 |D7 |D6 |D5 |D4 | (HIGH byte, address 0x07) \n    +---+---+---+---+---+---+---+---+ \n```", "```\n $ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_y_type\n le:s12/16>>4\n\n```", "```\nstruct iio_chan_spec { \n        [...] \n        struct { \n            char sign; /* Should be 'u' or 's' as explained above */ \n            u8 realbits; \n            u8 storagebits; \n            u8 shift; \n            u8 repeat; \n            enum iio_endian endianness; \n        } scan_type; \n        [...] \n}; \n```", "```\nstruct struct iio_chan_spec accel_channels[] = { \n        { \n                .type = IIO_ACCEL, \n                .modified = 1, \n                .channel2 = IIO_MOD_X, \n                /* other stuff here */ \n                .scan_index = 0, \n                .scan_type = { \n                        .sign = 's', \n                        .realbits = 12, \n                        .storagebits = 16, \n                        .shift = 4, \n                        .endianness = IIO_LE, \n                }, \n        } \n      /* similar for Y (with channel2 = IIO_MOD_Y, scan_index = 1) \n       * and Z (with channel2 = IIO_MOD_Z, scan_index = 2) axis \n       */ \n} \n```", "```\n#define BMA220_DATA_SHIFT 2 \n#define BMA220_DEVICE_NAME \"bma220\" \n#define BMA220_SCALE_AVAILABLE \"0.623 1.248 2.491 4.983\" \n\n#define BMA220_ACCEL_CHANNEL(index, reg, axis) {           \\ \n   .type = IIO_ACCEL,                                      \\ \n   .address = reg,                                         \\ \n   .modified = 1,                                          \\ \n   .channel2 = IIO_MOD_##axis,                             \\ \n   .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),           \\ \n   .info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),   \\ \n   .scan_index = index,                                    \\ \n   .scan_type = {                                          \\ \n         .sign = 's',                                      \\ \n         .realbits = 6,                                    \\ \n         .storagebits = 8,                                 \\ \n         .shift = BMA220_DATA_SHIFT,                       \\ \n         .endianness = IIO_CPU,                            \\ \n   },                                                      \\ \n} \n\nstatic const struct iio_chan_spec bma220_channels[] = { \n   BMA220_ACCEL_CHANNEL(0, BMA220_REG_ACCEL_X, X), \n   BMA220_ACCEL_CHANNEL(1, BMA220_REG_ACCEL_Y, Y), \n   BMA220_ACCEL_CHANNEL(2, BMA220_REG_ACCEL_Z, Z), \n}; \n```", "```\n    jma@jma:~$ ls -l /sys/bus/iio/devices/iio:device0/\n\n(...)\n\n# without modifier, a channel name would have in_accel_raw (bad)\n\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_scale\n\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_x_raw\n\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_y_raw\n\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_z_raw\n\n(...)\n\n```", "```\n$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_x_type\n\nle:s6/8>>2 \n\n```", "```\nstatic irqreturn_t bma220_trigger_handler(int irq, void *p) \n{ \n   int ret; \n   struct iio_poll_func *pf = p; \n   struct iio_dev *indio_dev = pf->indio_dev; \n   struct bma220_data *data = iio_priv(indio_dev); \n   struct spi_device *spi = data->spi_device; \n\n   mutex_lock(&data->lock); \n   data->tx_buf[0] = BMA220_REG_ACCEL_X | BMA220_READ_MASK; \n   ret = spi_write_then_read(spi, data->tx_buf, 1, data->buffer, \n                       ARRAY_SIZE(bma220_channels) - 1); \n   if (ret < 0) \n         goto err; \n\n   iio_push_to_buffers_with_timestamp(indio_dev, data->buffer, \n                              pf->timestamp); \nerr: \n   mutex_unlock(&data->lock); \n   iio_trigger_notify_done(indio_dev->trig); \n\n   return IRQ_HANDLED; \n} \n```", "```\nstatic int bma220_read_raw(struct iio_dev *indio_dev, \n                  struct iio_chan_spec const *chan, \n                  int *val, int *val2, long mask) \n{ \n   int ret; \n   u8 range_idx; \n   struct bma220_data *data = iio_priv(indio_dev); \n\n   switch (mask) { \n   case IIO_CHAN_INFO_RAW: \n           /* If buffer mode enabled, do not process single-channel read */ \n           if (iio_buffer_enabled(indio_dev)) \n                   return -EBUSY; \n           /* Else we read the channel */ \n           ret = bma220_read_reg(data->spi_device, chan->address); \n           if (ret < 0) \n                   return -EINVAL; \n           *val = sign_extend32(ret >> BMA220_DATA_SHIFT, 5); \n           return IIO_VAL_INT; \n   case IIO_CHAN_INFO_SCALE: \n           ret = bma220_read_reg(data->spi_device, BMA220_REG_RANGE); \n           if (ret < 0) \n                   return ret; \n           range_idx = ret & BMA220_RANGE_MASK; \n           *val = bma220_scale_table[range_idx][0]; \n           *val2 = bma220_scale_table[range_idx][1]; \n           return IIO_VAL_INT_PLUS_MICRO; \n   } \n\n   return -EINVAL; \n} \n```", "```\nstatic int bma220_write_raw(struct iio_dev *indio_dev, \n                   struct iio_chan_spec const *chan, \n                   int val, int val2, long mask) \n{ \n   int i; \n   int ret; \n   int index = -1; \n   struct bma220_data *data = iio_priv(indio_dev); \n\n   switch (mask) { \n   case IIO_CHAN_INFO_SCALE: \n         for (i = 0; i < ARRAY_SIZE(bma220_scale_table); i++) \n               if (val == bma220_scale_table[i][0] && \n                   val2 == bma220_scale_table[i][1]) { \n                     index = i; \n                     break; \n               } \n         if (index < 0) \n               return -EINVAL; \n\n         mutex_lock(&data->lock); \n         data->tx_buf[0] = BMA220_REG_RANGE; \n         data->tx_buf[1] = index; \n         ret = spi_write(data->spi_device, data->tx_buf, \n                     sizeof(data->tx_buf)); \n         if (ret < 0) \n               dev_err(&data->spi_device->dev, \n                     \"failed to set measurement range\\n\"); \n         mutex_unlock(&data->lock); \n\n         return 0; \n   } \n\n   return -EINVAL; \n} \n```", "```\nstatic const struct iio_info bma220_info = { \n   .driver_module    = THIS_MODULE, \n   .read_raw         = bma220_read_raw, \n   .write_raw        = bma220_write_raw, /* Only if your driver need it */ \n}; \n```", "```\n/* \n * We provide only two mask possibility, allowing to select none or every \n * channels. \n */ \nstatic const unsigned long bma220_accel_scan_masks[] = { \n   BIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z), \n   0 \n}; \n\nstatic int bma220_probe(struct spi_device *spi) \n{ \n   int ret; \n   struct iio_dev *indio_dev; \n   struct bma220_data *data; \n\n   indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data)); \n   if (!indio_dev) { \n         dev_err(&spi->dev, \"iio allocation failed!\\n\"); \n         return -ENOMEM; \n   } \n\n   data = iio_priv(indio_dev); \n   data->spi_device = spi; \n   spi_set_drvdata(spi, indio_dev); \n   mutex_init(&data->lock); \n\n   indio_dev->dev.parent = &spi->dev; \n   indio_dev->info = &bma220_info; \n   indio_dev->name = BMA220_DEVICE_NAME; \n   indio_dev->modes = INDIO_DIRECT_MODE; \n   indio_dev->channels = bma220_channels; \n   indio_dev->num_channels = ARRAY_SIZE(bma220_channels); \n   indio_dev->available_scan_masks = bma220_accel_scan_masks; \n\n   ret = bma220_init(data->spi_device); \n   if (ret < 0) \n         return ret; \n\n   /* this call will enable trigger buffer support for the device */ \n   ret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time, \n                            bma220_trigger_handler, NULL); \n   if (ret < 0) { \n         dev_err(&spi->dev, \"iio triggered buffer setup failed\\n\"); \n         goto err_suspend; \n   } \n\n   ret = iio_device_register(indio_dev); \n   if (ret < 0) { \n         dev_err(&spi->dev, \"iio_device_register failed\\n\"); \n         iio_triggered_buffer_cleanup(indio_dev); \n         goto err_suspend; \n   } \n\n   return 0; \n\nerr_suspend: \n   return bma220_deinit(spi); \n} \n```", "```\n # cd /sys/bus/iio/devices/iio:device0\n  # cat in_voltage3_raw\n  6646\n\n # cat in_voltage_scale\n  0.305175781\n\n```", "```\n #\n\n echo 0 > /sys/devices/iio_sysfs_trigger/add_trigger\n\n```", "```\n# echo sysfstrig0 > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n\n```", "```\n # echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage7_en\n\n```", "```\n #\n\n echo 100 > /sys/bus/iio/devices/iio:device0/buffer/length\n\n```", "```\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable\n\n```", "```\n #\n\n echo 1 > /sys/bus/iio/devices/trigger0/trigger_now\n\n```", "```\n #\n\n echo 0 > /sys/bus/iio/devices/iio:device0/buffer/enable\n\n```", "```\n #\n\n echo \"\" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n\n```", "```\n #\n\n cat /dev/iio\\:device0 | xxd -\n\n```", "```\n # echo /sys/kernel/config/iio/triggers/hrtimer/trigger0\n\n #\n\n echo 50 > /sys/bus/iio/devices/trigger0/sampling_frequency\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage7_en\n\n #\n\n echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable\n\n #\n\n cat /dev/iio:device0 | xxd -\n\n 0000000: 0188 1a30 0000 0000 8312 68a8 c24f 5a14 ...0......h..OZ.\n\n  0000010: 0188 1a30 0000 0000 192d 98a9 c24f 5a14 ...0.....-...OZ.\n\n  [...] \n\n```", "```\n$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage_type\n\nbe:s14/16>>2\n\n```"]