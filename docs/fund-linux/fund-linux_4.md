# 第四章：使用命令行

在本章中，我们将学习每个 Linux 用户都应该知道的更多基本命令，然后我们将学习如何安装其他重要的第三方 Linux 程序。我们还将学习有关进程和信号的知识，向您介绍 Bash shell 脚本编写，并最终向您展示如何自动执行 Bash shell 脚本。

我们将涵盖以下主题：

+   基本的 Linux 命令

+   其他程序

+   理解进程

+   信号

+   使用 Bash shell 变量

+   Bash shell 脚本编写

# 基本的 Linux 命令

在本节中，我们将学习更多每个 Linux 用户都应该知道的基本 Linux Bash 命令。使用`cat`命令快速从文本文件中剪切列。这类似于`awk`的轻量级版本。

我们将讨论以下命令：

+   `cat`

+   `sort`

+   `awk`

+   `tee`

+   `tar`

+   其他杂项命令

首先，让我们创建`passwd`文件的较小版本，以便使用`cat`命令：

![](img/88408c56-6030-42df-ae10-e606d5343a63.png)

`-d`设置字段分隔符；默认情况下是制表符。`-f`使用要提取的单个字段编号或逗号分隔的字段编号列表。如果使用逗号分隔的列表，分割输入分隔符将被输出，可以使用`--output-delimiter`进行更改。

接下来，让我们创建一个没有注释和空行的`services`文件的较小版本。使用`cat`命令非常受限于文件分隔符是单个字符的特殊用例，例如冒号或制表符。对于拆分包含多个连续空格字符的文本文件，例如在 Linux 配置文件中经常使用的情况，例如在`/etc/services`文件中，`cat`命令不起作用。此外，当使用`cat`命令时，每行的字段顺序必须固定，否则会遇到问题。

在下面的截图中，您可以看到`services`文件不包含制表符，而是包含多个用星号标记的空白字符：

![](img/3d5e6dd5-5e05-4a45-a30d-19eb05bf2635.png)

如果您在此文件上使用`cat`，它将产生一堆垃圾。要使用`awk`来拆分具有多个连续空格的文件。`tr`命令类似于集合替换模式的轻量级版本或子集。它将一个字符集从`stdin`转换为另一个字符集，并输出到`stdout`。语法是不言自明的。您可以转换单个字符和字符范围。字符集类似于 POSIX 正则表达式类；请阅读手册以了解更多信息。

让我们讨论`sort`命令。`sort`命令按行对文本文件进行排序。默认情况下，它考虑整行进行排序。`-u`标志只打印出唯一的字段。如果我们使用数字而不是字母数字值的文件，默认情况下，`sort`期望字母数字值，因此数字的排序是错误的或不自然的。为了解决这个问题，使用`-n`选项，它使用数字进行排序。要从底部到顶部排序值，请使用`-r`标志。如果需要，您还可以影响排序列。`sort`始终考虑整行。为了解决这个问题，使用`-k 2.2`选项按第二列进行排序。还有许多其他排序选项。请参考手册以了解更多信息。

现在，为了结合`cat`或`awk`，`sort`和`unique`的功能，让我们一起使用这些工具来打印`/etc/services`文件中出现最频繁的 10 个服务名称，同时忽略注释和空行：

![](img/bc2915cf-f480-4875-a2cc-c8450e975445.png)

第二个命令现在应该是非常容易理解的。正如您所看到的，`discard`，`exp1`和`exp2`是`/etc/services`文件中最常出现的服务名称，出现了四次。要计算文件中的所有行，请使用`wc`命令进行单词计数。要从路径中提取纯文件名，请使用`basename`命令，这在脚本中经常使用，我们稍后将看到。如果您知道文件的扩展名，也可以使用`basename`命令从扩展名中提取文件名。类似地，要提取路径名，请使用`dirname`命令。要测量命令所需的时间，请使用`time`命令执行命令的前缀。要比较两个文件，请使用`diff`命令，它将打印空输出。如果这些文件相同，将不会有输出。否则，将显示文件之间的更改。`diff`命令也可以用于比较两个目录，逐个文件使用递归标志进行比较，该标志将遍历来自 A 的所有文件，并将它们与 B 文件夹中具有相同名称的相应大小文件进行比较。可以用于打印特定命令在文件系统中的位置的命令是基于`/path`变量，稍后我们将看到。

`tee`是一个有用的命令，可以用于将`stdout`命令存储在文件中，并在命令行上打印出来。在同时查看输出的同时保留输出记录非常有用。只需将要写入的文件名作为参数给`tee`命令。要压缩单个文件，即减小文件大小，请使用`gzip`。要解压缩，请使用`gunzip`命令。

要递归压缩完整的子目录，请使用`tar`命令。请注意，`f`选项必须是后面的选项，后面跟着您要创建的存档名称作为第一个参数，然后是您要存档和压缩的目录作为第二个参数。要将存档提取到任何后续目录，请使用`tar`命令和以下标志，`-C`是输出目录。`hostname`打印主机名；`uptime`打印服务器计算机已经运行的时间，`uname`打印系统信息，例如内核版本。

在`/etc/redhat-release`文件中，您将找到此 CentOS 7 基于的 Red Hat Enterprise 的版本。在`/proc/meminfo`文件中，您将找到内存信息，例如，您有多少 RAM。在`/proc/cpuinfo`中，您将找到有关 CPU 和核心的信息。`free -m`打印出有用的内存信息，例如，您有多少可用的 RAM。`df`打印出有关可用磁盘空间的信息。`du -page`打印出当前目录中文件占用的空间。如果您使用`max-depth=1`选项，还将获得文件夹内容的摘要。`users`打印出当前登录到系统的所有用户。`whoami`命令打印出当前使用此终端的用户的名称。

现在，我们将看到一些非常有用的命令。要打印当前日期和时间，请使用`date`命令。使用`+%s`生成唯一的时间戳。要打印日历，请使用`cal`命令。要暂停，中断 shell 执行，请使用`sleep`命令。`dd`程序，或磁盘转储，是每个 Linux 用户都需要了解的非常重要的工具。它用于从输入文件或设备复制数据到输出文件或设备。我们之前使用过`dd`，在第一部分中，用零覆盖文件系统的空闲空间，以便我们可以缩小 VM 映像，但`dd`命令还有许多其他用途。`dd`基本语法使用`if`作为输入文件和`of`作为输出文件的参数。还有两个非常重要的选项，块大小和计数。

您会看到块大小，即一次读取的数据量，为 1 MB，计数是块大小的重复次数，因此，在我们的示例中，1 MB 乘以 1,024 等于 1 GB。`dd`还支持从`stdin`读取和写入`stdout`，因此我们刚才使用的命令可以重写为`dd if=/dev/zero of=/tmp/1gig_file.empty bs=1M count=1024`。您不仅可以使用`dd`与设备文件一起使用，还可以使用它来复制普通文件。此外，您还可以使用它来创建整个分区的映像，例如用于备份。要访问分区，需要 root 帐户。

# 额外的程序

在本节中，我们将向您展示一些其他非常重要的 Linux 命令，您不想错过。这些程序未包含在 CentOS 7 最小安装中，因此我们首先需要安装它们以安装它们。本节是关于学习额外的命令行程序。额外的因为这些工具未包含在 CentOS 7 最小安装中，因此让我们首先使用 CentOS 7 软件包管理器`yum`安装所有这些程序。为了安装新软件，需要 root 用户。因此，首先以`root`身份登录。在开始之前，让我们安装`epel`存储库，这是一个额外的第三方存储库，用于存储官方 CentOS 7 源中找不到的软件，但非常值得信赖和安全。

首先，让我们安装一些工具，使我们的用户生活更轻松。`rsync`是一个文件传输程序，`pv`是管道查看器；`git`用于版本控制；`net-tools`包含显示网络信息的工具；`bind-utils`包含查询 DNS 信息的工具；`telnet`和`nmap`用于基本的网络故障排除；`nc`代表 netcat，`wget`用于从互联网下载文件；`links`是一个命令行网页浏览器。

接下来，让我们安装一些可以让您对系统进行实时查看的程序。这将安装`htop`，`iotop`和`iftop`。最后，让我们安装一些基本工具，包括屏幕，计算器，`bc`和`lsof`。首先，让我们介绍`rsync`。每个 Linux 用户都需要了解它，因为它是一个具有许多有用功能的强大工具。基本上，`rsync`是一个文件传输程序，但它不仅仅是在源和目标之间复制文件；相反，它会将它们同步，这意味着它只在源文件与目标文件不同时传输文件。这节省了大量的数据开销和时间。我经常使用`rsync`与`-rav`标志，这是默认使用的参数集，用于详细和递归地复制文件。

`cp`将`olip-home`文件夹递归地复制到新位置。现在，如果您更改源文件并在之后重新启动复制过程，`rsync`首先检查源文件和目标文件之间是否有任何差异，只传输更改部分：

![](img/a9ee4c73-daff-4518-9f4f-823242a6af94.png)

如前面的截图所示，我们触及了 `olip-home` 目录中的 `bashrc` 文件，这意味着更新了文件的时间戳，然后 `rsync` 检查并发现 `bashrc` 文件的时间戳已更新，因此文件会再次传输到目的地，因为它已经不同了。要远程复制文件到另一台运行 SSH 服务的服务器，并且已安装了 `rsync`，使用以下语法：`rsync -rav`。如你所见，IP 地址末尾的冒号表示目的地。在这里，我们将 `olip-home` 目录复制到 `/tmp` 目录，反之亦然，要将远程文件复制到本地服务器，使用 `rsync .rav /home/olip/ /tmp/new-olip-home`。`rsync` 有很多不同的功能，非常棒。你可以参考手册了解更多。我经常使用的另一个有用的工具的例子是 `--progress` 标志，它可以显示文件传输的进度。`pv` 是管道查看器，是一个非常有用的程序，可以显示通过 `stdout` 的流量。例如，我们可以用它来显示在传输大量数据流时的进度，比如使用 `dd` 命令。`git` 是一个文件版本控制程序，可以帮助你跟踪文件版本，也可以用于从 Git 仓库安装程序，比如非常流行的 GitHub 服务。例如，我们可以使用以下命令下载最新的 `pv` 源代码：`$ git clone https://github.com/icetee/pv.git`。

# net-tools

`net-tools` 是一组重要的工具，用于显示与网络相关的信息，比如 `netstat` 用于打印网络信息，或者 `route` 命令用于查看 IP 路由表。我们刚刚安装的 `bind-utils` 包含了浏览 DNS 信息的程序，例如，可以查看某个域上是否开放了某个端口，比如在 [`www.google.com`](https://www.google.com) 上的端口 `80`；你将会得到一些连接细节。按 *Esc* 键退出。`wget` 是每个系统管理员都需要了解的最基本的工具之一。它可以用来从互联网上下载文件。例如，要从 HTTP 下载一个随机的编程命令到 `stdout`，可以使用以下命令行：`wget -q0- http://whatthecommit.com/index.txt`，或者直接输入到一个新文件中：`wget -0 /tmp/output.txt http://whatthecommit.com/index.txt`。

# Nmap

Nmap 是另一个非常有用的工具，可以用来排除故障或获取有关网络的信息。它扫描计算机网络，发现并收集与其连接的其他主机的各种信息。请注意，端口扫描网络是一个非常有争议的话题；因为不正确地使用 `nmap` 可能会让你被起诉、被解雇、被国家禁止，甚至被监禁，我们只会用它来检索关于我们自己私有网络的非常有价值的信息。例如，要扫描网络上所有可用的主机和开放的端口，使用以下语法：`nmap` 网络地址。

你将看到一些可用的 IP 地址，它们有各种开放的端口和服务。这可以为你提供非常重要的信息，关于谁连接到你的网络，以及服务和计算机是否安全，是否暴露了不需要的细节。`nc` 或 netcat 是另一个非常有用的工具，可以帮助你调试和排除服务器的网络和防火墙设置。例如，你可以用它来查看服务器上是否开放了某个端口。在服务器上，你想要验证使用，例如，以下命令用于打开端口 `9999` 并在该端口后面放置一个文本文件流：`nc -l -p 9999 < /etc/redhat-release`。在这个网络中的任何其他服务器上，你可以尝试访问该服务器，例如使用 IP 地址 `197`，然后使用 IP 地址 `192.168.1.200` 上的端口 `9999` 并将该文件流回传，使用以下 `nc` 命令：`nc 192.168.1.200 9999 > /tmp/redhat-release`。

# links

在这个小节中，我们将学习关于`links`——命令行网页浏览器。要使用 links 程序打开 DuckDuckGo 搜索网站，请使用以下命令行：links [`duckduckgo.com/`](https://duckduckgo.com/)。这将打开 links 网页浏览器。移动光标上下以到达 DuckDuckGo 文本搜索字段。现在，你可以像在普通的 DuckDuckGo 网站上一样输入你的搜索词，然后按*Enter*键开始搜索。再次使用上下箭头键跳转到你想要浏览的搜索结果。学习 links 导航和快捷键超出了本书的范围。按*q*键退出 links，然后按*Enter*键确认你的选择。

# iotop

要实时查看系统的输入和输出，或者简称 I/O，带宽使用情况，输入`iotop`。iotop 需要使用 root 用户启动。你可以使用`iotop`，例如，了解你的硬盘读写速度有多快，然后按*q*键退出。阅读`iotop`的手册部分，了解更多关于它的快捷键，例如用于排序列。

# iftop

让我们来了解一下`iftop`程序，它可以实时查看网络流量和网络带宽使用情况，并进行监控。同样，这个工具需要使用 root 用户账户启动。如你所见，可以使用这个工具显示网络流量，按*q*键退出程序。阅读`iftop`的手册部分，了解更多关于它的快捷键。

# htop

现在，让我们启动`htop`，它类似于著名的 top 程序，可以交互式查看进程。`htop`是正常 top 程序的改进版本，增加了新功能，例如垂直和水平滚动，这样你就可以看到系统上运行的所有进程以及完整的命令行。`htop`程序会显示关于你的系统的许多不同信息。按*q*键退出程序。有许多不同的快捷选项要学习；阅读手册页面以了解更多。

# lsof

要打印出所有打开文件的列表，也就是当前访问文件的程序，请使用`lsof`命令。你会得到一个很长的列表；最好使用`grep`来过滤内容。要在命令行上快速进行一些数学计算，请使用 PC 计算器。`screen`是一个非常有用的命令，可以从 SSH 连接中分离出来，而不会实际断开或退出连接，这对于暂停工作然后稍后回到完全相同的位置，或者从另一台计算机工作非常有用。这可以节省大量时间。首先，为了创建一个新的可分离会话，请输入`screen`。现在做你的工作，例如，在 VI 中输入文本。现在，想象一下你的工作日结束了，你回家了。如果没有 screen，现在你需要保存你的更改，关闭 VI，并从服务器注销。有了 screen，只需使用组合键*Ctrl* + *A* + *D*从当前 SSH 会话中分离出来。如果成功从会话中分离出来，会出现一行显示`detached from`，然后是 screen 会话 ID。现在，为了证明我们可以重新附加到这个会话，只需从服务器注销，然后重新登录到服务器。然后，在服务器上输入 screen -list 以获取所有分离的屏幕的列表。要重新附加到你的屏幕，使用 screen ID：`$ screen -r 23433.pts-l_localhost`。如你所见，我们恢复到了离开的地方。如果要停止你的屏幕会话，请输入`exit`。在这里，我们向你展示了这些程序的最基本用例。

# 理解进程

在本节中，我们将向您展示 Linux 中的进程如何工作。现在，让我们讨论有关进程的一切。在 Linux 系统中，当前正在运行的每个程序都称为进程。一个单独的程序可以由多个进程组成，并且进程可以启动其他进程。例如，正如我们已经知道的那样，Bash shell 本身就是一个命令，因此在启动时会得到一个进程。您在此 shell 中启动的每个命令都是由 shell 进程启动的新进程。因此，例如，每次我们执行`la -al`命令时，Bash shell 进程都会创建一个新进程，其中`ls -al`命令正在运行。在每个 Linux 系统上，都有许多进程一直在运行。如果您有多处理器 CPU 计算机，则其中一些进程确实一直在并行运行。其他进程，或者如果您有单处理器 CPU，则只是半并行运行，这意味着每个进程只在 CPU 上运行几毫秒然后暂停，这也被称为进入睡眠状态，因此系统可以在一小段时间内执行下一个进程。这个系统允许所有进程看似并行执行，而实际上它们是依次顺序处理的。

Linux 系统中的所有进程都是由另一个进程创建的，以便每个进程都有一个创建它的父进程。只有第一个进程没有父进程，在 CentOS 7 中是`systemd`进程。要获取所有运行中进程的列表，请运行`ps`命令。这里我们使用`-ev`选项，并将其输出管道传输到`less`命令，因为它不适合屏幕。您将看到每个进程都有一个称为进程标识符或 PID 的唯一标识符。第一个进程，systemd 进程，具有 PID 1。随后的进程按递增顺序排列。每个进程都有一个与之关联的用户 ID，而且每个进程都有一个由父进程 ID 列表示的父进程。您会注意到列表中的前两个进程的父 PID 为 0，这意味着它们没有父进程。

为了更好地理解父子进程关系，您可以使用`pstree`命令，我们首先需要使用`psmisc`软件包进行安装。之后，只需启动`pstree`命令。通过它，您可以更好地了解哪个父进程创建了哪个子进程，以及进程之间的关系。如前所述，systemd 进程是系统中的第一个进程，它创建了系统中的所有其他进程。每个进程也有一个状态；输入`man ps`并转到状态部分。最重要的状态是`running`。这意味着进程当前正在运行，并将由 CPU 执行，或者在运行队列中，这意味着它即将启动。如果进程执行在等待队列中的下一个进程的情况下被中断，您将看到`sleeping`，或者`stopped`，甚至`defunct`或`zombie`，这意味着进程已终止，但父进程尚不知道。

在前一节中，我们已经学习了，您也可以使用`top`或`htop`命令来动态或实时查看系统中的进程。状态列显示进程的状态，其中`r`代表运行，`s`代表睡眠，等等。如果创建了一个新进程，父进程将被克隆或复制到子进程，因此它与父进程具有完全相同的数据和环境。只有 PID 会有所不同，但父进程和子进程彼此完全独立。

# 克隆

在 Linux 中，克隆一个进程也被称为**forking**。例如，如果你在 shell 中执行一个命令，比如`sleep`命令，一个新的进程就会被创建，与父 Bash shell 进程相同，其中`sleep`命令被执行。通常，父进程，例如我们的例子中的 Bash shell 进程，会等待直到子进程完成。这就是为什么在子进程运行时你得不到一个交互式的光标。这是你在 shell 中运行每个命令的正常行为。如果你的 Bash 命令行提示被阻塞，这也被称为运行一个前台作业。要杀死这个前台作业，按下*Ctrl* + *C*。你也可以通过在任何命令的末尾设置&符号来影响这个前台行为。所以，让我们用&符号重新运行上一个命令。当在命令的末尾使用&符号时，父进程不会等待子进程完成，而是两个进程现在并行运行。这也被称为在后台运行一个进程。你会注意到，在后台运行一个进程会返回子进程的进程 ID，所以我们以后可以引用它。例如，要杀死它，使用`kill`命令。为了将最后一个后台作业放到前台，再次输入`fg`并按下*Enter*键。现在，我们的`sleep`命令又回到了前台。要将它放回后台，按下*Ctrl* + *Z*。这并不是直接将我们的前台进程放到后台，而是暂停了进程。要将一个暂停的进程放到后台，输入`pg`，或者放到前台，输入`fg`。为了杀死任何暂停或后台作业，你可以使用`kill`命令。我们在后台运行的进程也被称为**作业**。要列出你当前在终端中拥有的所有作业，你可以使用`jobs`命令。如果你在后台有任何正在运行的作业，输出将显示出来，你可以用括号中的数字引用它。为了处理这样的作业 ID，你需要在前面加上一个百分号。例如，要杀死作业 ID 为 1 的作业，输入`kill %1`。请注意，我们刚刚使用的`pg`，`fg`和`kill`命令只在你在终端中只有一个当前后台作业时才有效。如果你在当前终端中使用多个作业，你需要使用百分号分别处理它们。

# 信号

信号被用于进程之间的通信。如果你启动一个新的进程，当它运行时，你如何通过你的 shell 或任何其他程序或进程与它通信？另外，父进程如何知道子进程何时结束？例如，你的 Bash 如何知道`ls -al`命令何时终止？在 Linux 中，这种通知和进程间通信是通过信号来完成的。在 Linux 中，如果一个进程启动另一个进程，父进程会被挂起，直到子进程命令完成，这将触发一个特殊的信号，这将唤醒父进程。父进程被挂起，以便不需要等待活动的 CPU 时间。一个常用的信号是中断信号，每当我们在一个活动程序中按下*Ctrl* + *C*时，它就会被发送到正在运行的进程。这将立即中断和停止进程。我们已经发送的另一个信号是通过按下*Ctrl* + *Z*来挂起一个进程，以便我们可以将它放到后台。除了使用键组合发送信号，你也可以直接使用`kill`命令向正在运行的进程发送各种信号。

# 杀死

要获取可以发送给进程的所有可用信号的列表，请使用`kill -l`。例如，发送给程序以终止它的标准信号是`SIGKILL`信号，其信号 ID 为 9。因此，让我们首先创建一个新进程，然后终止它；例如，在后台启动一个新的 sleep 进程。正如你已经学到的，将一个进程放入后台会打印出进程 ID。大多数情况下，我们使用`kill`命令来终止系统进程，这些进程通常不是由我们的用户启动的。因此，检索的标准方法是使用`ps`选项`aux`，然后按进程名称进行过滤。使用带有选项`aux`的`ps`会打印出完整的命令行，这通常有助于区分正确的进程，因为通常在这个列表中有多个具有相同命令名称的进程。在我们的示例中，我们只有一个正在运行的 sleep 进程，我们可以确认正确的进程 ID。现在，为了终止这个进程，使用`kill -9`发送`SIGKILL`信号，然后是进程 ID。让我们再次使用`ps`命令来确认：

![](img/e51b61bc-e449-4a4e-a70a-2319c1403587.png)

如你所见，`sleep`命令已成功终止。在前面的部分中，我们使用了`kill`命令和百分比作业 ID，但是使用 PID 而不是作业 ID 的`kill`命令有什么区别呢？后台和挂起的进程通常通过作业编号或作业 ID 进行操作。这个编号不同于进程 ID，因为它更短。使用 PID 杀死进程通常用于使用 root 账户杀死出现故障的系统进程。此外，一个作业可以由一系列或同时并行运行的多个进程组成。使用作业 ID 比跟踪单个进程更容易。

# 挂起

最后，让我们讨论`SIGUP`信号，或者挂起信号。在 CentOS 7 中，如果你在后台运行一个程序，比如`sleep`命令，并且退出系统，然后再次登录，你会看到命令或进程仍在运行。因此，在 CentOS 7 中，我们可以轻松地运行后台进程并退出 SSH 会话，这对于需要一直运行的程序或需要进行几个小时、几天甚至几个月的大量计算非常有用。在其他 Linux 发行版中，如果你退出系统，内核会向所有正在运行的后台进程发送挂起信号，或者简称为`SIGUP`，并终止它们。在这样的系统中，要禁用发送给你的进程的挂起信号，使用`nohup`；在你的命令前加上`nohup`命令，比如`nohup sleep 1000 &`。这样你就可以安全地退出系统，你的任务不会停止运行。但是，如前所述，在 CentOS 7 系统中，你不需要这样做。

# 使用 Bash shell 变量

在本节中，我们将向您介绍 Linux Bash shell 变量。Bash shell 变量是一种为任何动态值提供符号名称的好方法，因此我们可以通过名称引用值。这有助于创建非常灵活和方便的系统，您通常只需更改一个值，访问此值的计算机上的所有进程都可以自动更改其行为。使用 shell 变量提供了一种简单的方法，在 Linux 中多个应用程序和进程之间共享配置设置，我们将在下一节中看到。要定义一个新的环境变量，请使用以下语法`MY_VALUE=1`，变量的名称等于，然后是值。所有 Bash shell 变量都不得包含空格或特殊字符，并且按照惯例，通常 shell 变量都是大写的。要访问存储的 shell 变量的值，这只是存储值的 shell 扩展，用美元符号作为变量的前缀。您还可以将 shell 变量的内容复制到另一个变量中，使用以下语法：`MY_NEW_VALUE=$MY_VALUE`。要取消设置 shell 变量的内容，请使用`unset`命令。对于分配 shell 变量，与我们在前几章的 shell 引用和 globbing 部分学到的任何其他 Bash 主题一样，都适用相同的引用和转义规则。例如，首先将字符串`b`分配给 shell 变量`a`。现在，为了在字符串中嵌入空格，必须使用引号。在字符串中嵌入双引号时，使用单引号来包围。有许多预定义和全局的 shell 环境变量来配置系统范围的设置，例如`home`、`path`、`shell`等。

虽然 Linux 中没有大多数环境变量的官方标准，但很多程序都使用常见的变量名。例如，如果为`PROXY`环境变量设置一个值，所有使用该变量的程序和服务现在都可以访问这些新的集中信息，而无需您单独告诉每个程序或服务有什么变化。另一个非常重要的系统环境变量是`PATH`变量。它被 Bash shell 本身使用。它包含所有由冒号分隔的路径，Bash shell 尝试查找可执行文件的位置，因此您不必为包含在此路径中的命令提供完整路径。例如，如果我们在一个名为`my-script.sh`的新本地脚本文件夹中创建一个新的脚本文件，我们需要提供其完整的名称位置才能执行它；没有其他方法可以执行脚本。但是，我们不能从`/tmp`目录运行它，因为 Bash 在其路径中找不到它。现在，如果我们将脚本的位置添加到路径环境变量中，我们就可以在任何地方运行我们的脚本，而无需提供完整的路径，甚至自动完成也可以工作。但是 Bash shell 变量和环境变量之间有什么区别呢？

普通的 shell 变量不是所谓的进程环境的一部分，换句话说，在任何子进程或子进程中都看不到它们。这是因为在执行进程时，只有环境被克隆，而不是本地 shell 变量。您可以通过使用`MYVAR=helloworld`创建以下 shell 变量来测试这一点，然后在我们将作为子进程运行的脚本中使用它：

![](img/7b5b9eba-a6f7-4014-bc58-0402c11b383b.png)

正如您所看到的，我们创建了一个名为`MYVAR`的新 shell 变量，然后创建了一个引用或尝试访问此环境变量的脚本。现在，如果我们执行此脚本会发生什么？正如您所看到的，子进程或子进程无法访问父进程中的`MYVAR` Bash shell 变量，但是您可以通过将我们的`MYVAR` shell 变量定义为环境变量来更改此行为。在进程创建期间，任何子进程都会获得父进程的环境副本，包括所有环境变量，但不包括本地 shell 变量。如果您在 shell 变量前加上`export`这个词，子进程就可以访问这个环境变量，因为在创建新进程时，环境是从父进程复制到子进程的。但是，即使像 shell 变量这样的环境变量也无法在系统退出时保留，这意味着如果您关闭 SSH 会话，所有定义的变量都会消失。

如果您想创建一个系统范围的环境变量，该变量对每个用户都可用，并且在系统退出时仍然存在，请使用您的 root 用户帐户将变量放入`/etc/environment`文件中。您还可以使用以下语法通过在运行命令之前在 shell 变量名称前加上前缀的方式使 shell 变量对子进程可用，例如`MYVAR=NEW_Helloworld ~/scripts/local_var.sh`。这样，您就不必将 shell 变量定义为环境变量。另一个非常重要的规则是，子进程永远无法更改父进程的环境变量，因为子进程和父进程彼此独立，子进程只有父进程环境的本地副本。要测试这一点，请尝试以下操作：

![](img/9c5ff27f-be37-4490-b6e5-59ff3f1859c0.png)

首先，让我们清除本地子 Bash shell 变量可能具有的所有可能的旧值。接下来，创建一个脚本，创建一个名为`CHILDVAR`的新环境变量，其值为`Hello_from_child`。现在，如果我们执行此脚本会发生什么？如果执行脚本，`CHILDVAR`环境变量将在子进程中设置，并且此`CHILDVAR`环境变量对父进程不可见。总之，在脚本中定义的任何 shell 变量或环境变量永远不会在父进程中可见。如果要使 shell 变量从子进程可用于父进程，首先需要在子进程中创建一个所谓的源文件，在其中定义您的环境变量`vi ~/scripts/child.sh`。

接下来，在您的子进程中执行脚本：

![](img/97fcd181-08af-46a4-b269-99fc37ed054b.png)

这将为父进程创建源文件。现在，在父进程中，首先我们检查`CHILDVAR`环境变量是否可用。如果没有，让我们使用`source`命令来源化它。最后，让我们重新检查`CHILDVAR`环境变量是否现在可访问。如果是，那么这是在子进程中创建环境变量并使其可用的有效方法。

# Bash shell 脚本介绍

在本节中，我们将向您介绍 Bash shell 脚本的核心概念。Bash shell 脚本的另一个非常重要的特性是函数。我们在 Bash shell 脚本中大量使用函数，以使重复出现的任务或命令可重用。函数封装了一个任务，使其更加模块化。函数通常接收数据，处理数据，并返回结果。一旦编写了一个函数，它就可以一遍又一遍地使用，但我们也可以在命令行上使用函数。

让我们通过创建一个来讨论函数的一般语法：

```
$ say_hello90 {
>echo "My name is $1";
>}  
```

第一个单词是函数名，后面跟着开括号和闭括号，用于定义函数，然后是一个大括号；所有属于函数的命令都在开括号和闭括号内定义，这也被称为函数体。函数可以像普通命令一样有参数，这些参数可以从外部访问函数体。要在函数中访问特定参数，使用美元符号加数字的表示法。所以`$1`是第一个参数，`$2`是第二个，依此类推。让我们来看看我们的`say_hello`函数。如果我们用一个参数调用这个函数，函数将用一个参数执行，并且这个参数将在函数体中被使用，我们可以用`$1`变量访问第一个参数，这不过是一个普通的 shell 扩展。

函数也可以在它们的函数体中调用其他函数。现在，让我们学习如何将你的 shell 命令放入一个 shell 脚本文件中。脚本文件只是包含不同 Linux 命令、控制结构、循环等的纯文本文件。通常，它们是为了解决日常计算机问题并满足你自己的个人需求，而不是手动逐个执行单个命令。有两种方法可以将文本文件作为 shell 脚本执行。第一种方法是将其作为 Bash 命令的参数使用。另一种方法是在不使用它作为 Bash 命令的参数的情况下首先使脚本可执行，然后在第一行放置所谓的 shebang 行，告诉命令行这个文件是一个 Bash 脚本，并且应该用 Bash 解释器启动。在我们的例子中，`#!/bin/bash`是 shebang 行，告诉 Bash 这是一个 Bash shell 脚本。现在，要用 shebang 方法启动它，使它可执行，然后你可以在命令行上运行它，如下：

```
$ vi /tmp/new-script.sh
$ chmod +x /tmp/new-script.sh
/tmp/new-script.sh   
```

与使用函数类似，我们也可以在 shell 脚本中访问命令行参数，比如`$ vi /tmp/new-script.sh`。第一个参数可以用`$1`访问，第二个参数用`$2`，依此类推。在 shell 脚本中，你还可以用`$0`访问 shell 脚本的名称。可以用`$#`访问参数的总数。所以，例如，要编写一个检查你的脚本至少需要两个参数的检查，做如下操作：

```
#!/bin/bash
echo "Hello World"
echo "..........."
if [[ $# -lt 2 ]]
then
echo "Usage $0 param1 param2"
echo $1
echo $2
echo $0
echo $#  
```

所以，这个脚本的作用是检查命令行参数的数量是否至少为两个，如果不是这样，那么将打印出一个使用格式，说明你需要两个参数，按*Enter*，然后返回一个值为`1`的退出值，这意味着这个脚本抛出了一个错误，因为，正如我们已经知道的，脚本将在成功执行时返回`0`。让我们测试一下这个脚本：

![](img/e74aa248-dede-4c8d-b5a6-e0a0fc11d9b6.png)

如果我们只用一个参数启动脚本，它将打印出使用格式。然而，如果我们用两个参数启动它，它将正确工作。当涉及 shell 脚本时，还有很多东西要学习，我们只能向你展示最基本的东西来让你开始。你可以参考 Bash 手册，或者开始阅读你的 Cent0S 7 操作系统中免费提供的各种 shell 脚本。输入以下命令以获取所有`.sh`文件的列表：`su -c 'find / -name "*.sh"'`，这是你系统中 shell 脚本文件的默认扩展名。只需打开系统中可用的一个 shell 脚本文件，并尝试理解它，例如`/usr/libexec/grepconf.sh`。

# 实施 Bash shell 脚本

除了我们在前一节中使用的逻辑`and`和`or`表达式，如果我们需要根据命令的退出状态、变量值、命令输出等做出决定，我们需要理解`if`语句或条件分支。简而言之，`if`语句意味着基于某些条件，我们的脚本或命令行应该执行一个动作，否则应该执行其他动作。

让我们再次使用上一节的退出代码来演示：

![](img/e85d9ae2-c58a-4d0b-ba90-360496cda0f2.png)

在这个例子中，我们发出了`ls`命令来查看`oiip`主目录的内容。我们将`ls`命令的退出状态存储在`EXIT` Bash 变量中。在下一行，我们现在陈述了 if 条件。这可以理解为：`if` Bash 变量`EXIT`等于`0`，那么打印出两行文本，以及这个`if`条件与反向 if 词 fi。正如你所看到的，这两行已经被打印出来，这意味着 if 条件是真的，所以退出值是`0`。重要的是要注意，你必须非常小心地设置空格和换行，就像我在前面的例子中所做的那样，但你也可以把完整的 if 语句放在一行中，你可以看到如果按上箭头键显示历史中的最后一个命令。正如你所看到的，shell 在内部使用分号空格而不是换行来分隔大多数表达式，这有点难以阅读，特别是当你写更复杂的 Bash shell 脚本一行代码时。要否定任何 if 表达式，这意味着`if`语句在条件不满足时评估为真，使用以下内容：

```
$ EXIT=1
$ if ! [[ $EXIT -eq 0 ]]
>then
>echo "EXIT value is not zero"
>fi
EXIT value is not zero  
```

在这个例子中，if 条件可以理解为：如果退出值不等于`0`，那么打印出文本。在我们的例子中，这是真的，因为退出值是`1`。if 条件可以包括许多不同的测试，这里展示了最重要的一些。要测试相等性，使用`-eq`测试，就像我们刚刚看到的那样。你可以用它来比较数字。对于字符串比较，使用`==`运算符。你还可以使用逻辑`and`和`or`表达式，就像在上一节中介绍的那样，例如，也可以测试替代方案。这个例子可以理解为：如果密码等于`Hello_my_world_555`或者密码等于`my_secret_pass`。在这个例子中，密码是正确的。你还可以使用等于波浪线运算符来使用正则表达式。这个语句可以理解为：如果字符串与行的开头匹配，则 if 条件为真，其中第一个两个字符是变量，但接下来必须是`rem`，这是真的。对于数字值，你也可以使用`-lt`和`-gt`来测试小于或大于数字，而不是使用`-eq`，例如，测试小于或测试大于。

另一组非常重要的 if 条件是文件测试。存在大量非常强大的文件测试，用于查看文件或目录是否满足特定属性。有大量非常强大的文件测试，用于查看文件或目录是否满足特定属性，例如测试文件是否存在，使用`-a`文件测试，或者检查目录是否存在使用`-d`文件测试。这在下面的截图中显示：

![](img/e90b6248-ed1b-4803-98db-85f1d17a014c.png)

要了解所有现有文件测试，以及所有可用的比较运算符，请打开 Bash 手册并搜索条件表达式。我们刚刚学到的最简单的 if 语句的一般语法是，如果条件为真，则在开始 if 和结束`fi`之间的所有命令都会被执行。现在，你也可以加入一个`else`分支，如果条件不为真，则会执行该分支。下面的截图显示了执行情况：

![](img/23e888b5-7f09-45cd-8940-0801ccb8f8a1.png)

`else`分支由`else`关键字引入。在我们的例子中，if 条件不为真，所以将执行 else 分支。如果你有几个独立的条件要检查，你也可以使用`elif`语句，这比连续写多个`if`语句要好。所以，不是写三个单独的`if`语句来检查等于、小于和大于的条件，而是使用更紧凑的`elif`表示法：

![](img/f565c1c7-4290-4328-9762-b4d442a7969f.png)

接下来，我们将讨论循环。Bash shell 中最重要的循环之一是`for in`循环。它可以用于迭代一系列单词。单词的分隔符可以是空格或换行符。现在，如果我们在`for`循环中使用这样一个以空格或换行符分隔的单词列表，它将迭代列表中的每一项，我们可以在`for`循环的主体中使用当前值，在那里我们也可以执行命令。这个块将重复多次，就像我们在这个列表中有多少元素一样。在我们的例子中，循环变量的名称，我们称之为`count`，是可以自由选择的：

![](img/35e6cf55-b95c-4ec3-9643-437edd33597b.png)

这个例子可以理解为：对于`1`、`2`、`3`和`4`的列表，每次迭代都将当前值保存在计数变量中，然后在循环体中打印出其内容。但是`for in`循环可以做什么呢？例如，以下 Bash 内置命令扩展为连续数字的列表：`$ echo {1..20}`。您也可以使用`seq`命令做同样的事情，但这会产生一个以换行符分隔的列表。因此，如果我们需要运行一个循环，我们可以这样做。换行符分隔的列表可以完成所有工作，但不要忘记将命令放在美元括号表示法中。正如我们已经知道的那样，shell 通配符字符输出由空格分隔的所有文件的列表，因此我们也可以这样做。在`for in`循环中使用文件的一个重要用例是重命名多个文件，例如，在具有不同文件扩展名的目录中。请注意，在此示例中，我们使用`basename`命令并将其放在美元括号表示法中以返回纯文件名：

![](img/bc907652-f59f-4f97-8a58-0ab9bf7359a9.png)

如您所见，我们创建了一个具有扩展名`.txt`的新目录，其中包含五个文件。然后，我们使用`for each`循环循环我们的五个文件，并且对于每个文件，我们将文件移动到 doc 扩展名。还有其他非常重要的循环，比如`while`循环。您可以参考 Bash 手册并搜索 while。

# 自动化脚本执行

在本节中，我们将向您展示如何自动化 Bash shell 脚本执行。Cron 系统在每个 Linux 系统上都可用，允许管理员根据任何小时、天甚至月份来确定预定义的计划，从而自动化命令或脚本。它是 CentOS 7 操作系统的标准组件，在本节中，我们将向您介绍管理重复任务的概念，以便利用这个宝贵的工具。

首先，让我们创建一个新的脚本，它将从令人难以置信的**Commandlinefu**网页下载一个优雅而有用的 Linux 命令行示例，并将其放入 Linux 系统中的`motd`或每日消息文件中，以便用户每次登录系统时都可以看到。`motd`文件是一个简单的文本文件，其中的内容将在成功登录时显示。然后，我们将脚本作为 cron 作业运行，以便每天更新一次每日消息，这对于每天学习一个新的优雅的命令行解决方案非常有用。

为了做到这一点，首先以`root`身份登录，因为 cron 系统位于系统目录中。接下来，复制原始的`motd`文件。之后，让我们创建我们的脚本文件来更新系统中的`motd`文件：

![](img/8d41cb92-dd19-490a-ad88-4d27d46abdd5.png)

```
#!/bin/bash
Wget -0 /etc/motd http://www.commandlinefu.com/commands/random/plaintext
```

这个脚本是普通的批处理脚本，从网页[`www.commandlinefu.com/commands/random/plaintext`](http://www.commandlinefu.com/commands/random/plaintext)下载一个随机的 Commandlinefu 示例，使用`wget`程序将下载的文件保存为`/etc/motd`。因此，我们可以在登录系统时直接看到内容。现在，让我们测试一下我们的新脚本：

![](img/e22ea232-2309-486e-8922-c9e8bb155502.png)

正如您所看到的，脚本已成功从[`www.commandlinefu.com/`](http://www.commandlinefu.com/)网页下载了一个 Commandlinefu。为了测试我们使用的 Commandlinefu 网页 URL 是否真的返回一个随机的命令行示例，让我们重新启动我们的脚本：

![](img/72e3a481-291c-4e5d-977d-a438557e2864.png)

正如您所看到的，这次的命令行示例是不同的。现在，根据您自己的脚本执行偏好，您需要决定要多久执行一次脚本。文件系统中有一些特殊的 cron 目录用于执行系统范围的 cron 作业，您可以使用`# ls /etc/cron* -d`来访问它们。这些文件夹称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们位于`/etc`目录中，它们的名称指的是它们运行的时间点。因此，如果我们希望我们的新 Commandlinefu 脚本每天启动一次，只需将脚本文件放入`cron.daily`目录中，或者使用`cd /etc/cron* -d`创建一个符号链接。如果您希望使用不同的时间表运行它，只需将其放入`cron.hourly`、`cron.monthly`或`cron.weekly`目录中。如果您不想再执行它，只需从文件夹中删除脚本或符号链接。如果您不想运行系统范围的 cron 作业，您也可以作为普通用户使用`crontab`命令。您可以阅读`crontab`手册以了解更多关于这个命令的信息。最后，让我们测试一下`motd`文件是否工作。退出 SSH 会话，然后重新登录：

![](img/f57b53a4-dda2-498d-8433-45e31749d239.png)

正如您所看到的，它运行得很好。根据我们创建的 cron 作业，明天应该会在这里呈现一个不同的命令行示例。

在本章中，我们向您介绍了用于脚本自动化的 Linux cron 系统。

# 总结

在本章中，我们讨论了从基本的 Linux 命令、信号、进程到 Bash shell 脚本的各种主题。

在下一章中，我们将介绍高级命令行概念。
