- en: Signaling - Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号-第一部分
- en: Signals are a crucial mechanism for the Linux system developer to understand
    and exploit. We cover this rather large topic over two chapters in this book,
    this chapter and the next one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信号对于Linux系统开发人员来说是一个至关重要的机制，需要理解和利用。我们在本书的两章中涵盖了这个相当大的主题，即本章和下一章。
- en: In this chapter, the reader is introduced to what signals are, why they are
    useful to the systems developer, and, most importantly of course, how exactly
    the developer is to handle and thus exploit the signalling mechanism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，读者将了解信号是什么，为什么它们对系统开发人员很有用，最重要的当然是开发人员如何处理和利用信号机制。
- en: We will continue this exploration in the next chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中继续探讨这个问题。
- en: 'In this chapter, the reader will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，读者将学习以下内容：
- en: What exactly signals are.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号到底是什么。
- en: Why they are useful.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么它们很有用。
- en: The available signals.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的信号。
- en: How exactly you can handle signals in an application, which really involves
    many things—blocking or unblocking signals, writing safe handlers, getting rid
    of pesky zombies once and for all, working with apps where the signal volume is
    high, and more.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在应用程序中处理信号，这实际上涉及许多事情——阻塞或解除信号、编写安全处理程序、一劳永逸地摆脱讨厌的僵尸进程、处理信号量很高的应用程序等等。
- en: Why signals?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要信号？
- en: 'At times, the systems programmer requires the OS to provide an asynchronous
    facility—some way of letting you know that a certain event or condition has occurred. Signals provide
    that very feature on the Unix/Linux OSes. A process can trap or subscribe to a
    signal; when this occurs, the process will asynchronously be notified of the fact
    by the OS, and will then run the code of a function in response: a signal handler.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，系统程序员需要操作系统提供异步设施——某种方式让你知道某个事件或条件已经发生。信号在Unix/Linux操作系统上提供了这个特性。进程可以捕获或订阅信号；当这发生时，操作系统将异步通知进程，并且运行一个函数的代码作为响应：信号处理程序。
- en: 'Take the following example cases:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：
- en: A CPU-intensive process is busy working on a scientific or mathematical calculation
    (for easy understanding, let's say it's generating primes); recall (from [Chapter
    3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource Limits*) that there
    is an upper limit on CPU usage and that it's been set to a particular value. What
    if it's breached? The process will be killed by default. Can we prevent this?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CPU密集型进程正在忙于进行科学或数学计算（为了便于理解，我们假设它正在生成素数）；回想一下（来自[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)，*资源限制*）CPU使用率有一个上限，并且已经设置为特定值。如果超出了呢？进程将被默认杀死。我们能阻止这种情况发生吗？
- en: 'The developer wants to perform a common task: set up a timer and have it expire
    in, say, 1.5 seconds from now. How will the OS inform the process that the timer
    has expired?'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员想要执行一个常见的任务：设置一个定时器，并在1.5秒后让它到期。操作系统将如何通知进程定时器已经到期？
- en: 'On some Sys V Unixes (typically running on enterprise-class servers), what
    if a sudden power failure occurs? An event is broadcast to all processes (that
    have expressed an interest in, or subscribed to the event) informing them of the
    same: they could flush their buffers, and save their data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些Sys V Unix系统（通常在企业级服务器上运行），如果突然断电会发生什么？一个事件会广播给所有进程（那些对事件表示兴趣或订阅了事件的进程），通知它们相同的情况：它们可以刷新缓冲区并保存数据。
- en: A process has an inadvertent defect (a bug); it makes an invalid memory access.
    The memory subsystem (well, technically, the MMU and the OS) determines it must
    be killed. How exactly will it be killed?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程有一个无意的缺陷（一个错误）；它进行了无效的内存访问。内存子系统（技术上来说，是MMU和操作系统）决定必须将其杀死。它将如何被杀死？
- en: Linux's asynchronous IO (AIO) framework, and many other such scenarios.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux的异步IO（AIO）框架，以及许多其他类似的场景。
- en: All of these example scenarios are serviced by the same mechanism: signals.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例场景都由同一机制服务：信号。
- en: The signal mechanism in brief
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍信号机制
- en: A signal can be defined as an asynchronous event that is delivered to a target
    process. Signals are delivered to the target process either by another process
    or the OS (the kernel) itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以定义为传递给目标进程的异步事件。信号可以由另一个进程或操作系统（内核）本身传递给目标进程。
- en: At the code level, a signal is merely an integer value; more correctly, it is
    a bit in a bitmask. It's important to understand that, although the signal may
    seem like an interrupt, it is not an interrupt. An interrupt is a hardware feature;
    a signal is purely a software mechanism.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码级别，信号只是一个整数值；更准确地说，它是位掩码中的一位。重要的是要理解，尽管信号可能看起来像是中断，但它并不是中断。中断是硬件特性；信号纯粹是软件机制。
- en: 'OK, let''s try a simple exercise: run a process, putting it in an infinite
    loop, and then manually send it a signal via the keyboard. Find the code in (`ch11/sig1.c`):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试一个简单的练习：运行一个进程，将其放在一个无限循环中，然后通过键盘手动发送一个信号给它。在（`ch11/sig1.c`）中找到代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Why is the `sleep(1);`code typecast to `(void)`? This is our way of informing
    the compiler (and possibly any static analysis tool) that we are not concerned
    about its return value. Well, the fact is we should be; there will be more on
    this later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`sleep(1);`代码被强制转换为`(void)`？这是我们告诉编译器（可能是任何静态分析工具）我们不关心它的返回值的方式。事实上，我们应该关心；稍后会有更多内容。
- en: 'It''s working is quite obvious: let''s build and run it, and, after the third
    loop iteration, we press the *Ctrl* + *C* key combination on the keyboard.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作是很明显的：让我们构建并运行它，在第三次循环迭代后，我们在键盘上按下*Ctrl* + *C*组合键。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yes, as expected, the process terminates. But how exactly did this happen?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如预期的那样，进程终止了。但这到底是如何发生的呢？
- en: 'Here is the answer in brief: signalling. More verbosely, this is what occurs
    (it''s still kept simple, though): when the user presses the *Ctrl* + *C* key
    combination (shown as `^C` in the output), the kernel''s `tty`layer code processes
    this input, cooks the input key combination into, and delivers a signal to the
    foreground process on the shell.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简要的答案：信号。更详细地说，这是发生的情况（尽管仍然保持简单）：当用户按下*Ctrl* + *C*键组合（在输出中显示为`^C`）时，内核的`tty`层代码处理此输入，将输入键组合处理成信号，并将其传递给shell上的前台进程。
- en: But, hang on a second. Remember, a signal is just an integer value. So, which
    integer? Which signal? The *Ctrl* + *C* key combination is mapped to the the `SIGINT`
    signal, integer value `2`, thus causing it to be delivered to the process. (The
    next section begins to explain the different signals; for now, let's not get too
    stressed out about it).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等一下。记住，信号只是一个整数值。那么，是哪个整数？哪个信号？*Ctrl* + *C*键组合映射到`SIGINT`信号，整数值为`2`，因此导致其传递给进程。（下一节开始解释不同的信号；现在，让我们不要太担心它）。
- en: 'So, OK, the `SIGINT` signal, value `2`, was delivered to our `sig1` process.
    But then what? Here, again, is a key point: every signal is associated with a
    function to run when it is delivered; this function is called the **signal handler**.
    If we do not change it, the default signal function runs. Well, that brings up
    the question: Since we have not written any default (or other) signal-handling
    code, then who has provided this default signal handler function? The short answer
    is this: the OS (the kernel) handles all cases in which a process receives a signal
    for which the app has not installed any handler; in other words, for the default
    case.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，好吧，`SIGINT`信号，值为`2`，已传递给我们的`sig1`进程。但是接下来呢？这里再次是一个关键点：每个信号都与一个在其传递时运行的函数相关联；这个函数称为**信号处理程序**。如果我们不改变它，将运行默认的信号函数。那么，这带来了一个问题：由于我们没有编写任何默认（或其他）信号处理代码，那么是谁提供了这个默认信号处理程序函数？简短的答案是：操作系统（内核）处理所有情况，即进程接收到应用程序没有安装任何处理程序的信号；换句话说，对于默认情况。
- en: 'The action performed by the signal handler function or the underlying kernel
    code determines what will happen to the target process when the signal arrives.
    So, now we can understand better: the action carried out by the default signal
    handler (kernel code, really) for the `SIGINT` signal is to terminate the process,
    in effect, causing the receiving process to die.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理函数或底层内核代码执行的操作将决定信号到达目标进程时会发生什么。因此，现在我们可以更好地理解：`SIGINT`信号的默认信号处理程序（实际上是内核代码）执行的操作是终止进程，实际上导致接收进程死亡。
- en: 'We show this in the form of a diagram as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其以以下图表的形式显示：
- en: '![](img/7a2a9522-ca6d-4541-ab47-d3df5ca5f5b9.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a2a9522-ca6d-4541-ab47-d3df5ca5f5b9.png)'
- en: Signal delivered via keyboard, default handler causes process to die
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键盘传递信号，默认处理程序导致进程死亡
- en: 'From this diagram, we can see the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中，我们可以看到以下步骤：
- en: A process, **P** comes alive and runs its code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程**P**启动并运行其代码。
- en: The user presses `^C`, in effect causing the `SIGINT` signal to be sent to the
    process.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户按下`^C`，实际上导致`SIGINT`信号被发送到进程。
- en: As we have not set up any signal handler, the default signal handling action
    for this signal, which is part of the OS, is invoked.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有设置任何信号处理程序，因此OS的默认信号处理操作将被调用。
- en: This default signal handling code within the OS causes the process to die.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统中的默认信号处理代码导致进程死亡。
- en: 'FYI, for the default case—that is, all cases where the application developer
    has not installed a specific signal-handling routine (we will learn how exactly
    to install our own signal handlers shortly)—what exactly does the OS code that
    handles these cases do? Depending on the signal being processed, the OS will perform
    one of these five possible actions (see the following table for details):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: FYI，对于默认情况，也就是所有应用程序开发人员没有安装特定信号处理例程的情况（我们将很快学习如何安装我们自己的信号处理程序），处理这些情况的操作系统代码会做什么？根据正在处理的信号，操作系统将执行以下五种可能的操作之一（有关详细信息，请参见以下表格）：
- en: Ignore the signal
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略信号
- en: Stop the process
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止进程
- en: Continue the (previously stopped) process
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续（先前停止的）进程
- en: Terminate the process
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止进程
- en: Terminate the process and emit a core dump
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止进程并发出核心转储
- en: 'The really interesting and powerful thing is this: the programmer has the ability
    to change–to re-vector the signal handling to their own function(s)! In effect,
    we can trap or catch signals by using certain APIs. Once we do so, when the signal
    occurs, control will not go to the default signal- handling (OS) code, but, rather,
    to the function we want it to. In this manner, the programmer can take charge
    and work with the powerful signalling mechanism.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣和强大的是：程序员有能力改变-重新定向信号处理到他们自己的函数！实际上，我们可以使用某些API来捕获信号。一旦我们这样做，当信号发生时，控制将不会转到默认的信号处理（操作系统）代码，而是转到我们想要的函数。通过这种方式，程序员可以控制并利用强大的信号机制。
- en: 'Of course, there is much more to it: the devil does indeed lie in the details!
    Read on.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这还有更多：细节确实隐藏在其中！继续阅读。
- en: Available signals
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用信号
- en: 'The Unix/Linux OS provides a set of 64 signals in total. They are broadly divided
    into two types: the standard or Unix signals and the real-time signals. We shall
    find that while they do share common attributes, there are some important differences
    as well; here, we shall investigate the Unix (or standard) signals and later,
    the latter.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux操作系统总共提供了64个信号。它们大致分为两种类型：标准或Unix信号和实时信号。我们将发现，虽然它们共享共同的属性，但也有一些重要的区别；在这里，我们将调查Unix（或标准）信号，稍后再调查后者。
- en: The generic communication interface for signalling from userspace, besides the
    keyboard key combinations (such as *Ctrl* + *C*), is the `kill(1)` utility (and,
    consequently, the `kill(2)` system call).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了键盘键组合（如*Ctrl* + *C*）之外，用户空间的通用通信接口是`kill(1)`实用程序（因此也是`kill(2)`系统调用）。
- en: Besides the kill, there are several other APIs that deliver a signal; we shall
    flesh out more on this in a later section of this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了kill，还有几个其他API可以传递信号；我们将在本章的后面部分详细介绍这一点。
- en: 'Running the `kill(1)` utility with the `-l` or list option lists the available
    signals on the platform:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kill(1)`实用程序的`-l`或列表选项在平台上列出可用的信号：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Perhaps the moniker `kill(1) `is a misnomer: the kill utility just sends a
    signal to a given process (or job). Thus (per your author at least), the name `sendsig` might
    have been a better choice for the utility.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`kill(1)`这个名字是个误称：kill实用程序只是向给定的进程（或作业）发送一个信号。因此（至少对于您的作者来说），`sendsig`这个名字可能是更好的选择。
- en: 'An FAQ: where are the signals numbered `32` and `33`?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题：信号32和33的编号在哪里？
- en: They are internally used by the Linux Pthreads implementation (called NPTL),
    and are hence unavailable to app developers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它们由Linux Pthreads实现（称为NPTL）内部使用，因此不可用于应用程序开发人员。
- en: The standard or Unix signals
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准或Unix信号
- en: As can be seen from the output of kill, all supported signals on the platform
    are shown; the first 31 of these (on your typical Linux box) are called the standard
    or Unix signals. Unlike the real-time signals that follow, each standard/Unix
    signal has a very specific name, and, as you might guess, purpose.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从kill的输出中可以看出，平台上支持的所有信号都显示出来；其中前31个（在典型的Linux系统上）被称为标准或Unix信号。与随后的实时信号不同，每个标准/Unix信号都有一个非常具体的名称和目的。
- en: (Worry not; we shall discuss the real-time signals, numbers 34 to 64, in the
    next chapter).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: （不用担心；我们将在下一章讨论实时信号，即34到64的数字）。
- en: 'The table you will see shortly, essentially reproduced from the man page on signal(7),
    summarizes the standard (Unix) signals in the following column order: the signal''s
    symbolic name, integer value(s), the default action taken upon delivery to a process,
    and a comment describing the signal.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您很快将看到的表格，基本上是从`signal(7)`的man页面中复制的，总结了标准（Unix）信号，列顺序如下：信号的符号名称，整数值，传递给进程时采取的默认操作，以及描述信号的注释。
- en: 'The default action column has the following types: the default action of the
    signal handler is to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作列有以下类型：信号处理程序的默认操作是：
- en: '**Terminate**: Terminate the process.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：终止进程。'
- en: '**Term&Core**: Terminate the process and emit a core dump. (A core dump is,
    essentially, a snapshot of the process''s dynamic segments, the data and stack
    segments, at the time when the (fatal) signal was delivered). This terminate and
    core dump action occurs when the kernel sends a fatal signal to a process. The
    implication is that the process has done something illegal (buggy); an exception
    is the `SIGQUIT` signal: we get a core dump when `SIGQUIT` is delivered to a process.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止和生成核心转储**：终止进程并生成核心转储。（核心转储实质上是进程的动态段，即数据和堆栈段，在传递（致命）信号时的快照）。当内核向进程发送致命信号时，会发生这种终止和核心转储操作。这意味着进程已经做了一些非法的事情（有bug）；一个例外是`SIGQUIT`信号：当`SIGQUIT`传递给进程时，我们会得到一个核心转储。'
- en: '**Ignore**: Ignore the signal.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略**：忽略该信号。'
- en: '**Stop**: Process enters the stopped (frozen/suspended) state (represented
    by `T` in the output of `ps -l)`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：进程进入停止（冻结/暂停）状态（在`ps -l`输出中用`T`表示）。'
- en: '**Continue**: Continue execution of a previously stopped process.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续**：继续执行先前停止的进程。'
- en: 'Refer to the table Standard or Unix signals:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 参考标准或Unix信号表：
- en: '| **Signal** | **Integer****value** | **Default****action** | **Comment** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **信号** | **整数值** | **默认操作** | **注释** |'
- en: '| `SIGHUP` | `1` | Terminate | Hang up detected on controlling terminal or
    death of controlling process​ |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `SIGHUP` | `1` | 终止 | 在控制终端检测到挂机或控制进程死亡​ |'
- en: '| `SIGINT` | `2` | Terminate | Interrupt from keyboard : `**^**C` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `SIGINT` | `2` | 终止 | 从键盘中断：`**^**C` |'
- en: '| `SIGQUIT` | `3` | Term&Core | Quit from keyboard : `**^\**` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `SIGQUIT` | `3` | 终止和生成核心转储 | 从键盘退出：`**^\**` |'
- en: '| `SIGILL` | `4` | Term&Core | Illegal Instruction |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `SIGILL` | `4` | 终止和生成核心转储 | 非法指令 |'
- en: '| `SIGABRT` | `6` | Term&Core | Abort signal from abort(3)​ |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `SIGABRT` | `6` | 终止和生成核心转储 | 来自abort(3)的中止信号​ |'
- en: '| `SIGFPE` | `8` | Term&Core | Floating-point exception​ |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `SIGFPE` | `8` | 终止和生成核心转储 | 浮点异常 |'
- en: '| `SIGKILL` | `9` | Terminate | (Hard) kill signal |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `SIGKILL` | `9` | 终止 | （强制）终止信号 |'
- en: '| `SIGSEGV` | `11` | Term&Core | Invalid memory reference |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSEGV` | `11` | 终止和生成核心转储 | 无效的内存引用 |'
- en: '| `SIGPIPE` | `13` | Terminate | Broken pipe: write to pipe with no readers;
    see pipe(7) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPIPE` | `13` | 终止 | 管道中断：向没有读取者的管道写入；参见pipe(7) |'
- en: '| `SIGALRM` | `14` | Terminate | Timer signal from alarm(2) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `SIGALRM` | `14` | 终止 | 来自alarm(2)的定时器信号 |'
- en: '| `SIGTERM` | `15` | Terminate | Termination signal (soft kill) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTERM` | `15` | 终止 | 终止信号（软终止） |'
- en: '| `SIGUSR1` | `30,10,16` | Terminate | User-defined signal 1 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `SIGUSR1` | `30,10,16` | 终止 | 用户定义的信号1 |'
- en: '| `SIGUSR2` | `31,12,17` | Terminate | User-defined signal 2 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `SIGUSR2` | `31,12,17` | 终止 | 用户定义的信号2 |'
- en: '| `SIGCHLD` | `20,17,18` | Ignore | Child stopped or terminated |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `SIGCHLD` | `20,17,18` | 忽略 | 子进程停止或终止 |'
- en: '| `SIGCONT` | `19,18,25` | Continue | Continue if stopped |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `SIGCONT` | `19,18,25` | 继续 | 如果停止则继续 |'
- en: '| `SIGSTOP` | `17,19,23` | Stop | Stop process |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSTOP` | `17,19,23` | 停止 | 停止进程 |'
- en: '| `SIGTSTP` | `18,20,24` | Stop | Stop typed at terminal : `^Z` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTSTP` | `18,20,24` | 停止 | 在终端上停止输入：`^Z` |'
- en: '| `SIGTTIN` | `21,21,26` | Stop | Terminal input for background process |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTTIN` | `21,21,26` | 停止 | 后台进程的终端输入 |'
- en: '| `SIGTTOU` | `22,22,27` | Stop | Terminal output for background process |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTTOU` | `22,22,27` | 停止 | 后台进程的终端输出 |'
- en: 'At times, the second column, the signal''s integer value, has three numbers.
    Well, it''s like this: the numbers are architecture-(meaning CPU) dependent; the
    middle column represents the value for the x86 architecture.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，第二列，信号的整数值，有三个数字。嗯，就是这样：这些数字是与架构（即CPU）相关的；中间列代表x86架构的值。
- en: Always use the symbolic name of the signal in code (such as `SIGSEGV`), including
    scripts, and never the number (such as `11`). You can see that the numeric value
    changes with the CPU, which could lead to non-portable buggy code!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中始终使用信号的符号名称（如`SIGSEGV`），包括脚本，而不是数字（如`11`）。您可以看到数字值随CPU而变化，这可能导致不可移植的错误代码！
- en: What if the system admin needs to urgently kill a process? Yes, its quite possible
    that, while logged into an interactive shell, time is very precious and an extra
    couple of seconds may make a difference. In such cases, typing kill `-9` is better
    than kill `-SIGKILL`, or even kill `-KILL`. (The previous point is with regard
    to writing source code).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统管理员需要紧急终止进程怎么办？是的，很可能，在交互式shell中，时间非常宝贵，多出来的几秒钟可能会有所不同。在这种情况下，键入kill `-9`比kill
    `-SIGKILL`或者kill `-KILL`更好。（前面的观点是关于编写源代码）。
- en: 'Passing the signal number to kill `-l` causes it to print the signal''s symbolic
    name (albeit in a shorthand notation). For example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号编号传递给kill `-l`会导致它打印信号的符号名称（尽管是简写形式）。例如：
- en: '`$ kill -l 11`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kill -l 11`'
- en: '`SEGV`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEGV`'
- en: '`$ `'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ `'
- en: The preceding table (and, as a matter of fact the following table as well) reveal
    that, with two exceptions, all the signals have a special purpose. Scanning the
    comment column reveals it. The exceptions are `SIGUSR1` and `SIGUSR2` these are
    general purpose signals; their use is left entirely to the imagination of the
    application designers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格（实际上后面的表格也是如此）显示，除了两个例外，所有信号都有特殊用途。扫描注释列可以发现这一点。例外是`SIGUSR1`和`SIGUSR2`，这些是通用信号；它们的使用完全取决于应用程序设计者的想象力。
- en: 'Further, the man page informs us that the following signals (shown in this
    table) are newer and included in the `SUSv2` and `POSIX.1-2001` standards:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，手册页告诉我们，以下信号（在此表中显示）是较新的，并包括在`SUSv2`和`POSIX.1-2001`标准中：
- en: '| **Signal** | **Integer** **Value** | **Default** **Action** | **Comment**
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **信号** | **整数值** | **默认操作** | **注释** |'
- en: '| `SIGBUS` | `10,7,10` | Term&Core | Bus error (bad memory access) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `SIGBUS` | `10,7,10` | Term&Core | 总线错误（内存访问错误） |'
- en: '| `SIGPOLL` |  | Terminate | Pollable event (Sys V). Synonym for SIGIO |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPOLL` |  | 终止 | 可轮询事件（Sys V）。SIGIO的同义词 |'
- en: '| `SIGPROF` | `27,27,29` | Terminate | Profiling timer expired |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPROF` | `27,27,29` | 终止 | 分析计时器已过期 |'
- en: '| `SIGSYS` | `12,31,12` | Term&Core | Bad system call (SVr4); see also seccomp(2)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSYS` | `12,31,12` | Term&Core | 系统调用错误（SVr4）；另请参阅seccomp(2) |'
- en: '| `SIGTRAP` | `5` | Term&Core | Trace/breakpoint trap |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTRAP` | `5` | Term&Core | 跟踪/断点陷阱 |'
- en: '| `SIGURG` | `16,23,21` | Ignore | Urgent condition on socket (4.2BSD) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SIGURG` | `16,23,21` | 忽略 | 套接字上的紧急情况（4.2BSD） |'
- en: '| `SIGVTALRM` | `26,26,28` | Terminate | Virtual alarm clock (4.2BSD) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `SIGVTALRM` | `26,26,28` | 终止 | 虚拟警报时钟（4.2BSD） |'
- en: '| `SIGXCPU` | `24,24,30` | Term&Core | CPU time limit exceeded (4.2BSD); see
    prlimit(2) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `SIGXCPU` | `24,24,30` | Term&Core | CPU时间限制超出（4.2BSD）；参见prlimit(2) |'
- en: '| `SIGXFSZ` | `25,25,31` | Term&Core | File size limit exceeded (4.2BSD); see
    prlimit(2) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `SIGXFSZ` | `25,25,31` | Term&Core | 文件大小限制超出（4.2BSD）；参见prlimit(2) |'
- en: Newer standard or Unix signals
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的标准或Unix信号
- en: A few remaining (not so common) signals are further mentioned by the same man
    page (`signal(7)`). Take a look if you are interested.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同一手册页还进一步提到了一些剩余的（不太常见的）信号（`signal(7)`）。如果感兴趣，可以看一下。
- en: 'It''s important to note that, out of all the signals mentioned, only two of
    them cannot be caught, ignored or blocked: the `SIGKILL` and the `SIGSTOP`. This
    is because the OS must guarantee a way to kill and/or stop a process.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，所有提到的信号中，只有两个信号不能被捕获、忽略或阻塞：`SIGKILL`和`SIGSTOP`。这是因为操作系统必须保证一种方法来终止和/或停止进程。
- en: Handling signals
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理信号
- en: In this section, we shall discuss in detail how exactly signals are handled
    by the application developer programmatically (using C code, of course).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细讨论应用程序开发人员如何以编程方式处理信号（当然是使用C代码）。
- en: Glance back at *Figure 1*.You can see how the OSperforms default signal handling,
    which runs when an uncaught signal is delivered to the process. This seems good,
    until we realize that, pretty often, the default action is to simply kill (or
    terminate) the process. What if the application demands we do something else?
    Or, what if, realistically, the application doescrash, instead of just abruptly
    dying (and perhaps leaving important files and other metadata in an inconsistent
    state). Perhaps we can put the program into a sane state by performing some required
    cleanup, flushing buffers, closing open files, logging the state/debug information,
    and so on, informing the user of the sorry state of affairs (with a nice dialog
    box perhaps), and *then *have the process die, gracefully and peacefully, if you
    will.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾*图1*。您可以看到操作系统如何执行默认的信号处理，当未捕获的信号传递给进程时运行。这似乎很好，直到我们意识到，默认操作很常见的是简单地杀死（或终止）进程。如果应用程序要求我们做其他事情怎么办？或者，实际上，应用程序崩溃了，而不仅仅是突然死亡（可能留下重要文件和其他元数据处于不一致的状态）。也许我们可以通过执行一些必要的清理，刷新缓冲区，关闭打开的文件，记录状态/调试信息等，通知用户糟糕的情况（也许是一个漂亮的对话框），然后优雅而平静地让进程死去。
- en: The ability to catch or trap a signal is the key to achieving these goals. As
    mentioned earlier, to re-vector the flow of control such that it's not the default
    signal-handling kernel code, but our custom signal handling code that executes
    when the signal arrives.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获或陷阱信号的能力是实现这些目标的关键。如前所述，重新定向控制流，使其不是默认的信号处理内核代码，而是我们自定义的信号处理代码在信号到达时执行。
- en: 'So, how do we achieve this? By using APIs to register interest in and thus
    handle signals. Broadly, there are three available APIs to catch or trap a signal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这一点呢？通过使用API来注册对信号的兴趣，从而处理信号。广义上说，有三种可用的API来捕获或陷阱信号：
- en: '`sigaction(2)` system call'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigaction(2)`系统调用'
- en: '`signal(2)` system call'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal(2)`系统调用'
- en: '`sigvec(3)` library API'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigvec(3)`库API'
- en: Well, of these three APIs, the `sigvec` is nowadays considered deprecated. Also,
    unless the work is really simplistic, you are urged to forgo the `signal(2)` API
    in favor of the `sigaction` API. Effectively, the powerful way to handle signals
    is via the `sigaction(2)` system call; it is the one we shall discuss in depth.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这三个API中，`sigvec`现在被认为是已弃用的。此外，除非工作真的很简单，您应该放弃`signal(2)`API，转而使用`sigaction`API。实际上，处理信号的强大方法是通过`sigaction(2)`系统调用；这是我们将深入讨论的方法。
- en: Using the sigaction system call to trap signals
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sigaction系统调用来捕获信号
- en: The `sigaction(2)` system call is the right way to trap or catch signals; it's
    powerful, POSIX compliant, and can be used to hone your application's signal-handling
    superbly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigaction(2)`系统调用是捕获或捕捉信号的正确方法；它功能强大，符合POSIX，并且可以用来优化应用程序的信号处理。'
- en: 'At a high level, the `sigaction` system call is used to register a signal handler
    for a given signal. If the signal''s handler function was `foo`, we can use `sigaction` to
    change its signal handler to `bar`. As usual, there is a lot more we can specify
    as well, which has a powerful impact upon signal handling, and we shall come to
    all that shortly. Here is the signature:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，`sigaction`系统调用用于为给定信号注册信号处理程序。如果信号的处理函数是`foo`，我们可以使用`sigaction`将其信号处理程序更改为`bar`。通常情况下，我们还可以指定更多内容，这对信号处理产生了强大的影响，我们很快就会讨论到所有这些。这是签名：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Feature Test Macro Requirements for `glibc` (see `feature_test_macros(7)`):
    `sigaction()`:  `_POSIX_C_SOURCE`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`的特性测试宏要求（参见`feature_test_macros(7)`）：`sigaction()`: `_POSIX_C_SOURCE`'
- en: '`siginfo_t`:  `_POSIX_C_SOURCE >= 199309L`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`siginfo_t`: `_POSIX_C_SOURCE >= 199309L`'
- en: The man page on `sigaction(2)` informs us (via the Feature Test Macro Requirements
    section; see further on for a few details) that using `sigaction` requires the
    definition of the `_POSIX_C_SOURCE` macro; this is almost always the case with
    modern code on Linux. Further, usage of the `siginfo_t` data structure (explained
    later in this chapter) requires you to have `POSIX` version `199309L` or later.
    (The format is `YYYYMM`; hence, that's the `POSIX` standard draft as of September
    1993; again, this would certainly be the case on any reasonably modern Linux platform).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigaction(2)`的man页面告诉我们（通过特性测试宏要求部分；稍后会有更多细节），使用`sigaction`需要定义`_POSIX_C_SOURCE`宏；这在现代Linux上几乎总是如此。此外，使用`siginfo_t`数据结构（稍后在本章中解释）需要您拥有`POSIX`版本`199309L`或更高版本。（格式为`YYYYMM`；因此，这是1993年9月的`POSIX`标准草案；同样，在任何相当现代的Linux平台上都是如此）。'
- en: Sidebar – the feature test macros
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏 - 特性测试宏
- en: 'A quick digression: feature test macros are a `glibc` feature; they allow a
    developer to specify, at compile time, the exact feature set by defining these
    macros in the source. The manual (man) pages always specify (as required), the
    feature test macros required to be present to support a certain API or feature.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的离题：特性测试宏是`glibc`的一个特性；它允许开发人员在源代码中定义这些宏，从而在编译时指定确切的特性集。手册（man）页面总是指定（如有必要）要求存在的特性测试宏，以支持某个API或特性。
- en: With regard to these feature test macros, on both the Ubuntu (17.10) and Fedora
    (27) Linux distributions, we have tested the source code of this book upon, the
    value of `_POSIX_C_SOURCE` is `200809L`. The macro is defined in the header file
    `<features.h>`, which is itself included in the header `<unistd.h>`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些特性测试宏，在Ubuntu（17.10）和Fedora（27）Linux发行版上，我们已经测试了本书的源代码，`_POSIX_C_SOURCE`的值为`200809L`。该宏在头文件`<features.h>`中定义，该头文件本身包含在头文件`<unistd.h>`中。
- en: 'A simple test program to print a few feature test macros is provided within
    the book''s GitHub source tree here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc).
    Why not give it a try on your Linux platform?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的GitHub源代码树中提供了一个简单的测试程序，用于打印一些特性测试宏：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc)。为什么不在您的Linux平台上试一试呢？
- en: More on feature test macros from the `glibc` documentation: [http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html](http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`文档中有关特性测试宏的更多信息：[http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html](http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html)。'
- en: The sigaction structure
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sigaction结构
- en: The `sigaction(2)` system call takes three parameters, of which the second and
    third are of the same data type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigaction(2)`系统调用有三个参数，其中第二个和第三个参数的数据类型相同。'
- en: 'The first parameter `int signum` is the signal to trap. This straight away
    reveals an important point: signals are meant to be trapped one at a time—you
    can only trap one signal with a single call to `sigaction`. Do not attempt to
    be overly clever and do things such as pass a bitmask of signals (bitwise-ORed)
    together; that''s a bug. Of course, you can always call `sigaction` multiple times
    or in a loop.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`int signum`是要捕获的信号。这立即揭示了一个重要的观点：信号是要逐个捕获的 - 您只能使用单个`sigaction`调用捕获一个信号。不要试图过于聪明，做一些诸如一起传递信号的位掩码（按位或）之类的事情；那是一个错误。当然，您可以多次调用`sigaction`或在循环中调用。
- en: 'The data type of the second and third parameters is a pointer to a structure
    called, again, `sigaction`. The `sigaction` structure definition is as follows
    (from the header `/usr/include/bits/sigaction.h`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数的数据类型是指向一个名为`sigaction`的结构的指针。`sigaction`结构的定义如下（来自头文件`/usr/include/bits/sigaction.h`）：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first member, a function pointer, refers to the signal handler function itself.
    On modern Linux distributions, the `__USE_POSIX199309`  macro will indeed be defined;
    hence, as can be seen, the signal handler value is a union of two elements, implying
    that at runtime, exactly one of them will be used. The previous comments make
    it clear: by default, the `sa_handler` prototype function is used; however, if
    the flag `SA_SIGINFO` is passed along (in the third member `sa_flags`), then the
    `sa_sigaction` styled function is used. We shall make this clear with sample code
    soon.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个成员，一个函数指针，指的是信号处理程序函数本身。在现代Linux发行版上，`__USE_POSIX199309`宏确实会被定义；因此，可以看到，信号处理程序值是两个元素的联合，这意味着在运行时，将准确使用其中一个。先前的评论清楚地表明：默认情况下，使用`sa_handler`原型函数；然而，如果传递了标志`SA_SIGINFO`（在第三个成员`sa_flags`中），那么将使用`sa_sigaction`样式的函数。我们将很快用示例代码来说明这一点。
- en: The C library specifies `__sighandler_t` as: `typedef void (*__sighandler_t)
    (int);`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C库将`__sighandler_t`指定为：`typedef void (*__sighandler_t) (int);`
- en: 'As mentioned previously, it''s a pointer to a function that will receive one
    parameter: an integer value (yes, you guessed it: the signal that is delivered).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，它是一个指向函数的指针，将接收一个参数：一个整数值（是的，你猜对了：传递的信号）。
- en: Before going deeper into the data structure, it would be instructive to write
    and try out a simple C program that handles a couple of signals, using defaults
    for most of the previously mentioned `sigaction` structure members.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解数据结构之前，编写并尝试一个简单的C程序来处理一对信号，对于先前提到的`sigaction`结构的大多数成员使用默认值将是有益的。
- en: 'The source code of the `main()` function of `ch11/sig2.c` :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch11/sig2.c`的`main()`函数的源代码：'
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We deliberately `memset(3)` the `sigaction` structure to all zeros, to initialize
    it (initializing is always good coding practice in any case!). Then, we initialize
    the signal handler to our own signal-handling function `siggy`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将`sigaction`结构的所有成员都设置为零，以初始化它（在任何情况下初始化都是良好的编码实践！）。然后，我们将信号处理程序初始化为我们自己的信号处理函数`siggy`。
- en: 'Notice how, to trap two signals, we require two `sigaction(2)` system calls.
    The second parameter, the pointer to struct `sigaction`, is to be populated by
    the programmer and is considered to be the new settings for the signal. The third
    parameter is, again, a pointer to struct `sigaction`; it, however, is a value-result type:
    if non-NULL and allocated, the kernel will populate it with the previous settings
    of the signal. This is a useful feature: what if the design requires you to perform
    a save and restore of some signal dispositions. Here, as a simple case, we just
    set the third parameter to `NULL`, implying that we are not interested in the
    previous signal state.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了捕获两个信号，我们需要两个`sigaction(2)`系统调用。第二个参数，指向结构`sigaction`的指针，由程序员填充，被认为是信号的新设置。第三个参数再次是指向结构`sigaction`的指针；然而，它是一个值-结果类型：如果非空且已分配，内核将用信号的先前设置填充它。这是一个有用的特性：如果设计要求您执行一些信号处理的保存和恢复。在这里，作为一个简单的情况，我们只是将第三个参数设置为`NULL`，意味着我们对先前的信号状态不感兴趣。
- en: 'We then enter the same (as `sig1.c`) infinite loop... Our simple signal handler
    function `siggy` is shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入与`sig1.c`相同的无限循环...我们简单的信号处理程序函数`siggy`如下所示：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The signal handler receives one integer value as its parameter: the signal
    that caused control to reach here. Hence, we can multiplex on multiple signals:
    set up a common signal handler and perform a simple switch-case to handle each
    specific signal.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序接收一个整数值作为参数：导致控制到达此处的信号。因此，我们可以对多个信号进行多路复用：设置一个公共信号处理程序，并执行一个简单的`switch-case`来处理每个特定的信号。
- en: 'The signal handling function''s return type is `void`, of course. Ask yourself:
    Where will it return? It''s an unknown. Remember, signals can arrive asynchronously; we
    have no idea when exactly the handler will run.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理函数的返回类型当然是`void`。问问自己：它会返回到哪里？这是未知的。记住，信号可以异步到达；我们不知道处理程序何时会运行。
- en: 'Let''s try it out:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that this time, the `SIGINT` (via keyboard `^C`) and the `SIGQUIT`
    (via keyboard `**^\**` key combination) signals are being handled by the application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这次，应用程序正在处理`SIGINT`（通过键盘`^C`）和`SIGQUIT`（通过键盘`**^\**`组合键）信号。
- en: 'So, how do we terminate the app? Well, one way is to open another terminal
    window and kill the app via the `kill` utility. For now, though, we use another
    method: we send the `SIGTSTP` signal to the process (via keyboard `**^Z**` key
    combination) to put it into the stopped state; we get back the shell. Now, we
    simply kill it via `kill(1)`.(`[1]` is the process''s job number; you can use
    the `jobs` command to see all current jobs on the session).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何终止应用程序呢？好吧，一种方法是打开另一个终端窗口，并通过`kill`实用程序杀死应用程序。不过，现在，我们使用另一种方法：我们向进程发送`SIGTSTP`信号（通过键盘`**^Z**`组合键）将其置于停止状态；我们返回shell。现在，我们只需通过`kill(1)`杀死它。(`[1]`是进程的作业号；您可以使用`jobs`命令查看会话中的所有当前作业)。
- en: 'We show this in the form of a diagram as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下形式的图表显示：
- en: '![](img/871c65ca-8d1e-4ef9-8d22-0ced84f61f91.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871c65ca-8d1e-4ef9-8d22-0ced84f61f91.png)'
- en: 'Figure 2: Handling a Signal'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：处理信号
- en: Clearly, as demonstrated by our simple `sig2` application and *Figure 2*, once
    a signal is trapped (via the `sigaction(2)` (or the signal) system call), when
    it is delivered to the process, control is now re-vectored to the new application-specific
    signal handler function, and not to the default OS signal-handling code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，正如我们简单的`sig2`应用程序和*图2*所示，一旦捕获到信号（通过`sigaction(2)`（或`signal`）系统调用），当它传递给进程时，控制现在重新定向到新的特定于应用程序的信号处理程序函数，而不是默认的操作系统信号处理代码。
- en: 'In the program `sig2`, all looks good, except that you, the careful reader,
    may have noticed a bit of a puzzle: in the siggy signal handler function''s code, why
    not just use a simple `printf(3)` to emit a message. Why  the `write(2)` system
    call? Actually, there''s a really good reason behind this. This, and more, is
    coming up.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序`sig2`中，一切看起来都很好，除了你，细心的读者，可能已经注意到一个谜题：在信号处理程序函数的代码中，为什么不只使用一个简单的`printf(3)`来发出消息。为什么要使用`write(2)`系统调用？实际上，这背后有一个非常好的原因。这还有更多内容即将呈现。
- en: Trap all required signals as early as possible, in the application's initialization.
    This is because signals can arrive at any moment; the sooner we are ready to handle
    them, the better.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能早地在应用程序初始化时捕获所有必需的信号。这是因为信号可以在任何时刻到达；我们越早准备好处理它们，就越好。
- en: Masking signals
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏蔽信号
- en: 'While a process is running, what if it wants to block (or mask) certain signals?
    This is indeed possible via the API interface; in fact, the second member of the `sigaction(2)` structure
    is the signal mask, the mask of signals to block from delivery to the process while
    the signal handler function is running. A mask typically implies a bitwise-or
    of signals:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程正在运行时，如果它想要屏蔽（或者屏蔽）某些信号怎么办？通过API接口确实是可能的；事实上，`sigaction(2)`结构的第二个成员就是信号掩码，即在信号处理程序函数运行时要屏蔽的信号的掩码。掩码通常意味着信号的按位或运算：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do notice the previous comment; it implies some signal is already being blocked.
    Yes, indeed; let's say a process traps a signal `n` via the `sigaction` system
    call. At some later point that signal n is delivered to it; while our process
    handles the signal—that is, runs the code of its signal handler—that signal n
    is blocked from delivery to the process. For how long is it blocked? Until we
    return from the signal handler. In other words, the OS auto-blocks the signal
    currently being handled. This usually is precisely what we want, and it works
    to our advantage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面的评论；它暗示着某个信号已经被屏蔽。是的，确实；假设一个进程通过`sigaction`系统调用捕获了一个信号`n`。在稍后的某个时间点，该信号n被传递给它；当我们的进程处理该信号时——也就是运行其信号处理程序代码时——该信号n被屏蔽，不会传递给进程。它被屏蔽多久？直到我们从信号处理程序返回。换句话说，操作系统自动屏蔽当前正在处理的信号。这通常正是我们想要的，并且对我们有利。
- en: Signal masking with the sigprocmask API
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sigprocmask API进行信号屏蔽
- en: What if we want to block (or mask) some other signals during execution. For
    example, while processing a critical region of code? The system call `sigprocmask(2)` is
    designed for this purpose:  `int sigprocmask(int how, const sigset_t *set, sigset_t
    *oldset);`
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在执行过程中屏蔽（或者屏蔽）一些其他信号。例如，在处理关键代码区域时？`sigprocmask(2)`系统调用就是为此设计的：`int sigprocmask(int
    how, const sigset_t *set, sigset_t *oldset);`
- en: 'The signal sets are essentially bitmasks of the signals in question. The set is
    the new set of signals to mask, while `oldset` is actually a return value (the value-result
    type of parameter), or the previous (or current)  value of the signal mask. The `how` parameter
    determines the behavior and can take these values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 信号集本质上是所讨论信号的位掩码。set是要屏蔽的新信号集，而`oldset`实际上是一个返回值（参数的值-结果类型），或者是信号掩码的先前（或当前）值。`how`参数决定了行为，并且可以取这些值：
- en: '`SIG_BLOCK` : Additionally, block (mask) the signals specified in the signal
    set set (along with the signals already masked)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG_BLOCK`：另外，屏蔽（掩码）信号集set中指定的信号（以及已经被屏蔽的信号）'
- en: '`SIG_UNBLOCK` : Unblock (unmask) the signals specified in the signal set set'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG_UNBLOCK`：解除（取消屏蔽）信号集set中指定的信号'
- en: '`SIG_SETMASK` : The signals specified in the signal set set are masked, overwriting
    the previous values'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG_SETMASK`：信号集set中指定的信号被屏蔽，覆盖先前的值'
- en: Querying the signal mask
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询信号掩码
- en: So, we understand that you can set the process's signal mask at the time of `sigaction(2)`
    (via the ` sa_mask` member), or via the `*s*igprocmask(2)` system call (as mentioned
    previously). But how exactly can you query the state of the process signal mask
    at any arbitrary point in time?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到可以在`sigaction(2)`时（通过`sa_mask`成员）或通过`*s*igprocmask(2)`系统调用（如前所述）设置进程的信号掩码。但是在任意时间点上如何查询进程信号掩码的状态呢？
- en: Well, again, via the `sigprocmask(2)` system call. But, logically, this API sets a
    mask, right? This is the trick: if the first parameter set is set to `NULL`, then
    the second parameter is effectively ignored, while in the third parameter `oldset`, the
    current signal mask value is populated, and thus we can query the signal mask
    without altering it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，再次通过`sigprocmask(2)`系统调用。但是，逻辑上，这个API设置一个掩码，对吧？这就是诀窍：如果第一个参数设置为`NULL`，那么第二个参数就会被有效地忽略，而在第三个参数`oldset`中，当前的信号掩码值就会被填充，因此我们可以查询信号掩码而不改变它。
- en: 'The `ch11/query_mask` program demonstrates this, the code is built upon our
    previous example `sig2.c`. Hence, we do not need to show the entire source; we
    just show the relevant code, in `main()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch11/query_mask`程序演示了这一点，代码是建立在我们之前的例子`sig2.c`之上。因此，我们不需要展示整个源代码；我们只展示相关的代码，在`main()`中：'
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, this time we use the `sigfillset(3)` (one of the useful `POSIX`
    signal set operations or `sigsetops(3)` operators) to populate the signal mask
    with all 1's, implying that, while the signal handler code is running, all signals
    will be masked (blocked).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这一次我们使用了`sigfillset(3)`（`POSIX`信号集操作或`sigsetops(3)`操作符中有用的一个）来用所有1填充信号掩码，这意味着，在信号处理程序代码运行时，所有信号都将被屏蔽。
- en: 'Here is the relevant portion of the signal handler code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是信号处理程序代码的相关部分：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ah! Here, the intelligence is within the `show_blocked_signals` function; we
    have this function in our common code source file: `../common.c`. Here''s the
    function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！这里，智能在`show_blocked_signals`函数中；我们在我们的公共代码源文件`../common.c`中有这个函数。这是函数：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The key here is this: the `sigprocmask(2)` is used with a NULL second parameter
    (the mask to set); hence, as stated earlier, the how parameter is ignored and
    the value-result third parameter `oldset` will hold the current process signal
    mask.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于：`sigprocmask(2)`与NULL第二个参数（要设置的掩码）一起使用；因此，正如前面所述，`how`参数被忽略，值-结果第三个参数`oldset`将保存当前进程的信号掩码。
- en: We can query each signal bit in the bitmask using, again, the `sigsetops:` `sigismember(3)` convenience
    method. Now all that's left to do is iterate over each bit in the mask and print
    the signal number, if the bit is set, or ignore it if it is cleared.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用`sigsetops:` `sigismember(3)`方便方法查询掩码中的每个信号位。现在剩下的就是迭代掩码中的每个位并打印信号编号，如果该位被设置，则忽略它。
- en: 'Here''s the output of a test run:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个测试运行的输出：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how the blocked signals are printed out. Hey, can you spot the missing signals?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意打印出的被阻塞的信号。嘿，你能发现缺失的信号吗？
- en: '`SIGKILL(#9)` and `SIGSTOP(#19)` cannot be masked; also, signals 32 and 33
    are internally reserved for and used by the `Pthreads` implementation.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGKILL(#9)`和`SIGSTOP(#19)`不能被屏蔽；另外，信号32和33是内部保留并由`Pthreads`实现使用的。'
- en: Sidebar – signal handling within the OS – polling not interrupts
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏 - 操作系统内的信号处理 - 轮询而不是中断
- en: 'Here, we do not intend to delve deep into the Linux kernel internal details
    of signal handling; rather, we''d like to make clear a common misconception hinted
    at earlier: handling signals is not at all like hardware interrupt handling. Signals
    are not interrupts, nor faults or exceptions; all of these— interrupts, traps,
    exceptions, faults—are raised by the PIC/MMU/CPU hardware on a computer. Signals
    are purely a software feature.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不打算深入探讨Linux内核信号处理的内部细节；相反，我们想澄清之前提到的一个常见误解：处理信号根本不像处理硬件中断。信号不是中断，也不是故障或异常；所有这些——中断、陷阱、异常、故障——都是由计算机上的PIC/MMU/CPU硬件引发的。信号纯粹是软件功能。
- en: Delivering a signal to a process implies setting some members in the task structure of
    the task (in kernel memory), the so-called `TIF_SIGPENDING` bit, and the particular
    bit(s) representing the signal(s) in the task's `sigpending` set; this way, the
    kernel knows whether, and which, signals are pending delivery to the process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 向进程发送信号意味着在任务的任务结构（在内核内存中）中设置一些成员，即所谓的`TIF_SIGPENDING`位，以及任务的`sigpending`集中表示信号的特定位；这样，内核就知道是否有信号待传递给进程，以及是哪些信号。
- en: The reality is that at opportune points in time (which occur regularly), the
    kernel code checks whether a signal(s) is pending delivery, and, if so, delivers
    it, running or consuming the signal handler(s) of the process (in userland context).
    Signal handling is thus considered to be more of a polling mechanism rather than
    an interrupt one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，在适当的时间点（定期发生），内核代码会检查是否有信号待传递，如果有，就会传递它，运行或消耗进程的信号处理程序（在用户空间上下文中）。因此，信号处理被认为更像是一种轮询机制，而不是中断机制。
- en: Reentrant safety and signalling
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重入安全和信号传递
- en: There is an important-to-understand issue during signal handling, when working
    with reentrant-unsafe (also called async-signal-unsafe) functions within a signal
    handler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号处理期间，使用不安全的可重入（也称为异步信号不安全）函数时，存在一个重要的问题。
- en: Of course, to understand this issue, you must first understand what exactly
    a reentrant function is, and, subsequently, what is meant by reentrant-safe or
    async-signal-safe functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要理解这个问题，你必须首先了解什么是可重入函数，以及随后什么是可重入安全或异步信号安全函数。
- en: Reentrant functions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重入函数
- en: 'A reentrant function is one that can be reentered while an ongoing invocation
    is still running. It''s simpler than it sounds; check out this pseudo-code snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可重入函数是指在仍在运行的调用中可以重新进入的函数。比听起来简单；看看这段伪代码片段：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now imagine this sequence of activity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下这个活动序列：
- en: The function `my_foo()` is invoked by the business logic function `do_the_work_mate()`;
    it operates on the local buffer `mybuf`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`my_foo()`由业务逻辑函数`do_the_work_mate()`调用；它在本地缓冲区`mybuf`上操作
- en: While this is still running, a signal is dispatched to this process
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个仍在运行时，一个信号被发送到这个进程
- en: The signal handler code preempts whatever was executing at the moment it occurred
    and runs
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序代码会抢占发生时正在执行的任何内容并运行
- en: It reinvokes the function `my_foo()`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新调用函数`my_foo()`
- en: 'So, there we see it: the function `my_foo()` is reentered. By itself, that''s
    OK; the important question here is: is it safe?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到了：函数`my_foo()`被重新进入。单独来说，这没问题；这里重要的问题是：它是安全的吗？
- en: 'Recall (from our coverage in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*) that the process stack is used to hold function call frames
    and, hence, any local variables. Here, the reentrant function `my_foo()` only
    uses a local variable. It''s been invoked twice; each invocation will be a separate
    call frame on the process stack. The key point: each invocation of `my_foo()`
    works on a copy of the local variable `mybuf`; thus, it is safe. Hence, it''s
    documented as being `reentrant-safe`. In the signal-handling context, it''s called
    being `async-signal-safe`: invoking the function from within a signal handler
    while a previous invocation is still running is safe.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下（从我们在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中的覆盖中），进程堆栈用于保存函数调用帧和任何局部变量。在这里，可重入函数`my_foo()`只使用一个局部变量。它被调用了两次；每次调用都会在进程堆栈上创建一个单独的调用帧。关键点：`my_foo()`的每次调用都在局部变量`mybuf`的副本上工作；因此，它是安全的。因此，它被记录为`可重入安全`。在信号处理上下文中，它被称为`异步信号安全`：在先前的调用仍在运行时从信号处理程序中调用该函数是安全的。
- en: 'OK, let''s add a twist to the previous pseudo-code: change the function `my_foo()`''s
    local variable `mybuf` to become a global (or static) variable. Now think about
    what happens when it''s reentered; this time, distinct stack call frames cannot
    save us. As `mybuf` is global, there exists only one copy of it, which will be
    in an inconsistent state from the first function invocation (by `do_the_work_mate()`
    ). When the second invocation of `my_foo()` occurs, we will work on this inconsistent
    global `mybuf`, thus corrupting it. Hence, clearly, this is unsafe.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们给之前的伪代码加点变化：将函数`my_foo()`的局部变量`mybuf`改为全局（或静态）变量。现在想想当它被重新进入时会发生什么；这次，不同的堆栈调用帧不能拯救我们。由于`mybuf`是全局的，只有一个副本存在，它将处于不一致状态，从第一个函数调用（由`do_the_work_mate()`）开始。当第二次调用`my_foo()`发生时，我们将在这个不一致的全局`mybuf`上工作，从而破坏它。因此，显然，这是不安全的。
- en: Async-signal-safe functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步信号安全函数
- en: 'As a general rule, functions that use only local variables are reentrant-safe;
    any usage of a global or a static data renders them unsafe. This is a key point:
    you can only call those functions in a signal handler that are documented as being
    reentrant-safe or signal-async-safe.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，只使用局部变量的函数是可重入安全的；任何使用全局或静态数据的用法都会使它们变得不安全。这是一个关键点：你只能在信号处理程序中调用那些被记录为可重入安全或信号异步安全的函数。
- en: The man page on `signal-safety(7)` [http://man7.org/linux/man-pages/man7/signal-safety.7.html](http://man7.org/linux/man-pages/man7/signal-safety.7.html)
    provides details for this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal-safety(7)`手册页[http://man7.org/linux/man-pages/man7/signal-safety.7.html](http://man7.org/linux/man-pages/man7/signal-safety.7.html)提供了详细信息。'
- en: On Ubuntu, the man page with this name (`signal-safety(7)`) was installed in
    recent versions only; it does work on Ubuntu 18.04.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，这个名字的man手册（`signal-safety(7)`）只在最近的版本中安装；它在Ubuntu 18.04上可以使用。
- en: Among them, it publishes a list of (alphabetically ordered) functions that the
    `POSIX.1` standard requires an implementation to guarantee are implemented as
    being async-signal-safe, (See man page version 4.12, dated 2017-03-13)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，它发布了一个（按字母顺序排列的）函数列表，`POSIX.1`标准要求实现保证实现为异步信号安全的（参见2017-03-13日期的man页版本4.12）
- en: 'So the bottom line is this: from within a signal handler, you can only invoke
    the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以底线是：在信号处理程序中，你只能调用以下内容：
- en: C library functions or system calls that are in the signal-safety(7) man page
    (do look it up)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C库函数或系统调用在信号安全（7）手册页中（确实查找一下）
- en: Within a third-party library, functions explicitly documented as being async-signal-safe
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三方库中，明确记录为异步信号安全的函数
- en: Your own library or other functions that have been explicitly written to be async-signal-safe
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你自己的库或其他明确编写为异步信号安全的函数
- en: Also, don't forget that your signal handler function itself must be reentrant-safe.
    Do not access application global or static variables within it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要忘记你的信号处理程序函数本身必须是可重入安全的。不要在其中访问应用程序的全局或静态变量。
- en: Alternate ways to be safe within a signal handler
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在信号处理程序中保持安全的替代方法
- en: 'What if we must access some global state within our signal handler routine?
    There do exist some alternate ways of making it signal-safe:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在信号处理程序例程中访问一些全局状态呢？确实存在一些使其信号安全的替代方法：
- en: At the point you must access these variables, ensure that all signals are blocked
    (or masked), and, once done, restore the signal state (unmask).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必须访问这些变量的时候，确保所有信号被阻塞（或屏蔽），一旦完成，恢复信号状态（取消屏蔽）。
- en: Perform some kind of locking on shared data while accessing it.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问共享数据时进行某种形式的锁定。
- en: In multiprocess applications (the case we are talking about here), (binary) semaphores can
    be used as a locking mechanism to protect shared data across processes.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多进程应用程序中（我们在这里讨论的情况），（二进制）信号量可以用作锁定机制，以保护跨进程共享的数据。
- en: In multithreaded applications, the use of an appropriate locking mechanism (mutex
    locks, perhaps; we shall, of course, cover this in a later chapter in detail).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，使用适当的锁定机制（可能是互斥锁；当然，我们将在后面的章节中详细介绍）。
- en: If your requirement is to just operate upon global integers (a common case for
    signal handling!), use a special data type (the `sig_atomic_t`). Seen later on.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的需求只是对全局整数进行操作（这是信号处理的常见情况！），使用特殊的数据类型（`sig_atomic_t`）。稍后再看。
- en: The reality is that the first approach, blocking signals when required, is difficult
    to achieve in practice on complex projects (although you certainly can arrange
    for all signals to be masked while handling a signal by setting the signal mask
    to all 1s, as demonstrated in the previous section, *Querying the signal mask*).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现实是，第一种方法，在需要时阻塞信号，实际上很难在复杂项目中实现（尽管你当然可以通过将信号掩码设置为全1来安排在处理信号时屏蔽所有信号，如前一节所示，*查询信号掩码*）。
- en: The second approach, locking, is realistic though performance-sensitive for
    multiprocess and multithreaded applications.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，锁定，对于多进程和多线程应用程序来说是现实的，尽管对性能敏感。
- en: Here and now, while discussing signalling, we shall cover the third approach.
    Another reason for this is because working on (querying and/or setting) an integer
    within a signal handler is a very common case.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里和现在，讨论信号时，我们将涵盖第三种方法。另一个原因是因为在信号处理程序中处理（查询和/或设置）整数是一个非常常见的情况。
- en: Within the code we show in this book, there is the occasional use of async-signal-
    unsafe functions being used within a signal handler (usually one of the `[f|s|v]printf(3)`
    family). We stress that this has been done purely for demonstration purposes only;
    please do not give into temptation and use async-signal-unsafe functions in production
    code!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们展示的代码中，偶尔会在信号处理程序中使用异步信号不安全的函数（通常是`[f|s|v]printf(3)`系列中的一个）。我们强调这仅仅是为了演示目的而做的；请不要在生产代码中使用异步信号不安全的函数！
- en: Signal-safe atomic integers
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号安全的原子整数
- en: Visualize a multiprocess application. A process, A, must complete a certain
    quantum of work (let's say it must complete running a function `foo()`) and let
    another process, B, know that it has done so (in other words, we want synchronization between
    the two processes; see the next info box as well).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个多进程应用程序。一个进程A必须完成一定量的工作（比如说它必须完成运行函数`foo()`），并让另一个进程B知道它已经这样做了（换句话说，我们希望这两个进程之间实现同步；也请参见下一个信息框）。
- en: 'A simple way to achieve this is as follows: have process `A` send a signal
    (say `SIGUSR1`)  to process `B` when it has reached the required point. In turn,
    process B traps `SIGUSR1`, and when it does arrive, in its signal handler, it
    sets a global buffer to an appropriate message string to let the rest of the application
    know that we have reached this point.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一个简单方法是：当进程A达到所需点时，让进程A发送一个信号（比如`SIGUSR1`）给进程B。反过来，进程B捕获`SIGUSR1`，当它到达时，在它的信号处理程序中，它将全局缓冲区设置为适当的消息字符串，以让应用程序的其余部分知道我们已经到达了这一点。
- en: In the following tables, visualize the timeline going vertically (*y* axis)
    downward.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，将时间线纵向（*y*轴）向下可视化。
- en: 'Pseudo-code—the wrong way:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码-错误的方式：
- en: '| **Process A** | **Process B** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **进程A** | **进程B** |'
- en: '| Do work | Set up signal handler for `SIGUSR1` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 做工作 | 为`SIGUSR1`设置信号处理程序 |'
- en: '| Work on `foo()` | `char gMsg[32];   // global` Do work |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 对`foo()`进行处理 | `char gMsg[32];   // 全局` 做工作 |'
- en: '| `foo()` done; send `SIGUSR1` to process `B` |  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `foo()`完成；向进程`B`发送`SIGUSR1` |  |'
- en: '|  | `signal_handler()`function entered asynchronously |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  | `signal_handler()`函数异步进入 |'
- en: '|  | `strncpy(gMsg, "chkpointA", 32);` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | `strncpy(gMsg, "chkpointA", 32);` |'
- en: '| [...] | [...] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| [...] | [...] |'
- en: This looks fine, except that, please notice that, this global update on the
    message buffer `gMsg` is not guaranteed to be atomic. It's entirely possible that
    attempting to do so will result in a race—a condition in which we cannot predict
    with any certainty what the final result of the global variable will be. It's
    exactly this kind of data race that is the perfect breeding ground for a class
    of difficult-to-see-and-solve racy bugs. You must avoid them by using proper programming
    practices.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，只是请注意，对消息缓冲区`gMsg`的全局更新不能保证是原子的。完全有可能尝试这样做会导致竞争-一种我们无法确定全局变量的最终结果的情况。正是这种数据竞争是一类难以发现和解决的竞争性错误的理想滋生地。您必须通过使用适当的编程实践来避免它们。
- en: 'The solution: Switch from using a global buffer to a global integer-like variable
    of data type **`sig_atomic_t`**, and, importantly, mark it as `volatile` (so that
    the compiler disables optimizations around it).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：从使用全局缓冲区切换到使用数据类型为**`sig_atomic_t`**的全局整数变量，并且重要的是将其标记为`volatile`（以便编译器在其周围禁用优化）。
- en: 'Pseudo-code – the right way:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码-正确的方式：
- en: '| **Process A** | **Process B** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **进程A** | **进程B** |'
- en: '| Do work | Set up signal handler for `SIGUSR1` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 做工作 | 为`SIGUSR1`设置信号处理程序 |'
- en: '| Work on `foo()` | **`volatile sig_atomic_t gFlag=0;`** Do work |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 对`foo()`进行处理 | **`volatile sig_atomic_t gFlag=0;`** 做工作 |'
- en: '| `foo()` done; send `SIGUSR1` to process `B` |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `foo()`完成；向进程`B`发送`SIGUSR1` |  |'
- en: '|  | `signal_handler()`function entered asynchronously |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  | `signal_handler()`函数异步进入 |'
- en: '|  | **`gFlag = 1;`** |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  | **`gFlag = 1;`** |'
- en: '| [...] | [...] |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| [...] | [...] |'
- en: This time it will work just fine, without any race. (Writing the complete working
    code of the previous program is suggested as an exercise to readers).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它将正常工作，没有任何竞争。（建议读者将前一个程序的完整工作代码编写为练习）。
- en: It's important to realize that the usage of `sig_atomic_t` makes an (integer)
    variable only async-signal safe, not thread-safe. (Thread safety will be covered
    in detail in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml), *Multithreading
    with Pthreads Part I - Essentials*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，使用`sig_atomic_t`使（整数）变量只能在异步信号中安全，而不是线程安全。（线程安全将在以后的[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)中详细介绍，*使用Pthreads的多线程编程第I部分-基础知识*）。
- en: True process synchronization should be performed using an IPC mechanism appropriate
    for the purpose. Signals do serve as a primitive IPC mechanism; depending on your
    project,  other IPC mechanisms (sockets, message queues, shared memory, pipes,
    and semaphores)  might well be a better way to do so, though.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的进程同步应该使用适用于该目的的IPC机制来执行。信号确实可以作为原始的IPC机制；根据您的项目，其他IPC机制（套接字，消息队列，共享内存，管道和信号量）可能更适合这样做。
- en: 'According to Carnegie Mellon University''s Software Engineering Institute (CMU
    SEI) CERT C Coding Standard:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据卡内基梅隆大学软件工程研究所（CMU SEI）CERT C编码标准：
- en: SIG31-C:Do not access shared objects in signal handlers *(*[https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers](https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers))
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SIG31-C：不要在信号处理程序中访问共享对象*（[https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers](https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers)）*
- en: The type `sig_atomic_t` is the integer type of an object that can be accessed
    as an atomic entity even in the presence of asynchronous interrupts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`sig_atomic_t`是可以在异步中断的情况下作为原子实体访问的对象的整数类型。
- en: 'Additional note:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 附加说明：
- en: 'It''s worth checking out the code examples provided within the last link as
    well. Also, within the same context, the CMU SEI''s CERT C Coding Standard*, *the
    following points are noted, regarding the correct way to perform signal handling:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 查看最后一个链接中提供的代码示例也是值得的。此外，在相同的上下文中，CMU SEI的CERT C编码标准*，*关于执行信号处理的正确方式有以下几点需要注意：
- en: '`SIG30-C`. Call only asynchronous-safe functions within signal handlers.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG30-C`。在信号处理程序中只调用异步安全函数。'
- en: '`SIG31-C`: Do not access shared objects in signal handlers.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG31-C`：不要在信号处理程序中访问共享对象。'
- en: '`SIG34-C`. Do not call `signal()` from within interruptible signal handlers.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG34-C`。不要在可中断的信号处理程序中调用`signal()`。'
- en: '`SIG35-C`. Do not return from a computational exception signal handler.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG35-C`。不要从计算异常信号处理程序返回。'
- en: 'The last bullet point is perhaps better phrased by the `POSIX.1` committee:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要点可能更好地由`POSIX.1`委员会来表达：
- en: The behavior of a process is undefined after it returns normally from a signal-catching
    function for a SIGBUS, SIGFPE, SIGILL, or SIGSEGV signal that was not generated
    by `kill(2)`, `sigqueue(3)`, or `raise(2)`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 进程在从未由`kill(2)`，`sigqueue(3)`或`raise(2)`生成的`SIGBUS`，`SIGFPE`，`SIGILL`或`SIGSEGV`信号的信号捕获函数正常返回后的行为是未定义的。
- en: 'In other words, once your process receives any of the previously mentioned
    fatal signals from the OS, it can perform cleanup within it''s signal handler,
    but then it must terminate. (Allow us this joke: the hero exclaiming "Not today,
    Death!" , is all well and good in the movies, but when SIGBUS, SIGFPE, SIGILL,
    or SIGSEGV come calling, it''s time to clean up and gracefully die!). As a matter
    of fact, we delve into this aspect in a lot of detail within the next chapter.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一旦您的进程从操作系统接收到任何先前提到的致命信号，它可以在信号处理程序中执行清理，但然后必须终止。（请允许我们开个玩笑：英雄呼喊“今天不是，死神！”在电影中是很好的，但当SIGBUS，SIGFPE，SIGILL或SIGSEGV来临时，是时候清理并优雅地死去了！）。事实上，我们将在下一章中详细探讨这一方面。
- en: Powerful sigaction flags
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的sigaction标志
- en: 'From the previous section The `sigaction` structure, recall that one of the
    members of the `sigaction` structure is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一节的`sigaction`结构中，回想一下`sigaction`结构的成员之一如下：
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These special flags are very powerful. With them, the developer can precisely
    specify signal semantics that would otherwise be hard or impossible to obtain.
    The default value of zero implies no special behavior.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊标志非常强大。有了它们，开发人员可以精确指定信号语义，否则很难或不可能获得。零的默认值意味着没有特殊行为。
- en: 'We shall first enumerate the `sa_flags` possible values in this table and then
    proceed to work with them:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在本表中列举`sa_flags`的可能值，然后继续使用它们：
- en: '| `sa_flag` | Behavior or semantic it provides (from the man page on `sigaction(2)`).
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `sa_flag` | 它提供的行为或语义（来自`sigaction(2)`的man页面）。 |'
- en: '| `SA_NOCLDSTOP` | If `signum` is `SIGCHLD`, do not generate `SIGCHLD` when
    children stop or stopped children continue. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `SA_NOCLDSTOP` | 如果`signum`是`SIGCHLD`，则当子进程停止或停止的子进程继续时不生成`SIGCHLD`。 |'
- en: '| `SA_NOCLDWAIT` | (Linux 2.6 and later) If `signum` is `SIGCHLD`, do not transform
    children into zombies when they terminate. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `SA_NOCLDWAIT` | （Linux 2.6及更高版本）如果`signum`是`SIGCHLD`，则当它们终止时不将子进程转换为僵尸。
    |'
- en: '| `SA_RESTART` | Provide behavior compatible with BSD signal semantics by making
    certain system calls restartable across signals. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `SA_RESTART` | 通过使某些系统调用在信号中可重启，提供与BSD信号语义兼容的行为。 |'
- en: '| `SA_RESETHAND` | Restore the signal action to the default upon entry to the
    signal handler. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `SA_RESETHAND` | 在进入信号处理程序时将信号动作恢复为默认值。 |'
- en: '| `SA_NODEFER` | Do not prevent the signal from being received from within
    its own signal handler. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `SA_NODEFER` | 不要阻止信号在其自己的信号处理程序中被接收。 |'
- en: '| `SA_ONSTACK` | Call the signal handler on an alternate signal stack provided
    by `sigaltstack(2)`. If an alternate stack is not available, the default (process)
    stack will be used. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `SA_ONSTACK` | 在由`sigaltstack(2)`提供的备用信号堆栈上调用信号处理程序。如果备用堆栈不可用，则将使用默认（进程）堆栈。
    |'
- en: '| `SA_SIGINFO` | The signal handler takes three arguments, not one. In this
    case, `sa_sigaction` should be set instead of `sa_handler`. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `SA_SIGINFO` | 信号处理程序需要三个参数，而不是一个。在这种情况下，应该设置`sa_sigaction`而不是`sa_handler`。
    |'
- en: Keep in mind that `sa_flags` is an integer value interpreted by the OS as a bitmask; bitwise-ORing
    several flags together to imply their combined behavior is indeed common practice.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`sa_flags`是由操作系统解释为位掩码的整数值；将几个标志进行按位或运算以暗示它们的组合行为的做法确实很常见。
- en: Zombies not invited
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不邀请僵尸
- en: 'Let''s get started with the flag `SA_NOCLDWAIT`. First, a quick digression:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从标志`SA_NOCLDWAIT`开始。首先，一个快速的离题：
- en: 'As we learned in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*, a process can fork, resulting in an act of creation: a new
    child process is born! From that chapter, it is now relevant to recall our Fork
    **Rule #7**: The parent process must wait (block) upon the termination (death)
    of every child, directly or indirectly.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中学到的*进程创建*，一个进程可以fork，导致一个创造的行为：一个新的子进程诞生了！从那一章开始，现在回想起我们的Fork**规则＃7**：父进程必须等待（阻塞）每个子进程的终止（死亡），直接或间接地。
- en: 'The parent process can wait (block) upon the child''s termination via the waitsystem
    call API set. As we learned earlier, this is essential: if the child dies and
    the parent has not waited upon it, the child becomes a zombie—an undesirable state
    to be in, at best. At worst, it can terribly clog system resources.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程可以通过`wait`系统调用API集等待（阻塞）子进程的终止。正如我们之前学到的那样，这是必不可少的：如果子进程死亡而父进程没有等待它，子进程就会成为僵尸状态——这是一个不希望出现的状态。最坏的情况下，它可能会严重阻塞系统资源。
- en: However, blocking upon the death of the child (or children) via the wait API(s)
    causes the parent to become synchronous; it blocks, and thus, in a sense, it defeats
    the whole purpose of multiprocessing, to be parallelized. Can we not be asynchronously notified
    when our children die? This way, the parent can continue to perform processing,
    running in parallel with its children.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过`wait`API(s)阻塞在子进程（或子进程）的死亡上会导致父进程变成同步；它会阻塞，因此，在某种意义上，它会击败多处理的整个目的，即并行化。我们不能在我们的子进程死亡时异步通知吗？这样，父进程可以继续执行处理，与其子进程并行运行。
- en: 'Ah! Signals to the rescue: the OS will deliver the  `SIGCHLD` signal to the
    parent process whenever any of its children terminate or enter the stopped state.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！信号来拯救：每当其任何子进程终止或进入停止状态时，操作系统将向父进程传递`SIGCHLD`信号。
- en: 'Pay attention to the last detail: the `SIGCHLD` will be delivered even if a
    child process stops (and is thus not dead). What if we do not want that? In other
    words, we only want the signal sent to us when our children die. That is precisely
    what the `SA_NOCLDSTOP` flag performs: no child death on stop. So, if you do not
    want to get spoofed by the stopping of the children into thinking they''re dead,
    use this flag. (This also applies when a stopped child is subsequently continued,
    via the `SIGCONT`).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的细节：即使子进程停止（因此并非死亡），`SIGCHLD`也将被传递。如果我们不想要这样怎么办？换句话说，我们只希望在子进程死亡时向我们发送信号。这正是`SA_NOCLDSTOP`标志执行的操作：停止时不产生子进程死亡。因此，如果您不希望被子进程的停止所欺骗以为它们已经死亡，请使用此标志。（当通过`SIGCONT`继续停止的子进程时，也适用）。
- en: No zombies! – the classic way
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有僵尸！-经典方式
- en: 'The previous discussion should also make you realize that, hey, we now have
    a neat asynchronous way in which to get rid of any pesky zombies: trap the `SIGCHLD`,
    and in its signal handler, issue the wait call (using any of the wait APIs covered
    in [Chapter 9](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml), *Process Execution*),
    preferably with the `WNOHANG` option parameter such that we perform a non-blocking
    wait; thus, we do not block upon any live children and just succeed in clearing
    any zombies.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论也应该让你意识到，嘿，我们现在有了一个整洁的异步方式来摆脱任何讨厌的僵尸：捕获`SIGCHLD`，并在其信号处理程序中发出`wait`调用（使用[第9章](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml)中涵盖的任何等待API，最好使用`WNOHANG`选项参数，这样我们进行非阻塞等待；因此，我们不会在任何活着的子进程上阻塞，只会成功清除任何僵尸。
- en: 'Here is the classic Unix way to clear zombies:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清除僵尸的经典Unix方式：
- en: '[PRE15]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Delving into depth here would be of academic interest only on modern Linux (modern
    Linux, in your author's opinion, being the 2.6.0 Linux kernel and beyond, which,
    by the way, was released on December 18, 2003).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Linux上深入研究这里只会产生学术兴趣（在您的作者看来，现代Linux是指2.6.0及更高版本的Linux内核，顺便说一下，它于2003年12月18日发布）。
- en: No zombies! – the modern way
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有僵尸进程！- 现代的方式
- en: 'So, with modern Linux, avoiding zombies became vastly easier: just trap the
    `SIGCHLD` signal using `sigaction(2)`, specifying the `SA_NOCLDWAIT` bit in the
    signal flags bitmask. That''s it: zombie worries banished forever! On the Linux
    platform, the `SIGCHLD` signal is still delivered to the parent process—you can
    use it to keep track of children, or whatever accounting purposes you may dream
    up.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于现代Linux来说，避免僵尸进程变得更加容易：只需使用`sigaction(2)`捕获`SIGCHLD`信号，并在信号标志位掩码中指定`SA_NOCLDWAIT`位。就是这样：僵尸进程的担忧永远消失了！在Linux平台上，`SIGCHLD`信号仍然会传递给父进程
    - 您可以使用它来跟踪子进程，或者您可能想到的任何会计目的。
- en: 'By the way, the `POSIX.1` standard also specifies another way to get rid of
    the pesky zombie: just ignore the `SIGCHLD` signal (with the `SIG_IGN`). Well,
    you can use this approach, with the caveat that then you will never know when
    a child does indeed die (or stop).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`POSIX.1`标准还指定了另一种摆脱麻烦的僵尸进程的方法：只需忽略`SIGCHLD`信号（使用`SIG_IGN`）。好吧，您可以使用这种方法，但要注意，这样您将永远不会知道子进程确实死亡（或停止）。
- en: 'So, useful stuff: let''s put our new knowledge to the test: we rig up a small multiprocess
    application that generates zombies, but also clears them in the modern way as
    follows (`ch11/zombies_clear_linux26.c`):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有用的东西：让我们把我们的新知识付诸实践：我们设置一个小型的多进程应用程序，它生成僵尸进程，但也以现代方式清除它们（`ch11/zombies_clear_linux26.c`）：
- en: For readability, only the relevant parts of the code are displayed; to view
    and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，只显示了代码的相关部分；要查看和运行它，整个源代码在这里可用：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE16]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '(For now, ignore the `SA_RESTART` flag in the code; we shall explain it shortly). Here
    is the signal handler for `SIGCHLD`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: （暂时忽略代码中的`SA_RESTART`标志；我们很快会解释）。这是`SIGCHLD`的信号处理程序：
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we only emit a `printf(3)` within the signal handler when in debug
    mode (as it's async-signal unsafe).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当处于调试模式时，我们只在信号处理程序中发出`printf(3)`（因为它是异步信号不安全的）。
- en: 'Let''s try it out:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下：
- en: '[PRE18]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'OK, first we try it with option `1`; that is, using the `SA_NOCLDWAIT` flag:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先我们尝试使用选项`1`；也就是使用`SA_NOCLDWAIT`标志：
- en: '[PRE19]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Importantly, checking with `ps(1)` reveals there is no zombie.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，使用`ps(1)`检查后发现没有僵尸进程。
- en: 'Now run it with option `2`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用选项`2`运行它：
- en: '[PRE20]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the `*** Child dies! ***` message (that we did get in the previous
    run) does not appear, proving that we never enter the signal handler for `SIGCHLD`.
    Of course not; we ignored the signal. While that does prevent the zombie, it also
    prevents us from knowing that a child has died.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在上一次运行中得到的`*** Child dies! ***`消息没有出现，证明我们从未进入`SIGCHLD`的信号处理程序。当然不会；我们忽略了信号。虽然这确实可以防止僵尸进程，但也会阻止我们知道子进程已经死亡。
- en: The SA_NOCLDSTOP flag
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SA_NOCLDSTOP标志
- en: 'Regarding the `SIGCHLD` signal, there is an important point to realize: The
    default behavior is that, whether a process dies or stops, or a stopped child
    continues execution (typically via the `SIGCONT` signal being sent to it), the
    kernel posts the `SIGCHLD` signal to its parent.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SIGCHLD`信号，有一个重要的要意识到的地方：默认行为是，无论进程是死亡还是停止，或者一个已停止的子进程继续执行（通常是通过向其发送`SIGCONT`信号），内核都会向其父进程发送`SIGCHLD`信号。
- en: Perhaps this is useful. The parent is informed of all these events—the child's
    death, stop-page, or continuation. On the other hand, perhaps we do not want to
    be spoofed into thinking that our child process has died, when in reality it has
    just been stopped (or continued).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这很有用。父进程被通知所有这些事件 - 子进程的死亡、停止或继续。另一方面，也许我们不希望被欺骗，认为我们的子进程已经死亡，而实际上它只是被停止（或继续）。
- en: For such cases, use the `SA_NOCLDSTOP` flag; it literally means no `SIGCHLD`
    on child stop (or resume). Now you will only get the `SIGCHLD` upon child death.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，使用`SA_NOCLDSTOP`标志；它的字面意思是子进程停止（或恢复）时不发送`SIGCHLD`。现在只有在子进程死亡时才会收到`SIGCHLD`。
- en: Interrupted system calls and how to fix them with the SA_RESTART
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断的系统调用以及如何使用SA_RESTART修复它们
- en: Traditional (older) Unix OSes suffered from an issue regarding the handling
    of signals while processing blocking system calls.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 传统（较旧的）Unix操作系统在处理阻塞系统调用时存在一个问题。
- en: Blocking APIs
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞API
- en: An API is said to be blocking when, on issuing the API, the calling process
    (or thread) is put into a sleep state. Why is this? This is because the underlying
    OS or device driver understands that the event that the caller needs to wait upon
    has not yet occurred; thus, it must wait for it. Once the event (or condition)
    arises, the OS or driver wakes up the process; the process now continues to execute
    its code path.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出API时，调用进程（或线程）处于睡眠状态时，API被称为阻塞。为什么？这是因为底层的操作系统或设备驱动程序知道调用者需要等待的事件尚未发生；因此，它必须等待。一旦事件（或条件）发生，操作系统或驱动程序唤醒进程；进程现在继续执行其代码路径。
- en: Examples of blocking APIs are common: read, write, select, wait (and its variants), accept, and
    so on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞API的例子很常见：`read`、`write`、`select`、`wait`（及其变体）、`accept`等等。
- en: 'Take a moment to visualize this scenario:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间来想象这种情况：
- en: A process traps a signal (say, `SIGCHLD`).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程捕获一个信号（比如`SIGCHLD`）。
- en: The process, at some later point, issues a blocking system call (say, the `accept(2)`
    system call).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稍后，进程发出一个阻塞系统调用（比如`accept(2)`系统调用）。
- en: While it's in the sleep state, the signal is delivered to it.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它处于睡眠状态时，信号被传递给它。
- en: 'The following pseudo code illustrates the same:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码说明了相同的情况：
- en: '[PRE21]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By the way, the `accept(2)` system call is how a network server process blocks
    (waits) upon a client connecting to it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`accept(2)`系统调用是网络服务器进程在客户端连接到它时阻塞（等待）的方式。
- en: 'What should happen, now that the signal is delivered? The correct behavior
    is this: the process should wake up, handle the signal (run the code of its signal
    handler), and go to sleep once again, continuing to block upon the event it was
    waiting upon.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，信号被传递后应该发生什么？正确的行为是：进程应该唤醒，处理信号（运行其信号处理程序的代码），然后再次进入睡眠状态，继续阻塞在它正在等待的事件上。
- en: On older Unixes (your author has come across this on an old SunOS 4.x), the
    signal is delivered, the signal handler code runs, but after that the blocking
    system call fails, returning -1\. The `errno` variable is set to **`EINTR`** ,
    which translates to an interrupted system call.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的Unix系统（作者在旧的SunOS 4.x上遇到过这种情况），信号被传递，信号处理程序代码运行，但在此之后，阻塞系统调用失败，返回-1。`errno`变量设置为**`EINTR`**，这意味着系统调用被中断。
- en: 'This is considered a bug, of course. The poor Unix application developer had
    to resort to some temporary fixes, often resorting to wrapping each and every
    system call (foo in this example) in a loop, like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这被认为是一个bug。可怜的Unix应用程序开发人员不得不求助于一些临时修复措施，通常是在循环中包装每个系统调用（在这个例子中是foo），如下所示：
- en: '[PRE22]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is not easily maintainable*.*
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这不容易维护。
- en: The `POSIX` committee subsequently fixed this, requiring an implementation to
    provide a signal flag`SA_RESTART`. When this flag is used, the kernel will auto-restart
    any blocking system calls that happen to get interrupted by a signal or signals.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`POSIX`委员会随后修复了这个问题，要求实现提供一个信号标志`SA_RESTART`。当使用此标志时，内核将自动重新启动任何由信号中断的阻塞系统调用。'
- en: So, just use the useful `SA_RESTART` flag within your `sigaction(2)` when registering
    your signal handler(s), and this issue will disappear.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当注册信号处理程序时，只需在`sigaction(2)`中使用有用的`SA_RESTART`标志，这个问题就会消失。
- en: In general, using the `SA_RESTART` flag when programming the `sigaction(2)` would
    be a good idea. Not always, though; the [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml), 
    *Timers*, shows us use cases in which we deliberately keep away from this flag.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在编程`sigaction(2)`时使用`SA_RESTART`标志是一个好主意。不过，并不总是；[第13章](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml)，*定时器*，向我们展示了一些情况下我们故意远离这个标志。
- en: The once only SA_RESETHAND flag
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性的SA_RESETHAND标志
- en: 'The `SA_RESETHAND` signal flag is a bit peculiar. On older Unix platforms,
    there existed a bug that went like this: a signal is trapped (via the `signal(2)`
    function), the signal is dispatched, and then the process handles the signal.
    But, immediately on entering the signal handler, the kernel now resets the signal
    action to the original OS default handling code. So, the second time the signal
    arrives, the default handler code runs, often killing the process in the bargain.
    (Again, Unix developers sometimes had to resort to some bad racy code to try to
    fix this).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_RESETHAND`信号标志有点奇怪。在旧的Unix平台上，存在一个bug，即捕获信号（通过`signal(2)`函数），信号被分发，然后进程处理信号。但是，一旦进入信号处理程序，内核立即将信号动作重置为原始的操作系统默认处理代码。因此，第二次信号到达时，默认处理程序代码会运行，通常会导致进程被终止。
    （再次，Unix开发人员有时不得不求助于一些糟糕的竞争性代码来尝试解决这个问题）。'
- en: Thus, the signal would effectively be delivered only once. On today's modern
    Linux systems, a signal handler remains as it is; it is not reset by default to
    the original handler. Unless, of course, you want this once-only behavior, in
    this case, use the `SA_RESETHAND` flag (you would imagine that it's not terribly
    popular). Also, `SA_ONESHOT` is an older deprecated name for the same flag.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，信号实际上只会被传递一次。在今天的现代Linux系统中，信号处理程序保持原样；默认情况下不会被重置为原始处理程序。当然，如果你想要这种一次性的行为，可以使用`SA_RESETHAND`标志（你可能会觉得这并不是非常流行）。`SA_ONESHOT`也是同一个标志的一个较旧的不推荐使用的名称。
- en: To defer or not? Working with SA_NODEFER
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推迟还是不推迟？使用SA_NODEFER
- en: 'Lets recall how signals are handled by default:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下信号的默认处理方式：
- en: A process traps a signal n.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程捕获了一个信号n。
- en: Signal n is delivered to the process (either by another process or the OS).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号n被传递给进程（可以是另一个进程或操作系统）。
- en: The signal handler is dispatched; that is, it runs in response to the signal.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序被调度；也就是说，它是作为对信号的响应而运行的。
- en: Signal n is now auto-masked; that is, blocked from delivery to the process.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号n现在被自动屏蔽；也就是说，被阻止传递给进程。
- en: Signal handling is completed.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理已完成。
- en: Signal n is now auto-unmasked, that is, enabled for delivery to the process.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号n现在被自动解除屏蔽，也就是说，可以传递给进程。
- en: 'This is reasonable: while handling a particular signal, that signal is masked. This
    is the default behavior.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的：在处理特定信号时，该信号被屏蔽。这是默认行为。
- en: However, what if you are writing, say, an embedded real-time application, where
    the signal delivery implies some real-world event has occurred and the application must respond
    to this immediately (as soon as possible). In cases such as this, we would perhaps
    want to disable the auto-masking of signals, thus allowing the signal handler
    to be reentered the moment it arrives. Precisely this can be achieved by using
    the `SA_NODEFER` signal flag.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你正在编写一个嵌入式实时应用程序，其中信号传递意味着发生了一些真实世界的事件，并且应用程序必须立即（尽快）做出响应。在这种情况下，我们可能希望禁用信号的自动屏蔽，从而允许信号处理程序在到达时被重新进入。通过使用`SA_NODEFER`信号标志可以实现这一点。
- en: The English word defer means to delay or postpone; to put off until later.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 英语单词defer的意思是延迟或推迟；推迟到以后。
- en: This is the default behavior, which you can change when the flag is specified.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认行为，当指定了该标志时可以更改。
- en: Signal behavior when masked
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号被屏蔽时的行为
- en: 'To understand this better, let''s take a fictional example: say we trap a signal
    n, and the execution time for our signal handler for signal n is 55 ms (milliseconds).
    Also, visualize a scenario in which, via a timer (for a while at least), signal
    n is delivered to the process continually at 10-ms intervals. Now let''s examine
    what would happen in the default case and the case in which we use the `SA_NODEFER`
    flag.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们举一个虚构的例子：假设我们捕获了一个信号n，并且我们的信号处理程序的执行时间为55毫秒。此外，想象一种情况，通过一个定时器（至少一段时间），信号n以10毫秒的间隔不断地传递给进程。现在让我们来看看在默认情况下会发生什么，以及在使用`SA_NODEFER`标志的情况下会发生什么。
- en: 'Case 1 : Default : SA_NODEFER bit cleared'
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况1：默认：SA_NODEFER位清除
- en: 'Here, we are *not* using the `SA_NODEFER` signal flag. So, when the first instance
    of signal n arrives, our process jumps into the signal-handling code (which will
    take 55 ms to complete). However, the second signal will arrive just 10 ms into
    the signal handling code. But, hang on, it''s auto-masked! Hence, we will not
    process it. In fact, a simple calculation will show that up to five instances
    of signal n will reach our process in the 55-ms signal handling time frame:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们*不*使用`SA_NODEFER`信号标志。因此，当信号n的第一个实例到达时，我们的进程会跳转到信号处理代码（需要55毫秒才能完成）。然而，第二个信号将在信号处理代码进行10毫秒时到达。但是，等一下，它被自动屏蔽了！因此，我们不会处理它。实际上，简单的计算将显示，在55毫秒的信号处理时间内，最多会有五个信号n的实例到达我们的进程：
- en: '![](img/a470eda4-bde5-496d-84ad-81922157ac9d.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a470eda4-bde5-496d-84ad-81922157ac9d.png)'
- en: 'Figure 3: Default behavior: SA_NODEFER bit cleared: no queue, one signal instance
    pending delivery, no real impact on stack'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：默认行为：SA_NODEFER位清除：没有队列，一个信号实例待处理，对堆栈没有实质影响
- en: 'So, what exactly happens? Will these five signals be queued up for delivery
    once the handler completes? Ah! This is an important point: standard or Unix signals are not
    queued. However, the kernel does understand that one or more signals are pending
    delivery to the process; hence, once signal handling is done, exactly one instance
    of the pending signal is delivered (and the pending signal mask is subsequently
    cleared).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到底会发生什么？这五个信号会在处理程序完成后排队等待传递吗？啊！这是一个重要的观点：标准的或Unix信号*不会排队*。然而，内核确实知道*一个或多个信号正在等待传递给进程*；因此，一旦信号处理完成，将传递*一个*待处理信号实例（并且随后清除待处理信号掩码）。
- en: Thus, in our example, even though five signals were pending delivery, the signal
    handler will get invoked only once. In other words, no signals were queued, but
    one signal instance was served. This is how signalling works by default.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，即使有五个信号待处理，信号处理程序也只会被调用一次。换句话说，没有信号被排队，但是一个信号实例被处理了。这就是默认情况下信号的工作方式。
- en: '*Figure 3* shows this situation: the dashed signal arrows represent signals
    that were delivered after entering the signal handler; hence, just one instance
    is kept pending. Notice the process stack: the signal instance #1 of signal n
    (obviously) gets a call frame on the stack when the signal handler is invoked,
    nothing more.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3*显示了这种情况：虚线信号箭头代表进入信号处理程序后传递的信号；因此，只保留一个实例待处理。注意进程堆栈：当调用信号处理程序时，信号n的信号实例＃1（显然）在堆栈上得到一个调用帧，没有更多。'
- en: Question: What if the situation is as shown, but another signal, signal `m`,
    is delivered?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：如果情况如图所示，但另一个信号，信号`m`，被传递了呢？
- en: 'Answer: If signal m has been caught and is currently unmasked, it will be processed
    immediately; in other words, it will preempt everything, and its handler will
    run. Of course, the context is saved by the OS such that whatever got preempted
    can be later continued once context is restored. This has us conclude the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 回答：如果信号m已被捕获并且当前未被屏蔽，它将立即被处理；换句话说，它将*抢占*一切，并且其处理程序将运行。当然，操作系统保存了上下文，以便稍后可以恢复被抢占的内容。这使我们得出以下结论：
- en: Signals are peers; they have no priority associated with them.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号是*对等的*；它们没有与之相关的优先级。
- en: For standard signals, if several instances of the same integer value are delivered,
    and that signal is currently masked (blocked), then only one instance is kept
    pending; there is no queuing.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标准信号，如果传递了相同整数值的多个实例，并且该信号当前被屏蔽（阻塞），那么只保留一个实例待处理；不会排队。
- en: 'Case 2 : SA_NODEFER bit set'
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况2：SA_NODEFER位设置
- en: 'Now let''s reconsider the very same scenario, only this time we use the `SA_NODEFER`
    signal flag. So, when the first instance of signal n arrives, our process jumps
    into the signal-handling code (which will take 55 ms to complete). As before, the
    second signal will arrive just 10 ms into the signal-handling code, but hang on,
    this time it is not masked; it is not deferred. Thus, we will reenter the signal
    handler function immediately. Then, 20 ms later (after the signal handler was
    first entered by signal n instance #1), the third signal instance arrives. Again,
    we will reenter the signal handler function. Yes, this will happen five times.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新考虑完全相同的情况，只是这次我们使用了`SA_NODEFER`信号标志。因此，当信号n的第一个实例到达时，我们的进程会跳转到信号处理代码（需要55毫秒才能完成）。与以前一样，第二个信号将在信号处理代码进行10毫秒时到达，但是等一下，这次它没有被屏蔽；它没有被推迟。因此，我们将立即重新进入信号处理程序函数。然后，20毫秒后（信号n实例＃1首次进入信号处理程序后），第三个信号实例到达。同样，我们将重新进入信号处理程序函数。是的，这将发生五次。
- en: 'Figure 4 shows us this scenario:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图4向我们展示了这种情况：
- en: '![](img/4cd933d7-71b6-42b2-9062-a782900cbb23.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cd933d7-71b6-42b2-9062-a782900cbb23.png)'
- en: 'Figure 4: SA_NODEFER bit set: no queue; all signal instances processed upon
    delivery, stack intensive'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：设置了SA_NODEFER位：没有队列；所有信号实例在传递时处理，堆栈密集
- en: 'This looks good, but please realize the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，但请意识到以下情况：
- en: The signal handler code itself must be written to be reentrant-safe (no global
    or static variable usage; only call async-signal safe functions within it), as
    it is being continually reentered in this scenario.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，信号处理程序代码本身必须编写为*可重入安全*（不使用全局或静态变量；仅在其中调用*异步信号安全*函数），因为在这种情况下它将不断地被重新进入。
- en: 'Stack usage: every time the signal handler is reentered, do realize that an
    additional call frame has been allocated (pushed) on to the process stack.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈使用：每次重新进入信号处理程序时，都要意识到已经为进程堆栈分配（推送）了一个额外的调用帧。
- en: 'The second point bears thinking about: what if so many signals arrive (while
    handling previous invocations) that we overload and, indeed, overflow the stack?
    Well, disaster. Stack overflow is a bad bug; no exception handling is practically
    possible (we cannot, with any degree of confidence, catch  or trap into a stack
    overflow issue).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点值得思考：如果有这么多信号到达（在处理先前的调用时），我们会不会过载，甚至溢出堆栈？嗯，灾难。堆栈溢出是一个严重的错误；实际上几乎不可能进行异常处理（我们无法有信心捕获或陷入堆栈溢出问题）。
- en: 'A interesting code example `ch11/defer_or_not.c` follows to demonstrate both
    of these cases:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个有趣的代码示例`ch11/defer_or_not.c`，用于演示这两种情况：
- en: For readability, only key parts of the code are displayed; to view the complete
    source code, build and run it; the entire tree is available for cloning from the
    book's GitHub repo here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，只显示了代码的关键部分；要查看完整的源代码，请构建并运行它；整个树可在书的GitHub存储库中克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)
- en: '[PRE23]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the signal handler function:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是信号处理程序函数：
- en: '[PRE24]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We deliberately let the signal-handling code take a fairly long time (via our
    use of the `DELAY_LOOP` macro) so that we can simulate the case in which the same
    signal is delivered multiple times while it is being handled. In a real-world
    application, always strive to keep your signal handling as brief as is possible.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意让信号处理代码花费相当长的时间（通过我们使用的`DELAY_LOOP`宏），以便我们可以模拟在处理信号时多次传递相同信号的情况。在现实世界的应用中，始终努力使您的信号处理尽可能简短。
- en: 'The inline-assembly stack() function is an interesting way to get a register''s
    value. Read the following comment to see how it works:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 内联汇编`stack()`函数是获取寄存器值的有趣方法。阅读以下评论以了解其工作原理：
- en: '[PRE25]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The processor ABI - Application Binary Interface—documentation is an important
    area for the serious systems developer to be conversant with; check out more on
    this in the *Further reading* section on the GitHub repository.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器ABI - 应用程序二进制接口 - 文档是严肃系统开发人员需要熟悉的重要领域；在GitHub存储库的*进一步阅读*部分中查看更多信息。
- en: 'To properly test this application, we write a small shell script `bombard_sig.sh`,
    which literally bombards the given process with the (same) signal (we use SIGUSR1
    here). The user is expected to pass the process PID and the number of signal instances
    to send as parameters; if the second parameter is given as `-1`, the script continually
    bombards the process. Here is the key code of the script:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确测试此应用程序，我们编写了一个名为`bombard_sig.sh`的小型shell脚本，它会向给定进程（相同）信号轰炸（这里我们使用SIGUSR1）。用户应该传递进程PID和要发送的信号实例数作为参数；如果第二个参数给定为`-1`，则脚本将不断轰炸该进程。以下是脚本的关键代码：
- en: '[PRE26]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running of case 1 – SA_NODEFER bit cleared [default]
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行案例1 - 清除SA_NODEFER位[默认]
- en: 'Next, we execute the test case wherein the `SA_NODEFER` flag is cleared; this
    is the default behavior:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行测试用例，其中`SA_NODEFER`标志被清除；这是默认行为：
- en: '[PRE27]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, in another terminal window, we run the shell script:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个终端窗口中，我们运行shell脚本：
- en: '[PRE28]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `pgrep `figures out the PID of the `defer_or_not` process: useful! Just
    ensure the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`找出`defer_or_not`进程的PID：有用！只需确保以下内容：'
- en: (a) Only one instance of the process you are sending signals to is alive, or `pgrep `returns
    multiple PIDs and the script fails.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 您发送信号的进程只有一个实例，或者`pgrep`返回多个PID并且脚本失败。
- en: (b) The name passed to pgrep is 15 characters or less.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 传递给`pgrep`的名称为15个字符或更少。
- en: 'As soon as the script runs, firing off (12) signals to the process, this output
    appears:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本一运行，向进程发送（12）个信号，就会出现以下输出：
- en: '[PRE29]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Studying the preceding output, we notice as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 研究前面的输出，我们注意到如下内容：
- en: '`SIGUSR1` is caught and its signal handler runs; it emits a stream of numbers
    (incremented on each signal instance).'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR1`被捕获并且其信号处理程序运行；它发出一系列数字（在每个信号实例上递增）。'
- en: To do so correctly, we use a couple of  `volatile sig_atomic_t` globals (one
    for the value to print in the `DELAY_LOOP` macro and one to keep track of the
    total number of signals delivered to the process).
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了正确地执行此操作，我们使用了一对`volatile sig_atomic_t`全局变量（一个用于在`DELAY_LOOP`宏中打印的值，另一个用于跟踪传递给进程的信号总数）。
- en: The asterisk character `*` at the end of the digits implies that, by the time
    you see it, the signal handler has completed execution.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字末尾的星号`*`意味着，当您看到它时，信号处理程序已经执行完成。
- en: Though 12 instances of the `SIGUSR1` signal were delivered, the process was
    handling the first signal instance when the remaining 11 signals arrived; hence, only one
    was kept pending and processed after the handler completed. Of course, on different
    systems, it can always happen that you see more than one signal instance being
    handled.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管已传递了12个`SIGUSR1`信号实例，但在剩余的11个信号到达时，进程正在处理第一个信号实例；因此，只有一个信号保持挂起，并在处理程序完成后处理。当然，在不同的系统上，您可能会看到处理多个信号实例。
- en: Finally, notice that we print the stack pointer value at every signal handler
    invocation; it's a user-space virtual address, of course (recall our discussions
    in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*);
    more importantly, it's identical, implying that the very same stack frame was
    reused for the signal handler function (this often happens).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，注意我们在每次信号处理程序调用时打印堆栈指针值；当然，这是用户空间虚拟地址（回想我们在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中的讨论，*虚拟内存*）；更重要的是，它是相同的，这意味着相同的堆栈帧被重用于信号处理程序函数（这经常发生）。
- en: Running of case 2 – SA_NODEFER bit set
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行案例2 - 设置SA_NODEFER位
- en: 'Next, we execute the test case, wherein the `SA_NODEFER` flag is set (first
    ensure you have killed off any old instances of the `defer_or_not` process):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行测试用例，其中设置了`SA_NODEFER`标志（首先确保你已经杀死了`defer_or_not`进程的任何旧实例）：
- en: '[PRE30]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in another Terminal window, we run the shell script:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个终端窗口中，我们运行shell脚本：
- en: '[PRE31]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As soon as the script runs, firing off (12) signals to the process, the output
    is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，向进程发送（12）个信号，输出如下：
- en: '[PRE32]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, notice these things:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，请注意以下事项：
- en: '`SIGUSR1` is caught and its signal handler runs; it emits a stream of numbers
    (incremented on each signal instance).'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR1`被捕获并且它的信号处理程序运行；它发出一系列数字（每个信号实例递增）。'
- en: To do so correctly, we use a `volatile sig_atomic_t` global (one for the value
    to print in the `DELAY_LOOP` and one to keep track of the total number of signals
    delivered to the process).
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了正确地做到这一点，我们使用一个`volatile sig_atomic_t`全局变量（一个用于在`DELAY_LOOP`中打印的值，一个用于跟踪传递给进程的信号总数）。
- en: The asterisk character `*`at the end of the digits implies that, by the time
    you see it, the signal handler has completed execution; notice that this time,
    the * does not appear until much later.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字末尾的星号`*`表示，当你看到它时，信号处理程序已经执行完成；请注意，这一次，*直到很晚才出现。
- en: 'Twelve instances of the signal `SIGUSR1` are delivered one after the other:
    this time, each instance preempts the previous one (setting up a new call frame
    on the process stack; notice the unique stack pointer addresses).'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续传递了12个`SIGUSR1`信号实例：这一次，每个实例都会抢占前一个实例（在进程堆栈上设置一个新的调用帧；请注意独特的堆栈指针地址）。
- en: Notice how, after all signal instances have been handled, control is restored
    to the original context; we literally can see the stack unwind.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，在所有信号实例处理完毕后，控制被恢复到原始上下文；我们确实可以看到堆栈展开。
- en: Finally, look carefully at the stack pointer values; they are progressively decreasing.
    This, of course, is because on the `x86[_64]` CPU (as is the case on most modern
    CPUs), a downward-growing stack is the way it works.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，仔细观察堆栈指针的值；它们是逐渐减少的。当然，这是因为在`x86[_64]` CPU上（大多数现代CPU都是如此），堆栈是向下增长的。
- en: Do try out the program for yourself and see. It is interesting and powerful,
    but, remember, this is at the cost of being very stack intensive!
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 自己试试这个程序。它很有趣而且功能强大，但是请记住，这是以非常大的堆栈为代价的！
- en: 'How expensive is it (in terms of stack memory usage)? We can actually calculate
    the size of each stack (call) frame; take any two differing instances and subtract
    the lower from the higher. For example, let''s take the preceding case `s=6` and
    `s=5` : `s=5: 0x7ffe9e1784b0`      `s=6: 0x7ffe9e177db0`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '它（在堆栈内存使用方面）有多昂贵？我们实际上可以计算每个堆栈（调用）帧的大小；取任意两个不同的实例，从较小的中减去较大的。例如，让我们看看前面的情况`s=6`和`s=5`：`s=5:
    0x7ffe9e1784b0` `s=6: 0x7ffe9e177db0`'
- en: So, call frame `size =  0x7ffe9e1784b0 - 0x7ffe9e177db0 = 0x700 = 1792` bytes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调用帧`大小 = 0x7ffe9e1784b0 - 0x7ffe9e177db0 = 0x700 = 1792`字节。
- en: Here, for this particular application use case, each signal-handling call frame
    takes up to 1,792 bytes of memory.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定的应用用例中，每个信号处理调用帧占用了高达1792字节的内存。
- en: 'Let''s consider a worst-case scenario now: With an embedded real-time application,
    what if we receive, say, 5,000 signals very rapidly, while a previous instance
    is running (and of course the `SA_NODEFER` flag is set): We shall then end up
    creating 5,000 additional call frames on the process stack, which will cost approximately
    5,000 x 1,792 = 8,960,000 = ~ 8.5 MB!'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个最坏的情况：在嵌入式实时应用中，如果我们在上一个实例运行时非常快地接收到，比如说，5000个信号（当然设置了`SA_NODEFER`标志）：我们将在进程堆栈上创建5000个额外的调用帧，这将花费大约5000
    x 1,792 = 8,960,000 = ~ 8.5 MB！
- en: 'Why not actually test this case? (The value of being empirical - trying things
    out rather than just assuming them, is critical. See [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, as well). We do so as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不实际测试一下这种情况呢？（以实证为价值 - 尝试事物而不是仅仅假设它们，是至关重要的。参见[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*）。我们可以这样做：
- en: '[PRE33]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In another Terminal window, run the `bombard_sig.sh` script, asking it to generate
    5,000 signal instances. Refer to the following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，运行`bombard_sig.sh`脚本，要求它生成5000个信号实例。参考以下命令：
- en: '[PRE34]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the output in the first Terminal window:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个终端窗口中的输出：
- en: '[PRE35]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It crashes, of course, when it runs out of stack space.(Again, the results may
    vary on different systems; if you do not experience a crash, via stack overflow,
    with these numbers, try increasing the number of signals sent via the script and
    see...).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当它耗尽堆栈空间时，它当然会崩溃。（在不同的系统上，结果可能会有所不同；如果你没有经历过堆栈溢出导致的崩溃，尝试增加脚本发送的信号数量并观察...）。
- en: As we learned in [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, the typical process stack resource limit is 8 MB; thus, here we are in
    real danger of overflowing the stack, which will result in a fatal and sudden
    crash, of course. So, be careful! If you intend to use the `SA_NODEFER` flag,
    take the trouble to stress test your application under heavy workloads and see
    if more of the stack is being used than is safe.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)中学到的，*资源限制*，典型的进程堆栈资源限制为8
    MB；因此，我们真的有可能溢出堆栈，这将导致致命的突然崩溃。所以，请小心！如果你打算使用`SA_NODEFER`标志，请费点功夫在大负载下对你的应用进行压力测试，看看是否使用了比安全更多的堆栈。
- en: Using an alternate signal stack
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用备用信号堆栈
- en: Notice how our previous test case, sending 5,000 `SIGUSR1` signals to the `defer_or_not` application
    running with `SA_NODEFER` set, caused it to crash with a segmentation fault (often
    abbreviated as segfault). The OS sent the signal `SIGSEGV` (segmentation violation)
    to the process when it made an invalid memory reference; in other words, a bug
    related to a memory access. Trapping the `SIGSEGV` could be very valuable; we
    can gain information concerning how and why the application crashed (in fact,
    we shall do precisely this in the next chapter).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们之前的测试用例，向设置了`SA_NODEFER`的`defer_or_not`应用程序发送了5,000个`SIGUSR1`信号，导致它崩溃并出现段错误（通常缩写为segfault）。当进程进行无效的内存引用时，操作系统向进程发送了`SIGSEGV`（段错误）信号；换句话说，这是与内存访问相关的错误。捕获`SIGSEGV`可能非常有价值；我们可以获得关于应用程序崩溃的原因和方式的信息（实际上，我们将在下一章中做到这一点）。
- en: 'However, think carefully: in the last test case (the 5,000 signals... one),
    the reason the process crashed is that its stack overflowed. Thus, the OS delivered
    the signal `SIGSEGV`; we want to trap this signal and handle it. But there''s
    no space on the stack, so how can the signal handler function itself get invoked?
    This is a problem.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仔细想一想：在最后一个测试用例中（发送5,000个信号...），进程崩溃的原因是它的栈溢出。因此，操作系统发送了`SIGSEGV`信号；我们希望捕获这个信号并处理它。但是栈上没有空间，那么信号处理程序本身如何被调用？这是一个问题。
- en: 'An interesting solution exists: we can allocate (virtual) memory space for,
    and set up a separate alternate stack to be used for signal handling only. How?
    Via the `sigaltstack(2)` system call. It''s used for these kind of circumstances:
    you need to handle a `SIGSEGV`, but you''re out of stack space. Think about our
    previous real-time high-volume signal-handling application: we could perhaps redesign
    it such that we allocate a lot more space for a separate signal stack, so that
    it works in practice.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的解决方案：我们可以为信号处理分配（虚拟）内存空间，并设置一个单独的备用栈仅用于信号处理。如何做到？通过`sigaltstack(2)`系统调用。它用于这种情况：你需要处理`SIGSEGV`，但是你的栈空间不够了。想想我们之前的实时高容量信号处理应用：也许我们可以重新设计它，为单独的信号栈分配更多的空间，这样在实践中就可以工作了。
- en: Implementation to handle high-volume signals with an alternate signal stack
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用备用信号栈处理高容量信号的实现
- en: 'Here''s an attempt at precisely that: the code for `ch11/altstack.c` and a
    run-time test. Also, we have added a neat feature (to the previous version: the
    `defer_or_not` program): sending the process `SIGUSR2` signal will have it print
    out the first and the most recent stack pointer address. It will also calculate
    and display the delta—in effect, the amount of stack memory used so far by the
    application.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个精确的尝试：`ch11/altstack.c`的代码和运行时测试。此外，我们还添加了一个新功能（对于之前的版本：`defer_or_not`程序）：发送进程`SIGUSR2`信号将使其打印出第一个和最近的堆栈指针地址。它还将计算并显示增量——实际上是应用程序到目前为止使用的堆栈内存量。
- en: 'Changes from `ch11/defer_or_not.c`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ch11/defer_or_not.c`中的更改：
- en: We also trap the signals.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也捕获了信号。
- en: '`SIGUSR2`: to display the first and the most-recent stack pointer addresses
    and the delta between them.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR2`：显示第一个和最近的堆栈指针地址以及它们之间的差值。'
- en: '`SIGSEGV` : this is important in real-world applications. Trapping the `segfault`
    allows us to take control if the process crashes (here, probably due to stack
    overflow here) and perhaps display (or in real apps, write to a log) relevant
    information, perform cleanup, and then call `abort(3)` to exit. Realize that,
    after all, we must exit: the process is in an undefined state once this signal
    arrives from the OS. (Note that more detail on handling the `SIGSEGV` is covered
    in the next chapter).'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGSEGV`：这在现实世界的应用中很重要。捕获`segfault`允许我们在进程崩溃时（这里，可能是由于栈溢出）接管控制，并且也许显示（或在实际应用中，写入日志）相关信息，执行清理，然后调用`abort(3)`退出。要意识到，毕竟，我们必须退出：一旦这个信号从操作系统到达，进程就处于一个未定义的状态。（请注意，有关处理`SIGSEGV`的更多细节将在下一章中介绍）。'
- en: To avoid too much noise in the output, we replace the `DELAY_LOOP` macro with
    a silent version of the same.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免输出中的噪音过多，我们用一个静默版本的`DELAY_LOOP`宏替换它。
- en: For readability, only key parts of the code are displayed; to view the complete
    source code, build, and then run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，只显示了代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'In `ch11/altstack.c:main()`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch11/altstack.c:main()`中：
- en: '[PRE36]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `setup_altsigstack()` functions code is as follows :'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_altsigstack()`函数的代码如下：'
- en: '[PRE37]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The signal handling code is as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理代码如下：
- en: '[PRE38]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's perform some tests and run them considering the following cases.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些测试，并考虑以下情况运行它们。
- en: Case 1 – very small (100 KB) alternate signal stack
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况1 - 非常小（100KB）的备用信号栈
- en: 'We deliberately allocate a very small amount of space for the alternate signal
    stack—just 100 kilobytes. Needless to say, it overflows quickly and segfaults;
    our handler for `SIGSEGV` runs, printing out some stats:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意为备用信号栈分配了非常少的空间——只有100千字节。不用说，它很快就溢出并且出现段错误；我们的`SIGSEGV`处理程序运行，打印出一些统计信息：
- en: '[PRE39]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In another Terminal window, run the shell script:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，运行shell脚本：
- en: '[PRE40]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, the output in the original window:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在原始窗口中的输出：
- en: '[PRE41]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As can be seen, according to our metrics, the total alternate signal stack usage
    was 91,392 bytes, close to 100 KB, at the time it was overflowed.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，根据我们的度量标准，备用信号栈的总使用量为91,392字节，接近100KB，在溢出时。
- en: 'The shell script terminates with the expected:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: shell脚本以预期的方式终止：
- en: '[PRE42]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Case 2 : A large (16 MB) alternate signal stack
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况2：一个大（16MB）备用信号栈
- en: 'This time, we deliberately allocate a generous amount of space for the alternate
    signal stack—16 megabytes. It can now handle a few thousand continuous signals.
    But, of course, at some point it will also overflow:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们故意为备用信号栈分配了大量空间——16兆字节。现在它可以处理几千个连续的信号。但是，当然，在某个时候它也会溢出：
- en: '[PRE43]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In another Terminal window, run the shell script:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中运行shell脚本：
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now the output in the original window:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在原始窗口中的输出：
- en: '[PRE45]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The shell script terminates with the expected:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: shell脚本以预期的方式终止：
- en: '[PRE46]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This time, it managed to process around nine thousand signals before it ran
    out of stack. The total alternate signal stack usage was a huge 16,764,160 bytes,
    or close to 16 MB, at the time it was overflowed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在堆栈耗尽之前，它成功处理了大约九千个信号。备用信号堆栈的总使用量为16,764,160字节，或接近16 MB，在溢出时。
- en: Different approaches to handling signals at high volume
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理高容量信号的不同方法
- en: 'In conclusion, if you have a scenario in which a high volume of multiple signals
    of the same type (as well as other signals) are delivered at a rapid pace to the
    process, we run the risk of losing (or dropping) signals if we use the usual methods.
    As we have seen, we can successfully handle all signals in several ways, each
    with their own approaches to signal-handling at high volume—pros and cons as shown
    in the following table:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果您遇到一个场景，其中大量相同类型的多个信号（以及其他信号）以快速的速度传递给进程，我们使用通常的方法就有丢失（或丢弃）信号的风险。正如我们所看到的，我们可以以几种方式成功处理所有信号，每种方式都有其自己的处理高容量信号的方法
    - 优缺点如下表所示：
- en: '| **Method** | **Pros** | **Cons/Limitations** |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **优点** | **缺点/限制** |'
- en: '| Use `sigfillset(3)` just prior to calling `sigaction(2)` to ensure that while
    the signal is being handled, all other signals are blocked. | Simple and straightforward
    approach. | Can lead to significant (unacceptable) delays in handling and/or dropping
    of  signals. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 在调用`sigaction(2)`之前使用`sigfillset(3)`来确保在处理信号时，所有其他信号都被阻塞。 | 简单直接的方法。 | 可能导致处理和/或丢弃信号出现显著（不可接受的）延迟。'
- en: '| Setting the `SA_NODEFER` signal flag and handling all signals as they arrive.
    | Simple and straightforward approach. | On load, heavy stack usage, danger of
    stack overflow. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 设置`SA_NODEFER`信号标志并在信号到达时处理所有信号。 | 简单直接的方法。 | 在负载下，堆栈使用量大，存在堆栈溢出的危险。'
- en: '| Use an alternate signal stack, set the `SA_NODEFER` signal flag, and handle
    all signals as they arrive. | Can specify alternate stack size as required. |
    More work to setup; must carefully test under load to determine (max) stack size
    to use. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 使用备用信号堆栈，设置`SA_NODEFER`信号标志，并在信号到达时处理所有信号。 | 可以根据需要指定备用堆栈大小。 | 设置更多工作；必须在负载下进行仔细测试以确定要使用的（最大）堆栈大小。'
- en: '| Use real-time signals (covered in the following chapter). | The OS queues
    pending signals automatically, low stack usage, signal prioritization possible.
    | System-wide limit on the maximum number that can be queued (can be tuned as
    root). |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 使用实时信号（在下一章中介绍）。 | 操作系统会自动排队待处理的信号，堆栈使用低，可以对信号进行优先级排序。 | 系统范围内对可以排队的最大数量有限制（可以作为root进行调整）。'
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the reader has initially been introduced to the notion of signalling on
    the Linux OS, what signals are, why they are useful, and, then, in a lot of detail,
    how to effectively handle signals within your application.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者首先介绍了Linux操作系统上的信号概念，信号的作用，以及如何在应用程序中有效处理信号的详细内容。
- en: Of course, there being even more to it, the following chapter continues this
    important discussion. See you there.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多内容，下一章将继续讨论这一重要内容。到那里见。
