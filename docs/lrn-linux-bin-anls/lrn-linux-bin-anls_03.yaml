- en: Chapter 3. Linux Process Tracing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 Linux进程跟踪
- en: In the last chapter, we covered the internals of the `ELF` format and explained
    its internal workings. In Linux and other Unix-flavored OSes that use `ELF`, the
    `ptrace` system call goes hand in glove with analyzing, debugging, reverse engineering,
    and modifying programs that use the `ELF` format. The `ptrace` system call is
    used to attach to a process and access the entire range of code, data, stack,
    heap, and registers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了`ELF`格式的内部结构并解释了它的内部工作原理。在使用`ELF`的Linux和其他Unix风格的操作系统中，`ptrace`系统调用与分析、调试、逆向工程和修改使用`ELF`格式的程序密切相关。`ptrace`系统调用用于连接到进程并访问整个代码、数据、堆栈、堆和寄存器范围。
- en: Since an `ELF` program is completely mapped in a process address space, you
    can attach to the process and parse or modify the `ELF` image very similarly to
    how you would do this with the actual `ELF` file on disk. The primary difference
    is that we use `ptrace` to access the program instead of using the `open/mmap/read/write`
    calls that would be used for the `ELF` file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ELF`程序完全映射在进程地址空间中，您可以连接到进程并类似于在磁盘上对实际`ELF`文件进行操作一样解析或修改`ELF`镜像。主要区别在于我们使用`ptrace`来访问程序，而不是使用`open/mmap/read/write`调用来访问`ELF`文件。
- en: With `ptrace`, we can have full control over a program's execution flow, which
    means that we can do some very interesting things, ranging from memory virus infection
    and virus analysis/detection to userland memory rootkits, advanced debugging tasks,
    hotpatching, and reverse engineering. Since we have entire chapters in this book
    dedicated to some of these tasks, we will not cover each of these in depth just
    yet. Instead, I will provide a primer for you to learn about some of the basic
    functionality of `ptrace` and how it is used by hackers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ptrace`，我们可以完全控制程序的执行流程，这意味着我们可以做一些非常有趣的事情，从内存病毒感染和病毒分析/检测到用户态内存rootkit、高级调试任务、热修补和逆向工程。由于本书中有专门章节涵盖了其中一些任务，我们暂时不会深入讨论每一个。相反，我将为您提供一个入门，让您了解`ptrace`的一些基本功能以及黑客如何使用它。
- en: The importance of ptrace
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ptrace的重要性
- en: In Linux, the `ptrace(2)` system call is the userland means of accessing a process
    address space. This means that someone can attach to a process that they own and
    modify, analyze, reverse, and debug it. Well-known debugging and analysis applications
    such as `gdb`, `strace`, and `ltrace` are `ptrace` assisted applications. The
    `ptrace` command is very useful for both reverse engineers and malware authors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，`ptrace(2)`系统调用是用户空间访问进程地址空间的手段。这意味着某人可以连接到他们拥有的进程并修改、分析、逆向和调试它。著名的调试和分析应用程序，如`gdb`、`strace`和`ltrace`都是`ptrace`辅助应用程序。`ptrace`命令对于逆向工程师和恶意软件作者都非常有用。
- en: It gives a programmer the ability to attach to a process and modify the memory,
    which can include injecting code and modifying important data structures such
    as the **Global Offset Table** (**GOT**) for shared library redirection. In this
    section, we will cover the most commonly used features of `ptrace`, demonstrate
    memory infection from the attacker's side, and process analysis by writing a program
    to reconstruct a process image back into an executable. If you have never used
    `ptrace`, then you will see that you have been missing out on a lot of fun!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它给程序员提供了连接到进程并修改内存的能力，这可以包括注入代码和修改重要的数据结构，比如用于共享库重定向的**全局偏移表**（**GOT**）。在本节中，我们将介绍`ptrace`最常用的功能，演示来自攻击者方的内存感染，以及通过编写一个程序来将进程镜像重构回可执行文件进行进程分析。如果您从未使用过`ptrace`，那么您会发现您错过了很多乐趣！
- en: ptrace requests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ptrace请求
- en: The `ptrace` system call has a `libc` wrapper like any other system call, so
    you may include `ptrace.h` and simply call `ptrace` while passing it a request
    and a process ID. The following details are not a replacement for the main pages
    of `ptrace(2)`, although some descriptions were borrowed from the main pages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrace`系统调用有一个`libc`包装器，就像任何其他系统调用一样，所以你可以包含`ptrace.h`并简单地调用`ptrace`，同时传递一个请求和一个进程ID。以下细节并不取代`ptrace(2)`的主要页面，尽管一些描述是从主要页面借来的。'
- en: 'Here''s the synopsis:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是概要。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ptrace request types
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ptrace请求类型
- en: 'Here is a list of requests that are most commonly used when using `ptrace`
    to interact with a process image:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用`ptrace`与进程镜像交互时最常用的请求列表：
- en: '| Request | Description |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | 描述 |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PTRACE_ATTACH` | Attach to the process specified in `pid`, making it a tracee
    of the calling process. The tracee is sent a `SIGSTOP` signal, but will not necessarily
    have stopped by the completion of this call. Use `waitpid(2)` to wait for the
    tracee to stop. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `PTRACE_ATTACH` | 连接到指定`pid`的进程，使其成为调用进程的被跟踪者。被跟踪者会收到一个`SIGSTOP`信号，但不一定在此调用完成时已经停止。使用`waitpid(2)`等待被跟踪者停止。
    |'
- en: '| `PTRACE_TRACEME` | Indicates that this process is to be traced by its parent.
    A process probably shouldn''t make this request if its parent isn''t expecting
    to trace it. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `PTRACE_TRACEME` | 表示此进程将由其父进程进行跟踪。如果父进程不希望跟踪它，那么进程可能不应该发出此请求。 |'
- en: '| `PTRACE_PEEKTEXT PTRACE_PEEKDATA PTRACE_PEEKUSER` | These requests allow
    the tracing process to read from a virtual memory address within the traced process
    image; for instance, we can read the entire text or data segment into a buffer
    for analysis.Note that there is no difference in implementation between the `PEEKTEXT`,
    `PEEKDATA`, and `PEEKUSER` requests. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `PTRACE_PEEKTEXT PTRACE_PEEKDATA PTRACE_PEEKUSER` | 这些请求允许跟踪进程从被跟踪进程镜像中的虚拟内存地址读取；例如，我们可以将整个文本或数据段读入缓冲区进行分析。请注意，在`PEEKTEXT`、`PEEKDATA`和`PEEKUSER`请求之间的实现没有区别。
    |'
- en: '| `PTRACE_POKTEXT PTRACE_POKEDATA PTRACE_POKEUSER` | These requests allow the
    tracing process to modify any location within the traced process image. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `PTRACE_POKTEXT PTRACE_POKEDATA PTRACE_POKEUSER` | 这些请求允许跟踪进程修改被跟踪进程镜像中的任何位置。
    |'
- en: '| `PTRACE_GETREGS` | This request allows the tracing process to get a copy
    of the traced process''s registers. Each thread context has its own register set,
    of course. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_GETREGS` | 此请求允许跟踪进程获取被跟踪进程的寄存器副本。当然，每个线程上下文都有自己的寄存器集。'
- en: '| `PTRACE_SETREGS` | This request allows the tracing process to set new register
    values for the traced process, for example, modifying the value of the instruction
    pointer to point to the shellcode. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_SETREGS` | 此请求允许跟踪进程为被跟踪的进程设置新的寄存器值，例如，修改指令指针的值指向shellcode。'
- en: '| `PTRACE_CONT` | This request tells the stopped traced process to resume execution.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_CONT` | 此请求告诉停止的被跟踪进程恢复执行。'
- en: '| `PTRACE_DETACH` | This request resumes the traced process as well but also
    detaches. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_DETACH` | 此请求恢复被跟踪的进程，但也会分离。'
- en: '| `PTRACE_SYSCALL` | This request resumes the traced process but arranges for
    it to stop at the entrance/exit of the next syscall. This allows us to inspect
    the arguments for the syscall and even modify them. This `ptrace` request is heavily
    used in the code for a program called `strace`, which is shipped with most Linux
    distributions. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_SYSCALL` | 此请求恢复被跟踪的进程，但安排它在下一个系统调用的入口/退出处停止。这允许我们检查系统调用的参数，甚至修改它们。这个`ptrace`请求在一个名为`strace`的程序的代码中被大量使用，它随大多数Linux发行版一起提供。'
- en: '| `PTRACE_SINGLESTEP` | This resumes the process but stops it after the next
    instruction. Single stepping allows a debugger to stop after every instruction
    that is executed. This allows a user to inspect the values of the registers and
    the state of the process after each instruction. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_SINGLESTEP` | 这会恢复进程，但在下一条指令后停止它。单步执行允许调试器在执行每条指令后停止。这允许用户在每条指令后检查寄存器的值和进程的状态。'
- en: '| `PTRACE_GETSIGINFO` | This retrieves information about the signal that caused
    the stop. It retrieves a copy of the `siginfo_t` structure, which we can analyze
    or modify (with `PTRACE_SETSIGINFO`) to send back to the tracee. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_GETSIGINFO` | 这会检索导致停止的信号的信息。它检索`siginfo_t`结构的副本，我们可以分析或修改它（使用`PTRACE_SETSIGINFO`）发送回tracee。'
- en: '| `PTRACE_SETSIGINFO` | Sets the signal information. Copies a `siginfo_t` structure
    from the address data in the tracer to the tracee. This will affect only signals
    that would normally be delivered to the tracee and would be caught by the tracer.
    It may be difficult to tell these normal signals from synthetic signals generated
    by `ptrace()` itself (`addr` is ignored). |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_SETSIGINFO` | 设置信号信息。从跟踪器中的地址数据复制一个`siginfo_t`结构到tracee。这只会影响通常会传递给tracee并且会被tracer捕获的信号。很难区分这些正常信号和`ptrace()`本身生成的合成信号（`addr`被忽略）。'
- en: '| `PTRACE_SETOPTIONS` | Sets the `ptrace` options from data (`addr` is ignored).
    Data is interpreted as a bitmask of options. These are specified by flags in the
    following section (check out the main pages of `ptrace(2)` for a listing). |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '`PTRACE_SETOPTIONS` | 从数据中设置`ptrace`选项（`addr`被忽略）。数据被解释为选项的位掩码。这些选项由以下部分的标志指定（查看`ptrace(2)`的主页面进行列出）。'
- en: The term *tracer* refers to the process that is doing the tracing (the one that
    is invoking `ptrace`), and the term *tracee* or *the traced* means the program
    that is being traced by the tracer (with `ptrace`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*tracer*指的是正在进行跟踪的进程（调用`ptrace`的进程），而术语*tracee*或*the traced*指的是被tracer跟踪的程序（使用`ptrace`）。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default behavior overrides any mmap or mprotect permissions. This means
    that a user can write to the text segment with `ptrace` (even though it is read-only).
    This is not true if the kernel is pax or grsec and patched with mprotect restrictions,
    which enforce segment permissions so that they apply to `ptrace` as well; this
    is a security feature.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为会覆盖任何mmap或mprotect权限。这意味着用户可以使用`ptrace`写入文本段（即使它是只读的）。如果内核是pax或grsec并且使用mprotect限制进行了修补，这就不成立了，它会强制执行段权限，以便它们也适用于`ptrace`；这是一个安全功能。
- en: My paper on *ELF runtime infection* at [http://vxheavens.com/lib/vrn00.html](http://vxheavens.com/lib/vrn00.html)
    discusses some methods to bypass these restrictions for code injection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[http://vxheavens.com/lib/vrn00.html](http://vxheavens.com/lib/vrn00.html)上的关于*ELF运行时感染*的论文讨论了一些绕过这些限制进行代码注入的方法。
- en: The process register state and flags
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程寄存器状态和标志
- en: 'The `user_regs_struct` structure for `x86_64` contains the general-purpose
    registers, segmentation registers, stack pointer, instruction pointer, CPU flags,
    and TLS registers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`x86_64`的`user_regs_struct`结构包含通用寄存器、分段寄存器、堆栈指针、指令指针、CPU标志和TLS寄存器：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the 32-bit Linux kernel, `%gs` was used as the **thread-local-storage** (**TLS**)
    pointer, although since `x86_64`, the `%fs` register has been used for this purpose.
    Using the registers from `user_regs_struct` and with read/write access to a process's
    memory using `ptrace`, we can have complete control over it. As an exercise, let's
    write a simple debugger that allows us to set a breakpoint at a certain function
    in a program. When the program runs, it will stop at the breakpoint and print
    the register values and the function arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位Linux内核中，`%gs`被用作**线程本地存储**（**TLS**）指针，尽管自`x86_64`以来，`%fs`寄存器已被用于此目的。使用`user_regs_struct`中的寄存器，并使用`ptrace`对进程的内存进行读/写访问，我们可以完全控制它。作为练习，让我们编写一个简单的调试器，允许我们在程序中的某个函数处设置断点。当程序运行时，它将在断点处停止并打印寄存器值和函数参数。
- en: A simple ptrace-based debugger
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的基于ptrace的调试器
- en: 'Let''s look at a code example that makes use of `ptrace` to create a debugger
    program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`ptrace`创建调试器程序的代码示例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the tracer program
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪程序
- en: 'To compile the preceding source code, use this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译前面的源代码，请使用以下命令：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that `tracer.c` locates the symbol table by finding and referencing
    the `SHT_SYMTAB` type section header, so it will not work on executables that
    have been stripped of the `SHT_SYMTAB` symbol table (although they may have `SHT_DYNSYM`).
    This actually makes sense, because usually we are debugging programs that are
    still in their development phase, so they usually do have a complete symbol table.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`tracer.c`通过查找和引用`SHT_SYMTAB`类型的段头来定位符号表，因此它不适用于已经剥离了`SHT_SYMTAB`符号表的可执行文件（尽管它们可能有`SHT_DYNSYM`）。这其实是有道理的，因为通常我们调试的程序仍处于开发阶段，所以它们通常有一个完整的符号表。
- en: The other limitation is that it doesn't allow you to pass arguments to the program
    you are executing and tracing. So, it wouldn't do well in a real debugging situation,
    where you may need to pass switches or command-line options to your program that
    is being debugged.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是它不允许你向正在执行和跟踪的程序传递参数。因此，在真正的调试情况下，你可能需要向正在调试的程序传递开关或命令行选项，这样它就不会表现得很好。
- en: As an example of the `./tracer` program that we designed, let's try it on a
    very simple program that calls a function called `print_string(char *)` twice,
    and passes to it the `Hello 1` string on the first round and `Hello 2` on the
    second.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们设计的`./tracer`程序的一个例子，让我们尝试在一个非常简单的程序上使用它，这个程序调用一个名为`print_string(char *)`的函数两次，并在第一轮传递`Hello
    1`字符串，在第二轮传递`Hello 2`。
- en: 'Here''s an example of using the `./tracer` code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`./tracer`代码的一个例子：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, a breakpoint was set on `print_string`, and each time the function
    was called, our `./tracer` program caught the trap, printed the register values,
    and then continued executing after we hit a character. The `./tracer` program
    is a good example of how a debugger such as `gdb` works. Although it is much simpler,
    it demonstrates process tracing, breakpoints, and symbol lookup.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`print_string`上设置了一个断点，每次调用该函数时，我们的`./tracer`程序都会捕获陷阱，打印寄存器值，然后在我们按下字符后继续执行。`./tracer`程序是`gdb`等调试器工作的一个很好的例子。虽然它要简单得多，但它演示了进程跟踪、断点和符号查找。
- en: This program works great if you want to execute a program and trace it all at
    once. But what about tracing a process that is already running? In such a case,
    we would want to attach to the process image with `PTRACE_ATTACH`. This request
    sends a `SIGSTOP` to the process we are attaching to, so we use `wait` or `waitpid`
    to wait for the process to stop.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想一次执行一个程序并跟踪它，这个程序效果很好。但是如果要跟踪一个已经运行的进程呢？在这种情况下，我们希望使用`PTRACE_ATTACH`附加到进程映像。这个请求发送一个`SIGSTOP`到我们附加的进程，所以我们使用`wait`或`waitpid`等待进程停止。
- en: A simple ptrace debugger with process attach capabilities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有进程附加功能的简单ptrace调试器
- en: 'Let''s look at a code example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个代码示例：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `./tracer` (version 2), we can now attach to an already running process,
    then set a breakpoint on the desired function, and trace the execution. Here is
    an example of tracing a program that prints the `Hello 1` string 20 times in a
    loop with `print_string(char *s);`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`./tracer`（版本2），我们现在可以附加到一个已经运行的进程，然后在所需的函数上设置一个断点，并跟踪执行。这是一个追踪一个程序的例子，该程序在循环中打印`Hello
    1`字符串20次，使用`print_string(char *s);`：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, we have accomplished the coding of simple debugging software that can both
    execute a program and trace it, or attach to an existing process and trace it.
    This demonstrates the most common type of use cases for ptrace, and most other
    programs you write that use ptrace will be variations of the techniques in the
    *tracer.c* code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了简单调试软件的编码，它既可以执行程序并跟踪它，也可以附加到现有进程并跟踪它。这展示了`ptrace`最常见的用例，你编写的大多数使用`ptrace`的程序都将是对*tracer.c*代码技术的变化。
- en: Advanced function-tracing software
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级函数跟踪软件
- en: 'In 2013, I designed a tool that traces function calls. It is quite similar
    to `strace` and `ltrace`, but instead of tracing `syscalls` or library calls,
    it traces every function call made from the executable. This tool was covered
    in [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, but it is quite
    relevant to the topic of `ptrace`. This is because it is completely dependent
    on `ptrace` and performs some pretty wicked dynamic analysis using control flow
    monitoring. The source code can be found on GitHub:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，我设计了一个跟踪函数调用的工具。它与`strace`和`ltrace`非常相似，但它跟踪的不是`syscalls`或库调用，而是跟踪可执行文件中的每个函数调用。这个工具在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中有介绍，*ELF二进制格式*，但它与`ptrace`的主题非常相关。这是因为它完全依赖于`ptrace`，并使用控制流监视执行一些非常狂野的动态分析。源代码可以在GitHub上找到：
- en: '[https://github.com/leviathansecurity/ftrace](https://github.com/leviathansecurity/ftrace)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/leviathansecurity/ftrace](https://github.com/leviathansecurity/ftrace)'
- en: ptrace and forensic analysis
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ptrace和取证分析
- en: The `ptrace()` command is the system call that is most commonly used for memory
    analysis of a userland. In fact, if you are designing forensics software that
    runs in userland, the only way it can access other processes memory is through
    the `ptrace` system call, or by reading the `proc` filesystem (unless, of course,
    the program has some type of explicit shared memory IPC setup).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrace()`命令是最常用于用户空间内存分析的系统调用。实际上，如果你正在设计运行在用户空间的取证软件，它访问其他进程的内存的唯一方式是通过`ptrace`系统调用，或者通过读取`proc`文件系统（当然，除非程序有某种显式的共享内存IPC设置）。'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One may attach to a process and then `open/lseek/read/write /proc/<pid>/mem`
    as an alternative to `ptrace` read/write semantics.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以附加到进程，然后作为`ptrace`读/写语义的替代方案`open/lseek/read/write /proc/<pid>/mem`。
- en: In 2011, I was awarded a contract by the DARPA CFT (Cyber Fast Track) program
    to design something called *Linux VMA Monitor*. The purpose of this software is
    to detect a wide range of known and unknown process memory infections, such as
    rootkits and memory-resident viruses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，我获得了DARPA CFT（网络快速跟踪）计划的合同，设计了一个名为*Linux VMA Monitor*的东西。这个软件的目的是检测各种已知和未知的进程内存感染，如rootkits和内存驻留病毒。
- en: It essentially performs automated intelligent memory forensic analysis on every
    single process address space using special heuristics that understands `ELF` execution.
    It can spot anomalies or parasites, such as hijacked functions and generic code
    infections. The software can either analyze live memory and work as a host intrusion
    detection system, or take snapshots of the process memory and perform an analysis
    on them. This software can also detect and disinfect `ELF` binaries that are infected
    with viruses on disk.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上使用特殊的启发式方法对每个进程地址空间执行自动智能内存取证分析，了解`ELF`执行。它可以发现异常或寄生体，如劫持函数和通用代码感染。该软件可以分析活动内存并作为主机入侵检测系统运行，或者对进程内存进行快照并对其进行分析。该软件还可以检测和清除磁盘上感染病毒的`ELF`二进制文件。
- en: The `ptrace` system call is used heavily in the software and demonstrates a
    lot of interesting code around the `ELF` binary and `ELF` runtime infections.
    I have not released the source code as I intend to provide a more production-ready
    version prior to the release. Throughout this text, we will cover almost all the
    infection types that *Linux VMA Monitor* can detect/disinfect, and we will discuss
    and demonstrate the heuristics used to identify these infections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrace`系统调用在软件中被大量使用，并展示了围绕`ELF`二进制和`ELF`运行时感染的许多有趣代码。我还没有发布源代码，因为我打算在发布之前提供一个更适合生产的版本。在本文中，我们将涵盖*Linux
    VMA Monitor*可以检测/清除的几乎所有感染类型，并讨论和演示用于识别这些感染的启发式方法。'
- en: For well over a decade, hackers have been hiding complex malware within process
    memory to remain stealthy. This may be a combination of shared library injection
    and GOT poisoning, or any other set of techniques. The chances of a system administrator
    finding these are very slim, especially since there is not a lot of software publicly
    available for detecting many of these attacks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 十多年来，黑客一直在进程内存中隐藏复杂的恶意软件以保持隐蔽。这可能是共享库注入和GOT污染的组合，或者任何其他一组技术。系统管理员发现这些的机会非常渺茫，特别是因为公开可用于检测这些攻击的软件并不多。
- en: I have released several tools, including but not limited to AVU and ECFS, both
    of which can be found on GitHub and my website at [http://bitlackeys.org/](http://bitlackeys.org/).
    Whatever other software is in existence for such things is highly specialized
    and privately used, or it simply may not exist at all. Meanwhile, a good forensics
    analyst can use a debugger or write custom software to detect such malware, and
    it is important to know what you are looking for and why. Since this chapter is
    all about ptrace, I wanted to emphasize how it is interrelated with forensic analysis.
    And it is, and especially for those who are interested in designing specialized
    software for the purpose of identifying threats in memory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我发布了几个工具，包括但不限于AVU和ECFS，它们都可以在GitHub和我的网站[http://bitlackeys.org/](http://bitlackeys.org/)上找到。其他存在的用于此类事物的软件都是高度专业化并且私下使用，或者根本不存在。与此同时，一位优秀的取证分析师可以使用调试器或编写自定义软件来检测此类恶意软件，了解你要寻找的内容以及原因是很重要的。由于本章节主要讨论ptrace，我想强调它与取证分析的相关性。尤其是对于那些对设计专门用于在内存中识别威胁的软件感兴趣的人。
- en: Towards the end of the chapter, we will see how to write a program to detect
    function trampolines in running software.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将看到如何编写程序来检测运行软件中的函数跳板。
- en: What to look for in the memory
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内存中寻找什么
- en: An `ELF` executable is nearly the same in the memory as it is on the disk, with
    the exception of changes to the data segment variables, global offset table, function
    pointers, and uninitialized variables (the `.bss` section).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ELF`可执行文件在内存中几乎与磁盘上的相同，除了对数据段变量、全局偏移表、函数指针和未初始化变量（`.bss`部分）的更改。'
- en: 'This means that many of the virus or rootkit techniques that are used in `ELF`
    binaries can also be applied to processes (runtime code), and therefore they are
    better for an attacker to remain hidden. We will cover all of these common infection
    vectors in depth throughout the book, but here is a list of some techniques that
    have been used to implement infectious code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`ELF`二进制文件中使用的许多病毒或rootkit技术也可以应用于进程（运行时代码），因此对于攻击者来说更好地保持隐藏。我们将在整本书中深入讨论所有这些常见的感染向量，但以下是一些已被用于实现感染代码的技术列表：
- en: '| Infection technique | Intended results | Residency type |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 感染技术 | 预期结果 | 驻留类型 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GOT infection | Hijacking shared library functions | Process memory or executable
    file |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| GOT感染 | 劫持共享库函数 | 进程内存或可执行文件 |'
- en: '| **Procedure linkage table** (**PLT**) infection | Hijacking shared library
    functions | Process memory or executable file |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **过程链接表**（**PLT**）感染 | 劫持共享库函数 | 进程内存或可执行文件 |'
- en: '| The `.ctors`/`.dtors` function pointer modification | Altering the control
    flow to malicious code | Process memory or executable file |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `.ctors`/`.dtors`函数指针修改 | 改变到恶意代码的控制流 | 进程内存或可执行文件 |'
- en: '| Function trampolines | Hijacking any function | Process memory or executable
    file |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 函数跳板 | 劫持任何函数 | 进程内存或可执行文件 |'
- en: '| Shared library injection | Inserting malicious code | Process memory or executable
    file |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 共享库注入 | 插入恶意代码 | 进程内存或可执行文件 |'
- en: '| Relocatable code injection | Inserting malicious code | Process memory or
    executable file |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 可重定位代码注入 | 插入恶意代码 | 进程内存或可执行文件 |'
- en: '| Direct modification to the text segment | Inserting malicious code | Process
    memory or executable file |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 对文本段的直接修改 | 插入恶意代码 | 进程内存或可执行文件 |'
- en: '| Process possession (injecting an entire program into the address space) |
    Running a totally different executable program hidden within an existing process
    | Process memory |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 进程占有（将整个程序注入地址空间） | 在现有进程中隐藏运行完全不同的可执行程序 | 进程内存 |'
- en: Using a combination of `ELF` format parsing, `/proc/<pid>/maps`, and `ptrace`,
    one can create a set of heuristics to detect every one of the preceding techniques,
    and create a counter method to disinfect the process from the so-called parasite
    code. We will delve into all of these techniques throughout the book, primarily
    in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses* and [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ELF`格式解析、`/proc/<pid>/maps`和`ptrace`的组合，可以创建一组启发式方法来检测前述技术中的每一种，并创建一个反方法来清除所谓的寄生代码。我们将在整本书中深入探讨所有这些技术，主要是在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术 – Linux/Unix病毒")和[第6章](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "第6章。Linux中的ELF二进制取证")。
- en: Process image reconstruction – from the memory to the executable
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程映像重构 – 从内存到可执行文件
- en: One neat exercise to test our abilities with both the `ELF` format and `ptrace`
    is to design software that can reconstruct a process image back into a working
    executable. This is especially useful for the type of forensic work where we find
    a suspicious program running on the system. **Extended core file snapshot** (**ECFS**)
    technology is capable of this and extends the functionality into an innovative
    forensics and debugging format that is backward compatible with the traditional
    Linux core files' format. This is available at [https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)
    and is further documented in [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*, in this book. Quenya also has this feature and
    is available for download at [http://www.bitlackeys.org/projects/quenya_32bit.tgz](http://www.bitlackeys.org/projects/quenya_32bit.tgz).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们对`ELF`格式和`ptrace`的能力的一个很好的练习是设计软件，可以将进程映像重构为可工作的可执行文件。这对于我们在系统上发现可疑程序运行的类型的取证工作特别有用。**扩展核心文件快照**（**ECFS**）技术能够做到这一点，并将功能扩展到与传统Linux核心文件格式向后兼容的创新取证和调试格式。这在[https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)上可用，并在本书的[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章。ECFS – 扩展核心文件快照技术")中有进一步的文档，*ECFS – 扩展核心文件快照技术*。Quenya也具有这个功能，并可以在[http://www.bitlackeys.org/projects/quenya_32bit.tgz](http://www.bitlackeys.org/projects/quenya_32bit.tgz)上下载。
- en: Challenges for process-executable reconstruction
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程可执行文件重构的挑战
- en: In order to reconstruct a process back into an executable we must first consider
    the challenges involved, as there are a myriad things to consider. There is one
    particular type of variables over which we have no control, and these are the
    global variables in the initialized data. They will have possibly changed at runtime
    to variables dictated by the code, and we will have no way of knowing what they
    are supposed to be initialized to before runtime. We may not even be able to find
    this out by static code analysis.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将进程重构为可执行文件，我们必须首先考虑所涉及的挑战，因为有很多事情需要考虑。有一种特定类型的变量是我们无法控制的，这些是初始化数据中的全局变量。它们可能在运行时已经改变为代码所规定的变量，我们无法知道它们在运行之前应该被初始化为什么。我们甚至可能无法通过静态代码分析找到这一点。
- en: 'The following are the goals for executable reconstruction:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可执行文件重构的目标：
- en: Take a process ID as an argument and reconstruct that process image back into
    its executable file state
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以进程ID作为参数，并将该进程映像重构为其可执行文件状态
- en: We should construct a minimal set of section headers so that the program can
    be analyzed by tools such as `objdump` and `gdb` with better accuracy
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该构建一个最小的段头表，以便程序可以通过`objdump`和`gdb`等工具进行更准确的分析
- en: Challenges for executable reconstruction
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行文件重构的挑战
- en: Full executable reconstruction is possible, but it comes with some challenges,
    especially when reconstructing a dynamically linked executable. Here, we will
    go over what the primary challenges are and what the general solution is for each
    one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的可执行文件重构是可能的，但在重构动态链接的可执行文件时会带来一些挑战。在这里，我们将讨论主要的挑战是什么，以及每个挑战的一般解决方案是什么。
- en: PLT/GOT integrity
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PLT/GOT完整性
- en: The global offset table will be filled in with the resolved values of the corresponding
    shared library functions. This was, of course, done by the dynamic linker, and
    so we must replace these addresses with the original PLT stub addresses. We do
    this so that when the shared library functions are called for the first time,
    they trigger the dynamic linker properly through the PLT instruction that pushes
    the GOT offset onto the stack. Refer to the *ELF and dynamic linking* section
    of [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 全局偏移表将填入相应共享库函数的解析值。当然，这是由动态链接器完成的，因此我们必须用原始的PLT存根地址替换这些地址。我们这样做是为了当共享库函数第一次被调用时，它们通过将GOT偏移推送到堆栈的PLT指令正确地触发动态链接器。参考本书的[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中的*ELF和动态链接*部分，*ELF二进制格式*。
- en: 'The following diagram demonstrates how GOT entries must be restored:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表演示了GOT条目如何被恢复：
- en: '![PLT/GOT integrity](img/00004.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![PLT/GOT完整性](img/00004.jpeg)'
- en: Adding a section header table
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个段头表
- en: Remember that a program's section header table is not loaded into the memory
    at runtime. This is because it is not needed. When reconstructing a process image
    back into an executable, it would be desirable (although not necessary) to add
    a section header table. It is perfectly possible to add every section header entry
    that was on the original executable, but a good `ELF` hacker can generate at least
    the basics.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，程序的段头表在运行时不会加载到内存中。这是因为它不需要。在将进程图像重构回可执行文件时，添加段头表是可取的（尽管不是必需的）。完全可以添加原始可执行文件中的每个段头条目，但是一个优秀的`ELF`黑客至少可以生成基本内容。
- en: 'So try to create a section header for the following sections: `.interp`, `.note`,
    `.text`, `.dynamic`, `.got.plt`, `.data`, `.bss`, `.shstrtab`, `.dynsym`, and
    `.dynstr`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请尝试为以下部分创建一个段头：`.interp`、`.note`、`.text`、`.dynamic`、`.got.plt`、`.data`、`.bss`、`.shstrtab`、`.dynsym`和`.dynstr`。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the executable that you are reconstructing is statically linked, then you
    won't have the `.dynamic`, `.got.plt`, `.dynsym`, or `.dynstr` sections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在重构的可执行文件是静态链接的，那么您将不会有`.dynamic`、`.got.plt`、`.dynsym`或`.dynstr`部分。
- en: The algorithm for the process
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程的算法
- en: 'Let''s look at executable reconstruction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看可执行文件的重构：
- en: 'Locate the base address of the executable (text segment). This can be done
    by parsing `/proc/<pid>/maps`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位可执行文件（文本段）的基地址。这可以通过解析`/proc/<pid>/maps`来完成：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `PTRACE_PEEKTEXT` request with `ptrace` to read in the entire text segment.
    You can see in a line from the preceding maps output that the address range for
    the text segment (marked `r-xp`) is `0x400000` to `0x401000`, which is 4096 bytes.
    So, this is how large your buffer should be for the text segment. Since we have
    not covered how to use `PTRACE_PEEKTEXT` to read more than a long-sized word at
    a time, I have written a function called `pid_read()` that demonstrates a good
    way to do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ptrace`的`PTRACE_PEEKTEXT`请求来读取整个文本段。您可以在前面的映射输出中看到文本段的地址范围（标记为`r-xp`）是`0x400000`到`0x401000`，即4096字节。因此，这就是文本段的缓冲区大小。由于我们还没有涵盖如何使用`PTRACE_PEEKTEXT`一次读取超过一个长字大小的字，我编写了一个名为`pid_read()`的函数，演示了一个很好的方法。
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Parse the `ELF` file header (for example, `Elf64_Ehdr`) to locate the program
    header table:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析`ELF`文件头（例如`Elf64_Ehdr`）以定位程序头表：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then parse the program header table to find the data segment:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后解析程序头表以找到数据段：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Read the data segment into a buffer, and locate the dynamic segment within
    it and then the GOT. Use `d_tag` from the dynamic segment to locate the GOT:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据段读入缓冲区，并在其中定位动态段，然后定位GOT。使用动态段中的`d_tag`来定位GOT：
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We discussed the dynamic segment and its tag values in the *Dynamic linking*
    section of [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "第2章。ELF二进制格式")的*ELF二进制格式*部分讨论了动态段及其标记值。
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the GOT has been located, it must be restored to its state prior to runtime.
    The part that matters the most is restoring the original PLT stub addresses in
    each GOT entry so that lazy linking works at program runtime. See the *ELF dynamic
    linking* section of [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到GOT，就必须将其恢复到运行时之前的状态。最重要的部分是恢复每个GOT条目中原始的PLT存根地址，以便懒惰链接在程序运行时起作用。参见[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")的*ELF动态链接*部分，*ELF二进制格式*：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The GOT entry that is reserved for `puts()` should be patched to point back
    to the PLT stub code that pushes the GOT offset onto the stack for that entry.
    The address for this, `0x4003e6`, is given in the preceding command. The method
    for determining the GOT-to-PLT entry relationship is left as an exercise for the
    reader.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`puts()`保留的GOT条目应该被修补，指向将GOT偏移推送到堆栈的PLT存根代码。前面的命令中给出了这个地址`0x4003e6`。确定GOT到PLT条目关系的方法留给读者作为练习。
- en: Optionally reconstruct a section header table. Then write the text and data
    segment (and the section header table) to the disk.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地重构一个段头表。然后将文本段和数据段（以及段头表）写入磁盘。
- en: Process reconstruction with Quenya on a 32-bit test environment
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在32位测试环境上使用Quenya进行进程重构
- en: A 32-bit `ELF` executable named `dumpme` simply prints the `You can Dump my
    segments!` string and then pauses, giving us time to reconstruct it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`dumpme`的32位`ELF`可执行文件简单地打印`You can Dump my segments!`字符串，然后暂停，让我们有时间重构它。
- en: 'Now, the following code demonstrates Quenya reconstructing a process image
    into an executable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下代码演示了Quenya将进程图像重构为可执行文件：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we are demonstrating that the output executable runs correctly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示了输出可执行文件是否正确运行：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Quenya has created a minimal section header table for the executable as well:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Quenya还为可执行文件创建了一个最小的段头表：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are seven section headers, starting at the offset `0x1118`, as shown
    here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了从偏移量`0x1118`开始的七个段头。
- en: '![Process reconstruction with Quenya on a 32-bit test environment](img/00005.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Quenya在32位测试环境上进行进程重构](img/00005.jpeg)'
- en: The source code for process reconstruction in Quenya is located primarily in
    `rebuild.c`, and Quenya may be downloaded from my site at [http://www.bitlackeys.org/](http://www.bitlackeys.org/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Quenya中用于进程重构的源代码主要位于`rebuild.c`中，Quenya可以从我的网站[http://www.bitlackeys.org/](http://www.bitlackeys.org/)下载。
- en: Code injection with ptrace
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ptrace进行代码注入
- en: So far we have examined some interesting use cases for `ptrace`, including process
    analysis and process image reconstruction. Another common use of `ptrace` is for
    introducing new code into a running process and executing it. This is commonly
    done by attackers to modify a running program so that it does something else,
    such as load a malicious shared library into the process address space.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了一些有趣的`ptrace`用例，包括进程分析和进程镜像重建。`ptrace`的另一个常见用途是向运行中的进程引入新代码并执行它。攻击者通常这样做是为了修改运行中的程序，使其执行其他操作，比如将恶意共享库加载到进程地址空间中。
- en: In Linux, the default `ptrace()` behavior is such that it allows you to write
    `Using PTRACE_POKETEXT` to segments that are not writable, such as the text segment.
    This is because it is expected that debuggers will need to insert breakpoints
    into the code. This works out great for hackers who want to insert code into memory
    and execute it. To demonstrate this, we have written `code_inject.c`. This attaches
    to a process and injects a shellcode that will create an anonymous memory mapping
    large enough to hold our payload executable, `payload.c`, which is then injected
    into the new memory and executed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，默认的`ptrace()`行为是允许你写入`Using PTRACE_POKETEXT`到不可写的段，比如文本段。这是因为预期调试器需要在代码中插入断点。这对于想要将代码插入内存并执行的黑客来说非常有用。为了演示这一点，我们编写了`code_inject.c`。它附加到一个进程并注入一个shellcode，将创建一个足够大的匿名内存映射来容纳我们的payload可执行文件`payload.c`，然后将其注入到新的内存中并执行。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier in this chapter, Linux kernels that are patched with `PaX`
    will not allow `ptrace()` to write to segments that are not writable. This is
    for further enforcement of memory protection restrictions. In the paper *ELF runtime
    infection via GOT poisoning*, I have discussed methods of bypassing these restrictions
    by manipulating the `vsyscall` table with `ptrace`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到过，使用`PaX`打补丁的Linux内核将不允许`ptrace()`写入不可写的段。这是为了进一步执行内存保护限制。在论文《通过GOT污染进行ELF运行时感染》中，我已经讨论了通过使用`ptrace`操纵`vsyscall`表来绕过这些限制的方法。
- en: 'Now, let''s look at a code example where we inject a shellcode into a running
    process that loads a foreign executable:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个代码示例，我们在运行中的进程中注入一个shellcode，加载一个外部可执行文件：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s the source code for `payload.c`. It is compiled without `libc` linking
    and with position-independent code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`payload.c`的源代码。它是在不链接`libc`并且使用位置无关代码的情况下编译的：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simple examples aren't always so trivial
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的例子并不总是那么琐碎
- en: Although the source code for our code injection doesn't appear really trivial,
    the `code_inject.c` source code is a slightly dampened-down version of a real
    memory infector. I say this because it is limited to injecting position-independent
    code, and it loads the text and data segments of the payload executable into the
    same memory region back to back.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的代码注入的源代码看起来并不是那么琐碎，但`code_inject.c`源代码是一个稍微简化的真实内存感染器。我这么说是因为它限制了注入位置无关代码，并且将payload可执行文件的文本和数据段加载到同一内存区域中。
- en: If the payload program were to reference any variables in the data segment,
    they would not work, so in a real scenario, there would have to be proper page
    alignment between the two segments. In our case, the payload program is very basic
    and simply writes a string to the terminal's standard output. Also in a real scenario,
    the attacker generally wants to save the original instruction pointer and registers
    and then resume execution at that point after the shellcode has been run. In our
    case, we just let the shellcode print a string and then exit the entire program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果payload程序引用了数据段中的任何变量，它们将无法工作，因此在真实场景中，两个段之间必须有适当的页面对齐。在我们的情况下，payload程序非常基本，只是向终端的标准输出写入一个字符串。在真实场景中，攻击者通常希望保存原始指令指针和寄存器，然后在shellcode运行后恢复执行。在我们的情况下，我们只是让shellcode打印一个字符串，然后退出整个程序。
- en: Most hackers inject shared libraries or relocatable code into a process address
    space. The idea of injecting complex executables into a process address space
    is a technique that I've not seen before, other than with my own experimentation
    and implementations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数黑客将共享库或可重定位代码注入到进程地址空间。将复杂的可执行文件注入到进程地址空间的想法是一种我以前没有见过的技术，除了我自己的实验和实现。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A good example of injecting complex programs into a process address space can
    be found in the `elfdemon` source code, which allows a user to inject a full dynamically
    linked executable of the `ET_EXEC` type into an existing process without overwriting
    the host program. This task has many challenges and can be found in an experimental
    project of mine at the following link:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`elfdemon`源代码中可以找到将完整的动态链接可执行文件（类型为`ET_EXEC`）注入到现有进程中而不覆盖主机程序的示例。这个任务有很多挑战，可以在我的一个实验项目中找到，链接如下：
- en: '[http://www.bitlackeys.org/projects/elfdemon.tgz](http://www.bitlackeys.org/projects/elfdemon.tgz)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.bitlackeys.org/projects/elfdemon.tgz](http://www.bitlackeys.org/projects/elfdemon.tgz)'
- en: Demonstrating the code_inject tool
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示code_inject工具
- en: 'As we can see, our program injects and executes a shellcode that creates an
    executable memory mapping, where the payload program is then injected and executed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的程序注入并执行了一个创建可执行内存映射的shellcode，然后注入和执行了payload程序：
- en: 'Run the host program (the one that you want to infect):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行主机程序（你想要感染的程序）：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run `code_inject` and tell it to inject the program named payload into the
    process for the host:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`code_inject`并告诉它将名为payload的程序注入到主机进程中：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may have noticed that there appears to be no traditional shellcode (byte
    code) in `code_inject.c`. That's because the `uint64_t injection_code(void *)`
    function is our shellcode. Since it is already compiled into machine instructions,
    we just calculated its length and passed its address to `pid_write()` in order
    to inject it into the process. This, in my opinion, is a more elegant way of doing
    things than the more common method of including an array of byte code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`code_inject.c`中似乎没有传统的shellcode（字节码）。这是因为`uint64_t injection_code(void
    *)`函数就是我们的shellcode。由于它已经编译成机器指令，我们只需计算其长度并将其地址传递给`pid_write()`，以便将其注入到进程中。在我看来，这比包含字节码数组的常见方法更加优雅。
- en: A ptrace anti-debugging trick
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个ptrace反调试技巧
- en: The `ptrace` command can be used as an anti-debugging technique. Often when
    a hacker doesn't want their program to be easily debugged, they include certain
    anti-debugging techniques. One popular way in Linux is to use `ptrace` with the
    `PTRACE_TRACEME` request so that it traces the process of itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrace`命令可以用作反调试技术。通常，当黑客不希望他们的程序容易被调试时，他们会包含某些反调试技术。在Linux中，一种流行的方法是使用`ptrace`和`PTRACE_TRACEME`请求，以便跟踪自身的进程。'
- en: Remember that a process can only have one tracer at a time, so if a process
    is already being traced and a debugger tries to attach using `ptrace`, it says
    `Operation not permitted`. `PTRACE_TRACEME` can also be used to check whether
    your program is already being debugged. You can use the code in the following
    section to check this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个进程一次只能有一个跟踪器，因此如果一个进程已经被跟踪，并且调试器尝试使用`ptrace`附加，它会显示`Operation not permitted`。`PTRACE_TRACEME`也可以用来检查您的程序是否已经被调试。您可以使用下一节中的代码来检查这一点。
- en: Is your program being traced?
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的程序正在被跟踪吗？
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code works because it should only fail if the program is already
    being traced. So, if `ptrace` returns an error value (less than `0`) with `PTRACE_TRACEME`,
    you can be certain that a debugger is present and then exit the program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以有效，是因为只有在程序已经被跟踪的情况下才会失败。因此，如果`ptrace`使用`PTRACE_TRACEME`返回一个错误值（小于`0`），你可以确定存在调试器，然后退出程序。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a debugger is not present, then `PTRACE_TRACEME` will succeed, and now that
    the program is tracing itself, any attempts by a debugger to trace the program
    will fail. So, it is a nice anti-debugging measure.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调试器存在，那么`PTRACE_TRACEME`将成功，现在程序正在跟踪自身，任何调试器对程序的跟踪尝试都将失败。因此，这是一个不错的反调试措施。
- en: As shown in [Chapter 1](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985
    "Chapter 1. The Linux Environment and Its Tools"), *The Linux Environment and
    Its Tools*, the `LD_PRELOAD` environment variable may be used to bypass this anti-debug
    measure by tricking the program into loading a fake `ptrace` command that does
    nothing but return `0`, and will therefore not have any effect against debuggers.
    On the contrary, if a program uses the `ptrace` anti-debugging trick without using
    the `libc ptrace` wrapper—and instead creates its own wrapper—then the `LD_PRELOAD`
    trick will not work. This is because the program is not relying on any library
    for access to `ptrace`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985 "第1章。Linux环境及其工具")所示，*Linux环境及其工具*，`LD_PRELOAD`环境变量可以用来绕过这种反调试措施，通过欺骗程序加载一个什么都不做只返回`0`的假`ptrace`命令，因此不会对调试器产生任何影响。相反，如果一个程序使用`ptrace`反调试技巧而不使用`libc
    ptrace`包装器，并且创建自己的包装器，那么`LD_PRELOAD`技巧将不起作用。这是因为程序不依赖任何库来访问`ptrace`。
- en: 'Here is an alternative way to use `ptrace` by writing your own wrapper for
    it. We will be using the `x86_64 ptrace` wrapper in this example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用自己的包装器来使用`ptrace`的替代方法。在本例中，我们将使用`x86_64 ptrace`包装器。
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the importance of the `ptrace` system call
    and how it can be used in conjunction with viruses and memory infections. On the
    flip side, it is a powerful tool for security researchers, reverse engineering,
    and advanced hot patching techniques.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了`ptrace`系统调用的重要性以及它如何与病毒和内存感染结合使用。另一方面，它是安全研究人员、逆向工程和高级热修补技术的强大工具。
- en: The `ptrace` system call will be used periodically throughout the rest of this
    book. Let this chapter serve only as a primer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrace`系统调用将在本书的其余部分定期使用。让本章只作为一个入门。'
- en: In the next chapter, we will cover the exciting world of Linux ELF virus infection
    and the engineering practices behind virus creation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Linux ELF病毒感染的激动人心的世界以及病毒创建背后的工程实践。
