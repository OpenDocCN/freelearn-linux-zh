- en: Chapter 5. The Linux Root Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Linux根文件系统
- en: In this chapter, you will learn about the root filesystem and its structure.
    You will also be presented with information about the root filesystem's content,
    the various device drivers available, and its the communication with the Linux
    kernel. We will slowly make the transition to the Yocto Project and the method
    used to define the Linux root filesystem's content. The necessary information
    will be presented to make sure that a user will be also able to customize the
    `rootfs` filesystem according to its needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解根文件系统及其结构。您还将获得有关根文件系统内容、各种设备驱动程序以及与Linux内核的通信的信息。我们将逐渐过渡到Yocto项目以及用于定义Linux根文件系统内容的方法。将提供必要的信息，以确保用户能够根据自己的需求定制`rootfs`文件系统。
- en: The special requirements of the root filesystem will be presented. You will
    be given information on its content, subdirectories, defined purposes, the various
    filesystem options available, the BusyBox alternative, and also a lot of interesting
    features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将介绍根文件系统的特殊要求。您将获得有关其内容、子目录、定义目的、各种文件系统选项、BusyBox替代方案以及许多有趣功能的信息。
- en: When interacting with an embedded environment, a lot of developers would start
    from a minimal root filesystem made available by a distribution provider, such
    as Debian, and using a cross-toolchain will enhance it with various packages,
    tools, and utilities. If the number of packages to be added is big, it can be
    very troublesome work. Starting from scratch would be an even bigger nightmare.
    Inside the Yocto Project, this job is automatized and there is no need for manual
    work. The development is started from scratch, and it offers a large number of
    packages inside the root filesystem to make the work fun and interesting. So,
    let's move ahead and take a look at this chapter's content to understand more
    about root filesystems in general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在与嵌入式环境交互时，许多开发人员会从分发提供商（如Debian）那里获得一个最小的根文件系统，并使用交叉工具链来增强它，添加各种软件包、工具和实用程序。如果要添加的软件包数量很大，这可能会是非常麻烦的工作。从头开始将是一个更大的噩梦。在Yocto项目中，这项工作是自动化的，无需手动工作。开发是从头开始的，并且在根文件系统中提供了大量的软件包，使工作变得有趣和有趣。因此，让我们继续前进，看看本章的内容，以更全面地了解根文件系统。
- en: Interacting with the root filesystem
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与根文件系统交互
- en: A root filesystem consists of a directory and file hierarchy. In this file hierarchy,
    various filesystems can be mounted, revealing the content of a specific storage
    device. The mounting is done using the mount command, and after the operation
    is done, the mount point is populated with the content available on the storage
    device. The reverse operation is called `umount` and is used to empty the mount
    point of its content.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统由目录和文件层次结构组成。在这个文件层次结构中，可以挂载各种文件系统，显示特定存储设备的内容。挂载是使用`mount`命令完成的，在操作完成后，挂载点将被存储设备上可用的内容填充。反向操作称为`umount`，用于清空挂载点的内容。
- en: The preceding commands are very useful for the interaction of applications with
    various files available, regardless of their location and format. For example,
    the standard form for the `mount` command is `mount –t type device directory`.
    This command asks the kernel to connect the filesystem from the device that has
    the `type` format mentioned in the command line, along with the directory mentioned
    in the same command. The `umount` command needs to be given before removing the
    device to make sure the kernel caches are written in the storage point.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令对应用程序与各种可用文件的交互非常有用，无论它们的位置和格式如何。例如，`mount`命令的标准形式是`mount -t type device
    directory`。这个命令要求内核连接设备上的文件系统，该设备在命令行中指定了`type`格式，同时还要连接命令中提到的目录。在移除设备之前，需要使用`umount`命令来确保内核缓存被写入存储点。
- en: 'A root filesytem is available in the root hierarchy, also known as `/`. It
    is the first available filesystem and also the one on which the `mount` command
    is not used, since it is mounted directly by the kernel through the `root= argument`.
    The following are the multiple options to load the root filesystem:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统位于根目录结构中，也称为`/`。它是第一个可用的文件系统，也是不使用`mount`命令的文件系统，因为它是通过内核直接通过`root=`参数挂载的。以下是加载根文件系统的多个选项：
- en: From the memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存
- en: From the network using NFS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NFS从网络中
- en: From a NAND chip
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从NAND芯片
- en: From an SD card partition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从SD卡分区
- en: From a USB partition
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从USB分区
- en: From a hard disk partition
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从硬盘分区
- en: These options are chosen by hardware and system architects. To make use of these,
    the kernel and bootloader need to be configured accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项由硬件和系统架构师选择。要使用这些选项，需要相应地配置内核和引导加载程序。
- en: 'Besides the options that require interaction with a board''s internal memory
    or storage devices, one of the most used methods to load the root filesystem is
    represented by the NFS option, which implies that the root filesystem is available
    on your local machine and is exported over the network on your target. This option
    offers the following advantages:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要与板载内存或存储设备进行交互的选项外，加载根文件系统最常用的方法之一是NFS选项，这意味着根文件系统在本地机器上可用，并且在目标机器上通过网络进行导出。此选项提供以下优势：
- en: The size of the root filesystem will not be an issue due to the fact that the
    storage space on the development machine is much larger than the one available
    on the target
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于开发机器上的存储空间比目标机器上的存储空间大得多，根文件系统的大小不会成为问题
- en: The update process is much easier and can be done without rebooting
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新过程更容易，无需重新启动
- en: Having access to an over the network storage is the best solution for devices
    with small even inexistent internal or external storage devices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问网络存储是对于内部或外部存储空间较小甚至不存在的设备的最佳解决方案
- en: 'The downside of the over the network storage is the fact that a sever client
    architecture is needed. So, for NFS, an NFS server functionality will need to
    be available on the development machine. For a Ubuntu host, the required configuration
    involves installing the `nfs-kernel–server` package, `sudo apt-get install nfs-kernel-server`.
    After the package is installed, the exported directory location needs to be specified
    and configured. This is done using the `/etc/exports` file; here, configuration
    lines similar to `/nfs/rootfs <client-IP-address> (rw,no_root_squash,no_subtree_check)`
    appear, where each line defines a location for the over the network shared locations
    with the NFS client. After the configuration is finished, the NFS server needs
    to be restarted in this way: `sudo /etc/init.d/nfs-kernel-server restart`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络存储的缺点是需要服务器客户端架构。因此，对于NFS，开发机器上需要提供NFS服务器功能。对于Ubuntu主机，所需的配置涉及安装`nfs-kernel-server`软件包，`sudo
    apt-get install nfs-kernel-server`。安装软件包后，需要指定和配置导出目录位置。这是通过`/etc/exports`文件完成的；在这里，类似于`/nfs/rootfs
    <client-IP-address> (rw,no_root_squash,no_subtree_check)`的配置行出现，其中每行定义了NFS客户端的网络共享位置。配置完成后，需要以以下方式重新启动NFS服务器：`sudo
    /etc/init.d/nfs-kernel-server restart`。
- en: 'For the client side available on the target, the Linux kernel needs to be configured
    accordingly to make sure that the NFS support is enabled, and also that an IP
    address will be available at boot time. This configurations are `CONFIG_NFS_FS=y`,
    `CONFIG_IP_PNP=y`, and `CONFIG_ROOT_NFS=y`. The kernel also needs to be configured
    with the `root=/dev/nfs` parameter, the IP address for the target, and the NFS
    server `nfsroot=192.168.1.110:/nfs/rootfs` information. Here is an example of
    the communication between the two components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标上可用的客户端端，需要相应配置Linux内核，以确保启用NFS支持，并且在启动时IP地址可用。这些配置是`CONFIG_NFS_FS=y`，`CONFIG_IP_PNP=y`和`CONFIG_ROOT_NFS=y`。内核还需要配置`root=/dev/nfs`参数，目标的IP地址和NFS服务器`nfsroot=192.168.1.110:/nfs/rootfs`信息。以下是两个组件之间通信的示例：
- en: '![Interacting with the root filesystem](img/image00323.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![与根文件系统交互](img/image00323.jpeg)'
- en: 'There is also the possibility of having a root filesystem integrated inside
    the kernel image, that is, a minimal root filesytem whose purpose is to start
    the full featured root filesystem. This root filesystem is called `initramfs`.
    This type of filesystem is very helpful for people interested in fast booting
    options of smaller root filesystems that only contain a number of useful features
    and need to be started earlier. It is useful for the fast loading of the system
    at boot time, but also as an intermediate step before starting the real root filesystem
    available on one of the available storage locations. The root filesystem is first
    started after the kernel booting process, so it makes sense for it to be available
    alongside the Linux kernel, as it resides near the kernel on the RAM memory. The
    following image explains this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性，即将根文件系统集成到内核映像中，即最小根文件系统，其目的是启动完整功能的根文件系统。这个根文件系统称为`initramfs`。这种类型的文件系统对于对快速启动选项感兴趣的人非常有帮助，因为它只包含一些有用的功能，并且需要在更早的时候启动。它对于在启动时快速加载系统非常有用，但也可以作为启动实际根文件系统之前的中间步骤。根文件系统在内核引导过程之后首先启动，因此它应该与Linux内核一起可用，因为它驻留在RAM内存上的内核附近。以下图片解释了这一点：
- en: '![Interacting with the root filesystem](img/image00324.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![与根文件系统交互](img/image00324.jpeg)'
- en: To create `initramfs`, configurations need to be made available. This happens
    by defining either the path to the root filesystem directory, the path to a `cpio`
    archive, or even a text file describing the content of the `initramfs` inside
    the `CONFIG_INITRAMFS_SOURCE`. When the kernel build starts, the content of `CONFIG_INITRAMFS_SOURCE`
    will be read and the root filesystem will be integrated inside the kernel image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`initramfs`，需要提供配置。这是通过定义根文件系统目录的路径、`cpio`存档的路径，甚至是描述`initramfs`内容的文本文件来完成的，这些都在`CONFIG_INITRAMFS_SOURCE`中。当内核构建开始时，将读取`CONFIG_INITRAMFS_SOURCE`的内容，并将根文件系统集成到内核映像中。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the `initramfs` filesystem's options can be found inside
    the kernel documentations files at `Documentation/filesystems/ramfs-rootfs-initramfs.txt`
    and `Documentation/early-userspace/README`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`initramfs`文件系统选项的更多信息可以在内核文档文件`Documentation/filesystems/ramfs-rootfs-initramfs.txt`和`Documentation/early-userspace/README`中找到。
- en: The initial RAM disk or `initrd` is another mechanism of mounting an early root
    filesystem. It also needs the support enabled inside the Linux kernel and is loaded
    as a component of the kernel. It contains a small set of executables and directories
    and represents a transient stage to the full featured root filesystem. It only
    represents the final stage for embedded devices that do not have a storage device
    capable of fitting a bigger root filesystem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 初始RAM磁盘或`initrd`是另一种挂载早期根文件系统的机制。它还需要在Linux内核中启用支持，并作为内核的组件加载。它包含一小组可执行文件和目录，并代表了完整功能的根文件系统的临时阶段。它只代表了对于没有能够容纳更大根文件系统的存储设备的嵌入式设备的最终阶段。
- en: 'On a traditional system, the `initrd` is created using the `mkinitrd` tool,
    which is, in fact, a shell script that automates the steps necessary for the creation
    of `initrd`. Here is an example of its functionality:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统系统上，使用`mkinitrd`工具创建`initrd`，实际上是一个自动化创建`initrd`所需步骤的shell脚本。以下是其功能的示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on `initrd` can be found at `Documentation/initrd.txt`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`initrd`的更多信息可以在`Documentation/initrd.txt`中找到。
- en: Using `initrd` is not as simple as `initramfs`. In this case, an archive needs
    to be copied in a similar manner to the one used for the kernel image, and the
    bootloader needs to pass its location and size to the kernel to make sure that
    it has started. Therefore, in this case, the bootloader also requires the support
    of `initrd`. The central point of the `initrd` is constituted by the `linuxrc`
    file, which is the first script started and is usually used for the purpose of
    offering access to the final stage of the system boot, that is, the real root
    filesytem. After `linuxrc` finishes the execution, the kernel unmounts it and
    continues with the real root filesystem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`initrd`不像`initramfs`那样简单。在这种情况下，需要以类似于用于内核映像的方式复制一个存档，并且引导加载程序需要将其位置和大小传递给内核，以确保它已经启动。因此，在这种情况下，引导加载程序还需要支持`initrd`。`initrd`的中心点由`linuxrc`文件构成，这是第一个启动的脚本，通常用于提供对系统引导的最后阶段的访问，即真正的根文件系统。在`linuxrc`完成执行后，内核会卸载它并继续执行真正的根文件系统。
- en: Delving into the filesystem
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入文件系统
- en: 'No matter what their provenience is, most of the available root filesystems
    have the same organization of directories, as defined by the **Filesystem Hierarchy
    Standard** (**FHS**), as it is commonly called. This organization is of great
    help to both developers and users because it not only mentions a directory hierarchy,
    but also the purpose and content of the directories The most notable ones are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们的来源是什么，大多数可用的根文件系统都具有相同的目录组织，由**文件系统层次结构**（**FHS**）定义，通常被称为。这种组织对开发人员和用户都非常有帮助，因为它不仅提到了目录层次结构，还提到了目录的目的和内容。最显著的是：
- en: '`/bin`: This refers to the location of most programs'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：这是大多数程序的位置'
- en: '`/sbin`: This refers to the location of system programs'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：这是系统程序的位置'
- en: '`/boot`: This refers to the location for boot options, such as the `kernel
    image`, `kernel config`, `initrd`, `system maps`, and other information'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：这是引导选项的位置，例如`内核映像`、`内核配置`、`initrd`、`系统映射`和其他信息'
- en: '`/home`: This refers to the user home directory'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`：这是用户主目录'
- en: '`/root`: This refers to the location of the root user''s home location'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/root`：这是根用户的主目录位置'
- en: '`/usr`: This refers to user-specific programs and libraries, and mimics parts
    of the content of the root filesystem'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：这是用户特定的程序和库的位置，并模仿了根文件系统的部分内容'
- en: '`/lib`: This refers to the location of libraries'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：这是库的位置'
- en: '`/etc`: This refers to the system-wide configurations'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：这是系统范围的配置'
- en: '`/dev`: This refers to the location of device files'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：这是设备文件的位置'
- en: '`/media`: This refers to the location of mount points of removable devices'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media`：这是可移动设备的挂载点的位置'
- en: '`/mnt`: This refers to the mount location point of static media'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt`：这是静态媒体的挂载位置点'
- en: '`/proc`: This refers to the mounting point of the `proc` virtual filesystem'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：这是`proc`虚拟文件系统的挂载点'
- en: '`/sys`: This refers to the mounting point of the `sysfs` virtual filesystem'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`：这是`sysfs`虚拟文件系统的挂载点'
- en: '`/tmp`: This refers to the location temporary files'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：这是临时文件的位置'
- en: '`/var`: This refers to data files, such as logging data, administrative information,
    or the location of transient data'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：这是数据文件的位置，例如日志数据、管理信息或瞬态数据的位置'
- en: The FHS changes over time, but not very much. Most of the previously mentioned
    directories remain the same for various reasons - the simplest one being the fact
    that they need to ensure backward compatibility.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FHS随时间而变化，但变化不大。大多数先前提到的目录出于各种原因保持不变-最简单的原因是它们需要确保向后兼容性。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest available information of the FHS is available at [http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.pdf](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.pdf).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FHS的最新信息可在[http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.pdf](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.pdf)上找到。
- en: 'The root filesystems are started by the kernel, and it is the last step done
    by the kernel before it ends the boot phase. Here is the exact code to do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统由内核启动，这是内核在结束引导阶段之前执行的最后一步。以下是执行此操作的确切代码：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, it can easily be identified that there are a number of locations
    used for searching the `init` process that needs to be started before exiting
    from the Linux kernel boot execution. The `run_init_process()` function is a wrapper
    around the `execve()` function that will not have a return value if no errors
    are encountered in the call procedure. The called program overwrites the memory
    space of the executing process, replacing the calling thread and inheriting its
    `PID`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，可以轻松地识别出用于搜索需要在退出Linux内核引导执行之前启动的`init`进程的多个位置。`run_init_process()`函数是`execve()`函数的包装器，如果在调用过程中未遇到错误，则不会返回值。被调用的程序覆盖了执行进程的内存空间，替换了调用线程并继承了它的`PID`。
- en: This initialization phase is so old that a similar structure inside the Linux
    1.0 version is also available. This represents the user space processing start.
    If the kernel is not able to execute one of the four preceding functions in the
    predefined locations, then the kernel will halt and a panic message will be prompted
    onto the console to issue an alert that no init processes can be started. So,
    the user space processing will not start until the kernel space processing is
    finished.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化阶段是如此古老，以至于Linux 1.0版本中也有类似的结构。这代表了用户空间处理的开始。如果内核无法在预定义的位置执行前述四个函数中的一个，则内核将停止，并且会在控制台上提示恐慌消息，以发出无法启动任何init进程的警报。因此，在内核空间处理完成之前，用户空间处理将不会开始。
- en: For the majority of the available Linux systems, `/sbin/init` is the location
    where the kernel spawns the init process; the same affirmation is also true for
    the Yocto Project's generated root filesystems. It is the first application run
    in the user space context, but it isn't the only necessary feature of the root
    filesystem. There are a couple of dependencies that need to be resolved before
    running any process inside the root filesystem. There are dependencies used to
    solve dynamically linked dependencies references that were not solved earlier,
    and also dependencies that require external configurations. For the first category
    of dependencies, the `ldd` tool can be used to spot the dynamically linked dependencies,
    but for the second category, there is no universal solution. For example, for
    the `init` process, the configuration file is `inittab,` which is available inside
    the `/etc` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数可用的Linux系统，`/sbin/init`是内核生成init进程的位置；对于Yocto项目生成的根文件系统，同样也是如此。它是用户空间中运行的第一个应用程序，但它并不是根文件系统的唯一必要特性。在运行根文件系统中的任何进程之前，需要解决一些依赖关系。有一些用于解决动态链接依赖引用的依赖关系，这些引用之前未解决，还有一些需要外部配置的依赖关系。对于第一类依赖关系，可以使用`ldd`工具来查找动态链接依赖关系，但对于第二类依赖关系，没有通用解决方案。例如，对于`init`进程，配置文件是`inittab`，它位于`/etc`目录中。
- en: For developers not interested in running another `init` process, this option
    is available and can be accessed using the kernel command line with the available
    `init=` parameter, where the path to the executed binary should be made available.
    This information is also available in the preceding code. The customization of
    the `init` process is not a method commonly used by developers, but this is because
    the `init` process is a very flexible one, which makes a number of start up scripts
    available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不希望运行另一个`init`进程的开发人员，可以使用内核命令行中的`init=`参数来访问此选项，其中应提供要执行的二进制文件的路径。这些信息也在前面的代码中提供。定制`init`进程并不是开发人员常用的方法，但这是因为`init`进程非常灵活，可以提供多个启动脚本。
- en: 'Every process started after `init` uses the parent-child relationship, where
    `init` acts as the parent for all the processes run in the user space context,
    and is also the provider of environment parameters. Initially, the init process
    spawns processes according to the information available inside the `/etc/inittab`
    configuration file, which defines the runlevel notion. A runlevel represents the
    state of the system and defines the programs and services that have been started.
    There are eight runlevels available, numbered from `0` to `6`, and a special one
    that is noted as `S`. Their purpose is described here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`之后启动的每个进程都使用父子关系，其中`init`充当用户空间中所有进程的父进程，并且还提供环境参数。最初，init进程根据`/etc/inittab`配置文件中的信息生成进程，该文件定义了运行级别的概念。运行级别表示系统的状态，并定义了已启动的程序和服务。有八个可用的运行级别，编号从`0`到`6`，还有一个特殊的`S`。它们的目的在这里描述：
- en: '| Runlevel value | Runlevel purpose |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 运行级别值 | 运行级别目的 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | It refers to the shutdown and power down command for the whole system
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 它指的是整个系统的关闭和关机命令 |'
- en: '| `1` | It is a single-user administrative mode with a standard login access
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 它是带有标准登录访问的单用户管理模式 |'
- en: '| `2` | It is multiuser without a TCP/IP connection |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 它是没有TCP/IP连接的多用户模式 |'
- en: '| `3` | It refers to a general purpose multiuser |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 它指的是通用多用户 |'
- en: '| `4` | It is defined by the system''s owner |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 它由系统所有者定义 |'
- en: '| `5` | It refers to graphical interface and TCP/IP connection multiuser systems
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 它指的是图形界面和TCP/IP连接的多用户系统 |'
- en: '| `6` | It refers to a system reboot |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `6` | 它指的是系统重启 |'
- en: '| `s` | It is a single user mode that offers access to a minimal root shell
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 它是提供对最小根shell的单用户模式访问 |'
- en: Each runlevel starts and kills a number of services. The services that are started
    begin with `S`, and the ones that a killed begin with `K`. Each service is, in
    fact, a shell script that defines the behaviour of the provides that it defines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行级别启动和终止一些服务。启动的服务以`S`开头，终止的服务以`K`开头。每个服务实际上是一个shell脚本，定义了它所提供的行为。
- en: 'The `/etc/inittab` configuration script defines the runlevel and the instructions
    applied to all of them. For the Yocto Project, the `/etc/inittab` looks similar
    to this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/inittab`配置脚本定义了运行级别和应用于所有运行级别的指令。对于Yocto项目，`/etc/inittab`看起来类似于这样：'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the preceding `inittab` file is parsed by the `init`, the first script
    that is executed is the `si::sysinit:/etc/init.d/rcS` line, identified through
    the `sysinit` tag. Then, `runlevel 5` is entered and the processing of instructions
    continues until the last level, until a shell is finally spawned using `/sbin/getty
    symlink`. More information on either `init` or `inittab` can be found by running
    `man init` or `man inittab` in the console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当`init`解析前面的`inittab`文件时，首先执行的是通过`sysinit`标签标识的`si::sysinit:/etc/init.d/rcS`行。然后，进入`runlevel
    5`，并继续处理指令，直到最后一个级别，最终使用`/sbin/getty symlink`生成一个shell。可以在控制台中运行`man init`或`man
    inittab`来获取有关`init`或`inittab`的更多信息。
- en: The last stage of any Linux system is represented by the power off or shutdown
    command. It is very important, because if it's not done appropriately, it can
    affect the system by corrupting data. There are, of course, multiple options to
    implement the shutdown scheme, but the handiest ones remain in the form of utilities,
    such as `shutdown`, `halt`, or `reboot`. There is also the possibility to use
    `init 0` to halt the system, but, in fact, what all of them have in common is
    the use of the `SIGTERM` and `SIGKILL` signals. `SIGTERM` is used initially to
    notify you about the decision to shut down the system, to offer the chance to
    the system to perform necessary actions. After this is done, the `SIGKILL` signal
    is sent to terminate all the processes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Linux系统的最后阶段都由关机或关闭命令表示。这非常重要，因为如果不适当地执行，可能会通过损坏数据来影响系统。当然，有多种选项可以实现关闭方案，但最方便的形式仍然是使用诸如`shutdown`、`halt`或`reboot`之类的实用程序。还可以使用`init
    0`来关闭系统，但实际上，它们都共同使用`SIGTERM`和`SIGKILL`信号。`SIGTERM`最初用于通知您关于关闭系统的决定，以便系统执行必要的操作。完成后，发送`SIGKILL`信号以终止所有进程。
- en: Device drivers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备驱动程序
- en: One of the most important challenges for the Linux system is the access allowed
    to applications to various hardware devices. Notions, such as virtual memory,
    kernel space, and user space, do not help in simplifying things, but add another
    layer of complexity to this information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统面临的最重要挑战之一是允许应用程序访问各种硬件设备。诸如虚拟内存、内核空间和用户空间之类的概念并没有简化事情，而是为这些信息增加了另一层复杂性。
- en: A device driver has the sole purpose of isolating hardware devices and kernel
    data structures from user space applications. A user does not need to know that
    to write data to a hard disk, he or she will be required to use sectors of various
    sizes. The user only opens a file to write inside it and close when finished.
    The device driver is the one that does all the underlying work, such as isolating
    complexities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序的唯一目的是将硬件设备和内核数据结构与用户空间应用程序隔离开来。用户不需要知道，要向硬盘写入数据，他或她将需要使用不同大小的扇区。用户只需打开一个文件进行写入，完成后关闭即可。设备驱动程序是执行所有底层工作的程序，比如隔离复杂性。
- en: 'Inside the user space, all the device drivers have associated device nodes,
    which are, in fact, special files that represent a device. All the device files
    are located in the `/dev` directory and the interaction with them is done through
    the `mknod` utility. The device nodes are available under two abstractions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间中，所有设备驱动程序都有关联的设备节点，实际上是表示设备的特殊文件。所有设备文件都位于`/dev`目录中，并通过`mknod`实用程序与它们进行交互。设备节点在两个抽象层上可用：
- en: '**Block devices**: These are composed of fixed size blocks that are usually
    used when interacting with hard disks, SD cards, USB sticks, and so on'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**：这些由固定大小的块组成，通常在与硬盘、SD卡、USB存储设备等交互时使用'
- en: '**Character devices**: These are streams of characters that do not have a size,
    beginning, or end; they are mostly not in the form of block devices, such as terminals,
    serial ports, sound card and so on'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备**：这些是不具有大小、起始或结束的字符流；它们大多不是块设备的形式，比如终端、串行端口、声卡等'
- en: 'Each device has a structure that offers information about it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有一个提供有关其信息的结构：
- en: '`Type` identifies whether the device node is a character or block'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`标识设备节点是字符设备还是块设备'
- en: '`Major` identifies the category for the device'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Major`标识设备的类别'
- en: '`Minor` holds the identifier of the device node'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minor`保存设备节点的标识符'
- en: The `mknod` utility that creates the device node uses a triplet of information,
    such as `mknod /dev/testdev c 234 0`. After the command is executed, a `new /dev/testdev`
    file appears. It should bind itself to a device driver that is already installed
    and has already defined its properties. If an `open` command is issued, the kernel
    looks for the device driver that registered with the same major number as the
    device node. The minor number is used for handling multiple devices, or a family
    of devices, with the same device driver. It is passed to the device driver so
    that it can use it. There is no standard way to use the minor, but usually, it
    defines a specific device from a family of the devices that share the same major
    number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建设备节点的`mknod`实用程序使用三元组信息，例如`mknod /dev/testdev c 234 0`。执行命令后，将出现一个`new /dev/testdev`文件。它应该绑定到已安装并已定义其属性的设备驱动程序。如果发出`open`命令，内核将寻找与设备节点相同主要编号注册的设备驱动程序。次要编号用于处理多个设备或使用相同设备驱动程序的设备系列。它被传递给设备驱动程序以便使用。没有标准的使用次要编号的方法，但通常它定义了来自共享相同主要编号的设备系列中的特定设备。
- en: 'Using the `mknod` utility requires manual interaction and root privileges,
    and lets the developer do all the heavy lifting needed to identify the properties
    of the device node and its device driver correspondent. The latest Linux system
    offers the possibility to automate this process and to also complete these actions
    every time devices are detected or disappear. This is done as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mknod`实用程序需要手动交互和root权限，并允许开发人员完成识别设备节点及其设备驱动程序对应的属性所需的所有繁重工作。最新的Linux系统提供了自动化此过程的可能性，并且还可以在每次检测到设备或设备消失时完成这些操作。具体操作如下：
- en: '`devfs`: This refers to a device manager that is devised as a filesystem and
    is also accessible on a kernel space and user space.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devfs`：这是一个作为文件系统设计的设备管理器，也可在内核空间和用户空间中访问。'
- en: '`devtmpfs`: This refers to a virtual filesystem that has been available since
    the 2.6.32 kernel version release, and is an improvement to `devfs` that is used
    for boot time optimizations. It only creates device nodes for hardware available
    on a local system.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtmpfs`：这是一个虚拟文件系统，自2.6.32内核版本发布以来就可用，是对用于启动时间优化的`devfs`的改进。它只为本地系统上可用的硬件创建设备节点。'
- en: '`udev`: This refers to a daemon used on servers and desktop Linux systems.
    More information on this can be referred to by accesing [https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html](https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html).
    The Yocto Project also uses it as the default device manager.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udev`：这是指在服务器和桌面Linux系统上使用的守护程序。有关此的更多信息可以通过访问[https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html](https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html)来参考。Yocto项目也将其用作默认设备管理器。'
- en: '`mdev`: This offers a simpler solution then `udev`; it is, in fact, a derivation
    of udev.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdev`：这提供了比`udev`更简单的解决方案；实际上，它是`udev`的一个派生物。'
- en: Since system objects are also represented as files, it simplifies the method
    of interaction with them for applications. This would not been possible without
    the use of device nodes, that are actually files in which normal file interaction
    functions can be applied, such as `open()`, `read()`, `write()`, and `close()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统对象也被表示为文件，这简化了应用程序与它们交互的方法。如果没有使用设备节点，这是不可能的，设备节点实际上是文件，可以对其应用正常的文件交互功能，如`open()`，`read()`，`write()`和`close()`。
- en: Filesystem options
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统选项
- en: The root filesystem can be deployed under a very broad form of the filesystem
    type, and each one does a particular task better than the rest. If some filesystems
    are optimized for performance, others are better at saving space or even recovering
    data. Some of the most commonly used and interesting ones will be presented here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统可以以非常广泛的文件系统类型部署，并且每种文件系统都比其他文件系统更适合执行特定任务。如果某些文件系统针对性能进行了优化，那么其他文件系统则更擅长节省空间甚至恢复数据。这里将介绍一些最常用和有趣的文件系统。
- en: The logical division for a physical device, such as a hard disk or SD card,
    is called a **partition**. A physical device can have one or more partitions that
    cover its available storage space. It can be viewed as a logical disk that has
    a filesystem available for the user's purposes. The management of partitions in
    Linux is done using the `fdisk` utility. It can be used to `create`, `list`, `destroy`,
    and other general interactions, with more than 100 partition types. To be more
    precise, 128 partition types are available on my Ubuntu 14.04 development machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 物理设备的逻辑分区，如硬盘或SD卡，称为**分区**。物理设备可以有一个或多个分区，覆盖其可用存储空间。它可以被视为具有文件系统供用户使用的逻辑磁盘。在Linux中，使用`fdisk`实用程序来管理分区。它可以用于`创建`，`列出`，`销毁`和其他一般交互，有100多种分区类型。更准确地说，在我的Ubuntu
    14.04开发机器上有128种分区类型可用。
- en: One of the most used and well known filesystem partition formats is `ext2`.
    Also called **second extended filesystem**, it was introduced in 1993 by Rémy
    Card, a French software developer. It was used as the default filesystem for a
    large number of Linux distributions, such as Debian and Red Hat Linux, until it
    was replaced by its younger brothers, `ext3` and `ext4`. It continues to remain
    the choice of many embedded Linux distributions and flash storage devices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用和知名的文件系统分区格式之一是`ext2`。也称为**第二扩展文件系统**，它是由法国软件开发人员Rémy Card于1993年引入的。它曾被用作许多Linux发行版的默认文件系统，如Debian和Red
    Hat Linux，直到被其年轻的兄弟`ext3`和`ext4`取代。它继续是许多嵌入式Linux发行版和闪存存储设备的选择。
- en: The `ext2` filesystem splits data into blocks, and the blocks are arranged into
    block groups. Each block group maintains a copy of a superblock and the descriptor
    table for that block group. Superblocks are to store configuration information,
    and hold the information required by the booting process, although there are available
    multiple copies of it; usually, the first copy that is situated in the first block
    of the file system is the one used. All the data for a file is usually kept in
    a single block so that searches can be made faster. Each block group, besides
    the data it contains, has information about the superblock, descriptor table for
    the block group, inode bitmap and table information, and the block bitmap. The
    superblock is the one that holds the information important for the booting process.
    Its first block is used for the booting process. The last notion presented is
    in the form of `inodes`, or the index nodes, which represent files and directories
    by their permission, size, location on disk, and ownership.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ext2`文件系统将数据分割为块，并将块排列成块组。每个块组维护超级块的副本和该块组的描述符表。超级块用于存储配置信息，并保存引导过程所需的信息，尽管有多个副本；通常，位于文件系统第一个块中的第一个副本是所使用的。通常将文件的所有数据保存在单个块中，以便可以更快地进行搜索。除了包含的数据外，每个块组还包含有关超级块、块组的描述符表、索引节点位图和表信息以及块位图的信息。超级块是保存引导过程所需信息的地方。它的第一个块用于引导过程。最后一个概念是`inode`，或索引节点，它通过其权限、大小、在磁盘上的位置和所有权来表示文件和目录。'
- en: There are multiple applications used for interaction with the `ext2` filesystem
    format. One of them is `mke2fs`, which is used to create an `ext2` filesystem
    on a `mke2fs /deb/sdb1 –L` partition (`ext2` label partition). The is the `e2fsck`
    command, which is used to verify the integrity of the filesystem. If no errors
    are found, these tools give you information about the partition filesystem configuration,
    `e2fsck /dev/sdb1`. This utility is also able to fix some of the errors that appear
    after improper utilization of the device, but cannot be used in all scenarios.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个应用程序用于与`ext2`文件系统格式进行交互。其中之一是`mke2fs`，用于在`mke2fs /deb/sdb1 –L`分区（`ext2`标签分区）上创建`ext2`文件系统。还有`e2fsck`命令，用于验证文件系统的完整性。如果未发现错误，这些工具会为您提供有关分区文件系统配置的信息，`e2fsck
    /dev/sdb1`。此实用程序还能够修复设备不正确使用后出现的一些错误，但不能在所有情况下使用。
- en: Ext3 is another powerful and well known filesystem. It replaced `ext2` and became
    one of the most used filesystems on Linux distributions. It is in fact similar
    to `ext2`; the difference being that it has the possibility to journalize the
    information available to it. The `ext2` file format can be changed in an `ext3`
    file format using the `tune2fs –j /dev/sdb1` command. It is basically seen as
    an extension for the `ext2` filesystem format, one that adds the journaling feature.
    This happens because it was engineered to be both forward and backward compatible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ext3是另一个强大而广为人知的文件系统。它取代了`ext2`，成为Linux发行版中最常用的文件系统之一。实际上，它与`ext2`类似；不同之处在于它具有日志记录信息的可能性。可以使用`tune2fs
    –j /dev/sdb1`命令将`ext2`文件格式更改为`ext3`文件格式。基本上被视为`ext2`文件系统格式的扩展，它添加了日志记录功能。这是因为它被设计为向前和向后兼容。
- en: Journaling is a method that is used to log all the changes made on a filesystem
    form by making the recovery functionality possible. There are also other features
    that `ext3` adds besides the ones that are already mentioned; here, I am referring
    to the possibility of not checking for consistencies in the filesystem, mostly
    because journalizing the log can be reversed. Another important feature is that
    it can be mounted without checking whether the shutdown was performed correctly.
    This takes place because the system does not need to conduct a consistency check
    at power down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一种方法，用于记录文件系统上所做的所有更改，从而实现恢复功能。除了已经提到的功能外，`ext3`还添加了其他功能；在这里，我指的是文件系统中不需要检查一致性的可能性，主要是因为日志记录可以被撤消。另一个重要功能是，它可以在不检查关机是否正确执行的情况下挂载。这是因为系统在关机时不需要进行一致性检查。
- en: 'Ext4 is the successor of `ext3`, and was built with the idea of improving the
    performance and the storage limit in `ext3`. It is also backward compatible with
    the `ext3` and `ext2` filesystems and also adds a number of features:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Ext4是`ext3`的后继者，旨在改善`ext3`中的性能和存储限制。它还向后兼容`ext3`和`ext2`文件系统，并添加了许多功能：
- en: 'Persistent preallocation: This defines the `fallocate()` system call that can
    be used to preallocate space, which is most likely in a contiguous form; it is
    very useful for databases and streaming of media'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性预分配：这定义了`fallocate()`系统调用，可用于预先分配空间，这在大多数情况下是连续的形式；对于数据库和媒体流非常有用
- en: 'Delayed allocation: This is also called **allocate-on-flush**; it is used to
    delay the allocation blocks from the moment data from the disk is flushed, to
    reduce fragmentation and increase performance'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟分配：这也称为**在刷新时分配**；它用于延迟分配块，从磁盘刷新数据的时刻开始，以减少碎片化并提高性能
- en: 'Multi block allocation: This is a side effect of delayed allocation because
    it allows for data buffering and, at the same time, the allocation of multiple
    blocks.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多块分配：这是延迟分配的副作用，因为它允许数据缓冲，同时分配多个块。
- en: 'Increase subdirectory limit: This the `ext3` has a limit of 32000 subdirectories,
    the `ext4` does not have this limitation, that is, the number of subdirectories
    are unlimited'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加子目录限制：`ext3`的子目录限制为32000个，而`ext4`没有此限制，即子目录的数量是无限的
- en: 'Checksum for journal: This is used to improve reliability'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志的校验和：这用于提高可靠性
- en: '**Journalling Flash Filesystem version 2** (**JFFS2**) is a filesystem designed
    for the NAND and NOR flash memory. It was included in the Linux mainline kernel
    in 2001, the same year as the `ext3` filesystem, although in different months.
    It was released in November for the Linux version 2.4.15, and the JFFS2 filesystem
    was released in September with the 2.4.10 kernel release. Since it''s especially
    used to support flash devices, it takes into consideration certain things, such
    as the need to work with small files, and the fact that these devices have a wear
    level associated with them, which solves and reduces them by their design. Although
    JFFS2 is the standard for flash memory, there are also alternatives that try to
    replace it, such as LogFS, Yet Another Flash File System (YAFFS), and Unsorted
    Block Image File System (UBIFS).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志闪存文件系统版本2**（**JFFS2**）是为NAND和NOR闪存设计的文件系统。它于2001年被包含在Linux主线内核中，与`ext3`文件系统在同一年发布，尽管在不同的月份。它在Linux
    2.4.15版本中于11月发布，而JFFS2文件系统在2.4.10内核版本中于9月发布。由于它特别用于支持闪存设备，因此考虑了某些因素，例如需要处理小文件以及这些设备具有与之相关的磨损水平，这通过其设计解决和减少。尽管JFFS2是闪存的标准，但也有一些替代方案，例如LogFS、另一个闪存文件系统（YAFFS）和未排序块映像文件系统（UBIFS）。'
- en: Besides the previously mentioned filesystems, there are also some pseudo filesystems
    available, including `proc`, `sysfs`, and `tmpfs`. In the next section, the first
    two of them will be described, leaving the last one for you to discover by yourself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的文件系统外，还有一些伪文件系统可用，包括`proc`、`sysfs`和`tmpfs`。在下一节中，将描述前两者，留下最后一个让您自己发现。
- en: The `proc` filesystem is a virtual filesystem available from the first version
    of Linux. It was defined to allow a kernel to offer information to the user about
    the processes that are run, but over time, it has evolved and is now able to not
    only offer statistics about processes that are run, but also offer the possibility
    to adjust various parameters regarding the management of memory, processes, interrupts,
    and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`文件系统是Linux的第一个版本中提供的虚拟文件系统。它被定义为允许内核向用户提供有关正在运行的进程的信息，但随着时间的推移，它已经发展，现在不仅可以提供有关正在运行的进程的统计信息，还可以提供有关内存管理、进程、中断等各种参数的调整。'
- en: With the passing of time, the `proc` virtual filesystem became a necessity for
    Linux system users since it gathered a very large number of user space functionalities.
    Commands, such as `top`, `ps`, and `mount` would not work without it. For example,
    the `mount` example given without a parameter will present `proc` mounted on the
    `/proc` in the form of `proc` on `/proc type proc (rw,noexec,nosuid,nodev)`. This
    takes place since it is necessary to have `proc` mounted on the `root` filesystem
    on par with directories, such as `/etc`, `/home`, and others that are used as
    the destination of the `/proc` filesystem. To mount the `proc` filesystem, the
    mount `–t proc nodev/proc` mount command that is similar to the other filesystems
    available is used. More information on this can be found inside the kernel sources
    documentation at `Documentation/filesystems/proc.txt`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，`proc`虚拟文件系统对于Linux系统用户来说变得必不可少，因为它汇集了大量的用户空间功能。命令，如`top`、`ps`和`mount`，没有它将无法工作。例如，给出没有参数的`mount`示例将以`proc`挂载在`/proc`上的形式呈现为`proc`
    on `/proc type proc (rw,noexec,nosuid,nodev)`。这是因为需要将`proc`挂载在`root`文件系统上，与目录`/etc`、`/home`等一起使用作为`/proc`文件系统的目的地。要挂载`proc`文件系统，使用类似于其他可用文件系统的`mount
    –t proc nodev/proc`挂载命令。有关此更多信息可以在内核源文件的`Documentation/filesystems/proc.txt`中找到。
- en: 'The `proc` filesystem has the following structure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`文件系统具有以下结构：'
- en: For each running process, there is an available directory inside `/proc/<pid>`.It
    contains information about opened files, used memory, CPU usage, and other process-specific
    information.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个运行的进程，`/proc/<pid>`内有一个可用的目录。它包含有关打开的文件、使用的内存、CPU使用情况和其他特定于进程的信息。
- en: Information on general devices is available inside `/proc/devices`, `/proc/interrupts`,
    `/proc/ioports`, and `/proc/iomem`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般设备的信息位于`/proc/devices`、`/proc/interrupts`、`/proc/ioports`和`/proc/iomem`内。
- en: The kernel command line is available inside `/proc/cmdline`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核命令行位于`/proc/cmdline`内。
- en: Files used to change kernel parameters are available inside `/proc/sys`. More
    information is also available inside `Documentation/sysctl`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于更改内核参数的文件位于`/proc/sys`内。有关更多信息，也可以在`Documentation/sysctl`中找到。
- en: The `sysfs` filesystem is used for the representation of physical devices. It
    is available since the introduction of the 2.6 Linux kernel versions, and offers
    the possibility of representing physical devices as kernel objects and associate
    device drivers with corresponding devices. It is very useful for tools, such as
    `udev` and other device managers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysfs`文件系统用于表示物理设备。自2.6版Linux内核引入以来，它提供了将物理设备表示为内核对象并将设备驱动程序与相应设备关联的可能性。对于工具，如`udev`和其他设备管理器，它非常有用。'
- en: The `sysfs` directory structure has a subdirectory for every major system device
    class, and it also has a system buses subdirectory. There is also `systool` that
    can be used to browse the `sysfs` directory structure. Similar to the proc filesystem,
    `systool` also can also be visible if the `sysfs on /sys type sysfs (rw,noexec,nosuid,nodev)`
    `mount` command is offered on the console. It can be mounted using the `mount
    -t sysfs nodev /sys` command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysfs`目录结构为每个主要系统设备类都有一个子目录，还有一个系统总线子目录。还有`systool`可以用来浏览`sysfs`目录结构。与proc文件系统类似，如果在控制台上提供了`sysfs
    on /sys type sysfs (rw,noexec,nosuid,nodev)` `mount`命令，`systool`也可以可见。可以使用`mount
    -t sysfs nodev /sys`命令进行挂载。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on available filesystems can be found at [http://en.wikipedia.org/wiki/List_of_file_systems](http://en.wikipedia.org/wiki/List_of_file_systems).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用文件系统的更多信息，请访问[http://en.wikipedia.org/wiki/List_of_file_systems](http://en.wikipedia.org/wiki/List_of_file_systems)。
- en: Understanding BusyBox
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解BusyBox
- en: BusyBox was developed by Bruce Perens in 1999 with the purpose of integrating
    available Linux tools in a single executable. It has been used with great success
    as a replacement for a great number of Linux command line utilities. Due to this,
    and the fact that it is able to fit inside small embedded Linux distributions,
    it has gained a lot of popularity in the embedded environment. It provides utilities
    from file interactions, such as `cp`, `mkdir`, `touch`, `ls`, and `cat`, as well
    as general utilities, such as `dmesg`, `kill`, `fdisk`, `mount`, `umount`, and
    many others.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox由Bruce Perens于1999年开发，旨在将可用的Linux工具集成到一个单一的可执行文件中。它已被广泛成功地用作许多Linux命令行实用程序的替代品。由于这个原因，以及它能够适应小型嵌入式Linux发行版，它在嵌入式环境中获得了很多的流行。它提供了文件交互的实用工具，如`cp`、`mkdir`、`touch`、`ls`和`cat`，以及一般实用工具，如`dmesg`、`kill`、`fdisk`、`mount`、`umount`等。
- en: Not only is it very easy to configure and compile, but it is also very easy
    to use. The fact that it is very modular and offers a high degree of configuration
    makes it the perfect choice to use. It may not include all the commands available
    in a full-blown Linux distribution available on your host PC, but the ones that
    it does are more than enough. Also, these commands are just simpler versions of
    the full-blown ones used at implementation level, and are all integrated in one
    single executable available in `/bin/busybox` as symbolic links of this executable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅非常容易配置和编译，而且非常易于使用。它非常模块化，并提供高度的配置，使其成为理想的选择。它可能不包括主机PC上可用的完整Linux发行版中的所有命令，但它包含的命令已经足够了。此外，这些命令只是完整命令的简化版本，用于实现级别，并且都集成在一个单一可执行文件中，作为`/bin/busybox`中的符号链接。
- en: 'A developer interaction with the BusyBox source code package is very simple:
    just configure, compile, and install it, and there you have it. Here are some
    detailed steps to explain the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员与BusyBox源代码包的交互非常简单：只需配置、编译和安装，就可以了。以下是一些详细的步骤来解释以下内容：
- en: Run the configuration tool and chose the features you want to make available
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行配置工具并选择要提供的功能
- en: Execute make `dep` to construct the dependencies tree
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`make dep`来构建依赖树
- en: Build the package using the `make` command
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`make`命令构建软件包
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Install the executable and symbolic links on the target. People who are interested
    in interacting with the tool on their workstations should note that if the tool
    is installed for the host system, then the installation should be done in a location
    that does not overwrite any of the utilities and start up scripts available to
    the host.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标上安装可执行文件和符号链接。对于希望在其工作站上与该工具进行交互的人来说，如果该工具已安装到主机系统，则安装应该在不覆盖主机可用的任何实用程序和启动脚本的位置进行。
- en: The configuration of the BusyBox package also has a `menuconfig` option available,
    similar to the one available for the kernel and U-Boot, that is, `make` `menuconfig`.
    It is used to show a text menu that can be used for faster configuration and configuration
    searches. For this menu to be available, first the `ncurses` package needs to
    be available on the system that calls the make `menuconfig` command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox包的配置还有一个`menuconfig`选项，类似于内核和U-Boot可用的`make menuconfig`。它用于显示一个文本菜单，可用于更快的配置和配置搜索。要使此菜单可用，首先需要在调用`make
    menuconfig`命令的系统上安装`ncurses`包。
- en: 'At the end of the process, the BusyBox executable is available. If it''s called
    without arguments, it will present an output very similar to this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程结束时，BusyBox可执行文件可用。如果没有参数调用它，它将呈现一个与此类似的输出：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It presents the list of the utilities enabled in the configuration stage. To
    invoke one of the preceding utilities, there are two options. The first option
    requires the use of the BusyBox binary and the number of utilities called, which
    are represented as `./busybox ls`, while the second option involves the use of
    the symbolic link already available in directories, such as `/bin, /sbin, /usr/bin`,
    and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它呈现了在配置阶段启用的实用程序列表。调用上述实用程序之一有两种选项。第一种选项需要使用BusyBox二进制文件和调用的实用程序数量，表示为`./busybox
    ls`，而第二种选项涉及使用已经在目录中可用的符号链接，如`/bin、/sbin、/usr/bin`等。
- en: Besides the utilities that are already available, BusyBox also offers implementation
    alternatives for the `init` program. In this case, the `init` does not know about
    a runlevel, and all its configurations available inside the `/etc/inittab` file.
    Another factor that differentiates it from the standard `/etc/inittab` file is
    the fact that this one also has its special syntax. For more information, `examples/inittab`
    available inside BusyBox can be consulted. There are also other tools and utilities
    implemented inside the BusyBox package, such as a lightweight version for `vi`,
    but I will let you discover them for yourself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经可用的实用程序之外，BusyBox还为`init`程序提供了实现替代方案。在这种情况下，`init`不知道运行级别，所有配置都在`/etc/inittab`文件中。另一个与标准`/etc/inittab`文件不同的因素是，它还具有自己的特殊语法。有关更多信息，可以查看BusyBox中的`examples/inittab`。BusyBox包中还实现了其他工具和实用程序，例如`vi`的轻量级版本，但我会让你自己去发现它们。
- en: Minimal root filesystem
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小`root`文件系统
- en: Now that all the information relating to the `root` filesystem has been presented
    to you, it would be good exercise to describe the must-have components of the
    minimal `root` filesystem. This would not only help you to understand the `rootfs`
    structure and its dependencies better, but also help with requirements needed
    for boot time and the size optimization of the `root` filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有关于`root`文件系统的信息都已经呈现给你，描述最小`root`文件系统的必备组件将是一个很好的练习。这不仅有助于您更好地理解`rootfs`结构及其依赖关系，还有助于满足引导时间和`root`文件系统大小优化的要求。
- en: 'The starting point to describe the components is `/sbin/init`; here, by using
    the `ldd` command, the runtime dependencies can be found. For the Yocto Project,
    the `ldd /sbin/init` command returns:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 描述组件的起点是`/sbin/init`；在这里，可以使用`ldd`命令找到运行时依赖关系。对于Yocto项目，`ldd /sbin/init`命令返回：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From this information, the `/lib` directory structure is defined. Its minimal
    form is:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，定义了`/lib`目录结构。它的最小形式是：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following symbolic links to ensure backward compatibility and version immunity
    for the libraries. The `linux-gate.so.1` file in the preceding code is a **virtual
    dynamically linked shared object** (**vDSO**), exposed by the kernel at a well
    established location. The address where it can be found varies from one machine
    architecture to another.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是确保库的向后兼容性和版本免疫性的符号链接。在上述代码中，`linux-gate.so.1`文件是一个**虚拟动态链接共享对象**（**vDSO**），由内核在一个已建立的位置公开。它的地址因机器架构而异。
- en: 'After this, `init` and its runlevel must be defined. The minimal form for this
    is available inside the BusyBox package, so it will also be available inside the
    `/bin` directory. Alongside it, a symbolic link for shell interaction is necessary,
    so this is how the minimal for the bin directory will look:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，必须定义`init`及其运行级别。这个最小形式在BusyBox包中可用，因此也将在`/bin`目录中可用。除此之外，还需要一个用于shell交互的符号链接，因此`/bin`目录的最小形式如下：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, the runlevel needs to be defined. Only one is used in the minimal `root`
    filesystem, not because it is a strict requirement, but due to the fact that it
    can suppress some BusyBox warnings. This is how the `/etc` directory will look:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要定义运行级别。在最小的`root`文件系统中只使用一个，不是因为这是严格要求，而是因为它可以抑制一些BusyBox警告。这是`/etc`目录的样子：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the end, the console device needs to be available to the user for input
    and output operations, so the last piece of the `root` filesystem is inside the
    `/dev` directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控制台设备需要对用户进行输入和输出操作，因此`root`文件系统的最后一部分位于`/dev`目录中：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Having mentioned all of this, the minimal `root` filesystem seems to have only
    five directories and eight files. Its minimal size is below 2 MB and around 80
    percent of its size is due to the C library package. It is also possible to minimize
    its size by using the Library Optimizer Tool. You can find more information on
    this at [http://libraryopt.sourceforge.net/](http://libraryopt.sourceforge.net/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提到了所有这些，最小的`root`文件系统似乎只有五个目录和八个文件。其最小尺寸低于2 MB，大约80%的尺寸归功于C库软件包。还可以通过使用Library
    Optimizer Tool来最小化其大小。您可以在[http://libraryopt.sourceforge.net/](http://libraryopt.sourceforge.net/)找到更多信息。
- en: The Yocto Project
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目
- en: 'Moving to the Yocto Project, we can take a look at the core-image-minimal to
    identify its content and minimal requirements, as defined inside the Yocto Project.
    The `core-image-minimal.bb` image is available inside the `meta/recipes-core/images`
    directory, and this is how it looks:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Yocto项目，我们可以查看core-image-minimal以确定其内容和最低要求，如Yocto项目中所定义的。`core-image-minimal.bb`镜像位于`meta/recipes-core/images`目录中，看起来是这样的：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see here that this is similar to any other recipe. The image defines
    the `LICENSE` field and inherits a `bbclass` file, which defines its tasks. A
    short summary is used to describe it, and it is very different from normal package
    recipes. It does not have `LIC_FILES_CHKSUM` to check for licenses or a `SRC_URI`
    field, mostly because it does not need them. In return, the file defines the exact
    packages that should be contained in the `root` filesystem, and a number of them
    are grouped inside `packagegroup` for easier handling. Also, the `core-image bbclass`
    file defines a number of other tasks, such as `do_rootfs`, which is only specific
    for image recipes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到这与任何其他配方都是相似的。该镜像定义了`LICENSE`字段，并继承了一个`bbclass`文件，该文件定义了其任务。使用简短的摘要来描述它，它与普通软件包配方非常不同。它没有`LIC_FILES_CHKSUM`来检查许可证或`SRC_URI`字段，主要是因为它不需要它们。作为回报，该文件定义了应包含在`root`文件系统中的确切软件包，并且其中一些软件包被分组在`packagegroup`中以便更容易处理。此外，`core-image
    bbclass`文件定义了许多其他任务，例如`do_rootfs`，这仅适用于镜像配方。
- en: Constructing a `root` filesystem is not an easy task for anyone, but Yocto does
    it with a bit more success. It starts from the base-files recipe that is used
    to lay down the directory structure according to the **Filesystem Hierarchy Standard**
    (**FHS**), and, along with it, a number of other recipes are placed. This information
    is available inside the `./meta/recipes-core/packagegroups/packagegroup-core-boot.bb`
    recipe. As can be seen in the previous example, it also inherits a different kind
    of class, such as `packagegroup.bbclass`, which is a requirement for all the package
    groups available. However, the most important factor is that it clearly defines
    the packages that constitute `packagegroup`. In our case, the core boot package
    group contains packages, such as `base-files`, `base-passwd` (which contains the
    base system master password and group files), `udev`, `busybox`, and `sysvinit`
    (a System V similar to init).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`root`文件系统对任何人来说都不是一件容易的事情，但Yocto做得更成功一些。它从base-files配方开始，用于根据**文件系统层次结构标准**（**FHS**）布置目录结构，并且还有一些其他配方。这些信息可在`./meta/recipes-core/packagegroups/packagegroup-core-boot.bb`配方中找到。正如在先前的例子中所看到的，它还继承了不同类型的类，比如`packagegroup.bbclass`，这是所有可用的包组的要求。然而，最重要的因素是它清楚地定义了构成`packagegroup`的软件包。在我们的情况下，核心引导包组包含软件包，如`base-files`，`base-passwd`（其中包含基本系统主密码和组文件），`udev`，`busybox`和`sysvinit`（类似于System
    V的init）。
- en: As can be seen in the previously shown file, the BusyBox package is a core component
    of the Yocto Project's generated distributions. Although information was available
    about the fact that BusyBox can offer an init alternative, the default Yocto generated
    distributions do not use this. Instead, they choose to move to the System V-like
    init, which is similar to the one available for Debian-based distributions. Nevertheless,
    a number of shell interaction tools are made available through the BusyBox recipe
    available inside the `meta/recipes-core/busybox` location. For users interested
    in enhancing or removing some of features made available by the `busybox` package,
    the same concepts that are available for the Linux kernel configuration are used.
    The `busybox` package uses a `defconfig` file on which a number of configuration
    fragments are applied. These fragments can add or remove features and, in the
    end, the final configuration file is obtained. This identifies the final features
    available inside the `root` filesystem.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在先前显示的文件中所看到的，BusyBox软件包是Yocto项目生成的发行版的核心组件。虽然有关BusyBox可以提供init替代方案的信息是可用的，但默认的Yocto生成的发行版并不使用这个功能。相反，它们选择转向类似于Debian发行版可用的System
    V-like init。然而，通过`meta/recipes-core/busybox`位置内可用的BusyBox配方提供了一些shell交互工具。对于有兴趣增强或删除`busybox`软件包提供的一些功能的用户，可以使用与Linux内核配置相同的概念。`busybox`软件包使用`defconfig`文件，然后应用一些配置片段。这些片段可以添加或删除功能，最终得到最终的配置文件。这标识了`root`文件系统中可用的最终功能。
- en: Inside the Yocto Project, it is possible to minimize the size of the `root`
    filesystem by using the `poky-tiny.conf` distribution policies, which are available
    inside the `meta-yocto/conf/distro` directory. When they're used, these policies
    reduce not only the boot size, but the boot time as well. The simplest example
    for this is available using the `qemux86` machine. Here, changes are visible,
    but they are somewhat different from the ones already mentioned in the *Minimal
    root filesystem* section. The purpose of the minimization work done on `qemux86`
    was done around the core-image-minimal image. Its goals is to reduce the size
    to under 4 MB of the resulting `rootfs` and the boot time to under 2 seconds.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto项目中，可以通过使用`poky-tiny.conf`发行政策来最小化`root`文件系统的大小，这些政策可以在`meta-yocto/conf/distro`目录中找到。当使用这些政策时，不仅可以减小启动大小，还可以减小启动时间。最简单的示例是使用`qemux86`机器。在这里，变化是可见的，但与“最小根文件系统”部分中已经提到的有些不同。在`qemux86`上进行的最小化工作是围绕`core-image-minimal`镜像进行的。其目标是将结果`rootfs`的大小减小到4MB以下，启动时间减小到2秒以下。
- en: 'Now, moving to the selected Atmel SAMA5D3 Xplained machine, another `rootfs`
    is generated and its content is quite big. Not only has it included the `packagegroup-core-boot.bb`
    package group, but other package groups and separate packages are also included.
    One such example is the `atmel-xplained-demo-image.bb` image available inside
    the `meta-atmel` layer in the `recipes-core/images` directory:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转向选定的Atmel SAMA5D3 Xplained机器，另一个`rootfs`被生成，其内容相当庞大。它不仅包括了`packagegroup-core-boot.bb`软件包组，还包括其他软件包组和单独的软件包。其中一个例子是在`meta-atmel`层的`recipes-core/images`目录中可用的`atmel-xplained-demo-image.bb`镜像：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside this image, there is also another more generic image definition that
    is inherited. Here, I am referring to the `atmel-demo-image.inc` file, and when
    opened, you can see that it contains the core of all the `meta-atmel` layer images.
    Of course, if all the available packages are not enough, a developer could decide
    to add their own. There has two possibilities in front of a developer: to create
    a new image, or to add packages to an already available one. The end result is
    built using the `bitbake atmel-xplained-demo-image` command. The output is available
    in various forms, and they are highly dependent on the requirements of the defined
    machine. At the end of the build procedure, the output will be used to boot the
    root filesystem on the actual board.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个镜像中，还有另一个更通用的镜像定义被继承。我指的是`atmel-demo-image.inc`文件，打开后可以看到它包含了所有`meta-atmel`层镜像的核心。当然，如果所有可用的软件包都不够，开发人员可以决定添加自己的软件包。开发人员面临两种可能性：创建一个新的镜像，或者向已有的镜像添加软件包。最终结果是使用`bitbake
    atmel-xplained-demo-image`命令构建的。输出以各种形式可用，并且高度依赖于所定义的机器的要求。在构建过程结束时，输出将用于在实际板上引导根文件系统。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about the Linux `rootfs` in general, and also
    about the communication with the organization of the Linux kernel, Linux `rootfs`,
    its principles, content, and device drivers. Since communication tends to become
    larger over time, information about how a minimal filesystem should look was also
    presented to you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了Linux `rootfs`的一般情况，以及与Linux内核、Linux `rootfs`的组织、原则、内容和设备驱动程序的通信。由于通信随着时间的推移而变得更加庞大，关于最小文件系统应该如何看待的信息也被呈现给您。
- en: Besides this information, in the next chapter, you will be given an overview
    of the available components of the Yocto Project, since most of them are outside
    Poky. You will also be introduced to, and given a brief gist of, each component.
    After this chapter, a bunch of them will be presented to you and elaborated on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些信息，下一章将为您概述Yocto项目的可用组件，因为它们大多数都在Poky之外。您还将被介绍并简要介绍每个组件。在本章之后，将向您介绍并详细阐述其中的一些组件。
