- en: '*Chapter 6*: Virtual Display Devices and Protocols'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：虚拟显示设备和协议'
- en: In this chapter, we will discuss the way in which we access our virtual machines
    by using virtual graphic cards and protocols. There are almost 10 available virtual
    display adapters that we can use in our virtual machines, and there are multiple
    available protocols and applications that we can use to access our virtual machines.
    If we forget about SSH for a second and any kind of console-based access in general,
    there are various protocols available on the market that we can use to access
    the console of our virtual machine, such as VNC, SPICE, and noVNC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论通过虚拟图形卡和协议访问虚拟机的方式。我们可以在虚拟机中使用近10种可用的虚拟显示适配器，并且有多种可用的协议和应用程序可以用来访问我们的虚拟机。除了SSH和任何一般的基于控制台的访问，市场上还有各种协议可供我们使用来访问虚拟机的控制台，如VNC、SPICE和noVNC。
- en: In Microsoft-based environments, we tend to use a **remote desktop protocol**
    (**RDP**). If we are talking about **Virtual Desktop Infrastructure** (**VDI**),
    then there are even more protocols available – **PC over IP** (**PCoIP**), VMware
    Blast, and so on. Some of these technologies offer additional functionality, such
    as greater color depth, encryption, audio and filesystem redirection, printer
    redirection, bandwidth management, and USB and other port redirection. These are
    key technologies for your remote desktop experience in today's cloud-based world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Microsoft的环境中，我们倾向于使用**远程桌面协议**（**RDP**）。如果我们谈论**虚拟桌面基础设施**（**VDI**），那么甚至有更多的协议可用
    - **PC over IP**（**PCoIP**）、VMware Blast等等。其中一些技术提供了额外的功能，如更大的色深、加密、音频和文件系统重定向、打印机重定向、带宽管理以及USB和其他端口重定向。这些是当今云计算世界中远程桌面体验的关键技术。
- en: All of this means that we must put a bit more time and effort into getting to
    know various display devices and protocols, as well as how to configure and use
    them. We don't want to end up in situations in which we can't see the display
    of a virtual machine because we selected the wrong virtual display device, or
    in a situation where we try to open a console to see the content of a virtual
    machine and the console doesn't open.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着我们必须花更多的时间和精力去了解各种显示设备和协议，以及如何配置和使用它们。我们不希望出现这样的情况，即因为选择了错误的虚拟显示设备而无法看到虚拟机的显示，或者尝试打开控制台查看虚拟机内容时控制台无法打开的情况。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using virtual machine display devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟机显示设备
- en: Discussing remote display protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论远程显示协议
- en: Using the VNC display protocol
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VNC显示协议
- en: Using the SPICE display protocol
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SPICE显示协议
- en: Getting display portability with NoVNC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NoVNC实现显示可移植性
- en: Let's get started!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Using virtual machine display devices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟机显示设备
- en: 'To make the graphics work on virtual machines, QEMU needs to provide two components
    to its virtual machines: a virtual graphic adapter and a method or protocol to
    access the graphics from the client. Let''s discuss these two concepts, starting
    with a virtual graphic adapter. The latest version of QEMU has eight different
    types of virtual/emulated graphics adapters. All of these have some similarities
    and differences, all of which can be in terms of features and/or resolutions supported
    or other, more technical details. So, let''s describe them and see which use cases
    we are going to favor a specific virtual graphic card for:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使虚拟机上的图形工作，QEMU需要为其虚拟机提供两个组件：虚拟图形适配器和从客户端访问图形的方法或协议。让我们讨论这两个概念，从虚拟图形适配器开始。最新版本的QEMU有八种不同类型的虚拟/仿真图形适配器。所有这些都有一些相似之处和差异，这些差异可能是在功能和/或支持的分辨率方面，或者其他更多技术细节方面。因此，让我们描述它们，并看看我们将为特定虚拟图形卡偏爱哪些用例：
- en: '**tcx**: A SUN TCX virtual graphics card that can be used with old SUN OSes.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcx**：一种SUN TCX虚拟图形卡，可用于旧的SUN操作系统。'
- en: '**cirrus**: A virtual graphic card that''s based on an old Cirrus Logic GD5446
    VGA chip. It can be used with any guest OS after Windows 95.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cirrus**：一种基于旧的Cirrus Logic GD5446 VGA芯片的虚拟图形卡。它可以与Windows 95之后的任何客户操作系统一起使用。'
- en: '**std**: A standard VGA card that can be used with high-resolution modes for
    guest OSes after Windows XP.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std**：一种标准的VGA卡，可用于Windows XP之后的客户操作系统的高分辨率模式。'
- en: '**vmware**: VMware''s SVGA graphics adapter, which requires additional drivers
    in Linux guest OSes and VMware Tools installation for Windows OSes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vmware**：VMware的SVGA图形适配器，在Linux客户操作系统中需要额外的驱动程序和Windows操作系统中需要安装VMware Tools。'
- en: '**QXL**: The de facto standard paravirtual graphics card that we need to use
    when we use SPICE remote display protocol, which we will cover in detail a bit
    later in this chapter. There''s an older version of this virtual graphics card
    called QXL VGA, which lacks some more advanced features, while offering lower
    overhead (it uses less memory).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QXL**：事实上的标准半虚拟图形卡，当我们使用SPICE远程显示协议时需要使用，我们稍后将在本章中详细介绍。这个虚拟图形卡的旧版本称为QXL VGA，它缺少一些更高级的功能，但提供更低的开销（使用更少的内存）。'
- en: '**Virtio**: A paravirtual 3D virtual graphics card that is based on the virgl
    project, which provides 3D acceleration for QEMU guest OSes. It has two different
    types (VGA and gpu). virtio-vga is commonly used for situations where we need
    multi-monitor support and OpenGL hardware acceleration. The virtio-gpu version
    doesn''t have a built-in standard VGA compatibility mode.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Virtio**：一种基于virgl项目的半虚拟3D虚拟图形卡，为QEMU客户操作系统提供3D加速。它有两种不同的类型（VGA和gpu）。virtio-vga通常用于需要多显示器支持和OpenGL硬件加速的情况。virtio-gpu版本没有内置的标准VGA兼容模式。'
- en: '**cg3**: A virtual graphics card that we can use with older SPARC-based guest
    OSes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cg3**：一种虚拟图形卡，可用于较旧的基于SPARC的客户操作系统。'
- en: '**none**: Disables the graphics card in the guest OS.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**none**：禁用客户操作系统中的图形卡。'
- en: 'When configuring your virtual machine, you can select these options at startup
    or virtual machine creation. In CentOS 8, the default virtual graphics card that
    gets assigned to a newly created virtual machine is **QXL**, as shown in the following
    screenshot of the configuration for a new virtual machine:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置虚拟机时，您可以在启动或创建虚拟机时选择这些选项。在CentOS 8中，分配给新创建的虚拟机的默认虚拟图形卡是**QXL**，如下面的新虚拟机配置的屏幕截图所示：
- en: '![Figure 6.1 – Default virtual graphics card for a guest OS – QXL'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 客户操作系统的默认虚拟图形卡 - QXL'
- en: '](img/B14834_06_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_01.jpg)'
- en: Figure 6.1 – Default virtual graphics card for a guest OS – QXL
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 客户操作系统的默认虚拟图形卡 - QXL
- en: 'Also, by default, we can select three of these types of virtual graphics cards
    for any given virtual machine, as these are usually pre-installed for us on any
    Linux server that''s configured for virtualization:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，默认情况下，我们可以为任何给定的虚拟机选择这三种类型的虚拟图形卡，因为这些通常已经预先安装在为虚拟化配置的任何Linux服务器上：
- en: QXL
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QXL
- en: VGA
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VGA
- en: Virtio
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Virtio
- en: Some of the new OSes running in KVM virtualization shouldn't use older graphics
    card adapters for a variety of reasons. For example, ever since Red Hat Enterprise
    Linux/CentOS 7, there's an advisory not to use the cirrus virtual graphics card
    for Windows 10 and Windows Server 2016\. The reason for this is related to the
    instability of the virtual machine, as well as the fact that – for example – you
    can't use a full HD resolution display with the cirrus virtual graphics card.
    Just in case you start installing these guest OSes, make sure that you're using
    a QXL video graphics card as it offers the best performance and compatibility
    with the SPICE remote display protocol.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在KVM虚拟化中运行的一些新操作系统不应该使用旧的图形卡适配器，原因有很多。例如，自从Red Hat Enterprise Linux/CentOS 7以来，有一个建议不要为Windows
    10和Windows Server 2016使用cirrus虚拟图形卡。原因是虚拟机的不稳定性，以及 - 例如 - 您无法使用cirrus虚拟图形卡进行全高清分辨率显示。以防万一您开始安装这些客户操作系统，请确保您使用QXL视频图形卡，因为它提供了最佳性能和与SPICE远程显示协议的兼容性。
- en: Theoretically, you could still use cirrus virtual graphics card for some of
    the *really* old guest OSes (older Windows NTs such as 4.0 and older client guest
    OSes such as Windows XP), but that's about it. For everything else, it's much
    better to either use a std or QXL driver as they offer the best performance and
    acceleration support. Furthermore, these virtual graphics cards also offer higher
    display resolutions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，您仍然可以为一些*非常*老的客户操作系统（旧的Windows NT，如4.0和旧的客户操作系统，如Windows XP）使用cirrus虚拟图形卡，但仅限于此。对于其他所有情况，最好使用std或QXL驱动程序，因为它们提供了最佳的性能和加速支持。此外，这些虚拟图形卡还提供更高的显示分辨率。
- en: There are some other virtual graphics cards available for QEMU, such as embedded
    drivers for various **System on a Chip** (**SoC**) devices, ati vga, bochs, and
    so on. Some of these are often used, such as SoCs – just remember all of the world's
    Raspberry Pis, and BBC Micro:bits. These new virtual graphics options are further
    expanded by **Internet of Things** (**IoT**). So, there are loads of good reasons
    why we should pay close attention to what's happening in this market space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU还提供了一些其他虚拟图形卡，例如各种**片上系统**（**SoC**）设备的嵌入式驱动程序，ati vga，bochs等。其中一些经常被使用，比如SoCs
    - 只需记住世界上所有的树莓派和BBC Micro:bits。这些新的虚拟图形选项还通过**物联网**（**IoT**）得到进一步扩展。因此，有很多很好的理由让我们密切关注这个市场空间中发生的事情。
- en: 'Let''s show this via an example. Let''s say that we want to create a new virtual
    machine that is going to have a set of custom parameters assigned to it in terms
    of how we access its virtual display. If you remember in [*Chapter 3*](B14834_03_Final_ASB_ePub.xhtml#_idTextAnchor049),
    *Installing KVM Hypervisor, libvirt, and ovirt*, we discussed various libvirt
    management commands (`virsh`, `virt-install`) and we also created some virtual
    machines by using `virt-install` and some custom parameters. Let''s add to those
    and use a similar example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来展示这一点。假设我们想创建一个新的虚拟机，并为其分配一组自定义参数，以便我们访问其虚拟显示。如果您还记得[*第3章*](B14834_03_Final_ASB_ePub.xhtml#_idTextAnchor049)，*安装KVM
    Hypervisor、libvirt和ovirt*，我们讨论了各种libvirt管理命令（`virsh`、`virt-install`），并使用`virt-install`创建了一些虚拟机和一些自定义参数。让我们在这些基础上添加一些内容，并使用一个类似的例子：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what''s going to happen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要发生的事情：
- en: '![Figure 6.2 – KVM virtual machine with a VGA virtual graphics card is created.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 创建了一个带有VGA虚拟图形卡的KVM虚拟机。'
- en: Here, VNC is asking for a password to be specified
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，VNC要求指定密码
- en: '](img/B14834_06_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_02.jpg)'
- en: Figure 6.2 – KVM virtual machine with a VGA virtual graphics card is created.
    Here, VNC is asking for a password to be specified
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 创建了一个带有VGA虚拟图形卡的KVM虚拟机。在这里，VNC要求指定密码
- en: 'After we type in the password (`Packt123`, as specified in the virt-install
    configuration option), we''re faced with this screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入密码（`Packt123`，如在virt-install配置选项中指定的那样）之后，我们面对这个屏幕：
- en: '![Figure 6.3 – VGA display adapter and its low default (640x480) initial resolution
    - a familiar resolution for all of us who grew up in the 80s'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - VGA显示适配器及其低默认（640x480）初始分辨率 - 对于在80年代长大的我们来说是一个熟悉的分辨率'
- en: '](img/B14834_06_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_03.jpg)'
- en: Figure 6.3 – VGA display adapter and its low default (640x480) initial resolution
    - a familiar resolution for all of us who grew up in the 80s
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - VGA显示适配器及其低默认（640x480）初始分辨率 - 对于在80年代长大的我们来说是一个熟悉的分辨率
- en: That being said, we just used this as an example of how to add an advanced option
    to the `virt-install` command – specifically, how to install a virtual machine
    with a specific virtual graphics card.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们只是用这个作为一个例子，来展示如何向`virt-install`命令添加一个高级选项 - 具体来说，如何使用特定的虚拟图形卡安装虚拟机。
- en: There are other, more advanced concepts of using real graphics cards that we
    installed in our computers or servers to forward their *capabilities* directly
    to virtual machines. This is *very* important for concepts such as VDI, as we
    mentioned earlier. Let's discuss these concepts for a second and use some real-word
    examples and comparisons to understand the complexity of VDI solutions on a larger
    scale.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他更高级的概念，即使用我们在计算机或服务器上安装的真实图形卡，将它们的*功能*直接转发给虚拟机。这对于VDI等概念非常重要，正如我们之前提到的。让我们讨论一下这些概念，并使用一些真实世界的例子和比较来理解大规模VDI解决方案的复杂性。
- en: Physical and virtual graphics cards in VDI scenarios
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VDI场景中的物理和虚拟图形卡
- en: As we discussed in [*Chapter 1*](B14834_01_Final_ASB_ePub.xhtml#_idTextAnchor016),
    *Understanding Linux Virtualization*, VDI is a concept that uses virtualization
    paradigm for client OSes. This means that end users connect *directly* to their
    virtual machines by running a client OS (for example, Windows 8.1, Windows 10,
    or Linux Mint) that is either *reserved* for them or *pooled*, which means that
    multiple users can access the same virtual machines and get access to their *data*
    via additional VDI capabilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在《第1章》中讨论的那样，《理解Linux虚拟化》，VDI是一个利用虚拟化范式来为客户端操作系统提供服务的概念。这意味着最终用户通过运行客户端操作系统（例如Windows
    8.1、Windows 10或Linux Mint）*直接*连接到他们的虚拟机，这些虚拟机要么是*专门*为他们保留的，要么是*共享*的，这意味着多个用户可以访问相同的虚拟机并通过额外的VDI功能访问它们的*数据*。
- en: Now, if we're talking about most business users, they just need something that
    we jokingly call a *typewriter*. This usage model relates to a scenario in which
    the user uses a client OS for reading and writing documents, email, and browsing
    the internet. And for these use cases, if we were to use any vendor-based solution
    out there (VMware's Horizon, Citrix Xen Desktop, or Microsoft's Remote Desktop
    Services-based VDI solutions), we could do so with any one of them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们谈论大多数商业用户，他们只需要我们开玩笑称之为*打字机*的东西。这种使用模式涉及用户使用客户端操作系统阅读和撰写文件、电子邮件和浏览互联网。对于这些用例，如果我们要使用任何供应商的解决方案（VMware的Horizon、Citrix的Xen
    Desktop或微软基于远程桌面服务的VDI解决方案），我们可以使用其中任何一个。
- en: However, there's a big *but*. What happens if the scenario includes hundreds
    of users who need access to 2D and/or 3D video acceleration? What happens if we
    are designing a VDI solution for a company creating designs – architecture, plumbing,
    oil and gas, and video production? Running VDI solutions based on CPU and software-based
    virtual graphics cards will get us nowhere, especially at scale. This is where
    Xen Desktop and Horizon will be much more feature-packed if we're talking about
    the technology level. And – to be quite honest – KVM-based methods aren't all
    that far behind in terms of display options, it's just that they lag in some other
    enterprise-class features, which we will discuss in later chapters, such as [*Chapter
    12*](B14834_12_Final_ASB_ePub.xhtml#_idTextAnchor209), *Scaling Out KVM with OpenStack*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的*但是*。如果场景包括数百名需要访问2D和/或3D视频加速的用户会发生什么？如果我们正在为一个创建设计的公司设计VDI解决方案——比如建筑、管道、石油和天然气以及视频制作？基于CPU和软件虚拟图形卡的VDI解决方案在这种情况下将毫无作为，特别是在大规模情况下。这就是Xen
    Desktop和Horizon在技术水平上要更加功能丰富的地方。而且，说实话，基于KVM的方法在显示选项方面并不逊色，只是在一些其他企业级功能上稍显不足，我们将在后面的章节中讨论这些功能，比如《第12章》，*使用OpenStack扩展KVM*。
- en: 'Basically, there are three concepts we can use to obtain graphics card performance
    for a virtual machine:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以使用三个概念来获得虚拟机的图形卡性能：
- en: We can use a software renderer that's CPU-based.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用基于CPU的软件渲染器。
- en: We can reserve a GPU for a specific virtual machine (PCI passthrough).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为特定的虚拟机保留一个GPU（PCI直通）。
- en: We can *partition* a GPU so that we can use it in multiple virtual machines.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以*分区*一个GPU，这样我们可以在多个虚拟机中使用它。
- en: Just to use the VMware Horizon solution as a metaphor, these solutions would
    be called CPU rendering, **Virtual Direct Graphics Acceleration** (**vDGA**),
    and **Virtual Shared Graphics Acceleration** (**vSGA**). Or, in Citrix, we'd be
    talking about HDX 3D Pro. In CentOS 8, we are talking about *mediated devices*
    in the shared graphics card scenario.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用VMware Horizon解决方案作为比喻，这些解决方案将被称为CPU渲染、**虚拟直接图形加速**（**vDGA**）和**虚拟共享图形加速**（**vSGA**）。或者在Citrix中，我们会谈论HDX
    3D Pro。在CentOS 8中，我们在共享图形卡方案中谈论*中介设备*。
- en: 'If we''re talking about PCI passthrough, it definitely delivers the best performance
    as you can use a PCI-Express graphics card, forward it directly to a virtual machine,
    install a native driver inside the guest OS, and have the complete graphics card
    all for yourself. But that creates four problems:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论PCI直通，它绝对能提供最佳性能，因为你可以使用PCI-Express图形卡，直接转发给虚拟机，在客户操作系统内安装本机驱动程序，并完全拥有图形卡。但这会带来四个问题：
- en: You can only have that PCI-Express graphics card forwarded to *one* virtual
    machine.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能将PCI-Express图形卡转发给*一个*虚拟机。
- en: As servers can be limited in terms of upgradeability, for example, you can't
    run 50 virtual machines like that on one physical server as you can't fit 50 graphics
    cards on a single server – physically or in terms of PCI-Express slots, where
    you usually have up to six in a typical 2U rack server.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器在升级方面可能存在限制，例如，你不能像在一台物理服务器上那样运行50个虚拟机，因为你无法在单个服务器上放置50个图形卡——无论是从物理上还是从PCI-Express插槽上来看，通常情况下在一个典型的2U机架服务器上最多只有六个。
- en: If you're using Blade servers (for example, HP c7000), it's going to be even
    worse as you're going to use half of the server density per blade chassis if you're
    going to use additional graphics cards as these cards can only be fitted to double-height
    blades.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用刀片服务器（例如，HP c7000），情况会更糟，因为如果你要使用额外的图形卡，那么每个刀片机箱的服务器密度将减半，因为这些卡只能安装在双高刀片上。
- en: You're going to spend an awful lot of money scaling any kind of solution like
    this to hundreds of virtual desktops, or – even worse – thousands of virtual desktops.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要将任何这类解决方案扩展到数百个虚拟桌面，甚至更糟的是数千个虚拟桌面，您将花费大量资金。
- en: 'If we''re talking about a shared approach in which you partition a physical
    graphics card so that you can use it in multiple virtual machines, that''s going
    to create another set of problems:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论的是一种共享方法，即将物理图形卡分区，以便在多个虚拟机中使用它，那么这将产生另一组问题：
- en: You're much more limited in terms of which graphics card to use as there are
    maybe 20 graphics cards that support this usage model (some include NVIDIA GRID,
    Quadro, Tesla cards, and a couple of AMD and Intel cards).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择要使用的图形卡方面，您的选择要受到更多限制，因为可能只有大约20种图形卡支持这种使用模式（其中一些包括NVIDIA GRID、Quadro、Tesla卡以及几张AMD和英特尔卡）。
- en: If you share the same graphics card with four, eight, 16, or 32 virtual machines,
    you have to be aware of the fact that you'll get less performance, as you're sharing
    the same GPU with multiple virtual machines.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您与四、八、十六或三十二个虚拟机共享同一块图形卡，您必须意识到您的性能会降低，因为您正在与多个虚拟机共享同一块GPU。
- en: Compatibility with DirectX, OpenGL, CUDA, and video encoding offload won't be
    as good as you might expect, and you might be forced to use older versions of
    these standards.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与DirectX、OpenGL、CUDA和视频编码卸载的兼容性可能不如您期望的那样好，您可能会被迫使用这些标准的较旧版本。
- en: There might be additional licensing involved, depending on the vendor and solution.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会涉及额外的许可证，这取决于供应商和解决方案。
- en: The next topic on our list is how to use a GPU in a more advanced way – by using
    the GPU partitioning concept to provide parts of a GPU to multiple virtual machines.
    Let's explain how that works and gets configured by using an NVIDIA GPU as an
    example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表上的下一个主题是如何更高级地使用GPU - 通过使用GPU分区概念将GPU的部分提供给多个虚拟机。让我们解释一下这是如何工作的，并通过使用NVIDIA
    GPU作为示例来配置它。
- en: GPU partitioning using an NVIDIA vGPU as an example
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NVIDIA vGPU作为示例的GPU分区
- en: Let's use an example to see how we can use the scenario in which we partition
    our GPU (NVIDIA vGPU) with our KVM-based virtual machine. This procedure is very
    similar to the SR-IOV procedure we discussed in [*Chapter 4*](B14834_04_Final_ASB_ePub.xhtml#_idTextAnchor062),
    *Libvirt Networking*, where we used a supported Intel network card to present
    virtual functions to our CentOS host, which we then presented to our virtual machines
    by using them as uplinks for the KVM virtual bridge.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个示例来看看我们如何使用分区我们的GPU（NVIDIA vGPU）与我们基于KVM的虚拟机。这个过程与我们在[*第4章*](B14834_04_Final_ASB_ePub.xhtml#_idTextAnchor062)中讨论的SR-IOV过程非常相似，*Libvirt
    Networking*，在那里我们使用受支持的英特尔网络卡将虚拟功能呈现给我们的CentOS主机，然后通过将它们用作KVM虚拟桥的上行链路来呈现给我们的虚拟机。
- en: 'First, we need to check which kind of graphic cards we have, and it must be
    a supported one (in our case, we''re using a Tesla P4). Let''s use the `lshw`
    command to check our display devices, which should look similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查我们有哪种类型的显卡，它必须是受支持的（在我们的情况下，我们使用的是Tesla P4）。让我们使用`lshw`命令来检查我们的显示设备，它应该看起来类似于这样：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output of this command tells us that we have a 3D-capable GPU – specifically,
    a NVIDIA GP104GL-based product. It tells us that this device is already using
    the `vfio-pci` driver. This driver is the native SR-IOV driver for **Virtualized
    Functions** (**VF**). These functions are the core of SR-IOV functionality. We
    will describe this by using this SR-IOV-capable GPU.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出告诉我们我们有一个支持3D的GPU - 具体来说，是基于NVIDIA GP104GL的产品。它告诉我们这个设备已经在使用`vfio-pci`驱动程序。这个驱动程序是**虚拟化功能**（**VF**）的本机SR-IOV驱动程序。这些功能是SR-IOV功能的核心。我们将使用这个SR-IOV兼容的GPU来描述这一点。
- en: 'The first thing that we need to do – which all of us NVIDIA GPU users have
    been doing for years – is to blacklist the nouveau driver, which gets in the way.
    And if we are going to use GPU partitioning on a permanent basis, we need to do
    this permanently so that it doesn''t get loaded when our server starts. But be
    warned – this can lead to unexpected behavior at times, such as the server booting
    and not showing any output without any real reason. So, we need to create a configuration
    file for `modprobe` that will blacklist the nouveau driver. Let''s create a file
    called `nouveauoff.conf` in the `/etc/modprobe.d` directory with the following
    content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事 - 我们所有的NVIDIA GPU用户多年来一直在做的事情 - 是将nouveau驱动程序列入黑名单，因为它会妨碍我们。如果我们要永久使用GPU分区，我们需要永久地这样做，这样在服务器启动时就不会加载它。但要警告一下
    - 这有时会导致意外行为，比如服务器启动时没有任何输出而没有任何真正的原因。因此，我们需要为`modprobe`创建一个配置文件，将nouveau驱动程序列入黑名单。让我们在`/etc/modprobe.d`目录中创建一个名为`nouveauoff.conf`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we need to force our server to recreate the `initrd` image that gets
    loaded as our server starts and reboot the server to make that change is active.
    We are going to do that with the `dracut` command, followed by a regular `reboot`
    command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要强制服务器重新创建在服务器启动时加载的`initrd`映像，并重新启动服务器以使更改生效。我们将使用`dracut`命令来执行此操作，然后是常规的`reboot`命令：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the reboot, let''s check if our `vfio` driver for the NVIDIA graphics
    card has loaded and, if it has, check the vGPU manager service:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动后，让我们检查NVIDIA图形卡的`vfio`驱动程序是否已加载，如果已加载，请检查vGPU管理器服务：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create a UUID that we will use to present our virtual function to
    a KVM virtual machine. We will use the `uuidgen` command for that:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个UUID，我们将使用它来向KVM虚拟机呈现我们的虚拟功能。我们将使用`uuidgen`命令来执行此操作：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s use this UUID for the virtual machines that will share our GPU.
    For that, we need to create an XML template file that we will add to the existing
    XML files for our virtual machines in a copy-paste fashion. Let''s call this `vsga.xml`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个UUID来为将共享我们的GPU的虚拟机。为此，我们需要创建一个XML模板文件，然后以复制粘贴的方式将其添加到我们虚拟机的现有XML文件中。让我们称之为`vsga.xml`：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Use these settings as a template and just copy-paste the complete content to
    any virtual machine's XML file where you want to have access to our shared GPU.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置作为模板，只需将完整内容复制粘贴到任何虚拟机的XML文件中，您希望访问我们共享的GPU。
- en: The next concept that we need to discuss is the complete opposite of SR-IOV,
    where we're slicing a device into multiple pieces to present these pieces to virtual
    machines. In GPU passthrough, we're taking the *whole* device and presenting it
    directly to *one* object, meaning one virtual machine. Let's learn how to configure
    that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的下一个概念是SR-IOV的完全相反，其中我们将设备切片成多个部分，以将这些部分呈现给虚拟机。在GPU直通中，我们将*整个*设备直接呈现给*一个*对象，即一个虚拟机。让我们学习如何配置它。
- en: GPU PCI passthrough
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPU PCI直通
- en: 'As with every advanced feature, enabling GPU PCI passthrough requires multiple
    steps to be done in sequence. By doing these steps in the correct order, we''re
    directly presenting this hardware device to a virtual machine. Let''s explain
    these configuration steps and do them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个高级功能一样，启用GPU PCI直通需要按顺序完成多个步骤。通过按照正确的顺序执行这些步骤，我们直接将这个硬件设备呈现给虚拟机。让我们解释这些配置步骤并执行它们：
- en: To enable GPU PCI passthrough, we need to configure and enable IOMMU – first
    in our server's BIOS, then in our Linux distribution. We're using Intel-based
    servers, so we need to add `iommu` options to our `/etc/default/grub` file, as
    shown in the following screenshot:![Figure 6.4 – Adding intel_iommu iommu=pt options
    to a GRUB file
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用GPU PCI直通，我们需要在服务器的BIOS中配置和启用IOMMU，然后在Linux发行版中启用。我们使用基于Intel的服务器，因此我们需要向`/etc/default/grub`文件中添加`iommu`选项，如下截图所示：![图6.4
    - 向GRUB文件添加intel_iommu iommu=pt选项
- en: '](img/B14834_06_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_04.jpg)'
- en: Figure 6.4 – Adding intel_iommu iommu=pt options to a GRUB file
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 - 向GRUB文件添加intel_iommu iommu=pt选项
- en: 'The next step is to reconfigure the GRUB configuration and reboot it, which
    can be achieved by typing in the following commands:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是重新配置GRUB配置并重新启动它，可以通过输入以下命令来实现：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After rebooting the host, we need to acquire some information – specifically,
    ID information about the GPU device that we want to forward to our virtual machine.
    Let's do that:![](img/B14834_06_05.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动主机后，我们需要获取一些信息 - 具体来说，是关于我们要转发到虚拟机的GPU设备的ID信息。让我们这样做：![](img/B14834_06_05.jpg)
- en: Figure 6.5 – Using lspci to display relevant configuration information
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 使用lspci显示相关配置信息
- en: In our use case, we want to forward the Quadro 2000 card to our virtual machine
    as we're using the GT740 to hook up our monitors and the Quadro card is currently
    free of any workloads or connections. So, we need to take note of two numbers;
    that is, `0000:05:00.0` and `10de:0dd8`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们希望将Quadro 2000卡转发到我们的虚拟机，因为我们正在使用GT740连接我们的显示器，而Quadro卡目前没有任何工作负载或连接。因此，我们需要记下两个数字；即`0000:05:00.0`和`10de:0dd8`。
- en: We will need both IDs going forward, with each one for defining which device
    we want to use and where.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要这两个ID继续前进，每个ID用于定义我们要使用的设备和位置。
- en: The next step is to explain to our host OS that it will not be using this PCI
    express device (Quadro card) for itself. In order to do that, we need to change
    the GRUB configuration again and add another parameter to the same file (`/etc/defaults/grub`):![](img/B14834_06_06.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是向我们的主机操作系统解释，它不会为自己使用这个PCI Express设备（Quadro卡）。为了做到这一点，我们需要再次更改GRUB配置，并向同一文件(`/etc/defaults/grub`)添加另一个参数：![](img/B14834_06_06.jpg)
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This step marks the end of the *physical* server configuration. Now, we can
    move on to the next stage of the process, which is how to use the now fully configured
    PCI passthrough device in our virtual machine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步标志着*物理*服务器配置的结束。现在，我们可以继续进行下一阶段的过程，即如何在虚拟机中使用现在完全配置的PCI直通设备。
- en: Let's check if everything was done correctly by using the `virsh nodedev-dumpxml`
    command on the PCI device ID:![Figure 6.7 – Checking if the KVM stack can see
    our PCIe device
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用`virsh nodedev-dumpxml`命令检查是否一切都正确完成了，检查PCI设备ID：![图6.7 - 检查KVM堆栈是否能看到我们的PCIe设备
- en: '](img/B14834_06_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_07.jpg)'
- en: Figure 6.7 – Checking if the KVM stack can see our PCIe device
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 - 检查KVM堆栈是否能看到我们的PCIe设备
- en: 'Here, we can see that QEMU sees two functions: `0x1` and `0x0`. The `0x1` function
    is actually the GPU device''s *audio* chip, which we won''t be using for our procedure.
    We just need the `0x0` function, which is the GPU itself. This means that we need
    to mask it. We can do that by using the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到QEMU看到了两个功能：`0x1`和`0x0`。`0x1`功能实际上是GPU设备的*音频*芯片，我们不会在我们的过程中使用它。我们只需要`0x0`功能，即GPU本身。这意味着我们需要屏蔽它。我们可以通过使用以下命令来实现：
- en: '![Figure 6.8 – Detaching the 0x1 device so that it can''t be used for passthrough'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 - 分离0x1设备，以便它不能用于直通'
- en: '](img/B14834_06_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_08.jpg)'
- en: Figure 6.8 – Detaching the 0x1 device so that it can't be used for passthrough
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 - 分离0x1设备，以便它不能用于直通
- en: Now, let's add the GPU via PCI passthrough to our virtual machine. For this
    purpose, we're using a freshly installed virtual machine called `MasteringKVM03`,
    but you can use any virtual machine you want. We need to create an XML file that
    QEMU will use to know which device to add to a virtual machine. After that, we
    need to shut down the machine and import that XML file into our virtual machine.
    In our case, the XML file will look like this:![Figure 6.9 – The XML file with
    our GPU PCI passthrough definition for KVM
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过PCI直通将GPU添加到我们的虚拟机。为此，我们使用了一个名为`MasteringKVM03`的新安装的虚拟机，但您可以使用任何您想要的虚拟机。我们需要创建一个XML文件，QEMU将使用它来知道要添加到虚拟机的设备。之后，我们需要关闭机器并将该XML文件导入到我们的虚拟机中。在我们的情况下，XML文件将如下所示：![图6.9
    - 用于KVM的GPU PCI直通定义的XML文件
- en: '](img/B14834_06_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_09.jpg)'
- en: Figure 6.9 – The XML file with our GPU PCI passthrough definition for KVM
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 - 用于KVM的GPU PCI直通定义的XML文件
- en: The next step is to attach this XML file to the `MasteringKVM03` virtual machine.
    We can do this by using the `virsh attach-device` command:![Figure 6.10 – Importing
    the XML file into a domain/virtual machine
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将这个XML文件附加到`MasteringKVM03`虚拟机上。我们可以使用`virsh attach-device`命令来实现这一点：![图6.10-将XML文件导入域/虚拟机
- en: '](img/B14834_06_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_10.jpg)'
- en: Figure 6.10 – Importing the XML file into a domain/virtual machine
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10-将XML文件导入域/虚拟机
- en: 'After the previous step, we can start our virtual machine, log in, and check
    if the virtual machine sees our GPU:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步之后，我们可以启动虚拟机，登录，并检查虚拟机是否看到了我们的GPU：
- en: '![Figure 6.11 – Checking GPU visibility in our virtual machine'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11-检查虚拟机中GPU的可见性'
- en: '](img/B14834_06_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_11.jpg)'
- en: Figure 6.11 – Checking GPU visibility in our virtual machine
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11-检查虚拟机中GPU的可见性
- en: The next logical step would be to install the NVIDIA driver for this card for
    Linux so that we can freely use it as our discrete GPU.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个合乎逻辑的步骤将是为Linux安装这张卡的NVIDIA驱动程序，这样我们就可以自由地将其用作我们的独立GPU。
- en: Now, let's move on to another important subject that is related to remote display
    protocols. We kind of danced around this subject in the previous part of this
    chapter as well, but now we are going to tackle it head-on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论与远程显示协议相关的另一个重要主题。在本章的前一部分中，我们也围绕这个主题打转了一下，但现在我们要正面对待它。
- en: Discussing remote display protocols
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论远程显示协议
- en: As we mentioned previously, there are different virtualization solutions, so
    it's only normal that there are different methods to *access* virtual machines.
    If you take a look at the history of virtual machines, we had a number of different
    display protocols taking care of this particular problem. So, let's discuss this
    history a bit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，有不同的虚拟化解决方案，因此访问虚拟机的方法也是多种多样的。如果你看一下虚拟机的历史，你会发现有许多不同的显示协议来解决这个特定的问题。因此，让我们稍微讨论一下这段历史。
- en: Remote display protocols history
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程显示协议历史
- en: There will be people disputing this premise, but remote protocols started as
    text-only protocols. Whichever way you look at it, serial, text-mode terminals
    were here before we had X Windows or anything remotely resembling a GUI in the
    Microsoft, Apple, and UNIX-based worlds. Also, you can't dispute the fact that
    the telnet and rlogin protocols are also used to access remote display. It just
    so happens that the remote display that we're accessing by using telnet and rlogin
    is a text-based display. By extension, the same thing applies to SSH. And serial
    terminals, text consoles, and text-based protocols such as telnet and rlogin were
    some of the most commonly used starting points that go way back to the 1970s.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 会有人对这个前提提出异议，但远程协议最初是文本协议。无论你怎么看，串行、文本模式终端在微软、苹果和基于UNIX的世界中的X Windows或任何类似GUI的东西出现之前就已经存在了。此外，你无法否认的是telnet和rlogin协议也用于访问远程显示。恰巧我们通过telnet和rlogin访问的远程显示是基于文本的显示。同样的情况也适用于SSH。串行终端、文本控制台和telnet、rlogin等基于文本的协议是一些最常用的起点，可以追溯到上世纪70年代。
- en: 'The end of the 1970s was an important time in computer history as there were
    numerous attempts to start mass-producing a personal computer for large amounts
    of people (for example, Apple II from 1977). In the 1980s, people started using
    personal computers more, as any Amiga, Commodore, Atari, Spectrum, or Amstrad
    fan will tell you. Keep in mind that the first real, publicly available GUI-based
    OSes didn''t start appearing until Xerox Star (1981) and Apple Lisa (1983). The
    first widely available Apple-based GUI OS was Mac OS System 1.0 in 1984\. Most
    of the other previously mentioned computers were all using a text-based OS. Even
    games from that era (and for many years to come) looked like they were drawn by
    hand while you were playing them. Amiga''s Workbench 1.0 was released in 1985
    and with its GUI and color usage model, it was miles ahead of its time. However,
    1985 is probably going to be remembered for something else – this is the year
    that the first Microsoft Windows OS (v1.0) was released. Later, that became Windows
    2.0 (1987), Windows 3.0 (1990), Windows 3.1 (1992), by which time Microsoft was
    already taking the OS world by storm. Yes, there were other OSes by other manufacturers
    too:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代末是计算机历史上的重要时刻，因为当时有许多尝试为大量人群开始大规模生产个人计算机（例如，1977年的Apple II）。在20世纪80年代，人们开始更多地使用个人计算机，任何Amiga、Commodore、Atari、Spectrum或Amstrad的粉丝都会告诉你。请记住，真正的、公开可用的基于GUI的操作系统直到Xerox
    Star（1981）和Apple Lisa（1983）才开始出现。第一个广泛可用的基于苹果的GUI操作系统是1984年的Mac OS System 1.0。大多数其他先前提到的计算机都在使用基于文本的操作系统。即使是那个时代的游戏（以及很多年后的游戏）看起来都像是手绘的。Amiga的Workbench
    1.0于1985年发布，其GUI和颜色使用模型使其领先于时代。然而，1985年可能会因为另一件事而被记住-这是第一个微软Windows操作系统（v1.0）发布的年份。后来，它变成了Windows
    2.0（1987）、Windows 3.0（1990）、Windows 3.1（1992），到那时微软已经开始在操作系统世界中掀起风暴。是的，其他制造商也有其他操作系统：
- en: 'Apple: Mac OS System 7 (1991)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果：Mac OS System 7 (1991)
- en: 'IBM: OS/2 v1 (1988), v1.2 (1989), v2.0 (1992), Warp 4 (1996)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IBM: OS/2 v1 (1988), v1.2 (1989), v2.0 (1992), Warp 4 (1996)'
- en: All of these were just a tiny dot on the horizon compared to the big storm that
    happened in 1995, when Microsoft introduced Windows 95\. It was the first Microsoft
    client OS that was able to boot to GUI by default since the previous versions
    were started from a command line. Then came Windows 98 and XP, which meant even
    more market share for Microsoft. The rest of that story is probably very familiar,
    with Vista, Windows 7, Windows 8, and Windows 10.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些与1995年发生的大风暴相比只是一个小点。那一年，微软推出了Windows 95。这是微软首个能够默认启动到GUI的客户端操作系统，因为之前的版本都是从命令行启动的。然后是Windows
    98和XP，这意味着微软获得了更多的市场份额。后来的故事可能非常熟悉，包括Vista、Windows 7、Windows 8和Windows 10。
- en: The point of this story is not to teach you about OS history per se. It's about
    noticing the trend, which is simple enough. We started with text interfaces in
    the command line (for example, IBM and MS DOS, early versions of Windows, Linux,
    UNIX, Amiga, Atari, and so on). Then, we slowly moved toward more visual interfaces
    (GUI). With advancements in networking, GPU, CPU, and monitoring technologies,
    we've reached a phase in which we want a shiny, 4K-resolution monitor with 4-megapixel
    resolutions, low latency, huge CPU power, fantastic colors, and a specific user
    experience. That user experience needs to be immediate, and it shouldn't really
    matter that we're using a local OS or a remote one (VDI, the cloud, or whatever
    the background technology is).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的重点不是教你有关操作系统历史本身的知识。它是关于注意到趋势，这足够简单。我们从命令行中的文本界面开始（例如，IBM和MS DOS，早期的Windows，Linux，UNIX，Amiga，Atari等）。然后，我们慢慢地转向更加视觉化的界面（GUI）。随着网络、GPU、CPU和监控技术的进步，我们已经达到了一个阶段，我们希望拥有一个闪亮的、4K分辨率的显示器，4兆像素的分辨率，低延迟，强大的CPU性能，出色的颜色以及特定的用户体验。这种用户体验需要是即时的，而且我们使用本地操作系统或远程操作系统（VDI、云或其他背景技术）并不重要。
- en: This means that along with all the hardware components that we just mentioned,
    other (software) components needed to be developed as well. Specifically, what
    needed to be developed were high-quality remote display protocols, which nowadays
    must be able to be extended to a browser-based usage model, as well. People don't
    want to be forced to install additional applications (clients) to access their
    remote resources.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着除了我们刚提到的所有硬件组件之外，还需要开发其他（软件）组件。具体来说，需要开发的是高质量的远程显示协议，这些协议现在必须能够扩展到基于浏览器的使用模型。人们不想被迫安装额外的应用程序（客户端）来访问他们的远程资源。
- en: Types of remote display protocols
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程显示协议的类型
- en: 'Let''s just mention some protocols that are very active on the market *now*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只提一下目前市场上非常活跃的一些协议：
- en: 'Microsoft Remote Desktop Protocol/Remote FX: Used by Remote Desktop Connection,
    this multi-channel protocol allows us to connect to Microsoft-based virtual machines.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft远程桌面协议/Remote FX：由远程桌面连接使用，这种多通道协议允许我们连接到基于Microsoft的虚拟机。
- en: 'VNC: Short for Virtual Network Computing, this is a remote desktop sharing
    system that transmits mouse and keyboard events to access remote machines.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VNC：Virtual Network Computing的缩写，这是一个远程桌面共享系统，用于传输鼠标和键盘事件以访问远程机器。
- en: 'SPICE: Short for Simple Protocol for Independent Computing Environments, this
    is another remote display protocol that can be used to access remote machines.
    It was developed by Qumranet, which was bought by Red Hat.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPICE：独立计算环境的简单协议的缩写，这是另一种远程显示协议，可用于访问远程机器。它是由Qumranet开发的，后来被Red Hat收购。
- en: 'If we further expand our list to protocols that are being used for VDI, then
    the list increases further:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步扩展我们的协议列表，用于VDI的协议，那么列表将进一步增加：
- en: 'Teradici PCoIP (PC over IP): A UDP-based VDI protocol that we can use to access
    virtual machines on VMware, Citrix and Microsoft-based VDI solutions'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Teradici PCoIP（PC over IP）：基于UDP的VDI协议，我们可以使用它来访问VMware、Citrix和基于Microsoft的VDI解决方案上的虚拟机
- en: 'VMware Blast Extreme: VMware''s answer to PcoIP for VMware Horizon-based VDI
    solution'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware Blast Extreme：VMware针对VMware Horizon基于VDI解决方案的PcoIP的答案
- en: 'Citrix HDX: Citrix''s protocol for virtual desktops.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Citrix HDX：Citrix用于虚拟桌面的协议。
- en: 'Of course, there are others that are available but not used as much and are
    way less important, such as the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他可用但使用较少且不太重要的协议，例如以下内容：
- en: Colorado CodeCraft
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Colorado CodeCraft
- en: OpenText Exceed TurboX
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenText Exceed TurboX
- en: NoMachine
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoMachine
- en: FreeNX
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeNX
- en: Apache Guacamole
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Guacamole
- en: Chrome Remote Desktop
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome远程桌面
- en: Miranex
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Miranex
- en: The major differences between regular remote protocols and fully featured VDI
    protocols are related to additional functionalities. For example, on PCoIP, Blast
    Extreme, and HDX, you can fine-tune bandwidth settings, control USB and printer
    redirection (manually or centrally via policies), use multimedia redirection (to
    offload media decoding), Flash redirection (to offload Flash), client drive redirection,
    serial port redirection, and dozens of other features. You can't do some of these
    things on VNC or Remote Desktop, for example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 常规远程协议和完整功能的VDI协议之间的主要区别与附加功能有关。例如，在PCoIP、Blast Extreme和HDX上，您可以微调带宽设置，控制USB和打印机重定向（手动或通过策略集中控制），使用多媒体重定向（以卸载媒体解码），Flash重定向（以卸载Flash），客户端驱动器重定向，串口重定向等等。例如，您无法在VNC或远程桌面上执行其中一些操作。
- en: 'Having said that, let''s discuss two of the most common ones in the open source
    world: VNC and SPICE.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们讨论一下开源世界中最常见的两种：VNC和SPICE。
- en: Using the VNC display protocol
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VNC显示协议
- en: When the VNC graphics server is enabled through libvirt, QEMU will redirect
    the graphics output to its inbuilt VNC server implementation. The VNC server will
    listen to a network port where the VNC clients can connect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过libvirt启用VNC图形服务器时，QEMU将将图形输出重定向到其内置的VNC服务器实现。VNC服务器将监听VNC客户端可以连接的网络端口。
- en: 'The following screenshot shows how to add a VNC graphics server. Just go to
    **Virtual Machine Manager**, open the settings of your virtual machine, and go
    to the **Display Spice** tab on the left-hand side:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何添加VNC图形服务器。只需转到**虚拟机管理器**，打开虚拟机的设置，然后转到左侧的**显示Spice**选项卡：
- en: '![Figure 6.12 – VNC configuration for a KVM virtual machine'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 - 用于KVM虚拟机的VNC配置'
- en: '](img/B14834_06_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_12.jpg)'
- en: Figure 6.12 – VNC configuration for a KVM virtual machine
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 - 用于KVM虚拟机的VNC配置
- en: 'When adding VNC graphics, you will be presented with the options shown in the
    preceding screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 添加VNC图形时，您将看到前面截图中显示的选项：
- en: '**Type**: The type of the graphics server. Here, it is **VNC server**.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：图形服务器的类型。这里是**VNC服务器**。'
- en: '**Address**: VNC server listening address. It can be all, localhost, or an
    IP address. By default, it is **Localhost only**.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：VNC服务器监听地址。它可以是全部、本地主机或IP地址。默认情况下，它是**仅本地主机**。'
- en: '**Port**: VNC server listening port. You can either choose auto, where libvirt
    defines the port based on the availability, or you can define one yourself. Make
    sure it does not create a conflict.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口：VNC服务器监听端口。您可以选择自动，其中libvirt根据可用性定义端口，或者您可以自己定义一个。确保它不会产生冲突。
- en: '**Password**: The password protecting VNC access.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：保护VNC访问的密码。'
- en: '`virt-xml` command-line tool.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-xml`命令行工具。'
- en: 'For example, let''s add VNC graphics to a virtual machine called `PacktGPUPass`
    and then modify its VNC listening IP to `192.168.122.1`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向名为`PacktGPUPass`的虚拟机添加VNC图形，然后修改其VNC监听IP为`192.168.122.1`：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how it looks in the `PacktVM01` XML configuration file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`PacktVM01` XML配置文件中的外观：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also use `virsh` to edit `PacktGPUPass` and change the parameters individually.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`virsh`编辑`PacktGPUPass`并单独更改参数。
- en: Why VNC?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用VNC？
- en: You can use VNC when you access virtual machines on LAN or to access the VMs
    directly from the console. It is not a good idea to expose virtual machines over
    a public network using VNC as the connection is not encrypted. VNC is a good option
    if the virtual machines are servers with no GUI installed. Another point that
    is in favor of VNC is the availability of clients. You can access a virtual machine
    from any operating system platform as there will be a VNC viewer available for
    that platform.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在局域网上访问虚拟机或直接从控制台访问VM时，可以使用VNC。使用VNC在公共网络上暴露虚拟机不是一个好主意，因为连接没有加密。如果虚拟机是没有安装GUI的服务器，VNC是一个不错的选择。另一个支持VNC的点是客户端的可用性。您可以从任何操作系统平台访问虚拟机，因为该平台将有适用于该平台的VNC查看器。
- en: Using the SPICE display protocol
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPICE显示协议
- en: Like KVM, a **Simple Protocol for Independent Computing Environments** (**SPICE**)
    is one of the best innovations that came into open source virtualization technologies.
    It propelled the open source virtualization to a large **Virtual Desktop Infrastructure**
    (**VDI**) implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与KVM一样，**独立计算环境的简单协议**（**SPICE**）是进入开源虚拟化技术的最佳创新之一。它推动了开源虚拟化技术向大规模**虚拟桌面基础设施**（**VDI**）的实施。
- en: Important Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Qumranet originally developed SPICE as a closed source code base in 2007\. Red
    Hat, Inc. acquired Qumranet in 2008, and in December 2009, they decided to release
    the code under an open source license and treat the protocol as an open standard.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Qumranet最初在2007年将SPICE作为闭源代码库开发。Red Hat，Inc.在2008年收购了Qumranet，并于2009年12月决定在开源许可下发布代码并将协议视为开放标准。
- en: SPICE is the only open source solution available on Linux that gives two-way
    audio. It has high-quality 2D rendering capabilities that can make use of a client
    system's video card. SPICE also supports multiple HD monitors, encryption, smart
    card authentication, compression, and USB passthrough over the network. For a
    complete list of features, you can visit [http://www.spice-space.org/features.html](http://www.spice-space.org/features.html).
    If you are a developer and want to know about the internals of SPICE, visit [http://www.spice-space.org/documentation.html](http://www.spice-space.org/documentation.html).
    If you are planning for VDI or installing virtual machines that need GUIs, SPICE
    is the best option for you.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: SPICE是Linux上唯一可用的开源解决方案，可以实现双向音频。它具有高质量的2D渲染能力，可以利用客户端系统的视频卡。SPICE还支持多个高清监视器、加密、智能卡身份验证、压缩和网络上传输的USB。有关完整的功能列表，您可以访问[http://www.spice-space.org/features.html](http://www.spice-space.org/features.html)。如果您是开发人员，并且想了解SPICE的内部情况，请访问[http://www.spice-space.org/documentation.html](http://www.spice-space.org/documentation.html)。如果您计划进行VDI或安装需要GUI的虚拟机，SPICE是您的最佳选择。
- en: SPICE may not be compatible with some older virtual machines as they do not
    have support for QXL. In those cases, you can use SPICE along with other video
    generic virtual video cards.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些较旧的虚拟机上，SPICE可能与一些较旧的虚拟机不兼容，因为它们不支持QXL。在这些情况下，您可以将SPICE与其他通用虚拟视频卡一起使用。
- en: Now, let's learn how to add a SPICE graphics server to our virtual machine.
    This can be considered the best-performing virtual display protocol in the open
    source world.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何向我们的虚拟机添加SPICE图形服务器。这可以被认为是开源世界中性能最佳的虚拟显示协议。
- en: Adding a SPICE graphics server
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加SPICE图形服务器
- en: 'Libvirt now selects SPICE as the default graphics server for most virtual machine
    installations. You must follow the same procedures that we mentioned earlier for
    VNC to add the SPICE graphics server. Just change the VNC to SPICE in the dropdown.
    Here, you will get an additional option to select a **TLS port** since SPICE supports
    encryption:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt现在选择SPICE作为大多数虚拟机安装的默认图形服务器。您必须按照我们之前提到的VNC相同的程序来添加SPICE图形服务器。只需在下拉菜单中将VNC更改为SPICE。在这里，您将获得一个额外的选项来选择**TLS端口**，因为SPICE支持加密：
- en: '![Figure 6.13 – SPICE configuration for a KVM virtual machine'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13–KVM虚拟机的SPICE配置'
- en: '](img/B14834_06_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_13.jpg)'
- en: Figure 6.13 – SPICE configuration for a KVM virtual machine
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13–KVM虚拟机的SPICE配置
- en: To get to this configuration window, just edit the settings of your virtual
    machine. Go to the **Display Spice** options and select **Spice server** from
    the pull-down menu. All the other options are optional, so you don't necessarily
    have to do any additional configuration.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入此配置窗口，只需编辑虚拟机的设置。转到**显示Spice**选项，并从下拉菜单中选择**Spice服务器**。所有其他选项都是可选的，因此您不一定需要进行任何其他配置。
- en: With this previous procedure completed, we've covered all the necessary topics
    regarding display protocols. Let's now discuss the various methods we can use
    to access the virtual machine console.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了上述步骤后，我们已经涵盖了有关显示协议的所有必要主题。现在让我们讨论一下我们可以使用的各种方法来访问虚拟机控制台。
- en: Methods to access a virtual machine console
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问虚拟机控制台的方法
- en: There are multiple ways to connect to a virtual machine console. If your environment
    has full GUI access, then the easiest method is to use the virt-manager console
    itself. `virt-viewer` is another tool that can give you access to your virtual
    machine console. This tool is very helpful if you are trying to access a virtual
    machine console from a remote location. In the following example, we are going
    to make a connection to a remote hypervisor that has an IP of `192.168.122.1`.
    The connection is tunneled through an SSH session and is secure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以连接到虚拟机控制台。如果您的环境具有完整的图形用户界面访问权限，那么最简单的方法就是使用virt-manager控制台本身。`virt-viewer`是另一个工具，可以让您访问虚拟机控制台。如果您尝试从远程位置访问虚拟机控制台，则此工具非常有用。在以下示例中，我们将连接到具有IP`192.168.122.1`的远程hypervisor。连接通过SSH会话进行隧道传输，并且是安全的。
- en: 'The first step is to set up an authentication system without a password between
    your client system and the hypervisor:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在客户端系统和hypervisor之间建立一个无密码的身份验证系统：
- en: 'On the client machine, use the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端机器上，使用以下代码：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will be presented with a list of virtual machines available on the hypervisor.
    Select the one you have to access, as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到hypervisor上可用的虚拟机列表。选择要访问的虚拟机，如下截图所示：
- en: '![Figure 6.14 – virt-viewer selection menu for virtual machine access'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14 - 用于虚拟机访问的virt-viewer选择菜单'
- en: '](img/B14834_06_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_14.jpg)'
- en: Figure 6.14 – virt-viewer selection menu for virtual machine access
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 - 用于虚拟机访问的virt-viewer选择菜单
- en: 'To connect to a VM''s console directly, use the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要直接连接到VM的控制台，请使用以下命令：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If your Linux distro is using GRUB (not GRUB2), append the following line to
    your existing boot Kernel line in `/boot/grub/grub.conf` and shut down the virtual
    machine:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的Linux发行版使用GRUB（而不是GRUB2），请将以下行附加到`/boot/grub/grub.conf`中现有的引导内核行，并关闭虚拟机：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If your Linux distro is using GRUB2, then the steps become a little complicated.
    Note that the following command has been tested on a Fedora 22 virtual machine.
    For other distros, the steps to configure GRUB2 might be different, though the
    changes that are required for GRUB configuration file should remain the same:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Linux发行版使用GRUB2，则步骤会变得有点复杂。请注意，以下命令已在Fedora 22虚拟机上进行了测试。对于其他发行版，配置GRUB2的步骤可能会有所不同，尽管GRUB配置文件所需的更改应保持不变：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The changed configuration is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 更改后的配置如下：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, shut down the virtual machine. Then, start it again using `virsh`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭虚拟机。然后使用`virsh`再次启动它：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following command to connect to a virtual machine console that has
    already started:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以连接到已启动的虚拟机控制台：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also do this from a remote client, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从远程客户端执行此操作，如下所示：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In some cases, we have seen a console command stuck at `^]`. To work around
    this, press the *Enter* key multiple times to see the login prompt. Sometimes,
    configuring a text console is very useful when you want to capture the boot messages
    for troubleshooting purposes. Use *ctrl +]* to exit from the console.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们发现控制台命令卡在`^]`。要解决此问题，请多次按*Enter*键以查看登录提示。有时，当您想要捕获用于故障排除目的的引导消息时，配置文本控制台非常有用。使用*ctrl
    +]*退出控制台。
- en: Our next topic takes us to the world of noVNC, another VNC-based protocol that
    has a couple of major advantages over the *regular* VNC. Let's discuss these advantages
    and the implementation of noVNC now.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个主题将带我们进入noVNC的世界，这是另一种基于VNC的协议，它比*常规*VNC具有一些主要优势。现在让我们讨论这些优势以及noVNC的实现。
- en: Getting display portability with noVNC
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用noVNC实现显示可移植性
- en: All these display protocols rely on having access to some type of client application
    and/or additional software support that will enable us to access the virtual machine
    console. But what happens when we just don't have access to all of these additional
    capabilities? What happens if we only have text mode access to our environment,
    but we still want to have GUI-based management of connections to our virtual machines?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些显示协议都依赖于能够访问某种类型的客户端应用程序和/或附加软件支持，这将使我们能够访问虚拟机控制台。但是当我们无法访问所有这些附加功能时会发生什么？当我们只能以文本模式访问我们的环境时，但我们仍然希望以基于GUI的方式管理对我们的虚拟机的连接时会发生什么？
- en: 'Enter noVNC, a HTML5-based VNC client that you can use via a HTML5-compatible
    web browser, which is just fancy talk for *practically every web browser on the
    market*. It supports all the most popular browsers, including mobile ones, and
    loads of other features, such as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输入noVNC，这是一个基于HTML5的VNC客户端，您可以通过兼容HTML5的Web浏览器使用，这只是对市场上*几乎每个*Web浏览器的花哨说法。它支持所有最流行的浏览器，包括移动浏览器，以及许多其他功能，例如以下内容：
- en: Clipboard copy-paste
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板复制粘贴
- en: Supports resolution scaling and resizing
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持分辨率缩放和调整大小
- en: It's free under the MPL 2.0 license
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在MPL 2.0许可下免费
- en: It's rather easy to install and supports authentication and can easily be implemented
    securely via HTTPS
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装它相当容易，并支持身份验证，并且可以通过HTTPS轻松实现安全性
- en: 'If you want to make noVNC work, you need two things:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使noVNC工作，您需要两样东西：
- en: Virtual machine(s) that are configured to accept VNC connections, preferably
    with a bit of configuration done – a password and a correctly set up network interface
    to connect to the virtual machine, for instance. You can freely use `tigervnc-server`,
    configure it to accept connections on – for example – port `5901` for a specific
    user, and use that port and server's IP address for client connections.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已配置为接受VNC连接的虚拟机，最好进行了一些配置 - 例如设置了密码和正确设置的网络接口以连接到虚拟机。您可以自由使用`tigervnc-server`，将其配置为接受特定用户的连接
    - 例如 - 在端口`5901`上，并使用该端口和服务器的IP地址进行客户端连接。
- en: 'noVNC installation on a client computer, which you can either download from
    EPEL repositories or as a `zip/tar.gz` package and run directly from your web
    browser. To install it, we need to type in the following sequence of commands:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端计算机上安装noVNC，您可以从EPEL存储库下载，也可以作为`zip/tar.gz`软件包直接从Web浏览器运行。要安装它，我们需要输入以下一系列命令：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The end result will look something like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将看起来像这样：
- en: '![](img/B14834_06_15.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14834_06_15.jpg)'
- en: Figure 6.15 – noVNC console configuration screen
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 - noVNC控制台配置屏幕
- en: 'Here, we can use our VNC server password for that specific console. After typing
    in the password, we get this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用我们的VNC服务器密码来访问特定的控制台。输入密码后，我们会得到这个：
- en: '![Figure 6.16 – noVNC console in action – we can see the virtual machine console
    and use it to work with our virtual machine'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 - noVNC控制台实际操作 - 我们可以看到虚拟机控制台并使用它来处理我们的虚拟机'
- en: '](img/B14834_06_16.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_16.jpg)'
- en: Figure 6.16 – noVNC console in action – we can see the virtual machine console
    and use it to work with our virtual machine
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 - noVNC控制台实际操作 - 我们可以看到虚拟机控制台并使用它来处理我们的虚拟机
- en: 'We can also use all these options in oVirt. During the installtion of oVirt,
    we just need to select one additional option during the engine-setup phase:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在oVirt中使用所有这些选项。在安装oVirt时，我们只需要在engine-setup阶段选择一个额外的选项：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This option will enable oVirt to use noVNC as a remote display client, on top
    of the existing SPICE and VNC.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将使oVirt能够使用noVNC作为远程显示客户端，除了现有的SPICE和VNC。
- en: 'Let''s take a look at an example of configuring a virtual machine in oVirt
    with pretty much all of the options that we''ve discussed in this chapter. Pay
    close attention to the **Monitors** configuration option:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在oVirt中配置虚拟机的示例，几乎包括了本章讨论的所有选项。特别注意**监视器**配置选项：
- en: '![Figure 6.17 – oVirt also supports all the devices we discussed in this chapter'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 - oVirt还支持本章讨论的所有设备'
- en: '](img/B14834_06_17.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_06_17.jpg)'
- en: Figure 6.17 – oVirt also supports all the devices we discussed in this chapter
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 - oVirt还支持本章讨论的所有设备
- en: If we click on the **Graphics protocol** submenu, we will get the option to
    use SPICE, VNC, noVNC, and various combinations thereof. Also, at the bottom of
    the screen, we have available options for a number of monitors that we want to
    see in our remote display. This can be very useful if we want to have a high-performance
    multi-display remote console.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击**图形协议**子菜单，我们将得到使用SPICE、VNC、noVNC和各种组合的选项。此外，在屏幕底部，我们还有可用的选项，用于我们想要在远程显示中看到的显示器数量。如果我们想要一个高性能的多显示远程控制台，这可能非常有用。
- en: Seeing that noVNC has been integrated to noVNC as well, you can treat this as
    a sign of things to come. Think about it from this perspective – everything related
    to management applications in IT has steadily been moving to web-based applications
    for years now. It's only logical that the same things happen to virtual machine
    consoles. This has also been implemented in other vendors' solutions, so seeing
    noVNC being used here shouldn't be a big surprise.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于noVNC已经集成到noVNC中，您可以将其视为未来的迹象。从这个角度来看 - IT中与管理应用程序相关的一切已经稳步地转移到基于Web的应用程序多年了。同样的事情发生在虚拟机控制台上也是合乎逻辑的。其他供应商的解决方案也已经实施了这一点，因此在这里使用noVNC不应该是一个大惊喜。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered virtual display devices and protocols used to display
    virtual machine data. We also did some digging into the world of GPU sharing and
    GPU passthrough, which are important concepts for large-scale virtualized environments
    running VDI. We discussed some benefits and drawbacks to these scenarios as they
    tend to be rather complex to implement and require a lot of resources – financial
    resources included. Imagine having to do PCI passthrough for 2D/3D acceleration
    for 100 virtual machines. That would actually require buying 100 graphic cards,
    which is a big, big ask financially. Among the other topics we discussed, we went
    through various display protocols and options that can be used for console access
    to our virtual machines.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了虚拟显示设备和用于显示虚拟机数据的协议。我们还深入研究了GPU共享和GPU直通的世界，这是大规模运行VDI的虚拟化环境中的重要概念。我们讨论了这些情景的一些好处和缺点，因为它们往往相当复杂，需要大量资源，包括财政资源。想象一下，为100台虚拟机进行2D/3D加速的PCI直通。这实际上需要购买100张显卡，这在财务上是一个很大的要求。在我们讨论的其他主题中，我们讨论了可以用于控制台访问我们的虚拟机的各种显示协议和选项。
- en: In the next chapter, we will take you through some regular virtual machine operations
    – installation, configuration, and life cycle management, including discussing
    snapshots and virtual machine migration.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将带您了解一些常规虚拟机操作 - 安装、配置和生命周期管理，包括讨论快照和虚拟机迁移。
- en: Questions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which types of virtual machine display devices can we use?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些类型的虚拟机显示设备？
- en: What are the main benefits of using a QXL virtual display device versus VGA?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用QXL虚拟显示设备与VGA相比的主要好处是什么？
- en: What are the benefits and drawbacks of GPU sharing?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPU共享的好处和缺点是什么？
- en: What are the benefits of GPU PCI passthrough?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPU PCI直通的好处是什么？
- en: What are the main advantages of SPICE versus VNC?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SPICE相对于VNC的主要优势是什么？
- en: Why would you use noVNC?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用noVNC？
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章内容的更多信息，请参考以下链接：
- en: 'Configuring and managing virtualization: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/index)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和管理虚拟化：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/index)
- en: 'QEMU documentation: [https://www.qemu.org/documentation/](https://www.qemu.org/documentation/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU文档：[https://www.qemu.org/documentation/](https://www.qemu.org/documentation/)
- en: 'NVIDIA virtual GPU software documentation: [https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-red-hat-el-kvm/index.html](https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-red-hat-el-kvm/index.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA虚拟GPU软件文档：[https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-red-hat-el-kvm/index.html](https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-red-hat-el-kvm/index.html)
- en: 'Working with IOMMU groups: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/app-iommu](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/app-iommu)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IOMMU组：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/app-iommu](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/app-iommu)
