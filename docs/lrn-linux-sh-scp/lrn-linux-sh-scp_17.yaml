- en: Tips and Tricks with Cheat Sheet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速查表中的技巧和技巧
- en: In this final chapter, we have collected some tips and tricks to help you on
    your scripting journey. First, we'll touch on some subjects that are important,
    but weren't directly referenced in our earlier chapters. Then, we'll show you
    some practical shortcuts for the command line, which should help you improve your
    speed when doing Terminal work. Finally, we will end with a cheat sheet for the
    most important interactive commands we have discussed in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们收集了一些提示和技巧，以帮助您在脚本编写的旅程中。首先，我们将涉及一些重要但在早期章节中没有直接提到的主题。然后，我们将向您展示一些命令行的实用快捷方式，这应该有助于您在使用终端时提高速度。最后，我们将以一张我们在本书中讨论过的最重要的交互式命令的速查表结束。
- en: The following commands will be introduced in this chapter: `history` and `clear`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`history`和`clear`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: General tips and tricks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般的提示和技巧
- en: Command-line shortcuts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行快捷方式
- en: Cheat sheet for interactive commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式命令速查表
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Since this chapter consists mostly of tips, there are no scripts as we have
    seen in earlier chapters. To really get a feeling for these tricks, you should
    try them out yourself. As a final goodbye, your Ubuntu virtual machine can serve
    you well this one last time!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章主要是关于提示，所以没有像我们在早期章节中看到的脚本。要真正了解这些技巧的感觉，您应该自己尝试一下。作为最后的告别，您的Ubuntu虚拟机可以在这最后一次为您提供帮助！
- en: General tips and tricks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的提示和技巧
- en: For the first part of this chapter, we'll describe a few things we could not
    place properly in others parts of the book. With the exception of the first subject,
    *arrays*, both `history` and `alias` are not really used in a scripting context
    so we elected to present them here. But first, arrays!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分中，我们将描述一些我们无法在书的其他部分中恰当放置的事物。除了第一个主题*数组*之外，`history`和`alias`在脚本编写的上下文中并不真正使用，因此我们选择在这里介绍它们。但首先是数组！
- en: Arrays
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'If you come from a developer background or have dabbled in programming, you
    will have (probably) come across the term *array*. If we needed to explain arrays
    in a single sentence, it would look like this: Arrays allow us to store a *collection
    of data* *of the same type*. To make this a little less abstract, we''ll show
    you how we can create an *array of strings* in Bash:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自开发背景或曾涉足编程，您可能已经遇到过*数组*这个术语。如果我们需要用一句话来解释数组，它会是这样的：数组允许我们存储*相同类型的数据*的*集合*。为了让这个概念不那么抽象，我们将向您展示如何在Bash中创建一个*字符串数组*：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this string array, we place four elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字符串数组中，我们放置了四个元素：
- en: This
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这
- en: is
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: an
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个
- en: array
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: 'If we want to print the string in the first place in the array, we need to
    specify that we want the *zeroth position* with the `echo ${array[0]}` syntax.
    Remember, as is common in IT, the first item in a list is often found at the 0th
    position. Now, look at what happens if we try to grab the fourth position, and
    thus the fifth value (that is not there):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要打印数组中第一个位置的字符串，我们需要使用`echo ${array[0]}`语法来指定我们想要的*零位置*。请记住，正如在IT中常见的那样，列表中的第一项通常在0位置找到。现在，看看如果我们尝试获取第四个位置，因此第五个值（不存在）会发生什么：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Weirdly enough, even though we're asking for the value in a position of the
    array that does not exist, Bash does not consider this an error. If you did the
    same in some programming languages, such as Java, you'd see an error akin to `**ArrayIndexOutOfBoundsException**`.
    As you can see after the exit status of `0`, if we want to print *all the values
    in the array*, we use the asterisk (as a wildcard).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，即使我们要求获取数组中不存在的位置的值，Bash也不认为这是一个错误。如果在某些编程语言中（如Java）中执行相同操作，你会看到类似`**ArrayIndexOutOfBoundsException**`的错误。如你所见，在`0`的退出状态之后，如果我们想要打印*数组中的所有值*，我们使用星号（作为通配符）。
- en: In our scripting example, to keep it a little simpler, we've used *whitespace
    delimited strings* when we needed to create a list (for reference, look at the
    script `**for-simple.sh**` from [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),* Conditional
    Testing and Scripting Loops* again). In our experience, for most purposes, this
    is often easier to work with and powerful enough. Should this not seem the case
    for your scripting challenges, however, remember that such a thing as arrays in
    Bash exist and that, perhaps, these might work for you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本示例中，为了使其更简单一些，当我们需要创建一个列表时，我们使用了*空格分隔的字符串*（参考脚本`**for-simple.sh**`，来自[第11章](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml)，*条件测试和脚本循环*）。根据我们的经验，对于大多数情况来说，这通常更容易使用并且足够强大。然而，如果对于您的脚本挑战来说似乎不是这种情况，请记住Bash中存在数组这样的东西，也许这对您有用。
- en: The history command
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史命令
- en: A very powerful and cool command in Bash is `history`. Simply put, by default,
    Bash *will store a history of all the commands you type*. These are saved up to
    a certain threshold, and for our Ubuntu 18.04 installation this is 1,000 commands
    *in memory* and 2,000 commands *on disk*. Every time you do a clean exit/logout
    of your terminal, Bash will write the command history from memory to disk, taking
    both limits into account.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中一个非常强大和酷的命令是`history`。简而言之，默认情况下，Bash *会存储您输入的所有命令的历史记录*。这些保存在一定的阈值内，对于我们的Ubuntu
    18.04安装来说，内存中保存了1,000个命令，磁盘上保存了2,000个命令。每次您干净地退出/注销终端时，Bash都会将内存中的命令历史记录写入磁盘，同时考虑这两个限制。
- en: 'Before we dive (a little) deeper, let''s take a look at our personal history
    for the `**reader**` user:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们来看看`**reader**`用户的个人历史记录：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even though our history is very interesting, it is not interesting enough to
    print it fully here. Often, if you use this in practice, it can easily become
    an overload of information as well. We suggest you use the `history` command in
    the following manners:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的历史非常有趣，但在这里完全打印出来并不那么有趣。通常，如果在实践中使用这个命令，它也很容易变成信息的过载。我们建议您以以下方式使用`history`命令：
- en: '`history | less`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history | less`'
- en: '`history | grep sed`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history | grep sed`'
- en: If you pipe it to `less`, you'll end up with a nice pager that you can scroll
    through leisurely and use the search function in. When you exit it using `**q**`,
    you will be back at your uncluttered Terminal. If you're looking for a specific
    command (such as `sed`), you could also pipe the output of `history` through the
    `grep` command to make a course filter. If that's still too rough, consider adding
    `| less` behind the `grep` to make use of the pager once again.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其传输到`less`，您将得到一个漂亮的分页器，可以轻松滚动并使用搜索功能。当您使用`**q**`退出时，您将回到整洁的终端。如果您正在寻找特定命令（例如`sed`），您还可以通过`grep`命令过滤`history`的输出。如果这仍然太粗糙，考虑在`grep`后面添加`|
    less`，再次使用分页器。
- en: 'The configuration for history is found in a few environment variables, which
    are often set in your `**~/.bashrc**` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 历史记录的配置可以在一些环境变量中找到，这些环境变量通常在您的`**~/.bashrc**`文件中设置：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, you see the two defaults we had already announced (and which, if you
    want, can be edited!). For the others, `man bash` will inform you about the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们已经宣布的两个默认值（如果需要，可以进行编辑！）。对于其他命令，`man bash`会告诉您以下内容：
- en: HISTCONTROL
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HISTCONTROL
- en: HISTFILE
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HISTFILE
- en: HISTTIMEFORMAT
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HISTTIMEFORMAT
- en: Be sure to give those a quick read. Do not underestimate how convenient the
    `history` command can be; you will most certainly find yourself *almost* remembering
    how you used a command before, and if you remember enough you can use `history`
    to find out what you did so you can do it again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要快速阅读一下。不要低估`history`命令的便利性；您肯定会*几乎*记得以前如何使用命令，如果您记得足够多，可以使用`history`找出您做了什么，以便再次执行。
- en: Creating your own aliases
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的别名
- en: 'Bash allows you to create your own aliases for commands. We''ve seen this introduced
    in [Chapter 14](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml), *Scheduling and Logging*,
    but for day-to-day tasks, it is worth exploring a little bit further. The syntax
    is pretty straightforward:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Bash允许您为命令创建自己的别名。我们已经在[第14章](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml) *调度和日志*中介绍过这一点，但对于日常任务来说，值得进一步探索一下。语法非常简单：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this syntax, `alias` is the command, `name` is how the `alias` will be called
    by you on the Terminal, and `value` is what is actually called when you call the
    `alias`. For interactive work, this could look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语法中，`alias`是命令，`name`是您在终端上调用`alias`时的名称，`value`是您调用`alias`时实际调用的内容。对于交互式工作，这可能看起来像下面这样：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We created the alias `message`, which actually does `echo "Hello world!"` for
    us when called. For those of you with a little bit more experience, you''ve no
    doubt been using the "command" `ll` for some time now. As you might (or might
    not) remember, this is a common default `alias`. We can print currently set aliases
    with the `-p` flag:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了别名`message`，当调用时实际上执行`echo "Hello world!"`。对于一些经验丰富的人来说，您无疑已经使用了"command" `ll`一段时间了。您可能（或可能不）记得，这是一个常见的默认`alias`。我们可以使用`-p`标志打印当前设置的别名：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, by default we have some aliases set and the one we just created
    is there as well. What is even more interesting, is the fact that we can use `alias`
    to *override a command*, such as `ls` above. All the times we used `ls` in the
    book''s examples, we''ve actually been executing `ls --color=auto`! The same goes
    for `grep`, as the print clearly shows. The `ll` alias quickly allows us to use
    common, almost essential flags for `ls`. However, you would do well to realize
    that these aliases are distribution-specific. Take a look at the `ll` alias on
    my Arch Linux host machine for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，默认情况下我们设置了一些别名，我们刚刚创建的别名也在其中。更有趣的是，我们可以使用`alias`来*覆盖一个命令*，比如上面的`ls`。在本书的示例中，我们使用`ls`的所有时间，实际上都在执行`ls
    --color=auto`！`grep`也是如此。`ll`别名快速允许我们使用`ls`的常见、几乎必要的标志。但是，您应该意识到这些别名是特定于发行版的。例如，看看我Arch
    Linux主机上的`ll`别名：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is different from our Ubuntu machine. At the very least, that begs the
    question: where are these default aliases set? If you remember our explanation
    about `**/etc/profile**`, `**/etc/bash.bashrc**`, `**~/.profile**`, and `**~/.bashrc**`
    (in [Chapter 14](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml), *Scheduling and
    Logging* ), we know that these files are the most likely candidates. From experience,
    you can expect most aliases to be in the `**~/.bashrc**` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的Ubuntu机器不同。至少，这引出了一个问题：这些默认别名是在哪里设置的？如果您记得我们在[第14章](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml)
    *调度和日志*中关于`**/etc/profile**`、`**/etc/bash.bashrc**`、`**~/.profile**`和`**~/.bashrc**`的解释，我们知道这些文件是最有可能的候选者。根据经验，您可以期望大多数别名在`**~/.bashrc**`文件中：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have commands that you often use, or flags that you would like to include
    "by default," you can edit your `**~/.bashrc**` file and add as many `alias` commands
    as you like. Any commands in the `.bashrc` file are run when you log in. If you
    want to make an alias available system-wide, the `**/etc/profile**` or `**/etc/bash.bashrc**`
    files would be better choices to include your `alias` command in. Otherwise, you'd
    have to edit the personal `.bashrc` files of all users, current and future (which
    is not efficient, so you shouldn't even consider this).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用某些命令或者想要默认包含某些标志，可以编辑您的`**~/.bashrc**`文件，并添加尽可能多的`alias`命令。`.bashrc`文件中的任何命令都会在您登录时运行。如果要使别名在整个系统范围内可用，最好将`alias`命令包含在`**/etc/profile**`或`**/etc/bash.bashrc**`文件中。否则，您将不得不编辑所有用户（当前和未来）的个人`.bashrc`文件（这是低效的，因此您甚至不应该考虑这一点）。
- en: Command-line shortcuts
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行快捷方式
- en: 'Besides the convenience of the commands in the first part of this chapter,
    there is another type of time-saver, which does not necessarily need to be discussed
    in the context of shell scripting, but is still such a great asset that we''d
    feel bad if we did not share it with you: command-line shortcuts.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章第一部分中命令的便利之外，还有另一种节省时间的方法，这不一定需要在shell脚本的上下文中讨论，但它仍然是一个很大的优势，我们觉得如果不与您分享，会感到很遗憾：命令行快捷方式。
- en: Fun with exclamation marks
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感叹号的乐趣
- en: 'Exclamations marks are normally used to give text some emphasis, but under
    Bash they are actually a `shell` keyword:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号通常用于强调文本，但在Bash下它们实际上是一个`shell`关键字：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the term "shell keyword" does not really give us a great indication of
    what it does, there are multiple things we can accomplish with the exclamation
    mark. One we have already seen: if we want to negate a `test`, we can supply the
    exclamation mark within the check. If you''d like to verify this on your Terminal,
    try the following with either `true` or `false`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语“shell关键字”并不能真正告诉我们它的作用，但感叹号可以实现多种功能。我们已经看到其中一个：如果我们想要否定一个“test”，我们可以在检查中使用感叹号。如果您想在终端上验证这一点，请尝试以下操作，使用`true`或`false`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the exclamation mark reverses the exit status: true becomes
    false, and false becomes true. Another cool feature of the exclamation mark is
    that a double exclamation mark will be substituted on the command line with the
    full previous command, like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，感叹号可以颠倒退出状态：true变为false，false变为true。感叹号的另一个很酷的功能是，双感叹号将在命令行中用完整的上一个命令替换，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To ensure you''re clear about what you''re repeating, the command is printed
    to stdout alongside the output of the command. What''s more, we can also choose
    which part of the command to repeat by using numbers and a colon in combination
    with an exclamation mark. As always, `0` is reserved for the first argument, `1`
    for the second, and so on. A good example of this is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您清楚地知道您正在重复什么，该命令将与命令的输出一起打印到stdout。而且，我们还可以通过使用数字和冒号与感叹号相结合来选择要重复的命令的哪一部分。与往常一样，`0`保留给第一个参数，`1`保留给第二个参数，依此类推。这方面的一个很好的例子如下：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding example shows that we used `**!:1**` to substitute the second
    word of the previous command. Note that if we repeat this for the `ls -l file`
    command, the second word is actually the `-l` flag of the `ls` command, so don't
    assume only full commands are parsed; this is a simple whitespace delimited index.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子显示，我们使用`**!:1**`来替换上一个命令的第二个单词。请注意，如果我们对`ls -l file`命令重复此操作，第二个单词实际上是`ls`命令的`-l`标志，因此不要假设只有完整的命令被解析；这是一个简单的空格分隔的索引。
- en: 'There is one killer feature with exclamation marks, as far as we''re concerned:
    the `!$` construct. It is the same type of substitution, and as you might guess
    from how `**$**` works in `vim`, it substitutes the last word of the previous
    command. While this might not seem like that big a deal, take a look at how often
    the last word of the previous command is something you can reuse:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，感叹号的一个杀手功能是`!$`构造。这是相同类型的替换，正如您可能从`vim`中`**$**`的工作方式猜到的那样，它会替换上一个命令的最后一个单词。虽然这可能看起来不是那么重要，但看看上一个命令的最后一个单词有多少次是可以重用的：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or, when copying a file you want to edit:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当复制要编辑的文件时：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you start using it in practice, you'll find that this trick applies to
    so many commands that it will start saving you time almost immediately. In these
    examples, the names were short, but if we're talking long pathnames, we'd either
    have to take our hands away from the keyboard to do a copy/paste with the help
    of our mouse, or type everything again. And why would you, when a simple `**!$**`
    does the trick?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始在实践中使用它，您会发现这个技巧几乎可以适用于许多命令，它几乎立即就会为您节省时间。在这些示例中，名称很短，但是如果我们谈论长路径名，我们要么必须将手从键盘上拿开，用鼠标复制/粘贴，要么重新输入所有内容。当一个简单的`**!$**`就能解决问题时，您为什么要这样做呢？
- en: 'In the same way this can quickly become a lifesaver, there is one extremely
    good example of when to use `**!!**`. Take a look at the following situation,
    which everyone has encountered or will encounter sooner or later:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这可以迅速成为一个救命稻草，有一个极好的例子可以说明何时使用`**!!**`。看看以下每个人都遇到过或迟早会遇到的情况：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you forget to add a `sudo` in front of your command (because it is a privileged
    command or manipulates a privileged file), you can either:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当您忘记在命令前添加`sudo`（因为它是特权命令或操作特权文件）时，您可以选择：
- en: Type the whole command again
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次输入整个命令
- en: Copy and paste the command using the mouse
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标复制并粘贴命令
- en: Use the up arrow, followed by the Home key, and type `sudo`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上箭头，然后按Home键，输入`sudo`
- en: Or simply type `sudo !!`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者只需键入`sudo !!`
- en: 'It should be clear which is the shortest and easiest, and thus has our preference.
    Do realize that with this simplicity also comes responsibility: if you try to
    remove files you should not remove, and you''re quickly using `sudo !!` without
    fully thinking it through, your system could be gone in an instant. The warning
    still stands: when interacting as `**root**` or with `sudo`, always think twice
    before running a command.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显哪个是最短和最容易的，因此我们更倾向于使用它。要意识到，这种简单性也意味着责任：如果您尝试删除不应删除的文件，并且在没有充分考虑的情况下迅速使用`sudo
    !!`，您的系统可能会立即消失。警告仍然存在：在以`**root**`或`sudo`身份交互时，运行命令之前一定要三思。
- en: Running commands from the history
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从历史记录中运行命令
- en: 'The final thing we find noteworthy to describe in regards to exclamation marks
    is interacting with the history. As you learned just a few pages ago, the history
    saves your commands. With the exclamation mark, you can quickly run commands from
    your history: either by supplying the number of the command (for example, `!100`)
    or by entering part of the command (for example: `!ls`). In our experience, these
    functions are not used as much as the *reverse search* we''ll explain shortly,
    but it is still good to be aware of this functionality.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现与感叹号相关的最值得注意的最后一件事是与历史记录的交互。就像您在几页前学到的那样，历史记录保存了您的命令。使用感叹号，您可以快速从历史记录中运行命令：可以通过提供命令的编号（例如`!100`）或输入命令的一部分（例如：`!ls`）来运行。根据我们的经验，这些功能并没有像我们即将解释的*反向搜索*那样经常使用，但了解这个功能仍然是很好的。
- en: 'Let''s take a look at how this looks in practice:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是什么样子：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By supplying the number, `!1100` ran the command `date` again. You should realize
    that the history, once it reaches its maximum, will change. The command that is
    today equal to `!1100` might next week be a different command altogether. In practice,
    this is considered a risky move and is often best avoided, because you do not
    get a confirmation: you see what is being executed, while it is running (or probably,
    it is done by the time you have seen what you ran). You can only be sure if you
    check the history first, and in that case you''re not saving any time, only using
    extra.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供数字，`!1100`再次运行了`date`命令。你应该意识到，一旦历史记录达到最大值，它将会改变。今天等于`!1100`的命令可能下周会完全不同。实际上，这被认为是一种冒险的举动，通常最好避免，因为你不会得到确认：你看到正在执行的内容，当它正在运行时（或者可能是在你看到你运行的内容时已经完成）。只有在检查历史记录后，你才能确定，而在这种情况下，你并没有节省任何时间，只是使用了额外的时间。
- en: What is interesting, though, is repeating a command based on the command itself,
    such as `!ls` shows. It is still somewhat risky, especially if used in combination
    with destructive commands such as `rm`, but if you're sure what the last command
    was that matches your exclamation mark query, you should be relatively safe (especially
    for nondestructive commands such as `cat` or `ls`). Again, before you start incorporating
    this practice into your daily life, be sure to keep reading until we've explained
    reverse searching. At that point, we expect/hope that those are much more interesting
    to you, and then you can file away the information here as *good to know*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的是，基于命令本身重复一个命令，比如`!ls`显示的。这仍然有些冒险，特别是如果与`rm`等破坏性命令结合使用，但如果你确定最后一个与感叹号查询匹配的命令是什么，你应该相对安全（特别是对于`cat`或`ls`等非破坏性命令）。再次，在你开始将这种做法融入到你的日常生活之前，一定要确保继续阅读，直到我们解释了反向搜索。在那时，我们期望/希望这些对你来说更有趣，然后你可以把这里的信息存档为*好知识*。
- en: Keyboard shortcuts
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘快捷键
- en: 'The next class of shortcuts we want to discuss is *keyboard shortcuts*. In
    contrast to the previous commands and shell keywords, these are simply key combinations
    that modify things on the command line. The combinations we''re discussing all
    work by using the *CTRL* key as a modifier: you hold down *CTRL* and press another
    key, for example the *t*. We''ll describe this as *CTRL+t*, as we have done in
    the rest of the book as well. Speaking of `**CTRL+t**`, this is actually the first
    shortcut we''d like to address! You can use `CTRL+t` when you''ve made a *typo*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的下一个快捷方式类别是*键盘快捷键*。与之前的命令和shell关键字相比，这些只是修改命令行上的事物的键盘组合。我们要讨论的组合都是通过使用*CTRL*键作为修饰符来工作的：你按住*CTRL*键，然后按下另一个键，例如*t*。我们将像在本书的其余部分一样描述这个为*CTRL+t*。说到`**CTRL+t**`，这实际上是我们想要讨论的第一个快捷键！当你打错字时，你可以使用`CTRL+t`：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because the terminal is modified, it is kind of hard to get an accurate representation
    for these pages. We''ve included a comment between the lines, to show what we
    do and what changes when we do it. However, in your Terminal, you will only ever
    see one line. Go ahead and try it out. By pressing *CTRL+t*, you can swap the
    last two characters around as often as you''d like. Do note that it takes whitespace
    into account as well: if you''ve already pressed the spacebar, you''ll swap the
    whitespace with the last letter, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于终端被修改，很难准确地表示这些页面。我们在行之间包含了一条注释，以显示我们做了什么以及我们做了什么改变。然而，在你的终端中，你只会看到一行。试一试吧。通过按下*CTRL+t*，你可以随意交换最后两个字符。请注意，它也考虑了空格：如果你已经按下了空格键，你将会交换空格和最后一个字母，就像这样：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you start using this shortcut, you will soon realize that swapping two letters
    is a much more common occurrence than you might initially expect. As with most
    things in Bash, this functionality is present because people use it, so you do
    not need to feel bad about yourself if this happens to you a bit too often! At
    least with this shortcut, you'll be able to mitigate the errors quickly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始使用这个快捷键，你很快就会意识到交换两个字母比你最初期望的要常见得多。与Bash中的大多数事物一样，这个功能之所以存在是因为人们使用它，所以如果这对你来说发生得太频繁，你不需要为自己感到难过！至少有了这个快捷键，你可以快速地减轻错误。
- en: 'Next up is the `**CTRL+l**` shortcut (lowercase *L*), which is actually a shortcut
    for a command: `clear`. The functionality of clear is almost as simple as the
    name of the command: `clear` - *clear the terminal screen* (from `man clear`).
    This is actually a shortcut (and by extension, a command) that we use extensively
    for every Terminal session. As soon as you get to the *bottom* of your Terminal
    emulator screen, with a lot of clutter above, you might notice this isn''t as
    nice to work with as the empty Terminal you start with (our personal opinion,
    perhaps shared by you). If you want to clear this up, you can either use the *CTRL+l*
    shortcut, or simply type the command `clear`. When you clear your Terminal, the
    output is not gone: you can always scroll up (often via mouse wheel or *SHIFT+page-up*)
    to see what was cleared. But at least your cursor is on a nice, clean screen at
    the top!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`**CTRL+l**`快捷键（小写的*L*），实际上是一个命令的快捷键：`clear`。clear的功能几乎和命令的名字一样简单：`clear`
    - *清除终端屏幕*（来自`man clear`）。这实际上是一个我们在每个终端会话中广泛使用的快捷键（以及命令）。一旦你到达终端仿真器屏幕的*底部*，上面有很多混乱，你可能会注意到这不像你开始时的空终端那样好用（我们的个人意见，也许你也有同感）。如果你想清理这些，你可以使用*CTRL+l*快捷键，或者简单地输入`clear`命令。当你清除终端时，输出并没有消失：你可以随时向上滚动（通常通过鼠标滚轮或*SHIFT+page-up*）来查看被清除的内容。但至少你的光标在一个干净的屏幕顶部！
- en: 'There is also a shortcut for the `exit` command, `**CTRL+d**`. Not only does
    this work great for when you want to *exit an SSH session*, but it works for many
    other interactive prompts as well: a great example for this is `at` (in reality,
    you *need* to use *CTRL+d* to exit from the `at` prompt, as `exit` will just be
    interpreted as a command to run!). As you know, `**CTRL+c**` sends a cancel to
    a running command (technically a SIGINT, as there are many intensities of cancel/kill
    under Linux), so be sure not to confuse *CTRL+d* with *CTRL+c*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`exit`命令的快捷键，`**CTRL+d**`。这不仅适用于*退出SSH会话*，还适用于许多其他交互提示：一个很好的例子是`at`（实际上，你*需要*使用*CTRL+d*来退出`at`提示，因为`exit`将被解释为一个要运行的命令！）。正如你所知，`**CTRL+c**`发送一个取消到正在运行的命令（在Linux下有许多取消/终止的强度，技术上是一个SIGINT），所以一定不要混淆*CTRL+d*和*CTRL+c*。
- en: 'With regards to navigation, there are two CTRL-based shortcuts which are often
    easier to reach than their alternatives: `**CTRL+e**` and `**CTRL+a**`. `**CTRL+e**`
    moves the cursor to the end of the line, in a similar way to what the END key
    accomplishes. As you might expect, `**CTRL+a**` does the reverse: it functions
    as an alternative to the HOME key. Especially for those of you that are proficient
    in touch typing, these shortcuts are faster than moving your right hand away from
    the home row to find the *END*/*HOME* keys.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导航，有两个基于CTRL的快捷键通常比它们的替代方案更容易到达：`**CTRL+e**`和`**CTRL+a**`。`**CTRL+e**`将光标移动到行的末尾，类似于END键的功能。正如你所期望的，`**CTRL+a**`则相反：它作为HOME键的替代功能。特别是对于那些熟练使用触摸打字的人来说，这些快捷键比将右手移开主键行找到*END*/*HOME*键更快。
- en: Copying and pasting from the terminal
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从终端复制和粘贴
- en: A very common thing to do with GUI-based systems is cutting and pasting text.
    You'll select text, often with the mouse, and either use the right mouse button
    to copy and paste, or hopefully you've found the good old `**CTRL+c**` and `**CTRL+v**`
    (for Windows, Command key for macOS). As we explained before and reminded you
    of two paragraphs ago, *CTRL+c* under Linux is definitely not a *copy*, but a
    *cancel*. Similarly, *CTRL+v* will most likely not paste text either. So, how
    then, under Linux, do we copy and paste?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于GUI的系统中，常见的事情是剪切和粘贴文本。你会选择文本，通常用鼠标，然后要么使用右键复制和粘贴，或者希望你已经找到了老式的`**CTRL+c**`和`**CTRL+v**`（对于Windows，macOS的Command键）。正如我们之前解释过并在两段前提醒过你的，Linux下的*CTRL+c*绝对不是*复制*，而是*取消*。同样，*CTRL+v*也很可能不会粘贴文本。那么，在Linux下，我们如何复制和粘贴呢？
- en: 'First of all, if you''re using SSH and a Terminal emulator from within a GUI
    desktop, you have the right mouse button available to accomplish this (or, if
    you''re feeling really fancy, pressing the middle mouse button often defaults
    to paste as well!). You can select text from somewhere on the internet, for example,
    copy it, and paste it into your Terminal emulator with either button. However,
    we always strive to optimize our processes, and as soon as you need to grab the
    mouse, you''re losing valuable time. For text you have already copied, there is
    (for most Terminal emulators!) a shortcut to paste: `**SHIFT+insert**`. Just so
    you know, this paste shortcut is not limited to Linux or most Terminal emulators:
    it seems to be pretty universal, working on Windows and Linux with GUIs as well.
    Personally, we have replaced *CTRL+v* almost completely with *SHIFT+insert* for
    our pasting needs.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你正在使用SSH和GUI桌面内的终端仿真器，你可以使用右键来完成这个操作（或者，如果你感觉非常高级，按下中键通常也默认为粘贴！）。你可以从互联网上的某个地方选择文本，例如，复制它，并用任一按钮粘贴到你的终端仿真器中。然而，我们总是努力优化我们的流程，一旦你需要抓住鼠标，你就会浪费宝贵的时间。对于你已经复制的文本，（对于大多数终端仿真器！）有一个快捷键可以粘贴：`**SHIFT+insert**`。只是让你知道，这个粘贴快捷键不仅限于Linux或大多数终端仿真器：它似乎是相当通用的，在Windows和带有GUI的Linux上也可以工作。就我们个人而言，我们几乎完全用*SHIFT+insert*替代了*CTRL+v*来满足我们的粘贴需求。
- en: 'Obviously, if we can paste in this manner, there must also be a similar way
    for copying. This is very similar: instead of *SHIFT+insert*, copying can be done
    with `**CTRL+insert**`. Again, this is not limited to Linux or Terminals: it works
    just fine on Windows as well. For those of us working with Linux and Windows,
    replacing *CTRL+c* and *CTRL+v* with *CTRL+insert* and *SHIFT+insert* ensures
    that we are always properly copying and pasting, no matter what environment we''re
    working in. Personally, we use Linux at home but Windows at work, which means
    our time is spent about 50/50 between the operating systems: trust us, it is very
    nice to have shortcuts that always work!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们可以以这种方式粘贴，那么也一定有一种类似的复制方式。这非常类似：复制可以用`**CTRL+insert**`来完成。同样，这不仅限于Linux或终端：在Windows上也可以很好地工作。对于我们这些在Linux和Windows上工作的人来说，用*CTRL+insert*和*SHIFT+insert*替换*CTRL+c*和*CTRL+v*确保我们无论在哪种环境下都能正确地复制和粘贴。就我们个人而言，我们在家里使用Linux，但在工作中使用Windows，这意味着我们的时间大约50/50地花在操作系统上：相信我们，总是能够正常工作的快捷键非常好！
- en: 'Now, the method above still sort of relies on having a mouse. Most of the time
    (think more than 95%, depending on your job) this will be the case, but sometimes
    you will simply not have a mouse (when connected directly to a Terminal of a server
    in a data center, for example). Fortunately for us, there are three shortcuts
    that work in Bash and will allow us to cut and paste directly on the command line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上面的方法仍然有点依赖于鼠标。大多数情况下（根据你的工作，可能超过95%），这是成立的，但有时你可能根本没有鼠标（例如，当直接连接到数据中心的服务器的终端时）。幸运的是，Bash中有三个快捷键可以让我们在命令行上直接剪切和粘贴：
- en: '`**CTRL+w**`: Cut the word before the cursor'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**CTRL+w**`：剪切光标前的单词'
- en: '`**CTRL+u**`: Cut everything on the line before the cursor'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**CTRL+u**`：剪切光标前的整行'
- en: '`**CTRL+y**`: Paste everything that was cut (using the two commands above,
    not the general OS clipboard!)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**CTRL+y**`：粘贴所有被剪切的内容（使用上面的两个命令，而不是一般的操作系统剪贴板！）'
- en: 'Besides being able to cut and paste, *CTRL+w* is also great to remove a single
    whole word from the command line. Look at the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够剪切和粘贴，*CTRL+w*也非常适合从命令行中删除一个完整的单词。看下面的例子：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Something that tends to happen is giving an incorrect final argument to a command.
    If you want to revise this real quickly, a simple *up-arrow* followed by a *CTRL+w*
    will place the previous command minus the final argument back on your Terminal.
    Now, you just have to give it the correct argument to run it again. Alternatively,
    you could either:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发生的一件事是给命令提供一个不正确的最终参数。如果你想快速修改这个问题，只需简单地按一下*向上箭头*，然后按*CTRL+w*，就会将上一个命令减去最终参数的部分重新放回终端。现在，你只需要给它正确的参数再次运行。或者，你也可以：
- en: Retype the whole command
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新输入整个命令
- en: Scroll, copy and paste using the mouse
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标滚动、复制和粘贴
- en: '*Up-arrow* followed by a number of backspaces'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向上箭头*后跟一些退格键'
- en: In our experience, a double keystroke is always faster than all other possible
    solutions. Only if the last argument was a single character would using *up-arrow*
    and *backspace* be *equally fast*, which is kind of a stretch.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，双击键总是比所有其他可能的解决方案更快。只有最后一个参数是单个字符时，使用*向上箭头*和*退格键*才会*同样快*，这有点牵强。
- en: 'Now, in the previous example, we did not actually only *remove* the final argument,
    we actually *cut* it. When you cut an argument, it gives you the ability to *paste*
    it back again. As stated, this is a Bash-specific clipboard which is not tied
    to the system clipboard; while you might think that paste is always done with
    *SHIFT+insert*, in this case we use *CTRL+y* for the Bash-specific clipboard.
    The best example to show this is with a full line cut, using `**CTRL+u**`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的例子中，我们实际上并不只是*删除*最终参数，我们实际上是*剪切*它。当你剪切一个参数时，它会给你重新*粘贴*的能力。正如所述，这是一个特定于Bash的剪贴板，它不与系统剪贴板绑定；虽然你可能认为粘贴总是用*SHIFT+insert*完成，但在这种情况下，我们使用*CTRL+y*来操作Bash特定的剪贴板。最好的例子是使用`**CTRL+u**`来剪切整行：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is, for us, a typical scenario in which we are one step ahead of ourselves.
    We have already typed a command we need to execute, but before we press *ENTER*
    we realize we forgot to do something that needs to be done before our current
    command can succeed. In this scenario, we use `**CTRL+u**` to cut the entire command,
    continue with the prerequisite command, and when we're ready we paste the line
    with `**CTRL+y**` again. Again, you might think this will not happen to you, but
    you might be surprised at how often you will encounter this precise pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这是一个典型的情况，我们比自己提前了一步。我们已经输入了一个需要执行的命令，但在按下*ENTER*之前，我们意识到我们忘记了在我们当前的命令成功之前需要做一些事情。在这种情况下，我们使用`**CTRL+u**`来剪切整个命令，继续进行先决条件命令，当我们准备好时再次粘贴该行使用`**CTRL+y**`。再次强调，你可能认为这不会发生在你身上，但你可能会惊讶地发现你会经常遇到这种精确的模式。
- en: Reverse search
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向搜索
- en: 'As far as keyboard shortcuts go, we believe we have saved the best for last.
    Out of all the time-savers we have so far introduced, this is by far the coolest
    as far as we''re concerned: *reverse searching*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就键盘快捷键而言，我们认为我们已经为最后留下了最好的。在我们迄今介绍的所有节省时间的方法中，这绝对是我们认为最酷的：*反向搜索*。
- en: 'A reverse search allows you to go back through your history, and search for
    a string within your executed commands. You can think of this as similar to `history
    | grep cat`, but much more interactive and much faster. To enter the reverse search
    prompt, the keys `**CTRL+r**` are used:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 反向搜索允许你浏览历史记录，并在执行的命令中搜索字符串。你可以将其视为类似于`history | grep cat`，但更加交互和更快。要进入反向搜索提示，使用键`**CTRL+r**`：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Please go ahead and give it a try. It is hard to get these interactive prompts
    down on paper, so we hope the comments above give a good indication of how a reverse
    search works. You can reverse search all the way up to the beginning of your history.
    If, at that point, you press *CTRL+r* again, you''ll see something like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试一下。很难将这些交互式提示记录下来，所以我们希望上面的注释能很好地说明反向搜索的工作原理。你可以一直反向搜索到历史记录的开头。如果在那时，你再次按下*CTRL+r*，你会看到类似以下的内容：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This signifies to you that there are no more matches for reverse search to find.
    At this point, or before if you think you're taking too long, you can always press
    *CTRL+c* to stop reverse searching.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这向你表明没有更多的匹配项供反向搜索查找。在这一点上，或者在你认为花费的时间太长之前，你可以随时按下*CTRL+c*来停止反向搜索。
- en: 'By contrast with the `!ls` syntax, reverse search will not start looking for
    the keywords only from the beginning of the line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`!ls`语法相比，反向搜索不会从行的开头开始查找关键词：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means that it is both more powerful (it just matches anywhere in the command)
    and more complicated to use (it does not match just the command). However, if
    you''re smart about this and you just want commands, you can always use a well-placed
    whitespace to make sure situations like the example above do not happen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它更强大（它只是匹配命令中的任何位置）并且更复杂（它不仅匹配命令）。然而，如果你对此很聪明，你只想要命令，你总是可以巧妙地使用空格来确保不会发生像上面的例子那样的情况：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While we'd love to talk more about reverse searching, the only true way for
    you to learn it properly is to start using it. Rest assured, if you get proficient
    in its use (and also know when to stop searching and just type in the command
    you're looking for), you'll be sure to impress your peers with your efficient
    Terminal work!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们很乐意更多地谈论反向搜索，但你真正学会它的唯一方法是开始使用它。放心，如果你熟练地使用它（并且知道何时停止搜索，直接输入你要找的命令），你一定会以你高效的终端工作给同行留下深刻印象！
- en: Cheat sheet for interactive commands
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式命令的速查表
- en: We're going to end this book with a simple cheat sheet used for interactive
    commands. Getting proficient in Bash is a matter of practice. However, over the
    years, we have found ourselves stumbling upon new ways to use commands, or flags
    we weren't aware of, that made our lives much easier. Even during the writing
    of this book, we encountered things we did not know about before that were pretty
    helpful. In the process of writing about commands and constructs, you are looking
    more closely at manual pages and resources than you do when you're simply using
    them in your day-to-day business.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个简单的交互命令备忘单结束这本书。熟练掌握Bash是一个练习的问题。然而，多年来，我们发现自己偶然发现了使用命令的新方法，或者我们不知道的标志，这使我们的生活变得更加轻松。即使在写这本书的过程中，我们也遇到了以前不知道的东西，这些东西非常有帮助。在写命令和结构的过程中，您比在日常业务中使用它们时更仔细地查看手册页面和资源。
- en: Please take advantage of these cheat sheets, as they include not only the basic
    syntax but also flags and tips we think are great to know about (we wish we'd
    found them earlier in our career)!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请充分利用这些备忘单，因为它们不仅包括基本的语法，还包括我们认为很重要的标志和提示（我们希望我们在职业生涯的早期就发现了它们）！
- en: 'Out of scope for these cheat sheets are things such as find/locate, redirection,
    tests, and loops: these have (hopefully) been adequately described in their own
    respective chapters.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些备忘单不包括诸如find/locate、重定向、测试和循环之类的内容：这些内容在它们各自的章节中已经得到了充分的描述（希望如此）。
- en: Navigation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: These commands are used for navigation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令用于导航。
- en: cd
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cd
- en: '| **Description** | Change the shell working directory. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改shell工作目录。 |'
- en: '| **Syntax** | cd [dir] |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | cd [dir] |'
- en: '| **Practical uses** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`cd`: Navigate to the home directory (as specified in HOME).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`：导航到主目录（如在HOME中指定）。'
- en: '`cd -`: Navigate back to the previous directory (as saved in OLDPWD).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd -`：导航回上一个目录（保存在OLDPWD中）。'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ls
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ls
- en: '| **Description** | List directory contents. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 列出目录内容。 |'
- en: '| **Syntax** | ls [OPTION]... [FILE]... |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | ls [选项]... [文件]... |'
- en: '| **Practical uses** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`ls -a`: Do not ignore entries starting with dots (. and ..).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -a`：不要忽略以点（.和..）开头的条目。'
- en: '`ls -l`: Use a long listing format.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -l`：使用长列表格式。'
- en: '`ls -h`: With `-l` and/or `-s`, print human readable sizes (for example, 1K
    234M 2G).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -h`：与`-l`和/或`-s`一起，打印人类可读的大小（例如，1K 234M 2G）。'
- en: '`ls -R`: List subdirectories recursively.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -R`：递归列出子目录。'
- en: '`ls -S`: Sort by file size, largest first.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -S`：按文件大小排序，从大到小。'
- en: '`ls -t`: Sort by modification time, newest first.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -t`：按修改时间排序，最新的排在前面。'
- en: '`ls -ltu`: Sort by, and show, access time.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -ltu`：按访问时间排序并显示。'
- en: '`ls -Z`: Print any security context of each file.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -Z`：打印每个文件的安全上下文。'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: pwd
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pwd
- en: '| **Description** | Print name of current/working directory. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 打印当前/工作目录的名称。 |'
- en: '| **Syntax** | pwd [OPTION]... |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | pwd [选项]... |'
- en: File manipulation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: These commands are used for file manipulation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令用于文件操作。
- en: cat
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猫
- en: '| **Description** | Concatenate files and print on the standard output. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 连接文件并打印到标准输出。 |'
- en: '| **Syntax** | cat [OPTION]... [FILE]... |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | cat [选项]... [文件]... |'
- en: '| **Practical uses** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`cat` or `cat -`: With no FILE, or when FILE is -, read standard input.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`猫`或`猫-`：没有文件，或者文件是-，读取标准输入。'
- en: '`cat -n`: Number all output lines.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat -n`：对所有输出行编号。'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: less
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: less
- en: '| **Description** | Page through text one screen at a time using a pager. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 使用分页器逐屏查看文本。 |'
- en: '| **Syntax** | less [OPTION]... [FILE]... |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | less [选项]... [文件]... |'
- en: '| **Practical uses** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`less -S`: Chop long lines. Lines do not wrap around, but can be seen with
    the left-right arrow keys.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less -S`：截断长行。行不换行，但可以用左右箭头键看到。'
- en: '`less -N`: Show line numbers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less -N`：显示行号。'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: touch
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: touch
- en: '| **Description** | Change file timestamps and/or create empty files. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改文件时间戳和/或创建空文件。 |'
- en: '| **Syntax** | touch [OPTION]... FILE... |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | touch [选项]... 文件... |'
- en: '| **Practical uses** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`touch <non-existent-file>`: Create an empty file.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch <不存在的文件>`：创建一个空文件。'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: mkdir
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mkdir
- en: '| **Description** | Make directories. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 创建目录。 |'
- en: '| **Syntax** | mkdir [OPTION]... DIRECTORY... |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | mkdir [选项]... 目录... |'
- en: '| **Practical uses** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`mkdir -m750 <dirname>`: Create directory with specified octal permissions.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir -m750 <dirname>`：创建具有指定八进制权限的目录。'
- en: '`mkdir -Z`: Set SELinux security context of each created directory to the default
    type.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir -Z`：将每个创建的目录的SELinux安全上下文设置为默认类型。'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: cp
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cp
- en: '| **Description** | Copy files and directories. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 复制文件和目录。 |'
- en: '| **Syntax** | cp [OPTION]... SOURCE... DIRECTORY |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | cp [选项]... 源... 目录 |'
- en: '| **Practical uses** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`cp -a`: Archive mode, preserve all permissions, links, attributes and so on.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -a`：归档模式，保留所有权限、链接、属性等。'
- en: '`cp -i`: Prompt before overwrite (overrides a previous `-n` option).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -i`：覆盖前提示（覆盖以前的`-n`选项）。'
- en: '`cp -r` and `cp -R`: Copy directories recursively.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -r`和`cp -R`：递归复制目录。'
- en: '`cp -u`: Copy only when the SOURCE file is newer than the destination file
    or when the destination file is missing.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -u`：仅在源文件比目标文件新或目标文件丢失时复制。'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: rm
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rm
- en: '| **Description** | Remove files or directories. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 删除文件或目录。 |'
- en: '| **Syntax** | rm [OPTION]... [FILE]... |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | rm [选项]... [文件]... |'
- en: '| **Practical uses** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`rm -f`: Ignore nonexistent files and arguments, never prompt.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -f`：忽略不存在的文件和参数，不要提示。'
- en: '`rm -i`: Prompt before every removal.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -i`：每次删除前提示。'
- en: '`rm -I` (capital i): Prompt once before removing more than three files, or
    when removing recursively; less intrusive than -i, while still giving protection
    against most mistakes.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -I`（大写i）：在删除三个以上的文件或递归删除时提示一次；比-i少侵入，同时仍然提供对大多数错误的保护。'
- en: '`rm -r` and `rm -R`: Remove directories and their contents recursively.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -r`和`rm -R`：递归删除目录及其内容。'
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: mv
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mv
- en: '| **Description** | Move (rename) files. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 移动（重命名）文件。 |'
- en: '| **Syntax** | mv [OPTION]... SOURCE... DIRECTORY |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | mv [选项]... 源... 目录 |'
- en: '| **Practical uses** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`mv -f`: Do not prompt before overwriting.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv -f`: 在覆盖之前不提示。'
- en: '`mv -n`: Do not overwrite an existing file.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv -n`: 不覆盖现有文件。'
- en: '`mv -u`: Move only when the SOURCE file is newer than the destination file
    or when the destination file is missing.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv -u`: 仅在源文件新于目标文件或目标文件丢失时移动。'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ln
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ln
- en: '| **Description** | Make links between files. Defaults to hard links. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 在文件之间创建链接。默认为硬链接。 |'
- en: '| **Syntax** | ln [OPTION]... [-T] TARGET LINK_NAME |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | ln [OPTION]... [-T] TARGET LINK_NAME |'
- en: '| **Practical uses** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`ln -s`: Make symbolic links instead of hard links.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ln -s`: 创建符号链接而不是硬链接。'
- en: '`ln -i`: Prompt whether to remove destinations.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ln -i`: 提示是否删除目标。'
- en: '|'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: head
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: head
- en: '| **Description** | Output the first part of files. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 输出文件的第一部分。 |'
- en: '| **Syntax** | head [OPTION]... [FILE]... |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | head [OPTION]... [FILE]... |'
- en: '| **Practical uses** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`head`: Print the first 10 lines of each FILE to standard output.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`: 将每个文件的前10行打印到标准输出。'
- en: '`head -n20` or `head -20`: Print the first NUM lines instead of the first 10.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head -n20`或`head -20`: 打印前NUM行而不是前10行。'
- en: '`head -c20`: Print the first NUM bytes of each file.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head -c20`: 打印每个文件的前NUM个字节。'
- en: '`head -q`: Never print headers giving file names.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head -q`: 永远不打印给出文件名的标题。'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: tail
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tail
- en: The `tail` command has the same options as `head`, but as seen from the end
    of the file instead of the beginning.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`命令与`head`具有相同的选项，但是从文件末尾而不是开头看到。'
- en: '| **Description** | Output the last part of files. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 输出文件的最后部分。 |'
- en: '| **Syntax** | tail [OPTION]... [FILE]... |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | tail [OPTION]... [FILE]... |'
- en: Permissions and ownership
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限和所有权
- en: These commands are used for permission and ownership manipulation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令用于权限和所有权操作。
- en: chmod
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chmod
- en: '| **Description** | Change file mode bits. Can be specified as either rwx or
    octal mode. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改文件模式位。可以指定为rwx或八进制模式。 |'
- en: '| **Syntax** | chmod [OPTION]... OCTAL-MODE FILE... |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | chmod [OPTION]... OCTAL-MODE FILE... |'
- en: '| **Practical uses** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`chmod -c`: Like verbose but report only when a change is made.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod -c`: 像verbose，但仅在更改时报告。'
- en: '`chmod -R`: Change files and directories recursively.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod -R`: 递归更改文件和目录。'
- en: '`chmod --reference=RFILE`: Copy the mode from a reference file.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod --reference=RFILE`: 从参考文件复制模式。'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: umask
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: umask
- en: '| **Description** | Set file mode creation mask. Since this is a *mask*, it
    is the reverse of a normal octal mode. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 设置文件模式创建掩码。由于这是*掩码*，因此与正常的八进制模式相反。 |'
- en: '| **Syntax** | umask [octal-mask] |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | umask [octal-mask] |'
- en: chown
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chown
- en: '| **Description** | Change file owner and group. Only executable with root
    permissions. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改文件所有者和组。仅在具有root权限时可执行。 |'
- en: '| **Syntax** | chown [OPTION]... [OWNER][:[GROUP]] FILE... |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | chown [OPTION]... [OWNER][:[GROUP]] FILE... |'
- en: '| **Practical uses** |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`chown user: <file>`: Change ownership to the user and their default group.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown user: <file>`: 更改所有权为用户和他们的默认组。'
- en: '`chown -c`: Like verbose, but report only when a change is made.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown -c`: 像verbose，但仅在更改时报告。'
- en: '`chown --reference=RFILE`: Copy the ownership from a reference file.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown --reference=RFILE`: 从参考文件复制所有权。'
- en: '`chown -R`: Operate on files and directories recursively.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown -R`: 递归操作文件和目录。'
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: chgrp
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chgrp
- en: '| **Description** | Change group ownership. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改组所有权。 |'
- en: '| **Syntax** | chgrp [OPTION]... GROUP FILE... |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | chgrp [OPTION]... GROUP FILE... |'
- en: '| **Practical uses** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`chgrp -c`: Like verbose, but report only when a change is made.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chgrp -c`: 像verbose，但仅在更改时报告。'
- en: '`chgrp --reference=RFILE`: Copy the group ownership from a reference file.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chgrp --reference=RFILE`: 从参考文件复制组所有权。'
- en: '`chgrp -R`: Operate on files and directories recursively.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chgrp -R`: 递归操作文件和目录。'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: sudo
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sudo
- en: '| **Description** | Execute a command as another user. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 以另一个用户的身份执行命令。 |'
- en: '| **Syntax** | sudo [OPTION]... |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | sudo [OPTION]... |'
- en: '| **Practical uses** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`sudo -i`: Become the root user.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo -i`: 成为根用户。'
- en: '`sudo -l`: List the allowed (and forbidden) commands for the invoking user.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo -l`: 列出调用用户允许（和禁止）的命令。'
- en: '`sudo -u <user> <command>`: Run a <command> as the specified <user>.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo -u <user> <command>`: 以指定的<user>身份运行<command>。'
- en: '`sudo -u <user> -i`: Login as the specified <user>.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo -u <user> -i`: 以指定的<user>登录。'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: su
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: su
- en: '| **Description** | Change user ID or become superuser. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 更改用户ID或成为超级用户。 |'
- en: '| **Syntax** | su [options] [username] |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | su [options] [username] |'
- en: '| **Practical uses** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`sudo su -`: Switch to root user. Requires sudo, optionally with your own password.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo su -`: 切换到root用户。需要sudo，可以选择使用自己的密码。'
- en: '`su - <user>`: Switch to <user>. Requires password entry for <user>.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`su - <user>`: 切换到<user>。需要<user>的密码输入。'
- en: '|'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: useradd
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useradd
- en: '| **Description** | Create a new user or update default new user information.
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 创建新用户或更新默认新用户信息。 |'
- en: '| **Syntax** | useradd [options] LOGIN |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | useradd [options] LOGIN |'
- en: '| **Practical uses** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`useradd -m`: Create the user''s home directory if it does not exist.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd -m`: 如果不存在，则创建用户的主目录。'
- en: '`useradd -s <shell>`: The name of the user''s login shell.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd -s <shell>`: 用户登录shell的名称。'
- en: '`useradd -u <uid>`: The numerical value of the user''s ID.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd -u <uid>`: 用户ID的数值。'
- en: '`useradd -g <group>`: The group name or number of the user''s initial login
    group.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd -g <group>`: 用户初始登录组的组名或编号。'
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: groupadd
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: groupadd
- en: '| **Description** | Create a new group. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 创建新组。 |'
- en: '| **Syntax** | groupadd [options] group |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | groupadd [options] group |'
- en: '| **Practical uses** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`groupadd -g <gid>`: The numerical value of the group''s ID.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupadd -g <gid>`: 组ID的数值。'
- en: '`groupadd -r`: Create a system group. These have GIDs which are (normally)
    lower than users.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupadd -r`: 创建系统组。这些组的GID（通常）低于用户。'
- en: '|'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: usermod
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: usermod
- en: '| **Description** | Modify a user account. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 修改用户帐户。 |'
- en: '| **Syntax** | usermod [options] LOGIN |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | usermod [options] LOGIN |'
- en: '| **Practical uses** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **实际用途** |'
- en: '`usermod -g <group> <user>`: Change the primary group of the <user> to <group>.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod -g <group> <user>`: 将<user>的主要组更改为<group>。'
- en: '`usermod -aG <group> <user>`: Add the <user> to the <group>. For the user,
    this will be a supplementary group.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod -aG <group> <user>`：将<user>添加到<group>中。对于用户来说，这将是一个附加组。'
- en: '`usermod -s <shell> <user>`: Set the login shell for the <user>.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod -s <shell> <user>`：为<user>设置登录shell。'
- en: '`usermod -md <homedir> <user>`: Move the <user>s home directory to <homedir>.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod -md <homedir> <user>`：将<user>的主目录移动到<homedir>。'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this final chapter with general tips and tricks. This part of the
    chapter dealt with arrays, the `history` command, and the ability to use `alias`
    to set up aliases for your favorite commands and their flags.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一般提示和技巧开始了这一最终章节。本章的这部分涉及数组、`history`命令以及使用`alias`为您喜欢的命令及其标志设置别名。
- en: 'We continued with keyboard shortcuts. We started that part by talking about
    exclamation marks and how versatile their use can be in Bash: it is used for negation
    of exit codes, substituting parts of previous commands, and even for running commands
    from history by matching either the line number or line content. After that, we
    showed how a few interesting keyboard shortcuts for Bash allow us to save some
    time on common operations and usage patterns (such as typos and forgotten intermediate
    commands). We saved the best keyboard shortcut for last: reverse searches. These
    allow you to interactively go through your personal history to find just the right
    command to execute again.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讲解键盘快捷键。我们首先讨论了感叹号的用途以及在Bash中它们的多功能性：它用于否定退出代码，替换先前命令的部分，甚至通过匹配行号或行内容从历史记录中运行命令。之后，我们展示了一些有趣的Bash键盘快捷键，可以帮助我们节省一些常见操作和使用模式的时间（例如拼写错误和忘记的中间命令）。我们将最好的键盘快捷键留到最后：反向搜索。这些快捷键允许您交互式地浏览您的个人历史记录，找到再次执行的正确命令。
- en: We ended this chapter and the book with a cheat sheet for most of the commands
    we introduced in this book. This cheat sheet contains the basic syntax for all
    commands, as well as our favorite flags and combinations with regards to the commands.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章和本书的结尾处提供了一个命令速查表，其中包含了我们在本书中介绍的大部分命令的基本语法，以及我们喜欢的标志和命令的组合。
- en: 'The following commands were introduced in this chapter: `history` and `clear`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`history`和`clear`。
- en: Final words
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的话
- en: 'If you have managed to make it this far: thank you for reading our book. We
    hope you enjoyed reading it as much as we enjoyed creating it. Keep on scripting
    and learning: practice makes perfect!'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经成功阅读到这里：感谢您阅读我们的书。我们希望您享受阅读它的过程，就像我们创作它一样。继续脚本编写和学习：熟能生巧！
