["```\n$ mount | grep -w proc\nproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)\n$ ls -l /proc/\ntotal 0\ndr-xr-xr-x  8 root  root          0 Jan 27 11:13 1/\ndr-xr-xr-x  8 root  root          0 Jan 29 08:22 10/\ndr-xr-xr-x  8 root  root          0 Jan 29 08:22 11/\ndr-xr-xr-x  8 root  root          0 Jan 29 08:22 11550/\n[...]\n-r--r--r--  1 root  root          0 Jan 29 08:22 consoles\n-r--r--r--  1 root  root          0 Jan 29 08:19 cpuinfo\n-r--r--r--  1 root  root          0 Jan 29 08:22 crypto\n-r--r--r--  1 root  root          0 Jan 29 08:20 devices\n-r--r--r--  1 root  root          0 Jan 29 08:22 diskstats\n[...]\n-r--r--r--  1 root  root          0 Jan 29 08:22 vmstat\n-r--r--r--  1 root  root          0 Jan 29 08:22 zoneinfo\n$ \n```", "```\n# cat /proc/sys/kernel/threads-max\n15741\n# echo 10000 > /proc/sys/kernel/threads-max\n# cat /proc/sys/kernel/threads-max\n10000\n#\n```", "```\nstruct proc_dir_entry *proc_mkdir(const char *name,\n                         struct proc_dir_entry *parent);\n```", "```\nstruct proc_dir_entry *proc_create(const char *name, umode_t mode,\n                         struct proc_dir_entry *parent,\n                         const struct file_operations *proc_fops);\n```", "```\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n```", "```\n// ch2/procfs_simple_intf/procfs_simple_intf.c\n[ ... ]\n/* Borrowed from ch1; the 'driver context' data structure;\n * all relevant 'state info' reg the driver and (fictional) 'device'\n * is maintained here.\n */\nstruct drv_ctx {\n    int tx, rx, err, myword, power;\n    u32 config1; /* treated as equivalent to 'debug level' of our driver */\n    u32 config2;\n    u64 config3;\n#define MAXBYTES   128\n    char oursecret[MAXBYTES];\n};\nstatic struct drv_ctx *gdrvctx;\nstatic int debug_level; /* 'off' (0) by default ... */\n```", "```\n$ cd <booksrc>/ch2/proc_simple_intf\n$ ../../lkm procfs_simple_intf          *<-- builds the kernel module*\nVersion info:\n[...]\n[24826.234323] procfs_simple_intf:procfs_simple_intf_init():321: proc dir (/proc/procfs_simple_intf) created\n[24826.240592] procfs_simple_intf:procfs_simple_intf_init():333: proc file 1 (/proc/procfs_simple_intf/llkdproc_debug_level) created\n[24826.245072] procfs_simple_intf:procfs_simple_intf_init():348: proc file 2 (/proc/procfs_simple_intf/llkdproc_show_pgoff) created\n[24826.248628] procfs_simple_intf:alloc_init_drvctx():218: allocated and init the driver context structure\n[24826.251784] procfs_simple_intf:procfs_simple_intf_init():368: proc file 3 (/proc/procfs_simple_intf/llkdproc_show_drvctx) created\n[24826.255145] procfs_simple_intf:procfs_simple_intf_init():378: proc file 4 (/proc/procfs_simple_intf/llkdproc_config1) created\n[24826.259203] procfs_simple_intf initialized\n$ \n```", "```\n$ cat /proc/procfs_simple_intf/llkdproc_debug_level\ndebug_level:0\n$\n```", "```\n$ sudo sh -c \"echo 2 > /proc/procfs_simple_intf/llkdproc_debug_level\"\n$ cat /proc/procfs_simple_intf/llkdproc_debug_level\ndebug_level:2\n$\n```", "```\n$ sudo sh -c \"echo 5 > /proc/procfs_simple_intf/llkdproc_debug_level\"\nsh: echo: I/O error\n$ dmesg\n[...]\n[ 6756.415727] procfs_simple_intf: trying to set invalid value for debug_level [allowed range: 0-2]; resetting to previous (2)\n```", "```\nstatic struct proc_dir_entry *gprocdir;\n[...]\ngprocdir = proc_mkdir(OURMODNAME, NULL);\n```", "```\n// ch2/procfs_simple_intf/procfs_simple_intf.c[...]\n#define PROC_FILE1           \"llkdproc_debug_level\"\n#define PROC_FILE1_PERMS     0644\n[...]\nstatic int __init procfs_simple_intf_init(void)\n{\n    int stat = 0;\n    [...]\n    /* 1\\. Create the PROC_FILE1 proc entry under the parent dir OURMODNAME;\n     * this will serve as the 'dynamically view/modify debug_level'\n     * (pseudo) file */\n    if (!proc_create(PROC_FILE1, PROC_FILE1_PERMS, gprocdir,\n &fops_rdwr_dbg_level)) {\n    [...]\n    pr_debug(\"proc file 1 (/proc/%s/%s) created\\n\", OURMODNAME, PROC_FILE1);\n    [...]\n```", "```\nstatic const struct file_operations fops_rdwr_dbg_level = {\n    .owner = THIS_MODULE,\n    .open = myproc_open_dbg_level,\n    .read = seq_read,\n    .write = myproc_write_debug_level,\n    .llseek = seq_lseek,\n    .release = single_release,\n};\n```", "```\nstatic int myproc_open_dbg_level(struct inode *inode, struct file *file)\n{\n    return single_open(file, proc_show_debug_level, NULL);\n}\n```", "```\n/* Our proc file 1: displays the current value of debug_level */\nstatic int proc_show_debug_level(struct seq_file *seq, void *v)\n{\n    if (mutex_lock_interruptible(&mtx))\n        return -ERESTARTSYS;\n    seq_printf(seq, \"debug_level:%d\\n\", debug_level);\n    mutex_unlock(&mtx);\n    return 0;\n}\n```", "```\n#define DEBUG_LEVEL_MIN     0\n#define DEBUG_LEVEL_MAX     2\n[...]\n/* proc file 1 : modify the driver's debug_level global variable as per what user space writes */\nstatic ssize_t myproc_write_debug_level(struct file *filp, \n                const char __user *ubuf, size_t count, loff_t *off)\n{\n   char buf[12];\n   int ret = count, prev_dbglevel;\n   [...]\n   prev_dbglevel = debug_level;\n *// < ... validity checks (not shown here) ... >*\n   /* Get the user mode buffer content into the kernel (into 'buf') */\n   if (copy_from_user(buf, ubuf, count)) {\n        ret = -EFAULT;\n        goto out;\n   }\n   [...]\n   ret = kstrtoint(buf, 0, &debug_level); /* update it! */\n   if (ret)\n        goto out;\n  if (debug_level < DEBUG_LEVEL_MIN || debug_level > DEBUG_LEVEL_MAX) {\n            [...]\n            debug_level = prev_dbglevel;\n            ret = -EFAULT; goto out;\n   }\n   /* just for fun, let's say that our drv ctx 'config1'\n      represents the debug level */\n   gdrvctx->config1 = debug_level;\n   ret = count;\nout:\n   mutex_unlock(&mtx);\n   return ret;\n}\n```", "```\n$ cat /proc/procfs_simple_intf/llkdproc_debug_level\ndebug_level:0\n$ sudo sh -c \"echo 1 > /proc/procfs_simple_intf/llkdproc_debug_level\"\n```", "```\n$ cat /proc/procfs_simple_intf/llkdproc_show_drvctx \ncat: /proc/procfs_simple_intf/llkdproc_show_drvctx: Permission denied\n$ sudo cat /proc/procfs_simple_intf/llkdproc_show_drvctx \nprodname:procfs_simple_intf\ntx:0,rx:0,err:0,myword:0,power:1\nconfig1:0x1,config2:0x48524a5f,config3:0x424c0a52\noursecret:AhA xxx\n$ \n```", "```\nstruct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode, struct     \n        proc_dir_entry *parent, int (*show)(struct seq_file *, void *), void *data);\n```", "```\n... proc_create_single_data(PROC_FILE2, PROC_FILE2_PERMS, gprocdir, proc_show_pgoff, 0) ...\n```", "```\nseq_printf(seq, \"%s:PAGE_OFFSET:0x%px\\n\", OURMODNAME, PAGE_OFFSET);\n```", "```\ndrivers/base/core.c:int device_create_file(struct device *dev,\n                         const struct device_attribute *attr);\n```", "```\n$ ls /sys/devices/platform/\nalarmtimer  'Fixed MDIO bus.0'   intel_pmc_core.0   platform-framebuffer.0   reg-dummy   \nserial8250 eisa.0  i8042  pcspkr power rtc_cmos uevent\n$\n```", "```\n// ch2/sysfs_simple_intf/sysfs_simple_intf.c\ninclude <linux/platform_device.h>\nstatic struct platform_device *sysfs_demo_platdev;\n[...]\n#define PLAT_NAME    \"llkd_sysfs_simple_intf_device\"\nsysfs_demo_platdev =\n     platform_device_register_simple(PLAT_NAME, -1, NULL, 0);\n[...]\n```", "```\n$ cd <...>/ch2/sysfs_simple_intf\n$ make && sudo insmod ./sysfs_simple_intf.ko\n[...]\n$ ls -l /sys/devices/platform/llkd_sysfs_simple_intf_device/\ntotal 0\n-rw-r--r-- 1 root root 4.0K Feb 15 20:22 driver_override\n-rw-r--r-- 1 root root 4.0K Feb 15 20:22 llkdsysfs_debug_level\n-r--r--r-- 1 root root 4.0K Feb 15 20:22 llkdsysfs_pgoff\n-r--r--r-- 1 root root 4.0K Feb 15 20:22 llkdsysfs_pressure\n-r--r--r-- 1 root root 4.0K Feb 15 20:22 modalias\ndrwxr-xr-x 2 root root 0 Feb 15 20:22 power/\nlrwxrwxrwx 1 root root 0 Feb 15 20:22 subsystem -> ../../../bus/platform/\n-rw-r--r-- 1 root root 4.0K Feb 15 20:21 uevent\n$ \n```", "```\nplatform_device_unregister(sysfs_demo_platdev);\n```", "```\nint device_create_file(struct device *dev, const struct device_attribute *attr);\n```", "```\n// include/linux/device.hstruct device_attribute {\n    struct attribute attr;\n    ssize_t (*show)(struct device *dev, struct device_attribute *attr,\n                    char *buf);\n    ssize_t (*store)(struct device *dev, struct device_attribute *attr,\n                     const char *buf, size_t count);\n};\n```", "```\n// include/linux/device.h\ndefine DEVICE_ATTR(_name, _mode, _show, _store) \\\n   struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)\n```", "```\n// include/linux/sysfs.h\n#define __ATTR(_name, _mode, _show, _store) { \\\n    .attr = {.name = __stringify(_name), \\\n    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) }, \\\n    .show = _show, \\\n    .store = _store, \\\n}\n```", "```\n#define DEVICE_ATTR_RW(_name) \\\n     struct device_attribute dev_attr_##_name = __ATTR_RW(_name)\n#define __ATTR_RW(_name) __ATTR(_name, 0644, _name##_show, _name##_store)\n```", "```\n// ch2/sysfs_simple_intf/sysfs_simple_intf.c\n#define SYSFS_FILE1 llkdsysfs_debug_level\n// [... *<we show the actual read/write callback functions just a bit further down>* ...]\nstatic DEVICE_ATTR_RW(SYSFS_FILE1);\n\nint __init sysfs_simple_intf_init(void)\n{\n [...]\n*/* << 0\\. The platform device is created via the platform_device_register_simple() API; code already shown above ... >> */*\n\n // 1\\. Create our first sysfile file : llkdsysfs_debug_level\n /* The device_create_file() API creates a sysfs attribute file for\n  * given device (1st parameter); the second parameter is the pointer\n  * to it's struct device_attribute structure dev_attr_<name> which was\n  * instantiated by our DEV_ATTR{_RW|RO} macros above ... */\n  stat = device_create_file(&sysfs_demo_platdev->dev, &dev_attr_SYSFS_FILE1);\n[...]\n```", "```\n/* debug_level: sysfs entry point for the 'show' (read) callback */\nstatic ssize_t llkdsysfs_debug_level_show(struct device *dev,\n                                          struct device_attribute *attr,\n                                          char *buf)\n{\n        int n;\n        if (mutex_lock_interruptible(&mtx))\n                return -ERESTARTSYS;\n        pr_debug(\"In the 'show' method: name: %s, debug_level=%d\\n\",   \n                 dev->kobj.name, debug_level); \n        n = snprintf(buf, 25, \"%d\\n\", debug_level);\n        mutex_unlock(&mtx);\n        return n;\n}\n```", "```\n$ ../../lkm sysfs_simple_intf          // <-- build and insmod it[...]\n[83907.192247] sysfs_simple_intf:sysfs_simple_intf_init():237: sysfs file [1] (/sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level) created\n[83907.197279] sysfs_simple_intf:sysfs_simple_intf_init():250: sysfs file [2] (/sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_pgoff) created\n[83907.201959] sysfs_simple_intf:sysfs_simple_intf_init():264: sysfs file [3] (/sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_pressure) created\n[83907.205888] sysfs_simple_intf initialized\n$\n```", "```\n$ ls -l /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level\n-rw-r--r-- 1 root root 4096 Feb   4 17:41 /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level\n$ cat /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level\n0\n```", "```\n#define DEBUG_LEVEL_MIN 0\n#define DEBUG_LEVEL_MAX 2\n\nstatic ssize_t llkdsysfs_debug_level_store(struct device *dev,\n                                           struct device_attribute *attr,\n                                           const char *buf, size_t count)\n{\n        int ret = (int)count, prev_dbglevel;\n        if (mutex_lock_interruptible(&mtx))\n                return -ERESTARTSYS;\n\n        prev_dbglevel = debug_level;\n        pr_debug(\"In the 'store' method:\\ncount=%zu, buf=0x%px count=%zu\\n\"\n        \"Buffer contents: \\\"%.*s\\\"\\n\", count, buf, count, (int)count, buf);\n        if (count == 0 || count > 12) {\n                ret = -EINVAL;\n                goto out;\n        }\n\n        ret = kstrtoint(buf, 0, &debug_level); /* update it! */\n *// < ... validity checks ... >*\n        ret = count;\n out:\n        mutex_unlock(&mtx);\n        return ret;\n}\n```", "```\n$ sudo sh -c \"echo 2 > /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level\"\n$ cat /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_debug_level\n2\n$\n```", "```\n$ cat /sys/devices/platform/llkd_sysfs_simple_intf_device/llkdsysfs_pressure\n25$\n```", "```\n/* show 'pressure' value: sysfs entry point for the 'show' (read) callback */\nstatic ssize_t llkdsysfs_pressure_show(struct device *dev,\n                       struct device_attribute *attr, char *buf)\n{\n        int n;\n        if (mutex_lock_interruptible(&mtx))\n                return -ERESTARTSYS;\n        pr_debug(\"In the 'show' method: pressure=%u\\n\", gpressure);\n        n = snprintf(buf, 25, \"%u\", gpressure);\n        mutex_unlock(&mtx);\n        return n;\n}\n/* The DEVICE_ATTR{_RW|RO|WO}() macro instantiates a struct device_attribute dev_attr_<name> here...   */\nstatic DEVICE_ATTR_RO(llkdsysfs_pressure); \n```", "```\n$ zcat /proc/config.gz | grep -w CONFIG_DEBUG_FS\nCONFIG_DEBUG_FS=y\n```", "```\n$ mount | grep -w debugfs\ndebugfs on /sys/kernel/debug type debugfs (rw,relatime)\n```", "```\n// ch2/debugfs_simple_intf/debugfs_simple_intf.c\n\nstatic struct dentry *gparent;\n[...]\nstatic int debugfs_simple_intf_init(void)\n{\n    int stat = 0;\n    struct dentry *file1, *file2;\n    [...]\n    gparent = debugfs_create_dir(OURMODNAME, NULL);\n```", "```\nstatic const struct file_operations dbgfs_drvctx_fops = {\n    .read = dbgfs_show_drvctx,\n};\n[...]\n*// < ... init function ... >*\n   /* Generic debugfs file + passing a pointer to a data structure as a\n    * demo.. the 4th param is a generic void * ptr; it's contents will be\n    * stored into the i_private field of the file's inode.\n    */\n#define DBGFS_FILE1 \"llkd_dbgfs_show_drvctx\"\n    file1 = debugfs_create_file(DBGFS_FILE1, 0440, gparent,\n                (void *)gdrvctx, &dbgfs_drvctx_fops);\n    [...]\n```", "```\nstatic ssize_t dbgfs_show_drvctx(struct file *filp, char __user * ubuf,\n                                 size_t count, loff_t * fpos)\n{\n    struct drv_ctx *data = (struct drv_ctx *)filp->f_inode->i_private;\n                       // retrieve the \"data\" from the inode\n#define MAXUPASS 256   // careful- the kernel stack is small!\n    char locbuf[MAXUPASS];\n\n    if (mutex_lock_interruptible(&mtx))\n        return -ERESTARTSYS;\n\n   /* As an experiment, we set our 'config3' member of the drv ctx stucture\n    * to the current 'jiffies' value (# of timer interrupts since boot);\n    * so, every time we 'cat' this file, the 'config3' value should change!\n    */\n   data->config3 = jiffies;\n   snprintf(locbuf, MAXUPASS - 1,\n            \"prodname:%s\\n\"\n            \"tx:%d,rx:%d,err:%d,myword:%d,power:%d\\n\"\n            \"config1:0x%x,config2:0x%x,config3:0x%llx (%llu)\\n\"\n            \"oursecret:%s\\n\",\n            OURMODNAME,\n            data->tx, data->rx, data->err, data->myword, data->power,\n            data->config1, data->config2, data->config3, data->config3,\n            data->oursecret);\n\n    mutex_unlock(&mtx);\n    return simple_read_from_buffer(ubuf, MAXUPASS, fpos, locbuf,\n                                   strlen(locbuf));\n}\n```", "```\n$ ../../lkm debugfs_simple_intf\n[...]\n[200221.725752] dbgfs_simple_intf: allocated and init the driver context structure\n[200221.728158] dbgfs_simple_intf: debugfs file 1 <debugfs_mountpt>/dbgfs_simple_intf/llkd_dbgfs_show_drvctx created\n[200221.732167] dbgfs_simple_intf: debugfs file 2 <debugfs_mountpt>/dbgfs_simple_intf/llkd_dbgfs_debug_level created\n[200221.735723] dbgfs_simple_intf initialized\n```", "```\n$ ls -l /sys/kernel/debug/dbgfs_simple_intf\nls: cannot access '/sys/kernel/debug/dbgfs_simple_intf': Permission denied\n$ sudo ls -l /sys/kernel/debug/dbgfs_simple_intf\ntotal 0\n-rw-r--r-- 1 root root 0 Feb  7 15:58 llkd_dbgfs_debug_level\n-r--r----- 1 root root 0 Feb  7 15:58 llkd_dbgfs_show_drvctx\n$\n```", "```\n$ sudo cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_show_drvctx\nprodname:dbgfs_simple_intf\ntx:0,rx:0,err:0,myword:0,power:1\nconfig1:0x0,config2:0x48524a5f,config3:0x102fbcbc2 (4345023426)\noursecret:AhA yyy\n$\n```", "```\n$ sudo cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_show_drvctx | grep config3\nconfig1:0x0,config2:0x48524a5f,config3:0x102fbe828 (4345030696)\n$\n```", "```\nstatic int debug_level;    /* 'off' (0) by default ... */ \n[...]\n /* 3\\. Create the debugfs file for the debug_level global; we use the\n    * helper routine to make it simple! There is a downside: we have no\n    * chance to perform a validity check on the value being written.. */\n#define DBGFS_FILE2     \"llkd_dbgfs_debug_level\"\n   file2 = debugfs_create_u32(DBGFS_FILE2, 0644, gparent, &debug_level);\n   [...]\n   pr_debug(\"%s: debugfs file 2 <debugfs_mountpt>/%s/%s created\\n\",\n             OURMODNAME, OURMODNAME, DBGFS_FILE2);\n```", "```\n$ sudo cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_debug_level\n0\n$ sudo sh -c \"echo 5 > /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_debug_level\"\n$ sudo cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_debug_level\n5\n$ \n```", "```\n// include/linux/debugfs.h\nstruct dentry *debugfs_create_u8(const char *name, umode_t mode,\n                 struct dentry *parent, u8 *value);\nstruct dentry *debugfs_create_u16(const char *name, umode_t mode,\n                 struct dentry *parent, u16 *value);\nstruct dentry *debugfs_create_u32(const char *name, umode_t mode,\n                 struct dentry *parent, u32 *value);\nstruct dentry *debugfs_create_u64(const char *name, umode_t mode,\n                 struct dentry *parent, u64 *value);\n```", "```\nstruct dentry *debugfs_create_x8(const char *name, umode_t mode,\n                 struct dentry *parent, u8 *value);\nstruct dentry *debugfs_create_x16(const char *name, umode_t mode,\n                 struct dentry *parent, u16 *value);\nstruct dentry *debugfs_create_x32(const char *name, umode_t mode,\n                 struct dentry *parent, u32 *value);\nstruct dentry *debugfs_create_x64(const char *name, umode_t mode,\n                 struct dentry *parent, u64 *value);\n```", "```\nstruct dentry *debugfs_create_bool(const char *name, umode_t mode,\n                  struct dentry *parent, bool *value);\n```", "```\nvoid debugfs_remove_recursive(struct dentry *dentry);\n```", "```\n// ch2/debugfs_simple_intf/debugfs_simple_intf.c\n[...]\n/* Module parameters */\nstatic int cause_an_oops;\nmodule_param(cause_an_oops, int, 0644);\nMODULE_PARM_DESC(cause_an_oops,\n\"Setting this to 1 can cause a kernel bug, an Oops; if 1, we do NOT perform required cleanup! so, after removal, any op on the debugfs files will cause an Oops! (default is 0, no bug)\");\n```", "```\nstatic void debugfs_simple_intf_cleanup(void)\n{\n        kfree(gdrvctx);\n        if (!cause_an_oops)\n debugfs_remove_recursive(gparent);\n        pr_info(\"%s removed\\n\", OURMODNAME);\n}\n```", "```\n# id\nuid=0(root) gid=0(root) groups=0(root)\n# insmod ./debugfs_simple_intf.ko cause_an_oops=1\n# cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_debug_level\n0\n# dmesg \n[ 2061.048140] dbgfs_simple_intf: allocated and init the driver context structure\n[ 2061.050690] dbgfs_simple_intf: debugfs file 1 <debugfs_mountpt>/dbgfs_simple_intf/llkd_dbgfs_show_drvctx created\n[ 2061.053638] dbgfs_simple_intf: debugfs file 2 <debugfs_mountpt>/dbgfs_simple_intf/llkd_dbgfs_debug_level created\n[ 2061.057089] dbgfs_simple_intf initialized (fyi, our 'cause an Oops' setting is currently On)\n# \n```", "```\n# rmmod debugfs_simple_intf\n# cat /sys/kernel/debug/dbgfs_simple_intf/llkd_dbgfs_debug_level \nKilled\n```", "```\nCPU: 1 PID: 4673 Comm: cat Tainted: G OE 5.4.0-llkd01 #2\n```", "```\nRIP: 0010:debugfs_u32_get+0x5/0x20\n```", "```\n$ cd <kernel-source-tree> ; find drivers/ -iname \"*debugfs*.c\" \ndrivers/block/drbd/drbd_debugfs.c\ndrivers/mmc/core/debugfs.c\ndrivers/platform/x86/intel_telemetry_debugfs.c\n[...]\ndrivers/infiniband/hw/qib/qib_debugfs.c\ndrivers/infiniband/hw/hfi1/debugfs.c\n[...]\ndrivers/media/usb/uvc/uvc_debugfs.c\ndrivers/acpi/debugfs.c\ndrivers/net/wireless/mediatek/mt76/debugfs.c\n[...]\ndrivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c\ndrivers/net/wimax/i2400m/debugfs.c\ndrivers/net/ethernet/broadcom/bnxt/bnxt_debugfs.c\ndrivers/net/ethernet/marvell/mvpp2/mvpp2_debugfs.c\ndrivers/net/ethernet/mellanox/mlx5/core/debugfs.c\n[...]\ndrivers/misc/genwqe/card_debugfs.c\ndrivers/misc/mei/debugfs.c\ndrivers/misc/cxl/debugfs.c\n[...]\ndrivers/usb/mtu3/mtu3_debugfs.c\ndrivers/sh/intc/virq-debugfs.c\ndrivers/soundwire/debugfs.c\n[...]\ndrivers/crypto/ccree/cc_debugfs.c\n```", "```\ndrivers/mmc/core/debugfs.c:mmc_add_card_debugfs():\ndebugfs_create_x32(\"state\", S_IRUSR, root, &card->state);\n```", "```\n// ch2/netlink_simple_intf/userapp_netlink/netlink_userapp.c\n#define NETLINK_MY_UNIT_PROTO        31\n    // kernel netlink protocol # (registered by our kernel module)\n#define NLSPACE 1024\n\n[...] \n /* 1\\. Get ourselves an endpoint - a netlink socket! */\nsd = socket(PF_NETLINK, SOCK_RAW, NETLINK_MY_UNIT_PROTO);\nprintf(\"%s:PID %d: netlink socket created\\n\", argv[0], getpid());\n\n/* 2\\. Setup the netlink source addr structure and bind it */\nmemset(&src_nl, 0, sizeof(src_nl));\nsrc_nl.nl_family = AF_NETLINK;\n/* Note carefully: nl_pid is NOT necessarily the PID of the sender process; it's actually 'port id' and can be any unique number */\nsrc_nl.nl_pid = getpid();\nsrc_nl.nl_groups = 0x0; // no multicast\nbind(sd, (struct sockaddr *)&src_nl, sizeof(src_nl))\n```", "```\n/* 3\\. Setup the netlink destination addr structure */\nmemset(&dest_nl, 0, sizeof(dest_nl));\ndest_nl.nl_family = AF_NETLINK;\ndest_nl.nl_groups = 0x0; // no multicast\ndest_nl.nl_pid = 0;      // destined for the kernel\n```", "```\n/* 4\\. Allocate and setup the netlink header (including the payload) */\nnlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(NLSPACE));\nmemset(nlhdr, 0, NLMSG_SPACE(NLSPACE));\nnlhdr->nlmsg_len = NLMSG_SPACE(NLSPACE);\nnlhdr->nlmsg_pid = getpid();\n/* Setup the payload to transmit */\nstrncpy(NLMSG_DATA(nlhdr), thedata, strlen(thedata)+1);\n```", "```\n/* 5\\. Setup the iovec and ... */\nmemset(&iov, 0, sizeof(struct iovec));\niov.iov_base = (void *)nlhdr;\niov.iov_len = nlhdr->nlmsg_len;\n[...]\n/* ... now setup the message header structure */\nmemset(&msg, 0, sizeof(struct msghdr));\nmsg.msg_name = (void *)&dest_nl;   // dest addr\nmsg.msg_namelen = sizeof(dest_nl); // size of dest addr\nmsg.msg_iov = &iov;\nmsg.msg_iovlen = 1; // # elements in msg_iov\n```", "```\n/* 6\\. Actually (finally!) send the message via sendmsg(2) */\nnsent = sendmsg(sd, &msg, 0);\n```", "```\n/* 7\\. Block on incoming msg from the kernel-space netlink component */\nprintf(\"%s: now blocking on kernel netlink msg via recvmsg() ...\\n\", argv[0]);\nnrecv = recvmsg(sd, &msg, 0);\n```", "```\n$ strace -e trace=network ./netlink_userapp\nsocket(AF_NETLINK, SOCK_RAW, 0x1f /* NETLINK_??? */) = -1 EPROTONOSUPPORT (Protocol not supported)\nnetlink_u: netlink socket creation failed: Protocol not supported\n+++ exited with 1 +++\n$\n```", "```\nstruct sock * netlink_kernel_create(struct net *, int , struct netlink_kernel_cfg *);\n```", "```\n// ch2/netlink_simple_intf/kernelspace_netlink/netlink_simple_intf.c\n#define OURMODNAME               \"netlink_simple_intf\"\n#define NETLINK_MY_UNIT_PROTO    31 \n    // kernel netlink protocol # that we're registering\nstatic struct sock *nlsock;\n[...]\nstatic struct netlink_kernel_cfg nl_kernel_cfg = { \n    .input = netlink_recv_and_reply,\n};\n[...]\nnlsock = netlink_kernel_create(&init_net, NETLINK_MY_UNIT_PROTO,\n            &nl_kernel_cfg);\n```", "```\nstatic void netlink_recv_and_reply(struct sk_buff *skb)\n{\n    struct nlmsghdr *nlh;\n    struct sk_buff *skb_tx;\n    char *reply = \"Reply from kernel netlink\";\n    int pid, msgsz, stat;\n\n    /* Find that this code runs in process context, the process\n     * (or thread) being the one that issued the sendmsg(2) */\n    PRINT_CTX();\n\n    nlh = (struct nlmsghdr *)skb->data;\n    pid = nlh->nlmsg_pid; /*pid of sending process */\n    pr_info(\"%s: received from PID %d:\\n\"\n        \"\\\"%s\\\"\\n\", OURMODNAME, pid, (char *)NLMSG_DATA(nlh));\n```", "```\n    //--- Let's be polite and reply\n    msgsz = strlen(reply);\n    skb_tx = nlmsg_new(msgsz, 0);\n    [...]\n    // Setup the payload\n    nlh = nlmsg_put(skb_tx, 0, 0, NLMSG_DONE, msgsz, 0);\n    NETLINK_CB(skb_tx).dst_group = 0; /* unicast only (cb is the\n        * skb's control buffer), dest group 0 => unicast */\n    strncpy(nlmsg_data(nlh), reply, msgsz);\n```", "```\n    // Send it\n    stat = nlmsg_unicast(nlsock, skb_tx, pid);\n```", "```\nstatic void __exit netlink_simple_intf_exit(void)\n{\n    netlink_kernel_release(nlsock);\n    pr_info(\"%s: removed\\n\", OURMODNAME);\n}\n```", "```\n$ cd <booksrc>/ch2/netlink_simple_intf/kernelspace_netlink $ ../../../lkm netlink_simple_intf\nVersion info:\nDistro:     Ubuntu 18.04.4 LTS\nKernel: 5.4.0-llkd01\n[...]\nmake || exit 1\n[...] Building for: KREL=5.4.0-llkd01 ARCH=x86 CROSS_COMPILE= EXTRA_CFLAGS= -DDEBUG\n  CC [M]  /home/llkd/booksrc/ch13/netlink_simple_intf/kernelspace_netlink/netlink_simple_intf.o\n[...]\nsudo insmod ./netlink_simple_intf.ko && lsmod|grep netlink_simple_intf\n------------------------------\nnetlink_simple_intf    16384  0\n[...]\n[58155.082713] netlink_simple_intf: creating kernel netlink socket\n[58155.084445] netlink_simple_intf: inserted\n$ \n```", "```\n$ cd ../userapp_netlink/\n$ make netlink_userapp\n[...] \n```", "```\nstatic struct file_operations ioct_intf_fops = { \n    .llseek = no_llseek,\n    .ioctl = ioct_intf_ioctl,\n    [...]\n};\n```", "```\n#include <sys/ioctl.h>\nint ioctl(int fd, unsigned long request, ...);\n```", "```\n// ch2/ioctl_intf/ioctl_llkd.h\n\n/* The 'magic' number for our driver; see Documentation/ioctl/ioctl-number.rst \n * Of course, we don't know for _sure_ if the magic # we choose here this\n * will remain free; it really doesn't matter, this is just for demo purposes;\n * don't try and upstream this without further investigation :-)\n */\n#define IOCTL_LLKD_MAGIC        0xA8\n\n#define IOCTL_LLKD_MAXIOCTL        3\n/* our dummy ioctl (IOC) RESET command */\n#define IOCTL_LLKD_IOCRESET     _IO(IOCTL_LLKD_MAGIC, 0)\n/* our dummy ioctl (IOC) Query POWER command */\n#define IOCTL_LLKD_IOCQPOWER    _IOR(IOCTL_LLKD_MAGIC, 1, int)\n/* our dummy ioctl (IOC) Set POWER command */\n#define IOCTL_LLKD_IOCSPOWER    _IOW(IOCTL_LLKD_MAGIC, 2, int)\n```", "```\n#include <sys/ioctl.h>\nint ioctl(int fd, unsigned long request, ...);\n```", "```\n// ch2/ioctl_intf/user space_ioctl/ioctl_llkd_userspace.c\n#include \"../ioctl_llkd.h\"\n[...]\nioctl(fd, IOCTL_LLKD_IOCRESET, 0);   // 1\\. reset the device\nioctl(fd, IOCTL_LLKD_IOCQPOWER, &power); // 2\\. query the 'power status'\n\n// 3\\. Toggle it's power status\nif (0 == power) {\n        printf(\"%s: Device OFF, powering it On now ...\\n\", argv[0]);\n        if (ioctl(fd, IOCTL_LLKD_IOCSPOWER, 1) == -1) { [...]\n        printf(\"%s: power is ON now.\\n\", argv[0]);\n    } else if (1 == power) {\n        printf(\"%s: Device ON, powering it OFF in 3s ...\\n\", argv[0]);\n        sleep(3); /* yes, careful here of sleep & signals! */\n        if (ioctl(fd, IOCTL_LLKD_IOCSPOWER, 0) == -1) { [...]\n        printf(\"%s: power OFF ok, exiting..\\n\", argv[0]);\n    }\n[...]\n```", "```\n// ch2/ioctl_intf/kerneldrv_ioctl/ioctl_llkd_kdrv.c\n#include \"../ioctl_llkd.h\"\n#include <linux/version.h>\n[...]\nstatic struct file_operations ioctl_intf_fops = { \n    .llseek = no_llseek,\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)\n    .unlocked_ioctl = ioctl_intf_ioctl, // use the 'unlocked' version\n#else\n    .ioctl = ioctl_intf_ioctl, // 'old' way\n#endif\n};\n```", "```\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)\nstatic long ioctl_intf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n#else\nstatic int ioctl_intf_ioctl(struct inode *ino, struct file *filp, unsigned int cmd, unsigned long arg)\n#endif\n{\n[...]\n```", "```\nstatic long ioctl_intf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    int retval = 0;\n    pr_debug(\"In ioctl method, cmd=%d\\n\", _IOC_NR(cmd));\n\n    /* Verify stuff: is the ioctl's for us? etc.. */\n    [...]\n\n    switch (cmd) {\n    case IOCTL_LLKD_IOCRESET:\n        pr_debug(\"In ioctl cmd option: IOCTL_LLKD_IOCRESET\\n\");\n        /* ... Insert the code here to write to a control register to reset  \n           the device ... */\n        break;\n    case IOCTL_LLKD_IOCQPOWER:  /* Get: arg is pointer to result */\n        pr_debug(\"In ioctl cmd option: IOCTL_LLKD_IOCQPOWER\\n\"\n            \"arg=0x%x (drv) power=%d\\n\", (unsigned int)arg, power);\n        if (!capable(CAP_SYS_ADMIN))\n            return -EPERM;\n        /* ... Insert the code here to read a status register to query the\n         * power state of the device ... * here, imagine we've done that \n         * and placed it into a variable 'power'\n         */\n        retval = __put_user(power, (int __user *)arg);\n        break;\n    case IOCTL_LLKD_IOCSPOWER:  /* Set: arg is the value to set */\n        if (!capable(CAP_SYS_ADMIN))\n            return -EPERM;\n        power = arg;\n        /* ... Insert the code here to write a control register to set the\n         * power state of the device ... */\n        pr_debug(\"In ioctl cmd option: IOCTL_LLKD_IOCSPOWER\\n\"\n            \"power=%d now.\\n\", power);\n        break;\n    default:\n        return -ENOTTY;\n    }\n[...]\n```"]