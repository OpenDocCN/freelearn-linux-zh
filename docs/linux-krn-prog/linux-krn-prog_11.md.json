["```\n#include <linux/slab.h>\nstruct kmem_cache *kmem_cache_create(const char *name, unsigned int size,  \n           unsigned int align, slab_flags_t flags, void (*ctor)(void *));\n```", "```\n// mm/slab_common.c\n[...]\n * The flags are\n *\n * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)\n * to catch references to uninitialized memory.\n *\n * %SLAB_RED_ZONE - Insert `Red` zones around the allocated memory to check\n * for buffer overruns.\n *\n * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware\n * cacheline. This can be beneficial if you're counting cycles as closely\n * as davem.\n[...]\n```", "```\n security/integrity/iint.c:integrity_iintcache_init()\n```", "```\niint_cache = kmem_cache_create(\"iint_cache\", sizeof(struct integrity_iint_cache),\n 0, SLAB_PANIC, init_once);\n```", "```\nvoid *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags);\n```", "```\nvoid kmem_cache_free(struct kmem_cache *, void *);\n```", "```\nvoid kmem_cache_destroy(struct kmem_cache *);\n```", "```\n// ch9/slab_custom/slab_custom.c\n#define OURCACHENAME   \"our_ctx\"\n/* Our 'demo' structure, that (we imagine) is often allocated and freed;\n * hence, we create a custom slab cache to hold pre-allocated 'instances'\n * of it... Its size: 328 bytes.\n */\nstruct myctx {\n    u32 iarr[10];\n    u64 uarr[10];\n    char uname[128], passwd[16], config[64];\n};\nstatic struct kmem_cache *gctx_cachep; \n```", "```\nstatic int create_our_cache(void)\n{\n    int ret = 0;\n    void *ctor_fn = NULL;\n\n    if (use_ctor == 1)\n        ctor_fn = our_ctor;\n    pr_info(\"sizeof our ctx structure is %zu bytes\\n\"\n            \" using custom constructor routine? %s\\n\",\n            sizeof(struct myctx), use_ctor==1?\"yes\":\"no\");\n\n  /* Create a new slab cache:\n   * kmem_cache_create(const char *name, unsigned int size, unsigned int \n      align, slab_flags_t flags, void (*ctor)(void *));  */\n    gctx_cachep = kmem_cache_create(OURCACHENAME, // name of our cache\n          sizeof(struct myctx), // (min) size of each object\n          sizeof(long),         // alignment\n          SLAB_POISON |         /* use slab poison values (explained soon) */\n          SLAB_RED_ZONE |       /* good for catching buffer under|over-flow bugs */\n          SLAB_HWCACHE_ALIGN,   /* good for performance */\n          ctor_fn);             // ctor: here, on by default\n\n  if (!gctx_cachep) {\n        [...]\n        if (IS_ERR(gctx_cachep))\n            ret = PTR_ERR(gctx_cachep);\n  }\n  return ret;\n}\n```", "```\n/* The parameter is the pointer to the just allocated memory 'object' from\n * our custom slab cache; here, this is our 'constructor' routine; so, we\n * initialize our just allocated memory object.\n */\nstatic void our_ctor(void *new)\n{\n    struct myctx *ctx = new;\n    struct task_struct *p = current;\n\n    /* TIP: to see how exactly we got here, insert this call:\n     *  dump_stack();\n     * (read it bottom-up ignoring call frames that begin with '?') */\n    pr_info(\"in ctor: just alloced mem object is @ 0x%llx\\n\", ctx);\n\n    memset(ctx, 0, sizeof(struct myctx));\n    /* As a demo, we init the 'config' field of our structure to some\n     * (arbitrary) 'accounting' values from our task_struct\n     */\n    snprintf(ctx->config, 6*sizeof(u64)+5, \"%d.%d,%ld.%ld,%ld,%ld\",\n            p->tgid, p->pid,\n            p->nvcsw, p->nivcsw, p->min_flt, p->maj_flt);\n}\n```", "```\n    obj = kmem_cache_alloc(gctx_cachep, GFP_KERNEL);\n    pr_info(\"Our cache object size is %u bytes; ksize=%lu\\n\",\n            kmem_cache_size(gctx_cachep), ksize(obj));\n    print_hex_dump_bytes(\"obj: \", DUMP_PREFIX_OFFSET, obj, sizeof(struct myctx));\n kmem_cache_free(gctx_cachep, obj);\n```", "```\nkmem_cache_destroy(gctx_cachep);\n```", "```\n$ sudo vmstat -m | head -n1\nCache                       Num  Total  Size  Pages\n$ sudo vmstat -m | grep our_ctx\nour_ctx                       0     21   768     21\n$ \n```", "```\n$ grep -w CONFIG_SLUB_DEBUG /boot/config-5.4.0-llkd01\nCONFIG_SLUB_DEBUG=y\n```", "```\n/* ...and for poisoning */\n#define POISON_INUSE    0x5a    /* for use-uninitialized poisoning */\n#define POISON_FREE     0x6b    /* for use-after-free poisoning */\n#define POISON_END      0xa5    /* end-byte of poisoning */\n```", "```\nif CONFIG_SLUB_DEBUG is enabled\n   AND the SLAB_POISON flag is set\n   AND there's no custom constructor function\n   AND it's type-safe-by-RCU\n```", "```\n$ cat /proc/cmdline\nBOOT_IMAGE=(hd0,msdos1)/vmlinuz-5.4.0-llkd01 root=/dev/mapper/fedora_localhost--live-root ro resume=/dev/mapper/fedora_localhost--live-swap rd.lvm.lv=fedora_localhost-live/root rd.lvm.lv=fedora_localhost-live/swap rhgb slub_debug=FZPU 3\n```", "```\n$ sudo cat /sys/kernel/slab/our_ctx/object_size  /sys/kernel/slab/our_ctx/slab_size \n328 768\n```", "```\n$ sudo cat /sys/kernel/slab/our_ctx/ctor\nour_ctor+0x0/0xe1 [slab_custom]\n```", "```\n#include <linux/vmalloc.h>\nvoid *vmalloc(unsigned long size);\n```", "```\nvoid *vzalloc(unsigned long size);\n```", "```\nvoid vfree(const void *addr);\n```", "```\n// ch9/vmalloc_demo/vmalloc_demo.c\n#define pr_fmt(fmt) \"%s:%s(): \" fmt, KBUILD_MODNAME, __func__\n[...]\n#define KVN_MIN_BYTES     16\n#define DISP_BYTES        16\nstatic void *vptr_rndm, *vptr_init, *kv, *kvarr, *vrx;\n\nstatic int vmalloc_try(void)\n{\n    if (!(vptr_rndm = vmalloc(10000))) {\n        pr_warn(\"vmalloc failed\\n\");\n        goto err_out1;\n    }\n    pr_info(\"1\\. vmalloc(): vptr_rndm = 0x%pK (actual=0x%px)\\n\", \n            vptr_rndm, vptr_rndm);\n    print_hex_dump_bytes(\" content: \", DUMP_PREFIX_NONE, vptr_rndm,     \n                DISP_BYTES);\n```", "```\n    /* 2\\. vzalloc(); memory contents are set to zeroes */\n    if (!(vptr_init = vzalloc(10000))) {\n        pr_warn(\"%s: vzalloc failed\\n\", OURMODNAME);\n        goto err_out2;\n    }\n    pr_info(\"2\\. vzalloc(): vptr_init = 0x%pK (actual=0x%px)\\n\",\n            vptr_init, (TYPECST)vptr_init);\n    print_hex_dump_bytes(\" content: \", DUMP_PREFIX_NONE, vptr_init, \n                DISP_BYTES);\n```", "```\n  /* 3\\. kvmalloc(): allocate 'kvn' bytes with the kvmalloc(); if kvn is\n   * large (enough), this will become a vmalloc() under the hood, else\n   * it falls back to a kmalloc() */\n    if (!(kv = kvmalloc(kvn, GFP_KERNEL))) {\n        pr_warn(\"kvmalloc failed\\n\");\n        goto err_out3;\n    }\n    [...]\n\n    /* 4\\. kcalloc(): allocate an array of 1000 64-bit quantities and zero\n     * out the memory */\n    if (!(kvarr = kcalloc(1000, sizeof(u64), GFP_KERNEL))) {\n        pr_warn(\"kvmalloc_array failed\\n\");\n        goto err_out4;\n    }\n    [...]\n    /* 5\\. __vmalloc(): <seen later> */\n    [...]\n    return 0;\nerr_out5:\n  vfree(kvarr);\nerr_out4:\n    vfree(kv);\nerr_out3:\n    vfree(vptr_init);\nerr_out2:\n    vfree(vptr_rndm);\nerr_out1:\n    return -ENOMEM;\n}\n```", "```\nstatic void __exit vmalloc_demo_exit(void)\n{\n    vfree(vrx);\n    kvfree(kvarr);\n    kvfree(kv);\n    vfree(vptr_init);\n    vfree(vptr_rndm);\n    pr_info(\"removed\\n\");\n}\n```", "```\nkptr = kmalloc(n);\nif (!kptr) {\n    kptr = vmalloc(n);\n    if (unlikely(!kptr))\n        <... failed, cleanup ...>\n}\n<ok, continue with kptr>\n```", "```\n#include <linux/mm.h>\nvoid *kvmalloc(size_t size, gfp_t flags);\n```", "```\nvoid kvfree(const void *addr);\n```", "```\n// include/linux/mm.h\nstatic inline void *kvmalloc_array(size_t n, size_t size, gfp_t flags)\n{\n        size_t bytes;\n        if (unlikely(check_mul_overflow(n, size, &bytes)))\n                return NULL;\n        return kvmalloc(bytes, flags);\n}\n```", "```\nvoid *kvcalloc(size_t n, size_t size, gfp_t flags);\n```", "```\nvoid *kvmalloc_node(size_t size, gfp_t flags, int node);\n```", "```\n$ sudo grep \"^0x00000000fb2af97f\" /proc/vmallocinfo\n0x00000000fb2af97f-0x00000000ddc1eb2c 5246976 0xffffffffc04a113d pages=1280 vmalloc vpages N0=1280\n```", "```\n* For tight control over page level allocator and protection flags\n* use __vmalloc() instead.\n```", "```\nvoid *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot);\n```", "```\nvrx = __vmalloc(42 * PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_RO);\n```", "```\nstatic int vmalloc_try(void)\n{\n    [...]\n    /* 5\\. __vmalloc(): allocate some 42 pages and set protections to RO */\n/* #undef WR2ROMEM_BUG */\n#define WR2ROMEM_BUG /* 'Normal' usage: keep this commented out, else we \n                      *  will crash! Read  the book, Ch 9, for details :-) */\n    if (!(vrx = __vmalloc(42*PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_RO))) {\n        pr_warn(\"%s: __vmalloc failed\\n\", OURMODNAME);\n        goto err_out5;\n    }\n    pr_info(\"5\\. __vmalloc(): vrx = 0x%pK (actual=0x%px)\\n\", vrx, vrx);\n    /* Try reading the memory, should be fine */\n    print_hex_dump_bytes(\" vrx: \", DUMP_PREFIX_NONE, vrx, DISP_BYTES);\n#ifdef WR2ROMEM_BUG\n    /* Try writing to the RO memory! We find that the kernel crashes\n     * (emits an Oops!) */\n   *(u64 *)(vrx+4) = 0xba;\n#endif\n    return 0;\n    [...]\n```", "```\nBUG: unable to handle page fault for address: ffffa858c1a39004\n#PF: supervisor write access in kernel mode\n#PF: error_code(0x0003) - permissions violation\n```", "```\n$ cat /proc/sys/kernel/sysrq\n16\n```", "```\n$ sudo sh -c \"echo 1 > /proc/sys/kernel/sysrq\"\n```", "```\n# echo f > /proc/sysrq-trigger\n```", "```\n// ch9/oom_killer_try/oom_killer_try.c\n#define BLK     (getpagesize()*2)\nstatic int force_page_fault = 0;\nint main(int argc, char **argv)\n{\n  char *p;\n  int i = 0, j = 1, stepval = 5000, verbose = 0;\n  [...]\n\n  do {\n      p = (char *)malloc(BLK);\n      if (!p) {\n          fprintf(stderr, \"%s: loop #%d: malloc failure.\\n\",\n                  argv[0], i);\n          break;\n      }\n\n      if (force_page_fault) {\n          p[1103] &= 0x0b; // write something into a byte of the 1st page\n          p[5227] |= 0xaa; // write something into a byte of the 2nd page\n      }\n      if (!(i % stepval)) { // every 'stepval' iterations..\n          if (!verbose) {\n              if (!(j%5)) printf(\". \");\n         [...]\n      }\n      i++;\n } while (p && (i < atoi(argv[1])));\n```", "```\n$ cat /proc/sys/vm/overcommit_memory  /proc/sys/vm/overcommit_ratio0\n50                       \n$                           << explained below >>\n\n$ ./oom-killer-try\nUsage: ./oom-killer-try alloc-loop-count force-page-fault[0|1] [verbose_flag[0|1]]\n$ ./oom-killer-try 2000000 0\n./oom-killer-try: PID 28896\n..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ...Killed\n$\n```", "```\n$ cat /proc/sys/vm/overcommit_memory\n0\n```", "```\n$ cat /proc/sys/vm/overcommit_ratio\n50\n```", "```\n$ cat /proc/sys/vm/overcommit_memory /proc/sys/vm/overcommit_ratio0\n50\n$ free -h\n              total    used    free     shared   buff/cache    available\nMem:          1.9Gi   1.0Gi    76Mi       12Mi        866Mi        773Mi\nSwap:         2.1Gi   3.0Mi   2.1Gi\n$ ./oom-killer-try\nUsage: ./oom-killer-try alloc-loop-count force-page-fault[0|1] [verbose_flag[0|1]]\n$ ./oom-killer-try 900000 1\n./oom_killer_try: PID 2032 (verbose mode: off)\n..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... .Killed\n$ \n$ free -h\n              total    used    free    shared   buff/cache     available\nMem:          1.9Gi   238Mi   1.5Gi     2.0Mi        192Mi         1.6Gi\nSwap:         2.1Gi   428Mi   1.6Gi\n$\n```", "```\n$ grep CommitLimit /proc/meminfo\nCommitLimit: 3182372 kB\n```", "```\n[...]\nTasks state (memory values in pages):\n[ pid ]  uid  tgid total_vm    rss pgtables_bytes swapents oom_score_adj name\n[  607]    0   607    11774      8   106496       361   -250 systemd-journal\n[  622]    0   622    11097      0    90112      1021  -1000 systemd-udevd\n[  732]    0   732     7804      0    69632       153  -1000 auditd\n\n              [...]\n\n[ 1950] 1000  1950    56717      1   77824        571  0    bash\n[ 2032] 1000  2032   755460 434468 6086656     317451  0    oom_killer_try\noom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-1000.slice/session-3.scope,task=oom_killer_try,pid=2032,uid=1000\nOut of memory: Killed process 2032 (oom_killer_try) total-vm:3021840kB, anon-rss:1737872kB, file-rss:0kB, shmem-rss:0kB, UID:1000 pgtables:6086656kB oom_score_adj:0\noom_reaper: reaped process 2032 (oom_killer_try), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB\n$ \n```", "```\n  net_oom_score = oom_score + oom_score_adj;\n```", "```\n./query_process_oom.sh | sort -k3n | tail\n```"]