- en: Chapter 9. Wic and Other Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 Wic和其他工具
- en: In this chapter, you will be given a brief introduction to a number of tools
    that address various problems and solves them in ingenious ways. This chapter
    can be thought of as an appetizer for you. If any of the tools presented here
    seem to interest you, I encourage you to feed your curiosity and try to find more
    about that particular tool. Of course, this piece of advice applies to any information
    presented in this book. However, this bit of advice holds true particularly for
    this chapter because I've chosen a more general description for the tools I've
    presented. I've done this as I've assumed that some of you may not be interested
    in lengthy descriptions and would only want to focus your interest in the development
    process, rather than in other areas. For the rest of you who are interested in
    finding out more about other key areas, please feel free to go through the extensions
    of information available throughout the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将简要介绍一些解决各种问题并以巧妙方式解决它们的工具。这一章可以被认为是为你准备的开胃菜。如果这里介绍的任何工具似乎引起了你的兴趣，我鼓励你满足你的好奇心，尝试找到更多关于那个特定工具的信息。当然，这条建议适用于本书中提供的任何信息。然而，这条建议特别适用于本章，因为我选择了对我介绍的工具进行更一般的描述。我这样做是因为我假设你们中的一些人可能对冗长的描述不感兴趣，而只想把兴趣集中在开发过程中，而不是其他领域。对于其他对了解更多其他关键领域感兴趣的人，请随意浏览本章中提供的信息扩展。
- en: In this chapter, a more detailed explanation of components, such as Swabber,
    Wic, and LAVA, will be offered. These tools are not the ones, which an embedded
    developer will encounter on everyday jobs, though interaction with such tools
    could make life a little easier. The first thing I should mention about these
    tools is that they have nothing in common with each other, and are very different
    from each other and address different requests. If Swabber, the first tool presented
    here, is used for access detection on a host development machine, the second tool
    represents a solution to the limitations that BitBake has with complex packaging
    options. Here, I am referring to the wic tool. The last element presented in this
    chapter is the automation testing framework called LAVA. It is an initiative from
    Linaro, a project that, in my opinion, is very interesting to watch. They are
    also combined with a continuous integration tool, like Jenkins, and this could
    make it a killer combination for every taste.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将提供对Swabber、Wic和LAVA等组件的更详细解释。这些工具不是嵌入式开发人员在日常工作中会遇到的工具，但与这些工具的交互可能会让生活变得更轻松一些。我应该首先提到这些工具的一件事是它们彼此之间没有任何共同之处，它们之间非常不同，并且解决了不同的问题。如果Swabber，这里介绍的第一个工具，用于在主机开发机器上进行访问检测，那么第二个工具代表了BitBake在复杂打包选项方面的限制的解决方案。在这里，我指的是wic工具。本章介绍的最后一个元素是名为LAVA的自动化测试框架。这是来自Linaro的一个倡议，我认为这个项目非常有趣。它还与Jenkins等持续集成工具结合在一起，这可能对每个人都是一个致命的组合。
- en: Swabber
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖把
- en: Swabber is a project, which although is presented on Yocto Project's official
    page, is said to be a work in progress; no activity has been done on it since
    September 18, 2011\. It does not have a maintainers file where you can find more
    information about its creators. However, the committers list should be enough
    for anyone interested in taking a deeper look at this project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Swabber是一个项目，虽然它在Yocto Project的官方页面上展示，但据说它还在进行中；自2011年9月18日以来没有任何活动。它没有维护者文件，您无法在其中找到更多关于其创建者的信息。然而，对于任何对这个项目感兴趣的人来说，提交者列表应该足够了解更多。
- en: This tool was selected for a short introduction in this chapter because it constitutes
    another point of view of the Yocto Project's ecosystem. Of course, a mechanism
    for access detection into the host system is not a bad idea and is very useful
    to detect accesses that could be problematic for your system, but it is not the
    first tool that comes to mind when developing software. When you have the possibility
    of redoing your build and inspecting your host ecosystem manually, you tend to
    lose sight of the fact that tools could be available for this task too, and that
    they could make your life easier.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章选择介绍这个工具，因为它构成了Yocto Project生态系统的另一个视角。当然，对主机系统进行访问检测的机制并不是一个坏主意，对于检测可能对系统有问题的访问非常有用，但在开发软件时并不是首选的工具。当你有可能重新构建并手动检查主机生态系统时，你往往会忽视工具也可以用于这个任务，并且它们可以让你的生活更轻松。
- en: 'For interaction with Swabber, the repository needs to be cloned first. The
    following command can be used for this purpose:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与Swabber交互，需要首先克隆存储库。可以使用以下命令来实现这一目的：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the source code is available on the host, the content of the repository
    should look as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码在主机上可用后，存储库的内容应如下所示：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, this project is not a major one, but consists of a number of
    tools made available by a passionate few. This includes two guys from **Windriver**:
    Alex deVries and David Borman. They worked on their own on the previously presented
    tools and made them available for the open source community to use. Swabber is
    written using the C language, which is a big shift from the usual Python/Bash
    tools and other projects that are offered by the Yocto Project community. Every
    tool has its own purpose, the similitude being that all the tools are built using
    the same Makefile. Of course, this isn''t restricted only to the usage of binaries;
    there are also two bash scripts available for distribution detect and update.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个项目并不是一个重大项目，而是由一些热情的人提供的一些工具。其中包括来自**Windriver**的两个人：Alex deVries和David
    Borman。他们独自开发了之前介绍的工具，并将其提供给开源社区使用。Swabber是用C语言编写的，这与Yocto Project社区提供的通常的Python/Bash工具和其他项目有很大的不同。每个工具都有自己的目的，相似之处在于所有工具都是使用相同的Makefile构建的。当然，这不仅限于使用二进制文件；还有两个bash脚本可用于分发检测和更新。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: More information about the tool can be found from its creators. Their e-mail
    addresses, which are available in the commits for the project, are `<[alex.devries@windriver.com](mailto:alex.devries@windriver.com)>`
    and `<[david.borman@windriver.com](mailto:david.borman@windriver.com)>`. However,
    please note that these are the workplace e-mail IDs and the people that worked
    on Swabber may not have the same e-mail address at the moment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关该工具的更多信息可以从其创建者那里获得。他们的电子邮件地址，可在项目的提交中找到，分别是`<[alex.devries@windriver.com](mailto:alex.devries@windriver.com)>`和`<[david.borman@windriver.com](mailto:david.borman@windriver.com)>`。但请注意，这些是工作场所的电子邮件地址，而曾经参与Swabber工作的人现在可能没有相同的电子邮件地址。
- en: The interaction with the Swabber tools is well described in the `README` file.
    Here, information regarding the setup and running of Swabber is available, though,
    for your sake, this will also be presented in the next few lines, so that you
    can understand quicker and in an easier manner.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与Swabber工具的交互在`README`文件中有很好的描述。在这里，关于Swabber的设置和运行的信息是可用的，不过，为了你的方便，这也将在接下来的几行中呈现，以便你能更快地理解和更容易地掌握。
- en: 'The first required step is the compilation of sources. This is done by invoking
    the `make` command. After the source code is built and the executables are available,
    the host distribution can be profiled using the `update_distro` command, followed
    by the location of the distribution directory. The name we''ve chosen for it is
    `Ubuntu-distro-test`, and it is specific for the host distribution on which the
    tool is executed. This generation process can take some time at first, but after
    this, any changes to the host system will be detected and the process will take
    lesser time. At the end of the profiling process, this is how the content of the
    `Ubuntu-distro-test` directory looks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个必要的步骤是编译源代码。这是通过调用`make`命令来完成的。在源代码构建并可执行文件可用后，可以使用`update_distro`命令对主机分发进行配置，然后是分发目录的位置。我们选择的名称是`Ubuntu-distro-test`，它是特定于执行工具的主机分发。这个生成过程一开始可能需要一些时间，但之后，对主机系统的任何更改都将被检测到，并且过程所需的时间将更少。在配置过程结束时，`Ubuntu-distro-test`目录的内容如下：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the host distribution is profiled, a Swabber report can be generated
    based on the profile created. Also, before creating the report, a profile log
    can be created for later use along with the reporting process. To generate the
    report, we will create a log file location with some specific log information.
    After the logs are available, the reports can be generated:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主机分发配置文件后，可以基于创建的配置文件生成一个Swabber报告。此外，在创建报告之前，还可以创建一个配置文件日志，以备报告过程中使用。为了生成报告，我们将创建一个具有特定日志信息的日志文件位置。日志可用后，就可以生成报告了：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This information was required by the tool, as shown in its help information:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工具需要这些信息，如其帮助信息所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the help information attached in the preceding code, the role of the arguments
    selected for the test command can be investigated. Also, an inspection of the
    tool's source code is recommended due to the fact that there are no more than
    1550 lines in a C file, the biggest one being the `swabber.c` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面代码中附加的帮助信息中，可以调查测试命令所选参数的作用。此外，由于C文件中不超过1550行，最大的文件是`swabber.c`文件，因此建议检查工具的源代码。
- en: The `required.txt` file contains the information about the packages used and
    also about the packages specific files. More information regarding configurations
    is also available inside the `extra.txt` file. Such information includes files
    and packages that can be accessed, various warnings and files that are not available
    in the host database, and various errors and files that are considered dangerous.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`required.txt`文件包含有关使用的软件包和特定文件的信息。有关配置的更多信息也可以在`extra.txt`文件中找到。这些信息包括可以访问的文件和软件包，各种警告以及主机数据库中不可用的文件，以及各种错误和被视为危险的文件。'
- en: For the command on which the tracing is done, the output information is not
    much. It has only been offered as an example; I encourage you to try various scenarios
    and familiarize yourselves with the tool. It could prove helpful to you later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跟踪的命令，输出信息并不多。这只是一个示例；我鼓励你尝试各种场景，并熟悉这个工具。这可能对你以后有所帮助。
- en: Wic
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wic
- en: Wic is a command line tool that can be also seen as an extension of the BitBake
    build system. It was developed due to the need of having a partitioning mechanism
    and a description language. As it can be concluded easily, BitBake lacks in these
    areas and although initiatives were taken to make sure that such a functionality
    would be available inside the BitBake build system, this was only possible to
    an extent; for more complex tasks, Wic can be an alternative solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Wic是一个命令行工具，也可以看作是BitBake构建系统的扩展。它是由于需要有一个分区机制和描述语言而开发的。很容易得出结论，BitBake在这些方面存在不足，尽管已经采取了一些措施，以确保这样的功能在BitBake构建系统内可用，但这只能在一定程度上实现；对于更复杂的任务，Wic可以是一个替代解决方案。
- en: In the following lines, I will try to describe the problem associated with BitBake's
    lack of functionality and how Wic can solve this problem in an easy manner. I
    will also show you how this tool was born and what source of inspiration source
    was.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我将尝试描述与BitBake功能不足相关的问题，以及Wic如何以简单的方式解决这个问题。我还将向你展示这个工具是如何诞生的，以及灵感来源是什么。
- en: When an image is being built using BitBake, the work is done inside an image
    recipe that inherits `image.bbclass` for a description of its functionality. Inside
    this class, the `do_rootfs()` task is the one that the OS responsible for the
    creation of the root filesystem directory that will be later be included in the
    final package and includes all the sources necessary to boot a Linux image on
    various boards. With the `do_rootf()` task finished, a number of commands are
    interrogated to generate an output for each one of the image defined types. The
    definition of the image type is done through the `IMAGE_FSTYPE` variable and for
    each image output type, there is an `IMAGE_CMD_type` variable defined as an extra
    type that is inherited from an external layer or a base type described in the
    `image_types.bbclass` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用BitBake构建图像时，工作是在继承`image.bbclass`的图像配方中完成的，以描述其功能。在这个类中，`do_rootfs()`任务是负责创建后续将包含在最终软件包中的根文件系统目录的OS。该目录包含了在各种板上引导Linux图像所需的所有源。完成`do_rootfs()`任务后，会查询一系列命令，为每种图像定义类型生成输出。图像类型的定义是通过`IMAGE_FSTYPE`变量完成的，对于每种图像输出类型，都有一个`IMAGE_CMD_type`变量被定义为从外部层继承的额外类型，或者是在`image_types.bbclass`文件中描述的基本类型。
- en: 'The commands behind every one of these types are, in fact, a shell command-specific
    for a defined root filesystem format. The best example of this is the `ext3` format.
    For this, the `IMAGE_CMD_ext3` variable is defined and these commands are invoked,
    shown as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每种类型背后的命令都是针对特定的根文件系统格式的shell命令。其中最好的例子就是`ext3`格式。为此，定义了`IMAGE_CMD_ext3`变量，并调用了这些命令，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the commands are called, the output is in the form of a `image-*.ext3`
    file. It is a newly created EXT3 filesystem according to the `FSTYPES` defined
    variable value, and it incorporates the root filesystem content. This example
    presents a very common and basic filesystem creation of commands. Of course, more
    complex options could be required in an industry environment, options that incorporate
    more than the root filesystem and add an extra kernel or even the bootloader alongside
    it, for instance. For these complex options, extensive mechanisms or tools are
    necessary.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用命令后，输出以`image-*.ext3`文件的形式呈现。这是根据定义的`FSTYPES`变量值新创建的EXT3文件系统，并包含了根文件系统内容。这个例子展示了一个非常常见和基本的文件系统创建命令。当然，在工业环境中可能需要更复杂的选项，这些选项不仅包括根文件系统，还可能包括额外的内核或甚至是引导加载程序。对于这些复杂的选项，需要广泛的机制或工具。
- en: 'The available mechanism implemented in the Yocto Project is visible inside
    the `image_types.bbclass` file through the `IMAGE_CMD_type` variable and has this
    form:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目中可见的可用机制在`image_types.bbclass`文件中通过`IMAGE_CMD_type`变量可见，并具有以下形式：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use the newly defined image formats, the machine configuration needs to
    be updated accordingly, using the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新定义的图像格式，需要相应地更新机器配置，使用以下命令：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using the `inherit ${IMAGE_CLASSES}` command inside the `image.bbclass` file,
    the newly defined `image_types_foo.bbclass` file's functionality is visible and
    ready to be used and added to the `IMAGE_FSTYPE` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`image.bbclass`文件中使用`inherit ${IMAGE_CLASSES}`命令，新定义的`image_types_foo.bbclass`文件的功能可见并准备好被使用，并添加到`IMAGE_FSTYPE`变量中。
- en: The preceding implementation implies that for each implemented filesystem, a
    series of commands are invoked. This is a good and simple method for a very simple
    filesystem format. However, for more complex ones, a language would be required
    to define the format, its state, and in general, the properties of the image format.
    Various other complex image format options, such as **vmdk**, **live**, and **directdisk**
    file types, are available inside Poky. They all define a multistage image formatting
    process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现意味着对于每个实现的文件系统，都会调用一系列命令。这对于非常简单的文件系统格式是一个很好的简单方法。然而，对于更复杂的文件系统，需要一种语言来定义格式、状态以及图像格式的属性。Poky中提供了各种其他复杂的图像格式选项，如**vmdk**、**live**和**directdisk**文件类型，它们都定义了一个多阶段的图像格式化过程。
- en: 'To use the `vmdk` image format, a `vmdk` value needs to be defined in the `IMAGE_FSTYPE`
    variable. However, for this image format to be generated and recognized, the `image-vmdk.bbclass`
    file''s functionalities should be available and inherited. With the functionalities
    available, three things can happen:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`vmdk`图像格式，需要在`IMAGE_FSTYPE`变量中定义一个`vmdk`值。然而，为了生成和识别这种图像格式，应该可用并继承`image-vmdk.bbclass`文件的功能。有了这些功能，可以发生三件事：
- en: An EXT3 image format dependency is created on the `do_rootfs()` task to make
    sure the `ext3` image format is generated first. The `vmdk` image format depends
    on this.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`do_rootfs()`任务中创建了对EXT3图像格式的依赖，以确保首先生成`ext3`图像格式。`vmdk`图像格式依赖于此。
- en: The `ROOTFS` variable is set for the `boot-directdisk` functionality.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROOTFS`变量被设置为`boot-directdisk`功能。'
- en: The `boot-directdisk.bbclass` is inherited.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承了`boot-directdisk.bbclass`。
- en: This functionality offers the possibility of generating images that can be copied
    onto a hard disk. At the base of it, the `syslinux` configuration file can be
    generated, and two partitions are also required for the boot up process. The end
    result consists of an MBR and partition table section followed by a FAT16 partition
    containing the boot files, SYSLINUX and the Linux kernel, and an EXT3 partition
    for the root filesystem location. This image format is also responsible for moving
    the Linux kernel, the `syslinux.cfg`, and `ldlinux.sys` configurations on the
    first partition, and copying using the `dd` command the EXT3 image format onto
    the second partition. At the end of this process, space is reserved for the root
    with the `tune2fs` command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能提供了生成可以复制到硬盘上的映像的可能性。在其基础上，可以生成 `syslinux` 配置文件，并且启动过程还需要两个分区。最终结果包括MBR和分区表部分，后跟一个包含引导文件、SYSLINUX和Linux内核的FAT16分区，以及用于根文件系统位置的EXT3分区。此图像格式还负责将Linux内核、`syslinux.cfg`
    和 `ldlinux.sys` 配置移动到第一个分区，并使用 `dd` 命令将EXT3图像格式复制到第二个分区。在此过程结束时，使用 `tune2fs` 命令为根目录保留空间。
- en: Historically, the usage of `directdisk` was hardcoded in its first versions.
    For every image recipe, there was a similar implementation that mirrored the basic
    one and hardcoded the heritage inside the recipe for the `image.bbclass` functionality.
    In the case of the `vmdk` image format, the `inherit boot-directdisk` line is
    added.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，`directdisk` 在其最初版本中是硬编码的。对于每个图像配方，都有一个类似的实现，它镜像了基本实现，并在 `image.bbclass`
    功能的配方中硬编码了遗产。对于 `vmdk` 图像格式，添加了 `inherit boot-directdisk` 行。
- en: 'With regard to custom-defined image filesystem types, one such example can
    be found inside the `meta-fsl-arm` layer; this example is available inside the
    `imx23evk.conf` machine definition. This machine adds the next two image filesystem
    types: `uboot.mxsboot-sdcard` and `sdcard`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自定义定义的图像文件系统类型，一个示例可以在 `meta-fsl-arm` 层中找到；此示例可在 `imx23evk.conf` 机器定义中找到。此机器添加了下面两种图像文件系统类型：`uboot.mxsboot-sdcard`
    和 `sdcard`。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `mxs-base.inc` file included in the preceding lines is in return including
    the `conf/machine/include/fsl-default-settings.inc` file, which in return adds
    the `IMAGE_CLASSES +="image_types_fsl"` line as presented in the general case.
    Using the preceding lines offers the possibility for the `IMAGE_CMD` commands
    to be first executed for the commands available for the `uboot.mxsboot-sdcard`
    format, followed by the `sdcard IMAGE_CMD` commands-specific image format.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中包含的 `mxs-base.inc` 文件又包含了 `conf/machine/include/fsl-default-settings.inc`
    文件，后者又添加了 `IMAGE_CLASSES +="image_types_fsl"` 行，如一般情况所示。使用前面的行提供了首先为 `uboot.mxsboot-sdcard`
    格式可用的命令执行 `IMAGE_CMD` 命令的可能性，然后是 `sdcard IMAGE_CMD` 命令特定的图像格式。
- en: 'The `image_types_fsl.bbclass` file defines the `IMAGE_CMD` commands, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`image_types_fsl.bbclass` 文件定义了 `IMAGE_CMD` 命令，如下所示：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the end of the execution process, the `uboot.mxsboot-sdcard` command is called
    using the `mxsboot` command. Following the execution of this command, the `IMAGE_CMD_sdcard`
    specific commands are called to calculate the SD card size and alignment, as well
    as to initialize the deploy space and set the appropriate partition type to the
    `0x53` value and copy the root filesystem onto it. At the end of the process,
    several partitions are available and they have corresponding twiddles that are
    used to package bootable images.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程结束时，使用 `mxsboot` 命令调用 `uboot.mxsboot-sdcard` 命令。执行此命令后，将调用 `IMAGE_CMD_sdcard`
    特定命令来计算SD卡的大小和对齐方式，初始化部署空间，并将适当的分区类型设置为 `0x53` 值，并将根文件系统复制到其中。在此过程结束时，将可用多个分区，并且它们具有相应的
    twiddles，用于打包可引导的映像。
- en: 'There are multiple methods to create various filesystems and they are spread
    over a large number of existing Yocto layers with some documentation available
    for the general public. There are even a number of scripts used to create a suitable
    filesystem for a developer''s needs. One such example is the `scripts/contrib/mkefidisk.sh`
    script. It is used to create an EFI-bootable direct disk image from another image
    format, that is, a `live.hddimg` one. However, a main idea remains: this kind
    of activity should be done without any middle image filesystem that is generated
    in intermediary phases and with something other than a partition language that
    is unable to handle complicated scenarios.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以创建各种文件系统，它们分布在大量现有的 Yocto 层中，并且一些文档可供一般公众使用。甚至有许多脚本用于为开发人员的需求创建合适的文件系统。其中一个示例是
    `scripts/contrib/mkefidisk.sh` 脚本。它用于从另一种图像格式（即 `live.hddimg`）创建一个EFI可引导的直接磁盘映像。然而，一个主要的想法仍然存在：这种类型的活动应该在没有在中间阶段生成的中间图像文件系统的情况下进行，并且应该使用无法处理复杂场景的分区语言。
- en: Keeping this information in mind, it seems that in the preceding example, we
    should have used another script. Considering the fact that it is possible to build
    an image from within the build system and also outside of it, the search for a
    number of tools that fit our needs was started. This search ended at the Fedora
    kickstart project. Although it has a syntax that is also suitable for areas involving
    deployment efforts, it is often considered to be of most help to developers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些信息，似乎在前面的示例中，我们应该使用另一个脚本。考虑到可以在构建系统内部和外部构建映像的可能性，开始寻找适合我们需求的一些工具。这个搜索结果是
    Fedora Kickstart 项目。尽管它的语法也适用于涉及部署工作的领域，但它通常被认为对开发人员最有帮助。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the Fedora Kickstart project at [http://fedoraproject.org/wiki/Anaconda/Kickstart](http://fedoraproject.org/wiki/Anaconda/Kickstart).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Fedora Kickstart 项目的更多信息，请访问 [http://fedoraproject.org/wiki/Anaconda/Kickstart](http://fedoraproject.org/wiki/Anaconda/Kickstart)。
- en: 'From this project, the most used and interesting components were `clearpart`,
    `part`, and `bootloader`, and these are useful for our purposes as well. When
    you take a look at the Yocto Project''s Wic tool, it is also available inside
    the configuration files. If the configuration file for Wic is defined as `.wks`
    inside the Fedora kickstart project, the configuration file read uses the `.yks`
    extension. One such configuration file is defined as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个项目中，最常用和有趣的组件是`clearpart`，`part`和`bootloader`，这些对我们的目的也很有用。当您查看Yocto项目的Wic工具时，它也可以在配置文件中找到。如果Wic的配置文件在Fedora
    kickstart项目中定义为`.wks`，则配置文件使用`.yks`扩展名。一个这样的配置文件定义如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The idea behind the preceding script is very simple: the `clearpart` component
    is used to clear the disk of any partitions while the `part` component is used
    for the reverse, that is, the components used for creating and installing the
    filesystem. The third too that is defined is the `bootloader` component, which
    is used for installation of the bootloader, and also handles the corresponding
    information received from the `part` component. It also makes sure that the boot
    process is done as described inside the configuration file. The functions defined
    as `pre()` and `post()` are used for pre and post calculus for creation of the
    image, stage image artefacts, or other complex tasks.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面脚本背后的想法非常简单：`clearpart`组件用于清除磁盘上的任何分区，而`part`组件用于相反的操作，即用于创建和安装文件系统的组件。定义的第三个工具是`bootloader`组件，用于安装引导加载程序，并处理从`part`组件接收到的相应信息。它还确保引导过程按照配置文件中的描述进行。定义为`pre()`和`post()`的函数用于创建图像、阶段图像工件或其他复杂任务的预和后计算。
- en: As shown in the preceding description, the interaction with the Fedora kickstarter
    project was very productive and interesting, but the source code is written using
    Python inside the Wic project. This is due to the fact that a Python implementation
    for a similar tool was searched for and it was found under the form of the `pykickstarted`
    library. This is not all that the preceding library was used for by the Meego
    project inside its **Meego Image Creator** (**MIC**) tool. This tool was used
    for a Meego-specific image creation process. Later, this project was inherited
    by the Tizen project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述描述所示，与Fedora kickstarter项目的交互非常富有成效和有趣，但源代码是在Wic项目内使用Python编写的。这是因为搜索了一个类似工具的Python实现，并在`pykickstarted`库的形式下找到了。这并不是Meego项目在其**Meego
    Image Creator**（**MIC**）工具中使用的前述库的全部用途。该工具用于Meego特定的图像创建过程。后来，该项目被Tizen项目继承。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more about MIC, refer to [https://github.com/01org/mic](https://github.com/01org/mic).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MIC的更多信息，请参阅[https://github.com/01org/mic](https://github.com/01org/mic)。
- en: 'Wic, the tool that I promised to present in this section is derived from the
    MIC project and both of them use the kickstarter project, so all three are based
    on plugins that define the behavior of the process of creating various image formats.
    In the first implementation of Wic, it was mostly a functionality of the MIC project.
    Here, I am referring to the Python classes it defines that were almost entirely
    copied inside Poky. However, over time, the project started to have its own implementations,
    and also its own personality. From version 1.7 of the Poky repository, no direct
    reference to MIC Python defined classes remained, making Wic a standalone project
    that had its own defined plugins and implementations. Here is how you can inspect
    the various configuration of formats accessible inside Wic:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Wic，我承诺在本节中介绍的工具，源自MIC项目，它们两者都使用kickstarter项目，因此所有三者都基于定义了创建各种图像格式过程行为的插件。在Wic的第一个实现中，它主要是MIC项目的功能。在这里，我指的是它定义的Python类，几乎完全复制到了Poky中。然而，随着时间的推移，该项目开始拥有自己的实现，也有了自己的个性。从Poky存储库的1.7版本开始，不再直接引用MIC
    Python定义的类，使Wic成为一个独立的项目，具有自己定义的插件和实现。以下是您可以检查Wic中可访问的各种格式配置的方法：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are configurations defined inside Wic. However, considering the fact that
    the interest in this tool has grown in the last few years, we can only hope that
    the number of supported configurations will increase.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Wic中定义了配置。然而，考虑到这个工具近年来的兴趣增加，我们只能希望支持的配置数量会增加。
- en: I mentioned previously that the MIC and Fedora kickstarter project dependencies
    were removed, but a quick search inside the Poky `scripts/lib/wic` directory will
    reveal otherwise. This is because Wic and MIC are both have the same foundation,
    the `pykickstarted` library. Though Wic is now heavily based on MIC and both have
    the same parent, the kickstarter project, their implementations, functionalities,
    and various configurations make them different entities, which although related
    have taken different paths of development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到MIC和Fedora kickstarter项目的依赖关系已经被移除，但在Poky `scripts/lib/wic`目录中快速搜索会发现情况并非如此。这是因为Wic和MIC都有相同的基础，即`pykickstarted`库。尽管Wic现在在很大程度上基于MIC，并且两者都有相同的父级，即kickstarter项目，但它们的实现、功能和各种配置使它们成为不同的实体，尽管相关，但它们已经走上了不同的发展道路。
- en: LAVA
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LAVA
- en: '**LAVA** (**Linaro Automation and Validation Architecture**) is a continuous
    integration system that concentrates on a physical target or virtual hardware
    deployment where a series of tests are executed. The executed tests are of a large
    variety from the simplest ones which only requires booting a target to some very
    complex scenarios that require external hardware interaction.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAVA**（**Linaro自动化和验证架构**）是一个连续集成系统，专注于物理目标或虚拟硬件部署，其中执行一系列测试。执行的测试种类繁多，从只需要启动目标的最简单测试到需要外部硬件交互的非常复杂的场景。'
- en: LAVA represents a collection of components that are used for automated validation.
    The main idea behind the LAVA stack is to create a quality controlled testing
    and automation environment that is suitable for projects of all sizes. For a closer
    look at a LAVA instance, the reader could inspect an already created one, the
    official production instance of which is hosted by Linaro in Cambridge. You can
    access it at [https://validation.linaro.org/](https://validation.linaro.org/).
    I hope you enjoy working with it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: LAVA代表一系列用于自动验证的组件。LAVA堆栈的主要思想是创建一个适用于各种规模项目的质量受控测试和自动化环境。要更仔细地查看LAVA实例，读者可以检查已经创建的实例，由Linaro在剑桥托管的官方生产实例。您可以在[https://validation.linaro.org/](https://validation.linaro.org/)访问它。希望您喜欢使用它。
- en: 'The LAVA framework offers support for the following functionalities:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: LAVA框架支持以下功能：
- en: It supports scheduled automatic testing for multiple packages on various hardware
    packages
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持在各种硬件包上对多个软件包进行定期自动测试
- en: It makes sure that after a device crashes, the system restarts automatically
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保设备崩溃后系统会自动重新启动
- en: It conducts regression testing
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它进行回归测试
- en: It conducts continuous integration testing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它进行持续集成测试
- en: It conducts platform enablement testing
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它进行平台启用测试
- en: It provides support for both local and cloud solutions
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持本地和云解决方案
- en: It provides support for result bundles
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了结果捆绑支持
- en: It provides measurements for performance and power consumption
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供性能和功耗的测量
- en: LAVA is primarily written using Python, which is no different from what the
    Yocto Project offers us. As seen in the Toaster Project, LAVA also uses the Django
    framework for a web interface and the project is hosted using the Git versioning
    system. This is no surprise since we are talking about Linaro, a not-for-profit
    organization that works on free and open source projects. Therefore, the thumb
    rule applied to all the changes made to the project should return in the upstream
    project, making the project a little easier to maintain. However, it is also more
    robust and has better performance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LAVA主要使用Python编写，这与Yocto项目提供的内容没有什么不同。正如在Toaster项目中看到的那样，LAVA还使用Django框架进行Web界面，项目使用Git版本控制系统进行托管。这并不奇怪，因为我们正在谈论Linaro，这是一个致力于自由开源项目的非营利组织。因此，应用于项目的所有更改应返回到上游项目，使项目更容易维护。但是，它也更健壮，性能更好。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those of you interested in more details about how this project can be used,
    refer to [https://validation.linaro.org/static/docs/overview.html](https://validation.linaro.org/static/docs/overview.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对如何使用该项目的更多细节感兴趣的人，请参阅[https://validation.linaro.org/static/docs/overview.html](https://validation.linaro.org/static/docs/overview.html)。
- en: 'For testing with the LAVA framework, the first step would be to understand
    its architecture. Knowing this helps not only with test definitions, but also
    with extending them, as well as the development of the overall project. The major
    components of this project are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LAVA框架进行测试，第一步是了解其架构。了解这一点不仅有助于测试定义，还有助于扩展测试，以及整个项目的开发。该项目的主要组件如下：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first component, the **web interface**, is responsible for user interaction.
    It is used to store data and submitted jobs using RDBMS, and is also responsible
    to display the results, device navigation, or as job submission receiver activities
    that are done through the XMLRPC API. Another important component is represented
    by **the scheduler daemon**, which is responsible for the allocation of jobs.
    Its activity is quite simple. It is responsible for pooling the data from a database
    and reserving devices for jobs that are offered to them by the dispatcher, another
    important component. The **dispatcher** is the component responsible for running
    actual jobs on the devices. It also manages the communication with a device, download
    images, and collects results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组件**Web界面**负责用户交互。它用于存储数据和使用RDBMS提交作业，并负责显示结果、设备导航，或者通过XMLRPC API进行作业提交接收活动。另一个重要组件是**调度程序守护程序**，负责分配作业。它的活动非常简单。它负责从数据库中汇集数据，并为由调度程序提供给它们的作业保留设备，调度程序是另一个重要组件。**调度程序**是负责在设备上运行实际作业的组件。它还管理与设备的通信，下载图像并收集结果。
- en: There are scenarios when only the dispatcher can be used; these scenarios involve
    the usage of a local test or a testing feature development. There are also scenarios
    where all the components run on the same machine, such as a single deployment
    server. Of course, the desired scenario is to have components decoupled, the server
    on one machine, database on another one, and the scheduler daemon and dispatcher
    on a separate machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时只能使用调度程序的情况；这些情况涉及使用本地测试或测试功能开发。还有一些情况，所有组件都在同一台机器上运行，比如单个部署服务器。当然，理想的情况是组件解耦，服务器在一台机器上，数据库在另一台机器上，调度程序守护程序和调度程序在另一台机器上。
- en: 'For the development process with LAVA, the recommended host machines are Debian
    and Ubuntu. The Linaro development team working with LAVA prefer the Debian distribution,
    but it can work well on an Ubuntu machine as well. There are a few things that
    need to be mentioned: for the Ubuntu machine, make sure that the universe repositories
    are available and visible by your package manager.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用LAVA进行开发过程，推荐的主机是Debian和Ubuntu。与LAVA合作的Linaro开发团队更喜欢Debian发行版，但它也可以在Ubuntu机器上很好地运行。有一些需要提到的事情：对于Ubuntu机器，请确保宇宙存储库可供包管理器使用并可见。
- en: 'The first package that is necessary is `lava-dev`; it also has scripts that
    indicate the necessary package dependencies to assure the LAVA working environment.
    Here are the necessary commands required to do this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的第一个软件包是`lava-dev`；它还有脚本指示必要的软件包依赖项，以确保LAVA工作环境。以下是执行此操作所需的必要命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Taking into consideration the location of the changes, various actions are required.
    For example, for a change in the `templates` directory's HTML content, refreshing
    the browser will suffice, but any changes made in the `*_app` directory's Python
    implementation will require a restart of the `apache2ctl` HTTP server. Also, any
    change made in the `*_daemon` directory's Python sources will require a restart
    of `lava-server` altogether.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到更改的位置，需要采取各种行动。例如，对于“模板”目录中的HTML内容的更改，刷新浏览器就足够了，但在“*_app”目录的Python实现中进行的任何更改都需要重新启动“apache2ctl”HTTP服务器。此外，“*_daemon”目录中的Python源代码的任何更改都需要完全重新启动“lava-server”。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For all of you interested in acquiring more information about LAVA development,
    the development guide constitutes a good resource of documentation, which is available
    at [https://validation.linaro.org/static/docs/#developer-guides](https://validation.linaro.org/static/docs/#developer-guides).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有对获取有关LAVA开发的更多信息感兴趣的人，开发指南构成了一份良好的文档资源，可在[https://validation.linaro.org/static/docs/#developer-guides](https://validation.linaro.org/static/docs/#developer-guides)找到。
- en: 'To install LAVA or any LAVA-related packages on a 64-bit Ubuntu 14.04 machine,
    new package dependencies are required in addition to the enabled support for universal
    repositories `deb http://people.linaro.org/~neil.williams/lava jessie main`, besides
    the installation process described previously for the Debian distribution. I must
    mention that when the `lava-dev` package is installed, the user will be prompted
    to a menu that indicates `nullmailer mailname`. I''ve chosen to let the default
    one remain, which is actually the host name of the computer running the `nullmailer`
    service. I''ve also kept the same configuration defined by default for `smarthost`
    and the installation process has continued. The following are the commands necessary
    to install LAVA on a Ubuntu 14.04 machine:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在64位Ubuntu 14.04机器上安装LAVA或任何与LAVA相关的软件包，除了启用通用存储库`deb http://people.linaro.org/~neil.williams/lava
    jessie main`之外，还需要新的软件包依赖项，以及之前为Debian发行版描述的安装过程。我必须提到，当安装“lava-dev”软件包时，用户将被提示进入一个菜单，指示“nullmailer
    mailname”。我选择让默认值保持不变，实际上这是运行“nullmailer”服务的计算机的主机名。我还保持了默认为“smarthost”定义的相同配置，并且安装过程已经继续。以下是在Ubuntu
    14.04机器上安装LAVA所需的命令：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Information about the LAVA installation process is available at [https://validation.linaro.org/static/docs/installing_on_debian.html#](https://validation.linaro.org/static/docs/installing_on_debian.html#).
    Here, you also find the installation processes for bot Debian and Ubuntu distributions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关LAVA安装过程的信息可在[https://validation.linaro.org/static/docs/installing_on_debian.html#](https://validation.linaro.org/static/docs/installing_on_debian.html#)找到。在这里，您还可以找到Debian和Ubuntu发行版的安装过程。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were presented a new set of tools. I will honestly admit
    that these tools are not the ones used most often in an embedded environment,
    but they've been introduced in order to offer another point of view to the embedded
    development environment. This chapter tried to explain to developers that there
    is more to the embedded world then just development and the tools that help with
    these tasks. In most cases, the adjacent components are the ones that could inspire
    and influence the development process the most.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被介绍了一组新的工具。我必须诚实地承认，这些工具并不是在嵌入式环境中最常用的工具，但它们被引入是为了为嵌入式开发环境提供另一个视角。本章试图向开发人员解释，嵌入式世界不仅仅是开发和帮助这些任务的工具。在大多数情况下，相邻的组件可能是对开发过程影响最大的组件。
- en: In the next chapter, a short presentation of the Linux real-time requirements
    and solutions will be presented. We will emphasize the various features that work
    alongside Linux in this area. A short presentation of the meta-realtime layer
    will be offered, and features, such as Preempt-RT and NOHZ, will be discussed.
    Without further ado, let's proceed to the next chapter. I hope you will enjoy
    its content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将简要介绍Linux实时要求和解决方案。我们将强调在这一领域与Linux一起工作的各种功能。将提供meta-realtime层的简要介绍，并讨论Preempt-RT和NOHZ等功能。话不多说，让我们继续下一章。希望您会喜欢它的内容。
