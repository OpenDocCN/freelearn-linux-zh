- en: Chapter 5. Linux Binary Protection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Linux二进制保护
- en: In this chapter, we are going to explore the basic techniques and motivations
    for obfuscation of Linux programs. Techniques that obfuscate or encrypt binaries
    or make them difficult to tamper with are called software protection schemes.
    By "software protection," we mean binary protection or binary hardening techniques.
    Binary hardening is not exclusive to Linux; in fact, there are many more products
    for the Windows OS in this technology genre, and there are definitely more examples
    to choose from for discussion.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Linux程序混淆的基本技术和动机。混淆或加密二进制文件或使其难以篡改的技术称为软件保护方案。通过“软件保护”，我们指的是二进制保护或二进制加固技术。二进制加固不仅适用于Linux；事实上，在这个技术类型中，Windows
    OS有更多的产品，也有更多的例子可供讨论。
- en: What many people fail to realize is that Linux has a market for this too, although
    it largely exists for anti-tamper products used by the government. There are also
    a number of ELF binary protectors that were released over the last decade in the
    hacker community, several of which paved the way for many of the technologies
    used today.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人没有意识到Linux也有市场需求，尽管主要用于政府使用的反篡改产品。在黑客社区中，过去十年中也发布了许多ELF二进制保护程序，其中有几个为今天使用的许多技术铺平了道路。
- en: An entire book could be dedicated to the art of software protection, and as
    the author of some of the more recent binary protection technologies for ELF,
    I could easily get carried away with this chapter. Instead, I will stick to explaining
    the fundamentals and some interesting techniques that are used, followed by some
    insights into my own binary protector—**Maya's Veil**. The tricky engineering
    and skills that go into binary protection make it a challenging topic to articulate,
    but I will do my best here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都可以专门讨论软件保护的艺术，作为一些最新的ELF二进制保护技术的作者，我很容易在这一章中陷入其中。相反，我将坚持解释基本原理和一些有趣的技术，然后深入了解我自己的二进制保护程序——**玛雅的面纱**。二进制保护所涉及的复杂工程和技能使其成为一个具有挑战性的话题，但我会尽力而为。
- en: ELF binary packers – dumb protectors
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF二进制打包程序-愚蠢的保护程序
- en: A **packer** is a type of software that is commonly used by malware authors
    and hackers to compress or encrypt an executable in order to obfuscate its code
    and data. One very common packer is named UPX ([http://upx.sourceforge.net](http://upx.sourceforge.net))
    and is available as a package on most Linux distributions. The original purpose
    of this type of packer was to compress an executable and make it smaller.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包程序**是一种常用于恶意软件作者和黑客的软件类型，用于压缩或加密可执行文件以混淆其代码和数据。一个非常常见的打包程序名为UPX（[http://upx.sourceforge.net](http://upx.sourceforge.net)），并且在大多数Linux发行版中都作为一个软件包提供。这种类型的打包程序的最初目的是压缩可执行文件并使其更小。'
- en: Since the code is compressed, it must have a way to decompress itself before
    executing in memory—this is where things get interesting, and we will discuss
    how this works in the *Stub mechanics and the userland exec* section. At any rate,
    malware authors have realized that compressing their malware-infected files would
    evade AV detection due to obfuscation. This led malware/antivirus researchers
    to develop automated unpackers, which are now used in most, if not all, modern
    AV products.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码被压缩，必须有一种方法在内存中执行之前对其进行解压缩——这就是事情变得有趣的地方，我们将在*存根机制和用户空间执行*部分讨论这是如何工作的。无论如何，恶意软件作者已经意识到，压缩其恶意软件感染文件将由于混淆而逃避AV检测。这导致恶意软件/杀毒软件研究人员开发了自动解包程序，现在几乎所有现代AV产品都在使用。
- en: Nowadays, the term "packed binary" refers not only to compressed binaries but
    also to encrypted binaries or binaries that are shielded with an obfuscation layer
    of any kind. Since the early 2000s, there have been several remarkable ELF binary
    protectors that have shaped the future of binary protection in Linux. We will
    explore each one of these and use them to model the different techniques used
    to protect ELF binaries. Beforehand, however, let's look at how stubs work to
    load and execute a compressed or encrypted binary.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，“打包二进制”一词不仅指压缩的二进制文件，还指加密的二进制文件或者任何形式的混淆层保护的二进制文件。自21世纪初以来，已经出现了几种显著的ELF二进制文件保护程序，塑造了Linux中二进制保护的未来。我们将探讨每一种保护程序，并使用它们来模拟保护ELF二进制文件所使用的不同技术。然而，在此之前，让我们看看存根是如何工作的，以加载和执行压缩或加密的二进制文件。
- en: Stub mechanics and the userland exec
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根机制和用户空间执行
- en: 'First, it is necessary to understand that a software protector is actually
    made up of two programs:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有必要了解软件保护实际上由两个程序组成：
- en: '**Protection phase code**: The program that applies the protection to the target
    binary'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护阶段代码**：将保护应用于目标二进制文件的程序'
- en: '**Runtime engine or stub**: The program that is merged with the target binary
    that is responsible for deobfuscation and anti-debugging at runtime'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时引擎或存根**：与目标二进制文件合并的程序，负责在运行时进行反混淆和反调试'
- en: The protector program can vary greatly depending on the types of protection
    that are being applied to the target binary. Whatever type of protection is being
    applied to the target binary must be understood by the runtime code. The runtime
    code (or stub) must know how to decrypt or deobfuscate the binary that it is merged
    with. In most cases of software protection, there is a relatively simple runtime
    engine merged with the protected binary; its sole purpose is to decrypt the binary
    and pass control to the decrypted binary in memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 保护程序的类型可以因应用于目标二进制文件的保护类型而有很大不同。无论应用于目标二进制文件的保护类型是什么，运行时代码必须能够理解。运行时代码（或存根）必须知道如何解密或反混淆与其合并的二进制文件。在大多数软件保护的情况下，受保护的二进制文件与一个相对简单的运行时引擎合并；它的唯一目的是解密二进制文件并将控制权传递给内存中的解密二进制文件。
- en: This type of runtime engine is not so much an engine—really—and we call it a
    stub. The stub is generally compiled without any libc linkings (for example, `gcc
    -nostdlib`), or is statically compiled. This type of stub, although simpler than
    a true runtime engine, is actually still quite complicated because it must be
    able to `exec()` a program from memory—this is where **userland exec** comes into
    play. We can thank the grugq for his contributions here.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的运行时引擎并不是一个引擎，我们称之为存根。存根通常是编译而成的，没有任何libc链接（例如，`gcc -nostdlib`），或者是静态编译的。这种存根虽然比真正的运行时引擎简单，但实际上仍然相当复杂，因为它必须能够从内存中`exec()`一个程序，这就是**用户空间执行**发挥作用的地方。我们应该感谢grugq在这里的贡献。
- en: The `SYS_execve` system call, which is generally used by the `glibc` wrappers
    (for example, `execve`, `execv`, `execle`, and `execl`) will load and run an executable
    file. In the case of a software protector, the executable is encrypted and must
    be decrypted prior to being executed. Only an unseasoned hacker would program
    their stub to decrypt the executable and then write it to disk in a decrypted
    form before they execute it with `SYS_exec`, although the original UPX packer
    did work this way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`glibc`包装器（例如`execve`，`execv`，`execle`和`execl`）的`SYS_execve`系统调用将加载并运行可执行文件。在软件保护程序的情况下，可执行文件是加密的，必须在执行之前解密。只有一个经验不足的黑客才会编写他们的存根来解密可执行文件，然后以解密形式将其写入磁盘，然后再使用`SYS_exec`执行它，尽管原始的UPX打包程序确实是这样工作的。
- en: The skilled way of accomplishing this is by decrypting the executable in place
    (in memory), and then loading and executing it from the memory—not a file. This
    can be done from the userland code, and therefore we call this technique userland
    exec. Many software protectors implement a stub that does this. One of the challenges
    in implementing a stub userland exec is that it must load the segments into their
    designated address range, which would typically be the same addresses that are
    designated for the stub executable itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的熟练方法是通过在原地（在内存中）解密可执行文件，然后从内存中加载和执行它，而不是从文件中。这可以从用户空间代码中完成，因此我们称这种技术为用户空间执行。许多软件保护程序实现了一个这样做的存根。实现存根用户空间执行的一个挑战是，它必须将段加载到它们指定的地址范围中，这通常是为存根可执行文件本身指定的相同地址。
- en: This is only a problem for ET_EXEC-type executables (since they are not position
    independent), and it is generally overcome by using a custom linker script that
    tells the stub executable segments to load at an address other than the default.
    An example of such a linker script is shown in the section on linker scripts in
    [Chapter 1](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985 "Chapter 1. The
    Linux Environment and Its Tools"), *The Linux Environment and Its Tools*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是ET_EXEC类型可执行文件的问题（因为它们不是位置无关的），通常可以通过使用自定义链接器脚本来克服，该脚本告诉存根可执行文件段加载到除默认地址之外的地址。这样的链接器脚本示例在[第1章](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985
    "第1章. Linux环境及其工具")的链接器脚本部分中显示，*Linux环境及其工具*。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On x86_32, the default base is 0x8048000, and on x86_64, it is 0x400000\. The
    stub should have load addresses that do not conflict with the default address
    range. For example, a recent one that I wrote is linked such that the text segment
    is loaded at 0xa000000.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_32上，默认基址是0x8048000，在x86_64上是0x400000。存根应该具有不与默认地址范围冲突的加载地址。例如，我最近编写的一个链接，文本段加载在0xa000000处。
- en: '![Stub mechanics and the userland exec](img/00012.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![存根机制和用户空间执行](img/00012.jpeg)'
- en: 'Illustration 5.1: A model of a binary protector stub'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：二进制保护程序存根的模型
- en: '*Illustration 5.1* shows visually how the encrypted executable is embedded
    within the data segment of the stub executable, wrapped within it, which is why
    stubs are also referred to as wrappers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*以可视方式显示了加密的可执行文件嵌入在存根可执行文件的数据段中，包装在其中，这就是为什么存根也被称为包装器。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will show in *Identifying protected binarires* section in [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux* how
    peeling a wrapper off can actually be a trivial task in many cases, and how it
    may also be an automated task with the use of software or scripts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985 "第6章.
    Linux中的ELF二进制取证")的*识别受保护的二进制文件*部分中展示，如何在许多情况下剥离包装实际上可能是一个微不足道的任务，也可能是一个使用软件或脚本自动化的任务。
- en: 'A typical stub performs the following tasks:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的存根执行以下任务：
- en: Decrypting its payload (which is the original executable)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密其有效负载（即原始可执行文件）
- en: Mapping the executable's loadable segments into the memory
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可执行文件的可加载段映射到内存中
- en: Mapping the dynamic linker into the memory
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动态链接器映射到内存中
- en: Creating a stack (that is with mmap)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个堆栈（即使用mmap）
- en: Setting the stack up (argv, envp, and the auxiliary vector)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置堆栈（argv，envp和辅助向量）
- en: Passing control to the entry point of the program
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制权传递给程序的入口点
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the protected program was dynamically linked, then the control will be passed
    to the entry point of the dynamic linker, which will subsequently pass it to the
    executable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果受保护的程序是动态链接的，那么控制权将传递给动态链接器的入口点，随后将其传递给可执行文件。
- en: A stub of this nature is essentially just a userland exec implementation that
    loads and executes the program embedded within its own program body, instead of
    an executable that is a separate file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种性质的存根本质上只是一个用户空间执行的实现，它加载和执行嵌入在其自身程序体内的程序，而不是一个单独的文件。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original userland exec research and algorithm can be found in the grugq's
    paper titled *The Design and Implementation of Userland Exec* at [https://grugq.github.io/docs/ul_exec.txt](https://grugq.github.io/docs/ul_exec.txt).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的用户空间执行研究和算法可以在grugq的名为*用户空间执行的设计与实现*的论文中找到，网址为[https://grugq.github.io/docs/ul_exec.txt](https://grugq.github.io/docs/ul_exec.txt)。
- en: An example of a protector
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个保护程序的例子
- en: 'Let''s take a look at an executable before and after it is protected by a simple
    protector that I wrote. Using `readelf` to view the program headers, we can see
    that the binary has all the segments that we would expect to see in a dynamically
    linked Linux executable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个在我写的简单保护程序保护之前和之后的可执行文件。使用`readelf`查看程序头，我们可以看到二进制文件具有我们期望在动态链接的Linux可执行文件中看到的所有段：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s run our protector program on the binary and view the program headers
    afterwards:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在二进制文件上运行我们的保护程序，然后查看程序头：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are many differences that you will note. The entry point is `0xa01136`,
    and there are only two loadable segments, which are the text and data segments.
    Both of these are at completely different load addresses than before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同之处。入口点是`0xa01136`，只有两个可加载段，即文本和数据段。这两者的加载地址与以前完全不同。
- en: This is of course because the load addresses of the stub cannot conflict with
    the load address of the encrypted executable contained within it, which must be
    loaded and memory-mapped to. The original executable has a text segment address
    of `0x400000`. The stub is responsible for decrypting the executable embedded
    within and then mapping it to the load addresses specified in the `PT_LOAD` program
    headers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是因为存根的加载地址不能与其中包含的加密可执行文件的加载地址冲突，必须加载和内存映射。原始可执行文件的文本段地址为`0x400000`。存根负责解密嵌入其中的可执行文件，然后将其映射到`PT_LOAD`程序头中指定的加载地址。
- en: 'If the addresses conflict with the stub''s load addresses, then it will not
    work. This means that the stub program has to be compiled using a custom linker
    script. The way this is commonly done is by modifying the existing linker script
    that is used by `ld`. For the protector used in this example, I modified a line
    in the linker script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地址与存根的加载地址冲突，那么它将无法工作。这意味着存根程序必须使用自定义链接器脚本进行编译。通常的做法是修改由`ld`使用的现有链接器脚本。对于本例中使用的保护程序，我修改了链接器脚本中的一行：
- en: 'This is the original line:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是原始行：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the modified line:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是修改后的行：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another thing that you can notice from the program headers in the protected
    executable is that there is no `PT_INTERP` segment or `PT_DYNAMIC` segment. This
    would appear to the untrained eye as a statically linked executable, since it
    does not appear to use dynamic linking. This is because you are not viewing the
    program headers of the original executable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从受保护的可执行文件的程序头中可以注意到的另一件事是没有`PT_INTERP`段或`PT_DYNAMIC`段。对于未经训练的人来说，这似乎是一个静态链接的可执行文件，因为它似乎没有使用动态链接。这是因为您没有查看原始可执行文件的程序头。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the original executable is encrypted and embedded within the stub
    executable, so you are really viewing the program headers from the stub and not
    from the executable that it is protecting. In many cases, the stub itself is compiled
    and linked with very minimal options and does not require dynamic linking itself.
    One of the primary characteristics of a good userland exec implementation is the
    ability to load the dynamic linker into memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，原始可执行文件是加密的，并嵌入在存根可执行文件中，因此您实际上是从存根而不是从它所保护的可执行文件中查看程序头。在许多情况下，存根本身是使用非常少的选项编译和链接的，并且不需要动态链接本身。良好的用户空间执行实现的主要特征之一是能够将动态链接器加载到内存中。
- en: As I mentioned, the stub is a userland exec, and it will map the dynamic linker
    to the memory after it decrypts and maps the embedded executable to the memory.
    The dynamic linker will then handle symbol resolution and runtime relocations
    before it passes control to the now-decrypted program.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，存根是一个用户空间执行程序，它将在解密并将嵌入式可执行文件映射到内存后，将动态链接器映射到内存。动态链接器将在将控制权传递给现在解密的程序之前处理符号解析和运行时重定位。
- en: Other jobs performed by protector stubs
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护程序存根执行的其他任务
- en: In addition to decrypting and loading the embedded executable into memory, which
    is the userland exec component, the stub may also perform other tasks. It is common
    for the stub to start anti-debugging and anti-emulation routines that are meant
    to further protect the binary from being debugged or emulated in order to raise
    the bar even further so that reverse engineering is even more difficult.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解密和将嵌入式可执行文件加载到内存中（即用户空间执行组件），存根还可能执行其他任务。存根通常会启动反调试和反仿真例程，旨在进一步保护二进制文件，使其更难以进行调试或仿真。
- en: In [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, we discussed some anti-debugging techniques used to prevent
    debugging based on `ptrace`. This prevents most debuggers, including GDB, from
    trivially tracing the binary. Later in this chapter, we will summarize the most
    common anti-debugging techniques used in binary protection for Linux.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985 "第4章。ELF病毒技术-Linux/Unix病毒")中，*ELF病毒技术-Linux/Unix病毒*，我们讨论了一些用于防止基于`ptrace`的调试的反调试技术。这可以防止大多数调试器，包括GDB，轻松跟踪二进制文件。在本章的后面，我们将总结用于Linux二进制保护的最常见反调试技术。
- en: Existing ELF binary protectors
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有ELF二进制保护程序
- en: Over the years, there have been a few noteworthy binary protectors that were
    released both publicly and from the underground scene. I will discuss some of
    the protectors for Linux and give a synopsis of the various features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经发布了一些值得注意的二进制保护程序，既公开发布的，也来自地下场景。我将讨论一些用于Linux的保护程序，并概述各种功能。
- en: DacryFile by the Grugq – 2001
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grugq的DacryFile–2001
- en: DacryFile is the earliest binary protector that I am aware of for Linux ([https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile](https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile)).
    This protector is simple but nonetheless clever and works very similarly to ELF
    parasite infection from a virus. In many protectors, the stub wraps around the
    encrypted binary, but in the case of DacryFile, the stub is just a simple decryption
    routine that is injected into the binary that is to be protected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: DacryFile是我所知道的最早的Linux二进制保护程序（[https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile](https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile)）。这个保护程序很简单，但仍然很聪明，工作方式与病毒的ELF寄生感染非常相似。在许多保护程序中，存根包裹在加密的二进制文件周围，但在DacryFile的情况下，存根只是一个简单的解密例程，被注入到要受保护的二进制文件中。
- en: DacryFile encrypts a binary from the beginning of the `.text` section to the
    end of the text segment using RC4 encryption. The decryption stub is a simple
    program written in asm and C, and it does not have the userland exec functionality;
    it simply decrypts the encrypted body of code. This stub is inserted at the end
    of the data segment, which is very reminiscent of how a virus inserts a parasite.
    The entry point of the executable is modified to point to the stub, and upon execution
    of the binary, the stub decrypts the text segment of the program. Then it passes
    the control to the original entry point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: DacryFile使用RC4加密从`.text`部分的开头到文本段的结尾加密二进制文件。解密存根是一个简单的用汇编和C编写的程序，它没有用户空间exec功能；它只是解密代码的加密主体。这个存根被插入到数据段的末尾，这非常像病毒插入寄生虫的方式。可执行文件的入口点被修改为指向存根，当二进制文件执行时，存根解密程序的文本段。然后将控制权传递给原始入口点。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On systems that support NX bit, the data segment cannot be used to hold code
    unless it is explicitly marked with executable permission bits, that is, `'p_flags
    |= PF_X`'.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持NX位的系统上，数据段除非显式标记为可执行权限位，否则不能用于保存代码，即`'p_flags |= PF_X'`。
- en: Burneye by Scut – 2002
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scut的Burneye - 2002
- en: Burneye is said by many to have been the first example of decent binary encryption
    in Linux. By today's standards, it would be considered weak, but it nevertheless
    brought some innovative features to the table. This includes three layers of encryption,
    the third of which is a password-protected layer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为Burneye是Linux中第一个体面的二进制加密示例。按照今天的标准，它可能被认为是薄弱的，但它仍然为这个领域带来了一些创新的功能。其中包括三层加密，第三层是受密码保护的层。
- en: The password is converted into a type of hash-sum and then used to decrypt the
    outermost layer. This means that unless the binary is given the correct password,
    it will never decrypt. Another layer, called a fingerprint layer, can be used
    instead of the password layer. This feature creates a key out of an algorithm
    that fingerprints the system that the binary was protected on, and prevents the
    binary from being decrypted on any other system but the one it was protected on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 密码被转换成一种哈希和校验和，然后用于解密最外层。这意味着除非二进制文件得到正确的密码，否则它将永远无法解密。另一层，称为指纹层，可以用来代替密码层。这个功能通过算法为二进制文件在其上受到保护的系统创建一个密钥，并阻止二进制文件在受保护的系统之外的任何其他系统上解密。
- en: There was also a self-destruct feature; it deletes the binary after it is run
    once. One of the primary things that separated Burneye from other protectors was
    that it was the first to use the userland exec technique to wrap binaries. Technically,
    this was first done by John Resier for the UPX packer, but UPX is considered more
    of a binary compressor than a protector. John allegedly passed on the knowledge
    of userland exec to Scut, as mentioned in the Phrack 58 article written by Scut
    and Grugq on ELF binary protection at [http://phrack.org/issues/58/5.html](http://phrack.org/issues/58/5.html).
    This article documents the inner workings of Burneye and is highly recommended
    for reading.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个自毁功能；在运行一次后删除二进制文件。Burneye与其他保护程序的主要区别之一是它是第一个使用用户空间exec技术来包装二进制文件的程序。从技术上讲，这首先是由John
    Resier为UPX打包程序完成的，但UPX被认为更像是一个二进制压缩器而不是一个保护程序。据称，John将用户空间exec的知识传授给了Scut，正如Scut和Grugq在[http://phrack.org/issues/58/5.html](http://phrack.org/issues/58/5.html)上写的ELF二进制保护文章中提到的那样。这篇文章记录了Burneye的内部工作原理，强烈推荐阅读。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A tool named `objobf`, which stands for **object obfuscator**, was also designed
    by Scut. This tool obfuscates an ELF32 ET_REL (object file) so that the code is
    very difficult to disassemble but is functionally equivalent. With the use of
    techniques such as opaque branches and misaligned assembly, this can be quite
    effective in deterring static analysis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`objobf`的工具，代表**对象混淆器**，也是由Scut设计的。这个工具混淆了一个ELF32 ET_REL（目标文件），使得代码非常难以反汇编，但在功能上是等效的。通过使用不透明分支和不对齐的汇编等技术，这在阻止静态分析方面可能非常有效。
- en: Shiva by Neil Mehta and Shawn Clowes – 2003
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Neil Mehta和Shawn Clowes的Shiva - 2003
- en: Shiva was probably the best publicly available example of Linux binary protection.
    The source code was never released—only the protector was—but several presentations
    were delivered at various conferences, such as Blackhat USA, by the authors. These
    revealed many of its techniques.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Shiva可能是Linux二进制保护的最好的公开示例。源代码从未发布过 - 只有保护程序 - 但作者在各种会议上发表了几次演讲，比如Blackhat USA。这些演讲揭示了它的许多技术。
- en: Shiva works for 32-bit ELF executables and provides a complete runtime engine
    (not just a decryption stub) that assists decryption and anti-debugging features
    throughout the duration of the process that it is protecting. Shiva provides three
    layers of encryption, where the innermost layer never fully decrypts the entire
    executable. It decrypts 1,024-byte blocks at a time and then re-encrypts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Shiva适用于32位ELF可执行文件，并提供一个完整的运行时引擎（不仅仅是解密存根），在保护过程中始终协助解密和反调试功能。Shiva提供三层加密，其中最内层永远不会完全解密整个可执行文件。它每次解密1024字节的块，然后重新加密。
- en: For a sufficiently large program, no more than 1/3rd of the program will be
    decrypted at any given time. Another powerful feature is the inherent anti-debugging—the
    Shiva protector uses a technique wherein the runtime engine spawns a thread using
    `clone()`, which then traces the parent, while the parent conversely traces the
    thread. This makes using dynamic analysis based on `ptrace` impossible, since
    a single process (or thread) may not have more than a single tracer. Also, since
    both processes are being traced by each other, no other debugger can attach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个足够大的程序，任何时候最多只有程序的三分之一会被解密。另一个强大的功能是固有的反调试功能——Shiva保护程序使用一种技术，其中运行时引擎使用`clone()`生成一个线程，然后跟踪父线程，而父线程反过来跟踪子线程。这使得基于`ptrace`的动态分析变得不可能，因为单个进程（或线程）可能不会有多个跟踪器。而且，由于两个进程互相跟踪，其他调试器也无法附加。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A renowned reverse engineer named Chris Eagle successfully unpacked a Shiva-protected
    binary using an x86 emulator plugin for IDA and gave a presentation on this feat
    at Blackhat. This reverse engineering of Shiva was said to have been accomplished
    within a 3-week period.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一位著名的逆向工程师Chris Eagle成功使用IDA的x86模拟器插件解包了一个受Shiva保护的二进制文件，并在Blackhat上就此成就做了一个演讲。据说这个Shiva的逆向工程是在3周内完成的。
- en: 'Presentation by the authors:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者的演讲：
- en: '[https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf](https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf](https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf)'
- en: 'Presentation by Chris Eagle (who broke Shiva):'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chris Eagle的演讲（破解Shiva）：
- en: '[http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf](http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf](http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf)'
- en: Maya's Veil by Ryan O'Neill – 2014
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maya's Veil by Ryan O'Neill – 2014
- en: Maya's Veil was designed by me in 2014 and is for ELF64 binaries. To this day,
    the protector is in a prototype stage and has not been released publicly, but
    there are some forked versions that have transpired into variations of the Maya
    project. One of them is [https://github.com/elfmaster/](https://github.com/elfmaster/),
    which is a version of Maya that incorporates only anti-exploitation technologies,
    such as control flow integrity. As the originator and designer of the Maya protector,
    I am at liberty to elaborate on some of the details of its inner workings, primarily
    for reasons of sparking interest and creativity in readers who are interested
    in this type of thing. In addition to being the author of this book, I am also
    quite approachable as a person, so feel free to contact me if you have more questions
    about Maya's Veil.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Maya's Veil是我在2014年设计的，适用于ELF64二进制文件。到目前为止，该保护程序处于原型阶段，尚未公开发布，但已经出现了一些分支版本，演变成了Maya项目的变种。其中一个是[https://github.com/elfmaster/](https://github.com/elfmaster/)，这是Maya的一个版本，只包括控制流完整性等反利用技术。作为Maya保护程序的发明者和设计者，我有权详细说明其内部工作的一些细节，主要是为了激发对这类事物感兴趣的读者的兴趣和创造力。除了是本书的作者外，我也是一个很平易近人的人，所以如果您对Maya's
    Veil有更多问题，可以随时联系我。
- en: Firstly, this protector was designed as a userland-only solution (which means
    no assistance from clever kernel modules) while still being able to protect a
    binary with sufficient anti-tamper qualities and—even more impressively—additional
    anti-exploitation features. Many of the capabilities that Maya possesses have
    so far been seen only with compiler plugins, whereas Maya operates directly on
    the already compiled executable binary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个保护程序被设计为仅在用户空间中解决方案（这意味着没有来自聪明的内核模块的帮助），同时仍然能够保护具有足够反篡改特性的二进制文件，甚至更令人印象深刻的是，还具有额外的反利用功能。迄今为止，Maya拥有的许多功能只能通过编译器插件实现，而Maya直接在已编译的可执行二进制文件上运行。
- en: Maya is extremely complicated, and documenting all of its inner workings would
    be a complete exegesis on the subject of binary protection, but I will summarize
    some of its most important qualities. Maya can be used to create a layer 1, layer
    2, or layer 3 protected binary. At the first layer, it uses an intelligent runtime
    engine; this engine is compiled as an object file named `runtime.o`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Maya非常复杂，记录其所有内部工作将是关于二进制保护主题的完整解释，但我将总结一些其最重要的特性。Maya可用于创建第1层、第2层或第3层受保护的二进制文件。在第一层，它使用智能运行时引擎；这个引擎被编译为一个名为`runtime.o`的目标文件。
- en: This file is injected using a reverse text-padding extension (Refer to [Chapter
    4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985 "Chapter 4. ELF
    Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology – Linux/Unix Viruses*),
    combined with relocatable code injection relinking techniques. Essentially, the
    object file for the runtime engine is linked to the executable that it is protecting.
    This object file is very important as it contains the code for anti-debugging,
    anti-exploitation, custom `malloc` with an encrypted heap, metadata about the
    binary that it is protecting, and so on. This object file was written in about
    90% C and 10% x86 assembly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件使用反向文本填充扩展（参见[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")，*ELF病毒技术- Linux/Unix病毒*），结合可重定位代码注入重链接技术。基本上，运行时引擎的目标文件链接到它所保护的可执行文件。这个目标文件非常重要，因为它包含了反调试、反利用、带有加密堆的自定义`malloc`、关于它所保护的二进制文件的元数据等代码。这个目标文件大约90%是C代码，10%是x86汇编代码。
- en: Maya's protection layers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Maya的保护层
- en: Maya has multiple layers of protection and encryption. Each additional layer
    enhances the level of security by adding more work for an attacker to peel off.
    The outermost layers are the most useful for preventing static analysis, whereas
    the innermost layer (layer 1) only decrypts the functions within the present call
    stack and re-encrypts them when done. The following is a more detailed explanation
    of each layer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 玛雅具有多层保护和加密。每个额外的层都通过增加攻击者剥离的工作量来增强安全级别。最外层的层对于防止静态分析是最有用的，而最内层的层（图层1）只会在当前调用堆栈内解密函数，并在完成后重新加密它们。以下是对每个图层的更详细解释。
- en: Layer 1
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图层1
- en: A layer 1 protected binary consists of every single function of the binary individually
    encrypted. Every function decrypts and re-encrypts on the fly, as they are called
    and returned. This works because `runtime.o` contains an intelligent and autonomous
    self-debugging capability that allows it to closely monitor the execution of a
    process and determine when it is being attacked or analyzed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制的图层1由二进制的每个单独加密的函数组成。每个函数在调用和返回时都会动态解密和重新加密。这是因为`runtime.o`包含了智能和自主的自我调试能力，使其能够密切监视进程的执行，并确定何时受到攻击或分析。
- en: The runtime engine itself has been obfuscated using code obfuscation techniques,
    such as those found on Scut's object obfuscator tool. The key storage and metadata
    for the decrypting and re-encrypting functions are stored in a custom `malloc()`
    implementation that uses an encrypted heap spawned by the runtime engine. This
    makes locating the keys difficult. Layer 1 protection is the first and most complex
    level of protection due to the fact that it instruments the binary with an intelligent
    and autonomous self-tracing capability for dynamic decryption, anti-debugging,
    and anti-exploitation abilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时引擎本身已经使用代码混淆技术进行了混淆，例如Scut的对象混淆器工具中发现的那些技术。用于解密和重新加密函数的密钥存储和元数据存储在运行时引擎生成的加密堆中的自定义`malloc()`实现中。这使得定位密钥变得困难。由于它为动态解密、反调试和反利用能力提供了智能和自主的自我跟踪能力，因此图层1保护是第一个也是最复杂的保护级别。
- en: '![Layer 1](img/00013.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: 图层1
- en: An over-simplified diagram showing how a layer 1 protected binary is laid out
    next to the original binary
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过于简化的图表，显示了一个受保护的二进制图层1与原始二进制的布局
- en: Layer 2
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图层2
- en: A layer 2 protected binary is the same as a level 1 protected binary, except
    that not only the functions but also every other section in the binary is encrypted
    to prevent static analysis. These sections are decrypted at runtime, leaving certain
    data exposed if someone is able to dump the process, which would have to be done
    through a memory driver because `prctl()` is used to protect the process from
    normal userland dumps through `/proc/$pid/mem` (and also stops the process from
    dumping any core files).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制的图层2与原始二进制并无二致，只是不仅函数，而且二进制中的每个其他部分都被加密以防止静态分析。这些部分在运行时解密，如果有人能够转储进程，那么某些数据将会暴露出来，这必须通过内存驱动程序完成，因为`prctl()`用于保护进程免受通过`/proc/$pid/mem`进行的普通用户空间转储（并且还阻止进程转储任何核心文件）。
- en: Layer 3
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图层3
- en: A layer 3 protected binary is the same as level 2, except that it adds one more
    complete layer of protection by embedding the layer 2 binary into the data segment
    of the layer 3 stub. The layer 3 stub works like a traditional userland exec.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制的图层3与图层2相同，只是它通过将图层2二进制嵌入到图层3存根的数据段中，增加了一层完整的保护。图层3存根的工作方式类似于传统的用户空间执行。
- en: Maya's nanomites
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玛雅的纳米机器
- en: Maya's Veil has many other features that make it difficult to reverse-engineer.
    One such feature is called **nanomites**. This is where certain instructions in
    the original binary are completely removed and replaced with junk instructions
    or breakpoints.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 玛雅的面纱有许多其他功能，使得它难以逆向工程。其中一个功能称为**纳米机器**。这是原始二进制中的某些指令被完全删除并替换为垃圾指令或断点的地方。
- en: When Maya's runtime engine sees one of these junk instructions or breakpoints,
    it checks its nanomite records to see what the original instruction was that existed
    there. The records are stored in the encrypted heap segment of the runtime engine,
    so accessing this information is non-trivial for a reverse engineer. Once Maya
    knows what the original instruction did, it emulates the instruction using the
    `ptrace` system call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当玛雅的运行时引擎看到这些垃圾指令或断点之一时，它会检查其纳米机器记录，看看原始指令是什么。记录存储在运行时引擎的加密堆段中，因此对于逆向工程师来说，访问这些信息并不容易。一旦玛雅知道原始指令的作用，它就会使用`ptrace`系统调用来模拟该指令。
- en: Maya's anti-exploitation
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玛雅的反利用
- en: The anti-exploitation features of Maya are what make it unique compared to other
    protectors. Whereas most protectors aim only to make reverse engineering difficult,
    Maya is able to strengthen a binary so that many of its inherent vulnerabilities
    (such as a buffer overflow) cannot be exploited. Specifically, Maya prevents **ROP**
    (short for **Return-Oriented Programming**) by instrumenting the binary with special
    control flow integrity technology that is embedded in the runtime engine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 玛雅的反利用功能是使其与其他保护程序相比独特的原因。大多数保护程序的目标仅仅是使逆向工程变得困难，而玛雅能够加强二进制，使其许多固有的漏洞（如缓冲区溢出）无法被利用。具体来说，玛雅通过在运行时引擎中嵌入特殊的控制流完整性技术来防止**ROP**（即**Return-Oriented
    Programming**）。
- en: 'Every function in a protected binary is instrumented with a breakpoint (`int3`)
    at the entry point and at every return instruction. The `int3` breakpoint delivers
    a SIGTRAP that triggers the runtime engine; the runtime engine then does one of
    several things:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制中的每个函数都在入口点和每个返回指令处插入了一个断点（`int3`）。`int3`断点会触发运行时引擎产生SIGTRAP；然后运行时引擎会执行以下几种操作之一：
- en: Decrypting the function (only if it hits the entry `int3` breakpoint)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密函数（仅在遇到入口`int3`断点时）
- en: Encrypting the function (only if it hits the return `int3` breakpoint)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密函数（仅在遇到返回`int3`断点时）
- en: Checking whether the return address has been overwritten
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查返回地址是否被覆盖
- en: Checking whether the `int3` breakpoint is a nanomite; if so, it will emulate
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`int3`断点是否是nanomite；如果是，它将进行模拟
- en: The third bullet is the anti-ROP feature. The runtime engine checks a hash map
    that contains valid return addresses for various points within the program. If
    the return address is invalid, then Maya will bail out and the exploitation attempt
    will fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要点是反ROP功能。运行时引擎检查包含程序内各个点的有效返回地址的哈希映射。如果返回地址无效，Maya将退出，利用尝试将失败。
- en: 'The following is an example of a vulnerable piece of software code that was
    specially crafted to test and show off Maya''s anti-ROP feature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个特制的易受攻击的软件代码示例，用于测试和展示Maya的反ROP功能：
- en: Source code of vuln.c
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: vuln.c的源代码
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example of exploiting vuln.c
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用vuln.c的示例
- en: 'Let''s take a look at how we can exploit `vuln.c`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用`vuln.c`：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s protect vuln using the `-c` option of Maya, which means control
    flow integrity. Then we will try to exploit the protected binary:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Maya的`-c`选项来保护vuln，这意味着控制流完整性。然后我们将尝试利用受保护的二进制文件：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This demonstrates that Maya has detected an invalid return address, `0x41414141`,
    before the return instruction actually succeeds. Maya's runtime engine interferes
    by crashing the program safely (without exploitation).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明Maya已经检测到一个无效的返回地址`0x41414141`，在返回指令实际成功之前。Maya的运行时引擎通过安全地崩溃程序来干扰（而不是利用）。
- en: Another anti-exploitation feature that Maya enforces is **relro** (**read-only
    relocations**). Most modern Linux systems have this feature enabled, but if it
    is not enabled, Maya will enforce it on its own by creating a read-only page with
    `mprotect()` that encompasses `the.jcr`, `.dynamic`, `.got`, `.ctors` (`.init_array`),
    and `.dtors` (`.fini_array`) sections. Other anti-exploitation features (such
    as function pointer integrity) are being planned for the future and have not yet
    made it into the code base.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Maya强制执行的另一个反利用功能是**relro**（**只读重定位**）。大多数现代Linux系统都启用了此功能，但如果未启用，Maya将通过使用`mprotect()`创建一个包含`the.jcr`、`.dynamic`、`.got`、`.ctors`（`.init_array`）和`.dtors`（`.fini_array`）部分的只读页面来强制执行。其他反利用功能（如函数指针完整性）正在计划中，尚未纳入代码库。
- en: Downloading Maya-protected binaries
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Maya保护的二进制文件
- en: 'For those who are interested in reverse-engineering some simple programs that
    were protected with Maya''s Veil, feel free to download a couple of samples that
    are available at [http://www.bitlackeys.org/maya_crackmes.tgz](http://www.bitlackeys.org/maya_crackmes.tgz).
    This link contains three files: `crackme.elf_hardest`, `crackme.elf_medium`, and
    `test.maya`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有兴趣逆向工程一些使用Maya的Veil保护的简单程序的人，可以随意下载一些样本，这些样本可以在[http://www.bitlackeys.org/maya_crackmes.tgz](http://www.bitlackeys.org/maya_crackmes.tgz)上找到。此链接包含三个文件：`crackme.elf_hardest`、`crackme.elf_medium`和`test.maya`。
- en: Anti-debugging for binary protection
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制保护的反调试
- en: Since binary protectors generally encrypt or obfuscate the physical body of
    a program, static analysis can be extremely difficult and, left to its own devises,
    will prove to be futile in many cases. Most reverse engineers who are attempting
    to unpack or break a protected binary will agree that a combination of dynamic
    analysis and static analysis must be used to gain access to the decrypted body
    of a binary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制保护程序通常加密或混淆程序的物理主体，静态分析可能非常困难，并且在许多情况下将被证明是徒劳的。大多数试图解包或破解受保护二进制文件的逆向工程师都会同意，必须使用动态分析和静态分析的组合来访问二进制文件的解密主体。
- en: A protected binary has to decrypt itself, or at least the portions of itself
    that are executing at runtime. Without any anti-debugging techniques, a reverse
    engineer can simply attach to the process of the protected program and set a breakpoint
    on the last instruction of the stub (assuming that the stub decrypts the entire
    executable).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制文件必须解密自身，或者至少解密在运行时执行的部分。没有任何反调试技术，逆向工程师可以简单地附加到受保护程序的进程，并在存根的最后一条指令上设置断点（假设存根解密整个可执行文件）。
- en: Once the breakpoint is hit, the attacker can look at the code segment for where
    the protected binary lives and find its decrypted body. This would be extremely
    simple, and therefore it is very important for good binary protection to use as
    many techniques as possible to make debugging and dynamic analysis difficult for
    the reverse engineer. A protector like Maya goes to great lengths to protect the
    binary from both static and dynamic analysis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发断点，攻击者可以查看受保护二进制文件所在的代码段，并找到其解密后的主体。这将非常简单，因此对于良好的二进制保护来说，使用尽可能多的技术使逆向工程师难以进行调试和动态分析非常重要。像Maya这样的保护程序会竭尽全力保护二进制免受静态和动态分析的影响。
- en: Dynamic analysis is not limited to the `ptrace` syscall, although most debuggers
    are limited to it for the purpose of accessing and manipulating a process. Therefore,
    a binary protector should not be limited to protecting only against `ptrace`;
    ideally it will also be resistant to other forms of dynamic analysis, such as
    emulation and dynamic instrumentation (for example, **Pin** and **DynamoRIO**).
    We covered many anti-debugging techniques against `ptrace` analysis in previous
    chapters, but what about resistance to emulation?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析并不局限于`ptrace`系统调用，尽管大多数调试器仅限于此目的来访问和操作进程。因此，二进制保护程序不应仅限于保护`ptrace`；理想情况下，它还应该对其他形式的动态分析具有抵抗力，比如模拟和动态插装（例如**Pin**和**DynamoRIO**）。我们在前几章中介绍了许多针对`ptrace`分析的反调试技术，但对于模拟的抵抗力呢？
- en: Resistance to emulation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对模拟的抵抗力
- en: Often, emulators are used to perform dynamic analysis and reverse engineering
    tasks on executables. One very good reason for this is that they allow the reverse
    engineer to easily instrument the control of the execution, and they also bypass
    a lot of typical anti-debugging techniques. There are many emulators being used
    out there—QEMU, BOCHS, and Chris Eagles' IDA X86 emulator plugin, to name some.
    So, countless anti-emulation techniques exist, but some of them are specific to
    each emulator's particular implementation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仿真器用于对可执行文件执行动态分析和逆向工程任务。这样做的一个非常好的原因是它们允许逆向工程师轻松地操纵执行的控制，并且它们也绕过了许多典型的反调试技术。有许多仿真器被广泛使用——QEMU、BOCHS和Chris
    Eagles的IDA X86仿真器插件，只是其中一些。因此，存在无数的反仿真技术，但其中一些是特定于每个仿真器的特定实现。
- en: This topic could expand into some very in-depth discussions and move in many
    directions, but I will keep it limited to my own experience. In my own experimentation
    with emulation and anti-emulation in the Maya protector, I have learned some generic
    techniques that should work against at least some emulators. The goal of our binary
    protector's anti-emulation is to be able to detect when it is being run in an
    emulator, and if this is true, it should halt the execution and exit.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题可以扩展到一些非常深入的讨论，并且可以朝多个方向发展，但我将把它限制在我自己的经验范围内。在我自己对Maya保护程序中的仿真和反仿真的实验中，我学到了一些通用的技术，应该对至少一些仿真器有效。我们的二进制保护程序的反仿真目标是能够检测是否在仿真器中运行，并且如果是真的，它应该停止执行并退出。
- en: Detecting emulation through syscall testing
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过系统调用测试检测仿真
- en: This technique can be especially useful in application-level emulators that
    are somewhat OS agnostic and are unlikely to have implemented more than the basic
    system calls (`read`, `write`, `open`, `mmap`, and so on). If an emulator does
    not support a system call and also does not delegate the unsupported syscall to
    the kernel, it is very likely that it will posit an erroneous return value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在应用级仿真器中特别有用，这些仿真器在某种程度上与操作系统无关，并且不太可能实现超出基本系统调用（`read`、`write`、`open`、`mmap`等）的功能。如果仿真器不支持系统调用，并且也不将不支持的系统调用委托给内核，那么很可能会得到错误的返回值。
- en: So, the binary protector could invoke a handful of less common syscalls and
    check whether the return value matches the expected value. A very similar technique
    would be to invoke certain interrupt handlers to see whether they behave correctly.
    In either case, we are looking for OS features that were not properly implemented
    by the emulator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，二进制保护程序可以调用少量不太常见的系统调用，并检查返回值是否与预期值匹配。非常类似的技术是调用某些中断处理程序，看它们是否表现正常。无论哪种情况，我们都在寻找仿真器没有正确实现的操作系统特性。
- en: Detecting emulated CPU inconsistencies
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测仿真CPU的不一致性
- en: The chances of an emulator perfectly emulating CPU architectures are next to
    none. Therefore, it is common to look for certain inconsistencies between how
    the emulator behaves and how the CPU should behave. One such technique is to attempt
    writing to privileged instructions, such as debug registers (for example, `db0`
    to `db7`) or control registers (for example, `cr0` to `cr4`). The emulation detection
    code may have a stub of ASM code that attempts to write to `cr0` and see whether
    it succeeds.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真器完美仿真CPU架构的可能性几乎为零。因此，通常会寻找仿真器行为与CPU应该行为之间的某些不一致之处。其中一种技术是尝试写入特权指令，例如调试寄存器（例如`db0`到`db7`）或控制寄存器（例如`cr0`到`cr4`）。仿真检测代码可能有一个尝试写入`cr0`并查看是否成功的ASM代码存根。
- en: Checking timing delays between certain instructions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查某些指令之间的时间延迟
- en: Another technique that can sometimes cause instability in the emulator itself
    is checking the timestamps between certain instructions and seeing how long the
    execution took. A real CPU should execute a sequence of instructions several magnitudes
    faster than an emulator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有时可能会导致仿真器本身不稳定的技术是检查某些指令之间的时间戳，并查看执行所需的时间。真实的CPU应该比仿真器快几个数量级地执行一系列指令。
- en: Obfuscation methods
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆方法
- en: A binary can be obfuscated or encrypted in many creative ways. Most binary protectors
    simply protect the entire binary with one or more layers of protection. At runtime,
    the binary is decrypted and can be dumped from the memory to acquire a copy of
    the unpacked binary. In more advanced protectors, such as Maya, every single function
    is encrypted individually, and allows only a single function to be decrypted at
    any given time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制可以以许多创造性的方式进行混淆或加密。大多数二进制保护程序只是用一层或多层保护来保护整个二进制文件。在运行时，二进制文件被解密，并且可以从内存中转储以获取解压后的二进制文件的副本。在更高级的保护程序中，例如Maya，每个函数都是单独加密的，并且一次只允许解密一个函数。
- en: Once a binary is encrypted, it must, of course, store the encryption keys somewhere.
    In the case of Maya (discussed earlier), a custom heap implementation that itself
    uses encryption to store encryption keys was designed. At some point, it would
    seem that a key has to be exposed (such as the key used to decrypt another key),
    but special techniques such as white-box cryptography can be used to make these
    final keys extremely obfuscated. If assistance from the kernel is used in a protector,
    then it is possible to store the key outside of the binary and process memory
    completely.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦二进制文件被加密，它当然必须将加密密钥存储在某个地方。在Maya（前面讨论过）的情况下，设计了一个自定义堆实现，它本身使用加密来存储加密密钥。在某个时候，似乎必须暴露一个密钥（例如用于解密另一个密钥的密钥），但可以使用特殊技术，如白盒密码术，使这些最终密钥极其模糊。如果在保护程序中使用内核的帮助，那么可以将密钥存储在二进制和处理内存之外。
- en: Code obfuscation techniques (such as false disassembly, which was described
    in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*) are also commonly used in binary protection to make static
    analysis more difficult for code that has been decrypted or is never encrypted.
    Binary protectors also usually strip the section header table from a binary and
    remove any unneeded strings and string tables from it, such as those that give
    symbol names.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码混淆技术（例如虚假反汇编，在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中描述，*ELF病毒技术- Linux/Unix病毒*）也常用于二进制保护，以使对已解密或从未加密的代码进行静态分析更加困难。二进制保护程序通常还会从二进制文件中剥离段头表，并删除其中的任何不需要的字符串和字符串表，比如那些提供符号名称的字符串。
- en: Protecting control flow integrity
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护控制流完整性
- en: 'A protected binary should aim to protect the program during runtime (the process
    itself) just as much as—if not more than—the binary at rest on the disk. Runtime
    attacks can generally be classified into two types:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的二进制文件应该在运行时（进程本身）保护程序，就像在磁盘上静止的二进制文件一样多，甚至更多。运行时攻击通常可以分为两种类型：
- en: Attacks based on `ptrace`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`ptrace`的攻击
- en: Vulnerability-based attacks
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于漏洞的攻击
- en: Attacks based on ptrace
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于ptrace的攻击
- en: The first variety, `ptrace` based attacks, also falls under the category of
    debugging a process. As already discussed, a binary protector wants to make `ptrace`
    based debugging very difficult for a reverse engineer. Aside from debugging, however,
    there are many other attacks that could potentially help break a protected binary,
    and it is important to know and understand what some of these are in order to
    give further clarification as to why a binary protector wants to protect a running
    process from `ptrace`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型，基于`ptrace`的攻击，也属于调试进程的范畴。正如前面讨论的，二进制保护程序希望使基于`ptrace`的调试对逆向工程师非常困难。然而，除了调试之外，还有许多其他攻击可能有助于破坏受保护的二进制文件，了解并理解其中一些是很重要的，以便进一步阐明为什么二进制保护程序希望保护运行中的进程免受`ptrace`的攻击。
- en: If a protector has gone so far that it is able to detect breakpoint instructions
    (and therefore make debugging more difficult) but is not able to protect itself
    from being traced by `ptrace`, then it is possible that it is still very vulnerable
    to `ptrace` based attacks, such as function hijacking and shared library injection.
    An attacker may not want to simply unpack a protected binary, but may aim to only
    change the binary's behavior. A good binary protector should try to protect the
    integrity of its control flow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个保护程序已经走得很远，能够检测断点指令（因此使调试更加困难），但无法保护自己免受`ptrace`跟踪，那么它可能仍然非常容易受到基于`ptrace`的攻击，比如函数劫持和共享库注入。攻击者可能不只是想解包一个受保护的二进制文件，而是可能只想改变二进制文件的行为。一个良好的二进制保护程序应该努力保护其控制流的完整性。
- en: 'Imagine that an attacker is aware that a protected binary is calling the `dlopen()`
    function to load a specific shared library, and the attacker wants the process
    to load a trojaned shared library instead. The following steps could lead to an
    attacker compromising a protected binary by changing its control flow:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个攻击者知道一个受保护的二进制文件正在调用`dlopen()`函数来加载一个特定的共享库，而攻击者希望该进程加载一个木马共享库。以下步骤可能导致攻击者通过改变其控制流来破坏受保护的二进制文件：
- en: Attaching to the process with `ptrace`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ptrace`附加到进程。
- en: Modifying the Global Offset Table entry for `dlopen()` to point to `__libc_dlopen_mode`
    (in `libc.so`).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改全局偏移表条目以使`dlopen()`指向`libc.so`中的`__libc_dlopen_mode`。
- en: 'Adjusting the `%rdi` register so that it points to this path: `/tmp/evil_lib.so`.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`%rdi`寄存器，使其指向这个路径：`/tmp/evil_lib.so`。
- en: Continuing execution.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续执行。
- en: At this point, the attacker has just forced a protected binary to load a malicious
    shared library and has therefore completely compromised the security of the protected
    binary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，攻击者刚刚强制一个受保护的二进制文件加载了一个恶意的共享库，因此完全破坏了受保护二进制文件的安全性。
- en: The Maya protector, as discussed earlier, is armed against such vulnerabilities
    thanks to a runtime engine that works as an active debugger, preventing any other
    process from attaching. If a protector can disable `ptrace` from attaching to
    the protected process, then that process is at much less risk of this type of
    runtime attack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，Maya保护程序通过运行时引擎作为主动调试器来防范此类漏洞，防止其他进程附加。如果保护程序能够禁用`ptrace`附加到受保护进程，那么该进程在很大程度上就不太容易受到这种类型的运行时攻击。
- en: Security vulnerability-based attacks
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于安全漏洞的攻击
- en: A vulnerability-based attack is a type of attack in which an attacker may be
    able to exploit an inherent weakness in the protected program, such as a stack-based
    buffer overflow, and subsequently change the execution flow to something of their
    choice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基于漏洞的攻击是一种攻击类型，攻击者可能能够利用受保护程序中固有的弱点，比如基于堆栈的缓冲区溢出，并随后改变执行流程为他们选择的内容。
- en: This type of attack is often more difficult to carry out on a protected program,
    since it yields much less information about itself, and using a debugger to narrow
    down on the locations used in the memory by the exploit is potentially much more
    difficult to gain insight into. Nevertheless, this type of attack is very possible,
    and this is why the Maya protector enforces control flow integrity and read-only
    relocations to protect specifically against vulnerability exploitation attacks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的攻击通常更难对受保护的程序进行，因为它提供的关于自身的信息要少得多，并且使用调试器来缩小利用中内存中使用的位置的范围可能更难获得洞察。尽管如此，这种类型的攻击是非常可能的，这就是为什么Maya保护程序强制执行控制流完整性和只读重定位，以特别防范漏洞利用攻击。
- en: I am not aware whether any other protectors out there right now are using similar
    anti-exploitation techniques, but I can only surmise that they are out there.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道现在是否有其他保护程序正在使用类似的反利用技术，但我只能推测它们存在。
- en: Other resources
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: Writing only one chapter on binary protection is not nearly comprehensive enough
    on its own to teach you all about this one subject. The other chapters in this
    book complement each other, however; when combined together, they will help you
    get to deeper levels of understanding. There are many good resources on this subject,
    some of which have already been mentioned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制保护上只写一章是远远不够全面的，无法教会你关于这个主题的所有知识。本书的其他章节相互补充，当结合在一起时，它们将帮助你深入理解。关于这个主题有许多好资源，其中一些已经提到过。
- en: 'One resource in particular, written by Andrew Griffith, is highly recommended
    for reading. This paper was written over a decade ago but describes many of the
    techniques and practices that are still very pertinent to the binary protectors
    of today:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 特别推荐一份由Andrew Griffith撰写的资源供阅读。这篇论文是十多年前写的，但描述了许多今天仍然与二进制保护相关的技术和实践：
- en: '[http://www.bitlackeys.org/resources/binary_protection_schemes.pdf](http://www.bitlackeys.org/resources/binary_protection_schemes.pdf)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.bitlackeys.org/resources/binary_protection_schemes.pdf](http://www.bitlackeys.org/resources/binary_protection_schemes.pdf)'
- en: 'This paper was followed by a talk given at a later date, and the slides can
    be found here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇论文后来还有一个演讲，幻灯片可以在这里找到：
- en: '[http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf](http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf](http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf)'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we revealed the inner workings of basic binary protection schemes
    for Linux binaries, and discussed the various features of existing binary protectors
    that have been released for Linux over the last decade.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们揭示了Linux二进制保护方案的内部工作原理，并讨论了过去十年中为Linux发布的各种二进制保护程序的各种特性。
- en: In the next chapter, we will be exploring things from the opposite angle and
    begin looking at ELF binary forensics in Linux.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从相反的角度探讨问题，并开始研究Linux中的ELF二进制取证。
