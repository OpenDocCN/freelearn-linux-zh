- en: Chapter 9. Starting up - the init Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。启动- init程序
- en: I looked at how the kernel boots up to the point that it launches the first
    program, `init`, in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel* and in [Chapter 5](ch05.html
    "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem* and [Chapter
    6](ch06.html "Chapter 6. Selecting a Build System"), *Selecting a Build System*,
    I looked at creating root filesystems of varying complexity, all of which contained
    an `init` program. Now it is time to look at the `init` program in more detail
    and discover why it is so important to the rest of the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](ch04.html "第4章。移植和配置内核")中看到了内核如何引导到启动第一个程序`init`的点，在[第5章](ch05.html
    "第5章。构建根文件系统")中，*构建根文件系统*和[第6章](ch06.html "第6章。选择构建系统")中，*选择构建系统*，我看了创建不同复杂性的根文件系统，其中都包含了`init`程序。现在是时候更详细地看看`init`程序，并发现它对系统的重要性。
- en: 'There are many possible implementations of `init`. I will describe the three
    main ones in this chapter: BusyBox `init`, System V `init`, and `systemd`. For
    each one, I will give an overview of how it works and the types of system it suits
    best. Part of that is balancing the trade-off between complexity and flexibility.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`有许多可能的实现。我将在本章中描述三种主要的实现：BusyBox `init`，System V `init`和`systemd`。对于每种实现，我将概述其工作原理和最适合的系统类型。其中一部分是在复杂性和灵活性之间取得平衡。'
- en: After the kernel has booted
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核引导后
- en: We saw in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"),
    *Porting and Configuring the Kernel*, how the kernel bootstrap code seeks to find
    a root filesystem, either `initramfs` or a filesystem specified by `root=` on
    the kernel command line, and then to execute a program which, by default, is `/init`
    for `initramfs`, and `/sbin/init` for a regular filesystem. The `init` program
    has root privilege and since it is the first process to run, it has a process
    ID (`PID`) of 1\. If, for some reason, `init` cannot be started, the kernel will
    panic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。移植和配置内核")中看到了*移植和配置内核*，内核引导代码如何寻找根文件系统，要么是`initramfs`，要么是内核命令行上指定的文件系统`root=`，然后执行一个程序，默认情况下是`initramfs`的`/init`，常规文件系统的`/sbin/init`。`init`程序具有根特权，并且由于它是第一个运行的进程，它具有进程ID（`PID`）为1。如果由于某种原因`init`无法启动，内核将会恐慌。
- en: 'The `init` program is the ancestor of all other processes, as shown here by
    the `pstree` command, which is part of the `psmisc` package in most distrubutions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序是所有其他进程的祖先，如`pstree`命令所示，它是大多数发行版中`psmisc`软件包的一部分：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The job of the `init` program is to take control of the system and set it running.
    It may be as simple as a shell command running a shell script – there is an example
    at the start of [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*—but, in the majority of cases, you will be using
    a dedicated `init` daemon. The tasks it has to perform are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序的工作是控制系统并使其运行。它可能只是一个运行shell脚本的shell命令-在[第5章](ch05.html "第5章。构建根文件系统")的开头有一个示例，*构建根文件系统*—但在大多数情况下，您将使用专用的`init`守护程序。它必须执行的任务如下：'
- en: At boot, it starts daemon programs, configures system parameters and the other
    things needed to get the system into a working state.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时，它启动守护程序，配置系统参数和其他必要的东西，使系统进入工作状态。
- en: Optionally, it launches daemons, such as `getty` on terminals which allow a
    login shell.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，它启动守护程序，比如在允许登录shell的终端上启动`getty`。
- en: It adopts processes that become orphaned as a result of their immediate parent
    terminating and there being no other processes in the thread group.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接管因其直接父进程终止而变成孤儿的进程，并且没有其他进程在线程组中。
- en: It responds to any of `init`'s immediate children terminating by catching the
    signal `SIGCHLD` and collecting the return value to prevent them becoming zombie
    processes. I will talk more about zombies in [Chapter 10](ch10.html "Chapter 10. Learning
    About Processes and Threads"), *Learning About Processes and Threads*.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过捕获信号`SIGCHLD`并收集返回值来响应`init`的任何直接子进程的终止，以防止它们变成僵尸进程。我将在[第10章](ch10.html "第10章。了解进程和线程")中更多地讨论僵尸进程，*了解进程和线程*。
- en: Optionally, it restarts those daemons that have terminated.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，它重新启动那些已经终止的守护进程。
- en: It handles system shutdown.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理系统关闭。
- en: In other words, `init` manages the lifecycle of the system, from boot up to
    shutdown. The current thinking is that `init` is well placed to handle other runtime
    events such as new hardware and the loading and unloading of modules. This is
    what `systemd` does.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`init`管理系统的生命周期，从启动到关闭。目前的想法是`init`很适合处理其他运行时事件，比如新硬件和模块的加载和卸载。这就是`systemd`的作用。
- en: Introducing the init programs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍init程序
- en: The three `init` programs that you are most likely to encounter in embedded
    devices are BusyBox `init`, System V `init`, and `systemd`. Buildroot has options
    to build all three with BusyBox `init` as the default. The Yocto Project allows
    you to choose between System V `init` and `systemd`, with System `V init` the
    default.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备中，您最有可能遇到的三种`init`程序是BusyBox `init`，System V `init`和`systemd`。Buildroot有选项可以构建所有三种，其中BusyBox
    `init`是默认选项。Yocto Project允许您在System V `init`和`systemd`之间进行选择，System `V init`是默认选项。
- en: 'The following table gives some metrics to compare the three:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了比较这三种程序的一些指标：
- en: '|   | BusyBox init | System V init | systemd |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| | BusyBox init | System V init | systemd |'
- en: '| --- | --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|---|---|---|---|'
- en: '| Complexity | Low | Medium | High |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|复杂性|低|中等|高|'
- en: '| Boot-up speed | Fast | Slow | Medium |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|启动速度|快|慢|中等|'
- en: '| Required shell | ash | ash or bash | None |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|所需的shell|ash|ash或bash|无|'
- en: '| Number of executables | 0 | 4 | 50(*) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|可执行文件数量|0|4|50(*)|'
- en: '| libc | Any | Any | glibc |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|libc|任何|任何|glibc|'
- en: '| Size (MiB) | 0 | 0.1 | 34(*) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|大小（MiB）|0|0.1|34(*)|'
- en: (*) Based on the Buildroot configuration of `system`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (*)基于`system`的Buildroot配置。
- en: Broadly speaking, there is an increase in flexibility and complexity as you
    go from BusyBox `init` to `systemd`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，从BusyBox `init`到`systemd`，灵活性和复杂性都有所增加。
- en: BusyBox init
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BusyBox init
- en: BusyBox has a minimal `init` program that uses a configuration file, `/etc/inittab`,
    to define rules to start programs at boot up and to stop them at shutdown. Usually,
    the actual work is done by shell scripts which, by convention, are placed in the
    `/etc/init.d` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox有一个最小的`init`程序，使用配置文件`/etc/inittab`来定义在启动时启动程序的规则，并在关闭时停止它们。通常，实际工作是由shell脚本完成的，按照惯例，这些脚本放在`/etc/init.d`目录中。
- en: '`init` begins by reading the configuration file, `/etc/inittab`. This contains
    a list of programs to run, one per line, with this format:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`首先通过读取配置文件`/etc/inittab`来开始。其中包含要运行的程序列表，每行一个，格式如下：'
- en: '`<id>::<action>:<program>`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<id>::<action>:<program>`'
- en: 'The role of these parameters is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的作用如下：
- en: '`id`: The controlling terminal for the command'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：命令的控制终端'
- en: '`action`: The conditions to run this command, as shown in the following paragraph'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：运行此命令的条件，如下一段所示'
- en: '`program`: The program to run'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`program`：要运行的程序'
- en: 'The actions are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是操作步骤：
- en: '`sysinit`: Run the program when `init` starts, before any of the other types
    of actions.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysinit`：当`init`启动时运行程序，先于其他类型的操作。'
- en: '`respawn`: Run the program and restart it if it terminates. It is used to run
    a program as a daemon.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`respawn`：运行程序并在其终止时重新启动。用于将程序作为守护进程运行。'
- en: '`askfirst`: This is the same as `respawn`, but prints the message **Please
    press Enter to activate this console** to the console and runs the program after
    *Enter* has been pressed. It is used to start an interactive shell on a terminal
    without prompting for a user name or password.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`askfirst`：与`respawn`相同，但在控制台上打印消息**请按Enter键激活此控制台**，并在按下*Enter*后运行程序。用于在终端上启动交互式shell而无需提示用户名或密码。'
- en: '`once`: Run the program once but do not attempt to restart it if it terminates.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`once`：运行程序一次，但如果终止则不尝试重新启动。'
- en: '`wait`: Run the program and wait for it to complete.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait`：运行程序并等待其完成。'
- en: '`restart`: Run the program when `init` receives the signal `SIGHUP`, indicating
    that it should reload the `inittab` file.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：当`init`接收到信号`SIGHUP`时运行程序，表示应重新加载`inittab`文件。'
- en: '`ctrlaltdel`: Run the program when `init` receives the signal `SIGINT`, usually
    as a result of pressing *Ctrl* + *Alt* + *Del* on the console.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrlaltdel`：当`init`接收到信号`SIGINT`时运行程序，通常是在控制台上按下*Ctrl* + *Alt* + *Del*的结果。'
- en: '`shutdown`: Run the program when `init` shuts down.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：当`init`关闭时运行程序。'
- en: 'Here is a small example that mounts `proc` and `sysfs` and runs a shell on
    a serial interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个小例子，它挂载`proc`和`sysfs`，并在串行接口上运行shell：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For simple projects in which you want to launch a small number of daemons and
    perhaps start a login shell on a serial terminal, it is easy to write the scripts
    manually, and this is appropriate if you are creating a **RYO** (**roll your own**)
    embedded Linux. However, you will find that hand-written `init` scripts rapidly
    become unmaintainable as the number of things to be configured increases. They
    tend not to be very modular and so need updating each time a new component is
    added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的项目，您希望启动少量守护进程并可能在串行终端上启动登录shell，手动编写脚本很容易，如果您正在创建一个**RYO**（**roll your
    own**）嵌入式Linux，这是合适的。但是，随着需要配置的内容增加，您会发现手写的`init`脚本很快变得难以维护。它们往往不太模块化，因此每次添加新组件时都需要更新。
- en: Buildroot init scripts
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildroot init脚本
- en: Buildroot has been making effective use of BusyBox `init` for many years. Buildroot
    has two scripts in `/etc/init.d` named `rcS` and `rcK`. The first one starts at
    boot-up and iterates over all the scripts beginning with a capital `S` followed
    by two digits, and runs them in numerical order. These are the start scripts.
    The `rcK` script is run at shutdown and iterates over all the scripts beginning
    with a capital `K` followed by two digits, and runs them in numerical order. These
    are the kill scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Buildroot一直在有效地使用BusyBox `init`。Buildroot在`/etc/init.d`中有两个脚本，名为`rcS`和`rcK`。第一个在启动时启动，并遍历所有以大写`S`开头后跟两位数字的脚本，并按数字顺序运行它们。这些是启动脚本。`rcK`脚本在关闭时运行，并遍历所有以大写`K`开头后跟两位数字的脚本，并按数字顺序运行它们。这些是关闭脚本。
- en: With this in place, it becomes easy for Buildroot packages to supply their own
    start and kill scripts, using the two digit number to impose the order in which
    they should be run, and so the system becomes extensible. If you are using Buildroot,this
    is transparent. If not, you could use it as a model for writing your own BusyBox
    `init` scripts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，Buildroot软件包可以轻松提供自己的启动和关闭脚本，使用两位数字来规定它们应该运行的顺序，因此系统变得可扩展。如果您正在使用Buildroot，这是透明的。如果没有，您可以将其用作编写自己的BusyBox
    `init`脚本的模型。
- en: System V init
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V init
- en: This `init` program was inspired by the one from UNIX System V, and so dates
    back to the mid 1980s. The version most often found in Linux distributions was
    written initially by Miquel van Smoorenburg. Until recently, it was considered
    the way to boot Linux, obviously including embedded systems, and BusyBox `init`
    is a trimmed down version of System V `init`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`init`程序受UNIX System V的启发，可以追溯到20世纪80年代中期。在Linux发行版中最常见的版本最初是由Miquel van Smoorenburg编写的。直到最近，它被认为是引导Linux的方式，显然包括嵌入式系统，而BusyBox
    `init`是System V `init`的精简版本。
- en: Compared to BusyBox `init`, System V `init` has two advantages. Firstly, the
    boot scripts are written in a well-known, modular format, making it easy to add
    new packages at build time or runtime. Secondly, it has the concept of runlevels,
    which allow a collection of programs to be started or stopped in one go, by switching
    from one runlevel to another.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与BusyBox `init`相比，System V `init`有两个优点。首先，引导脚本以众所周知的模块化格式编写，使得在构建时或运行时轻松添加新包。其次，它具有运行级别的概念，允许通过从一个运行级别切换到另一个运行级别来一次性启动或停止一组程序。
- en: 'There are 8 runlevels numbered from 0 to 6, plus S:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有从0到6编号的8个运行级别，另外还有S：
- en: '**S**: Single user mode'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：单用户模式'
- en: '**0**: Halt the system'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0**：关闭系统'
- en: '**1 to 5**: General use'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1至5**：通用使用'
- en: '**6**: Reboot the system'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6**：重新启动系统'
- en: 'Levels 1 to 5 can be used as you please. On desktop Linux distributions, they
    are conventionally assigned as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 级别1到5可以随您的意愿使用。在桌面Linux发行版中，它们通常分配如下：
- en: '**1**: Single user'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：单用户'
- en: '**2**: Multi-user with no network configuration'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：无需网络配置的多用户'
- en: '**3**: Multi-user with network configuration'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**：带网络配置的多用户'
- en: '**4**: Not used'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4**：未使用'
- en: '**5**: Multi-user with graphical login'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5**：带图形登录的多用户'
- en: 'The `init` program starts the default `runlevel` given by the `initdefault`
    line in `/etc/inittab`. You can change the runlevel at runtime using the command
    `telinit [runlevel]` which sends a message to `init`. You can find the current
    runlevel, and the previous one, by using the `runlevel` command. Here is an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序启动由`/etc/inittab`中的`initdefault`行给出的默认`runlevel`。您可以使用`telinit [runlevel]`命令在运行时更改运行级别，该命令向`init`发送消息。您可以使用`runlevel`命令找到当前运行级别和先前的运行级别。以下是一个示例：'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the first line, the output from `runlevel` is `N 5`, meaning that there
    is no previous runlevel because the `runlevel` has not changed since booting,
    and the current `runlevel` is `5`. After changing the `runlevel`, the output is
    `5 3` showing that there has been a transition from `5` to `3`. The `halt` and
    `reboot` commands switch to runlevels of `0` and `6` respectively. You can override
    the default `runlevel` by giving a different one on the kernel command line as
    a single digit from `0` to `6`, or `S` for single user mode. For example, to force
    the `runlevel` to be for a single user, you would append `S` to the kernel command
    line and it would look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行上，`runlevel`的输出是`N 5`，这意味着没有先前的运行级别，因为自启动以来`runlevel`没有改变，当前的`runlevel`是`5`。在改变`runlevel`后，输出是`5
    3`，显示已从`5`转换到`3`。`halt`和`reboot`命令分别切换到`0`和`6`的运行级别。您可以通过在内核命令行上给出不同的单个数字`0`到`6`，或者`S`表示单用户模式，来覆盖默认的`runlevel`。例如，要强制`runlevel`为单用户，您可以在内核命令行上附加`S`，看起来像这样：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each runlevel has a number of scripts that stop things, called `kill` scripts,
    and another group that starts things, the `start` scripts. When entering a new
    `runlevel`, `init` first runs the `kill` scripts and then the `start` scripts.
    Running daemons which have neither a `start` script nor a `kill` script in the
    new `runlevel` are sent a `SIGTERM` signal. In other words, the default action
    on switching `runlevel` is to terminate the daemons unless told to do otherwise.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行级别都有一些停止事物的脚本，称为`kill`脚本，以及另一组启动事物的脚本，称为`start`脚本。进入新的`runlevel`时，`init`首先运行`kill`脚本，然后运行`start`脚本。在新的`runlevel`中运行守护进程，如果它们既没有`start`脚本也没有`kill`脚本，那么它们将收到`SIGTERM`信号。换句话说，切换`runlevel`的默认操作是终止守护进程，除非另有指示。
- en: 'In truth, runlevels are not used that much in embedded Linux: most devices
    simply boot to the default `runlevel` and stay there. I have a feeling that it
    is partly because most people are not aware of them.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在嵌入式Linux中并不经常使用运行级别：大多数设备只是启动到默认的`runlevel`并保持在那里。我有一种感觉，部分原因是大多数人并不知道它们。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Runlevels are a simple and convenient way to switch between modes, for example,
    from production to maintenance mode.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行级别是在不同模式之间切换的一种简单方便的方式，例如，从生产模式切换到维护模式。
- en: System V `init` is an option in Buildroot and the Yocto Project. In both cases,
    the init scripts have been stripped of any bash specifics, so they work with the
    BusyBox ash shell. However, Buildroot cheats by replacing the BusyBox `init` program
    with SystemV `init` and adding `inittab` that mimics the behavior of BusyBox.
    Buildroot does not implement runlevels except that switching to levels 0 or 6
    halts or reboots the system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: System V `init`是Buildroot和Yocto Project的一个选项。在这两种情况下，init脚本已经被剥离了任何bash特定的内容，因此它们可以与BusyBox
    ash shell一起工作。但是，Buildroot通过用SystemV `init`替换BusyBox `init`程序并添加模仿BusyBox行为的`inittab`来作弊。Buildroot不实现运行级别，除非切换到级别0或6会停止或重新启动系统。
- en: Next, let's look at some of the details. The following examples are taken from
    the fido version of the Yocto Project. Other distributions may implement the `init`
    scripts a little differently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一些细节。以下示例取自Yocto Project的fido版本。其他发行版可能以稍有不同的方式实现`init`脚本。
- en: inittab
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inittab
- en: The `init` program begins by reading `/etc/inttab`, which contains entries that
    define what happens at each `runlevel`. The format is an extended version of the
    BusyBox `inittab` that I described in the preceding section, which is not surprising
    because BusyBox borrowed it from System V in the first place!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序首先读取`/etc/inttab`，其中包含定义每个`runlevel`发生的事情的条目。格式是我在前一节中描述的BusyBox `inittab`的扩展版本，这并不奇怪，因为BusyBox首先从System
    V借鉴了它！'
- en: 'The format of each line in `inittab` is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`inittab`中每行的格式如下：'
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The fields are shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 字段如下所示：
- en: '`id`: A unique identifier of up to four characters.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：最多四个字符的唯一标识符。'
- en: '`runlevels`: The runlevels for which this entry should be executed. (This was
    left blank in the BusyBox `inittab`)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runlevels`：应执行此条目的运行级别。（在BusyBox `inittab`中留空）'
- en: '`action`: One of the keywords given as follows.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：以下给出的关键字之一。'
- en: '`process`: The command to run.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process`：要运行的命令。'
- en: 'The actions are the same as for BusyBox `init`: `sysinit`, `respawn`, `once`,
    `wait`, `restart`, `ctrlaltdel`, and `shutdown`. However, System V `init` does
    not have `askfirst`, which is specific to BusyBox.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作与BusyBox `init`的操作相同：`sysinit`，`respawn`，`once`，`wait`，`restart`，`ctrlaltdel`和`shutdown`。但是，System
    V `init`没有`askfirst`，这是BusyBox特有的。
- en: 'As an example, this is the complete `inttab` supplied by the Yocto Project
    target core-image-minimal:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是Yocto Project目标core-image-minimal提供的完整的`inttab`：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The fist entry, `id:5:initdefault`, sets the default `runlevel` to `5`. The
    next entry, `si::sysinit:/etc/init.d/rcS`, runs the script `rcS` at boot up. There
    will be more about this later. A little further on, there is a group of six entries
    beginning with `l0:0:wait:/etc/init.d/rc 0`. They run the script `/etc/init.d/rc`
    each time there is a change in the runlevel: this script is responsible for processing
    the `start` and `kill` scripts. There is an entry for runlevel `S` which runs
    the single-user login program.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目`id:5:initdefault`将默认的`runlevel`设置为`5`。接下来的条目`si::sysinit:/etc/init.d/rcS`在启动时运行脚本`rcS`。稍后会有更多关于这个的内容。稍后，有一组六个条目，以`l0:0:wait:/etc/init.d/rc
    0`开头。它们在运行级别发生变化时运行脚本`/etc/init.d/rc`：这个脚本负责处理`start`和`kill`脚本。还有一个运行级别`S`的条目，运行单用户登录程序。
- en: 'Towards the end of `inittab`, there are two entries that run a `getty` daemon
    to generate a login prompt on the devices `/dev/ttyAMA0` and `/dev/tty1` when
    entering runlevels 1 through to 5, thereby allowing you to log on and get an interactive
    shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`inittab`的末尾，有两个条目，当进入运行级别1到5时，它们运行一个`getty`守护进程在设备`/dev/ttyAMA0`和`/dev/tty1`上生成登录提示，从而允许你登录并获得交互式shell：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The device `ttyAMA0` is the serial console on the ARM Versatile board we are
    emulating with QEMU, it will be different for other development boards. Tty1 is
    a virtual console which is often mapped to a graphical screen if you have built
    your kernel with `CONFIG_FRAMEBUFFER_CONSOLE or VGA_CONSOLE`. Desktop Linux usually
    spawns six `getty` processes on virtual terminals 1 to 6, which you can select
    with the key combination *Ctrl* + *Alt* + *F1* through *Ctrl* + *Alt* + *F6*,
    with virtual terminal 7 reserved for the graphical screen. Virtual terminals are
    seldom used on embedded devices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设备`ttyAMA0`是我们用QEMU模拟的ARM Versatile板上的串行控制台，对于其他开发板来说可能会有所不同。Tty1是一个虚拟控制台，通常映射到图形屏幕，如果你的内核使用了`CONFIG_FRAMEBUFFER_CONSOLE`或`VGA_CONSOLE`。桌面Linux通常在虚拟终端1到6上生成六个`getty`进程，你可以用组合键*Ctrl*
    + *Alt* + *F1*到*Ctrl* + *Alt* + *F6*来选择，虚拟终端7保留给图形屏幕。嵌入式设备上很少使用虚拟终端。
- en: 'The script `/etc/init.d/rcS` that is run by the `sysinit` entry does little
    more than enter runlevel `S`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由`sysinit`条目运行的脚本`/etc/init.d/rcS`几乎只是进入运行级别`S`：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hence, the first run level entered is `S`, followed by the default `runlevel`
    of `5`. Note that `runlevel` `S` is not recorded and is never displayed as a prior
    runlevel by the `runlevel` command.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个进入的运行级别是`S`，然后是默认的`runlevel` `5`。请注意，`runlevel` `S`不会被记录，也不会被`runlevel`命令显示为先前的运行级别。
- en: The init.d scripts
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: init.d脚本
- en: 'Each component that needs to respond to a `runlevel` change has a script in
    `/etc/init.d` to perform that change. The script should expect two parameters:
    `start` and `stop`. I will give an example of this later.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要响应`runlevel`变化的每个组件都有一个在`/etc/init.d`中执行该变化的脚本。脚本应该期望两个参数：`start`和`stop`。稍后我会举一个例子。
- en: 'The `runlevel` handling script, `/etc/init.d/rc`, takes the `runlevel` it is
    switching to as a parameter. For each `runlevel`, there is a directory named `rc<runlevel>.d`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`runlevel`处理脚本`/etc/init.d/rc`以`runlevel`作为参数进行切换。对于每个`runlevel`，都有一个名为`rc<runlevel>.d`的目录：'
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There you will find a set of scripts beginning with a capital `S` followed
    by two digits and you may also find scripts beginning with a capital `K`. These
    are `start` and `kill` scripts: Buildroot uses the same idea, borrowed from here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里你会找到一组以大写`S`开头后跟两位数字的脚本，你也可能会找到以大写`K`开头的脚本。这些是`start`和`kill`脚本：Buildroot使用了相同的想法，从这里借鉴过来：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are in fact symbolic links back to the appropriate script in `init.d`.
    The `rc` script runs all the scripts beginning with a `K` first, adding the `stop`
    parameter , and then runs those beginning with an `S` adding the `start` parameter
    . Once again, the two digit code is there to impart the order in which the scripts
    should run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些是指向`init.d`中适当脚本的符号链接。`rc`脚本首先运行所有以`K`开头的脚本，添加`stop`参数，然后运行以`S`开头的脚本，添加`start`参数。再次强调，两位数字代码用于指定脚本应该运行的顺序。
- en: Adding a new daemon
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的守护进程
- en: 'Imagine that you have a program named `simpleserver` which is written as a
    traditional Unix daemon, in other words, it forks and runs in the background.
    You will need an `init.d` script like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`simpleserver`的程序，它是作为传统的Unix守护进程编写的，换句话说，它会分叉并在后台运行。你将需要一个像这样的`init.d`脚本：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Start-stop-daemon` is a helper function that makes it easier to manipulate
    background processes such as this. It originally came from the Debian installer
    package, `dpkg`, but most embedded systems use the one from BusyBox. It starts
    the daemon with the `-S` parameter, making sure that there is never more than
    one instance running at any one time and it finds the daemon by name with `-K`
    and sends a signal, `SIGTERM`, by default. Place this script in `/etc/init.d/simpleserver`
    and make it executable.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start-stop-daemon`是一个帮助函数，使得更容易操作后台进程。它最初来自Debian安装程序包`dpkg`，但大多数嵌入式系统使用的是BusyBox中的版本。它使用`-S`参数启动守护进程，确保任何时候都不会有多个实例在运行，并使用`-K`按名称查找守护进程，并默认发送信号`SIGTERM`。将此脚本放在`/etc/init.d/simpleserver`中并使其可执行。'
- en: 'Then, add `symlinks` from each of the run levels that you want to run this
    program from, in this case, only the default `runlevel`, `5`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从你想要从中运行这个程序的每个运行级别添加`symlinks`，在这种情况下，只有默认的`runlevel`，`5`：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The number `99` means that this will be one of the last programs to be started.
    Bear in mind that there may be other links beginning `S99`, in which case the
    `rc` script will just run them in lexical order.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`99`表示这将是最后启动的程序之一。请记住，可能会有其他以`S99`开头的链接，如果是这样，`rc`脚本将按照词法顺序运行它们。
- en: 'It is rare in embedded devices to have to worry too much about shutdown operations,
    but if there is something that needs to be done, add `kill symlinks` to levels
    0 and 6:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备中很少需要过多担心关机操作，但如果有需要做的事情，可以在0和6级别添加`kill symlinks`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Starting and stopping services
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止服务
- en: 'You can interact with the scripts in `/etc/init.d` by calling them directly
    with, for example, the `syslog` script which controls the `syslogd` and `klogd`
    daemons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过直接调用`/etc/init.d`中的脚本与之交互，例如，控制`syslogd`和`klogd`守护进程的`syslog`脚本：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All scripts implement `start` and `stop` and should implement `help`. Some implement
    `status` as well, which will tell you whether the service is running or not. Mainstream
    distributions that still use System V `init` have a command named service to start
    and stop services and hide the details of calling the scripts directly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有脚本都实现了`start`和`stop`，并且应该实现`help`。有些还实现了`status`，它会告诉您服务是否正在运行。仍在使用System
    V `init`的主流发行版有一个名为service的命令，用于启动和停止服务，并隐藏直接调用脚本的细节。
- en: systemd
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: systemd
- en: '`systemd` defines itself as a system and service manager. The project was initiated
    in 2010 by Lennart Poettering and Kay Sievers to create an integrated set of tools
    for managing a Linux system including an `init` daemon. It also includes device
    management (`udev`) and logging, among other things. Some would say that it is
    not just an `init` program, it is a way of life. It is state of the art, and still
    evolving rapidly. `systemd` is common on desktop and server Linux distributions,
    and is becoming popular on embedded Linux systems too, especially on more complex
    devices. So, how is it better than System V `init` for embedded systems?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`将自己定义为系统和服务管理器。该项目由Lennart Poettering和Kay Sievers于2010年发起，旨在创建一套集成的工具，用于管理Linux系统，包括`init`守护程序。它还包括设备管理（`udev`）和日志记录等内容。有人会说它不仅仅是一个`init`程序，它是一种生活方式。它是最先进的，仍在快速发展。`systemd`在桌面和服务器Linux发行版上很常见，并且在嵌入式Linux系统上也变得越来越受欢迎，特别是在更复杂的设备上。那么，它比System
    V `init`在嵌入式系统上更好在哪里呢？'
- en: Configuration is simpler and more logical (once you understand it), rather than
    the sometimes convoluted shell scripts of System V `init`, `systemd` has unit
    configuration files to set parameters
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置更简单更合乎逻辑（一旦你理解了它），而不是System V `init`有时候复杂的shell脚本，`systemd`有单元配置文件来设置参数
- en: There are explicit dependencies between services rather than a two digit code
    that merely sets the sequence in which the scripts are run
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间有明确的依赖关系，而不是仅仅设置脚本运行顺序的两位数代码
- en: It is easy to set the permissions and resource limits for each service, which
    is important for security
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个服务设置权限和资源限制很容易，这对安全性很重要
- en: '`systemd` can monitor services and restart them if needed'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`可以监视服务并在需要时重新启动它们'
- en: There are watchdogs for each service and for s`ystemd` itself
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务和`systemd`本身都有看门狗
- en: Services are started in parallel, reducing boot time
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务并行启动，减少启动时间
- en: A complete description of `systemd` is neither possible nor appropriate here.
    As with System V `init`, I will focus on embedded use-cases, with examples based
    on the configuration produced by Yocto Fido, which has `systemd` version 219\.
    I will give a quick overview and then show you some specific examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不可能也不合适对`systemd`进行完整描述。与System V `init`一样，我将专注于嵌入式用例，并以Yocto Fido生成的配置为例，该配置具有`systemd`版本219。我将进行快速概述，然后向您展示一些具体示例。
- en: Building systemd with the Yocto Project and Buildroot
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Yocto Project和Buildroot构建systemd
- en: 'The default `init` in Yocto Fido is System V. To select `systemd`, add these
    lines to your configuration, for example, in `conf/local.conf`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto Fido中的默认`init`是System V。要选择`systemd`，请在配置中添加这些行，例如，在`conf/local.conf`中：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the leading space is important! Then rebuild.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前导空格很重要！然后重新构建。
- en: Buildroot has `systemd` as the third `init` option. It requires glibc as the
    C library, and kernel version 3.7 or later with a particular set of configuration
    options enabled. There is a complete list of dependencies in the `README` file
    in the top level of the `systemd` source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot将`systemd`作为第三个`init`选项。它需要glibc作为C库，并且需要启用特定一组配置选项的内核版本为3.7或更高。在`systemd`源代码的顶层的`README`文件中有完整的依赖项列表。
- en: Introducing targets, services, and units
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍目标、服务和单元
- en: Before I describe how `systemd init` works, I need to introduce these three
    key concepts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我描述`systemd init`如何工作之前，我需要介绍这三个关键概念。
- en: Firstly, a target is a group of services, similar to, but more general than,
    a SystemV `runlevel`. There is a default target which is the group of services
    that are started at boot time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，目标是一组服务，类似于但更一般化的SystemV `runlevel`。有一个默认目标，它是在启动时启动的服务组。
- en: Secondly, a service is a daemon that can be started and stopped, very much like
    a SystemV `service`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，服务是可以启动和停止的守护进程，非常类似于SystemV `service`。
- en: Finally, a unit is a configuration file that describes a `target`, a `service`,
    and several other things. Units are text files that contain properties and values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个单元是一个描述`target`，`service`和其他几个东西的配置文件。单元是包含属性和值的文本文件。
- en: You can change states and find out what is going on by using the `systemctl`
    command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`systemctl`命令更改状态并了解发生了什么。
- en: Units
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元
- en: 'The basic item of configuration is the unit file. Unit files are found in three
    different places:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的基本项是单元文件。单元文件位于三个不同的位置：
- en: '`/etc/systemd/system`: Local configuration'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/systemd/system`：本地配置'
- en: '`/run/systemd/system`: Runtime configuration'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/run/systemd/system`：运行时配置'
- en: '`/lib/systemd/system`: Distribution-wide configuration'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib/systemd/system`：分发范围内的配置'
- en: When looking for a unit, `systemd` searches the directories in that order, stopping
    as soon as it finds a match, allowing you to override the behavior of a distribution-wide
    unit by placing a unit of the same name in `/etc/systemd/system`. You can disable
    a unit completely by creating a local file that is empty or linked to `/dev/null`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找单元时，`systemd`按照这个顺序搜索目录，一旦找到匹配项就停止，这样可以通过在`/etc/systemd/system`中放置同名单元来覆盖分发范围内单元的行为。您可以通过创建一个空的本地文件或链接到`/dev/null`来完全禁用一个单元。
- en: 'All unit files begin with a section marked `[Unit]` which contains basic information
    and dependencies, for example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元文件都以标有`[Unit]`的部分开头，其中包含基本信息和依赖项，例如：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unit dependencies are expressed though `Requires`, `Wants`, and `Conflicts`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 单元依赖关系通过`Requires`、`Wants`和`Conflicts`来表达：
- en: '`Requires`: A list of units that this unit depends on, which is started when
    this unit is started'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Requires`: 此单元依赖的单元列表，当此单元启动时启动'
- en: '`Wants`: A weaker form of `Requires`: the units listed are started but the
    current unit is not stopped if any of them fail'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants`: `Requires`的一种较弱形式：列出的单元被启动，但如果它们中的任何一个失败，当前单元不会停止'
- en: '`Conflicts`: A negative dependency: the units listed are stopped when this
    one is started and, conversely, if one of them is started, this one is stopped'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`冲突`: 一个负依赖：列出的单元在此单元启动时停止，反之亦然'
- en: 'Processing the dependencies produces a list of units that should be started
    (or stopped). The keywords `Before` and `After` determine the order in which they
    are started. The order of stopping is just the reverse of the start order:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理依赖关系会产生一个应该启动（或停止）的单元列表。关键字`Before`和`After`确定它们启动的顺序。停止的顺序只是启动顺序的相反：
- en: '`Before`: This unit should be started before the units listed'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Before`: 在列出的单元之前应启动此单元'
- en: '`After`: This unit should be started after the units listed'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After`: 在列出的单元之后应启动此单元'
- en: 'In the following example, the `After` directive makes sure that the web server
    is started after the network:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`After`指令确保网络后启动Web服务器：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the absence of `Before` or `After` directives, the units will be started
    or stopped in parallel with no particular ordering.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有`Before`或`After`指令的情况下，单元将并行启动或停止，没有特定的顺序。
- en: Services
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务
- en: A service is a daemon that can be started and stopped, equivalent to a System
    V `service`. A service is a type of unit file with a name ending in `.service`,
    for example, `lighttpd.service`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是可以启动和停止的守护进程，相当于System V的`service`。服务是以`.service`结尾的一种单元文件，例如`lighttpd.service`。
- en: 'A service unit has a `[Service]` section that describes how it should be run.
    Here is the relevant section from `lighttpd.service`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 服务单元有一个描述其运行方式的`[Service]`部分。以下是`lighttpd.service`的相关部分：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are the commands to run when starting the service and restarting it. There
    are many more configuration points you can add in here, so refer to the man page
    for `systemd.service`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是启动服务和重新启动服务时要运行的命令。您可以在这里添加更多配置点，因此请参考`systemd.service`的手册页。
- en: Targets
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: A target is another type of unit which groups services (or other types of unit).
    It is a type of unit that only has dependencies. Targets have names ending in
    `.target`, for example, `multi-user.target`. A target is a desired state, which
    performs the same role as System V runlevels.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是另一种将服务（或其他类型的单元）分组的单元类型。它是一种只有依赖关系的单元类型。目标的名称以`.target`结尾，例如`multi-user.target`。目标是一种期望状态，起到与System
    V运行级别相同的作用。
- en: How systemd boots the system
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd如何引导系统
- en: 'Now we can see how `systemd` implements the bootstrap. `systemd` is run by
    the kernel as a result of `/sbin/init` being symbolically linked to `/lib/systemd/systemd`.
    It runs the default target, `default.target`, which is always a link to a desired
    target such as `multi-user.target` for a text login or `graphical.target` for
    a graphical environment. For example, if the default target is `multi-user.target`,
    you will find this symbolic link:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到`systemd`如何实现引导。`systemd`由内核作为`/sbin/init`的符号链接到`/lib/systemd/systemd`而运行。它运行默认目标`default.target`，它始终是一个指向期望目标的链接，例如文本登录的`multi-user.target`或图形环境的`graphical.target`。例如，如果默认目标是`multi-user.target`，您将找到此符号链接：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The default target may be overridden by passing `system.unit=<new target>`
    on the kernel command line. You can use `systemctl` to find out the default target,
    as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认目标可以通过在内核命令行上传递`system.unit=<new target>`来覆盖。您可以使用`systemctl`来查找默认目标，如下所示：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Starting a target such as `multi-user.target` creates a tree of dependencies
    that bring the system into a working state. In a typical system, `multi-user.target`
    depends on `basic.target`, which depends on `sysinit.target`, which depends on
    the services that need to be started early. You can print a graph using `systemctl
    list-dependencies`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 启动诸如`multi-user.target`之类的目标会创建一个依赖树，将系统带入工作状态。在典型系统中，`multi-user.target`依赖于`basic.target`，后者依赖于`sysinit.target`，后者依赖于需要早期启动的服务。您可以使用`systemctl
    list-dependencies`打印图形。
- en: You can also list all the services and their current state using `systemctl
    list-units --type service`, and the same for targets using `systemctl list-units
    --type target`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`systemctl list-units --type service`列出所有服务及其当前状态，以及使用`systemctl list-units
    --type target`列出目标。
- en: Adding your own service
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加您自己的服务
- en: 'Using the same `simpleserver` example as before, here is a service unit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的`simpleserver`示例，这是一个服务单元：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `[Unit]` section only contains a description so that it shows up correctly
    when listed using `systemctl` and other commands. There are no dependencies; as
    I said, it is very simple.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Unit]`部分只包含一个描述，以便在使用`systemctl`和其他命令列出时正确显示。没有依赖关系；就像我说的，它非常简单。'
- en: The `[Service]` section points to the executable, and has a flag to indicate
    that it forks. If it were even simpler and ran in the foreground, `systemd` would
    do the daemonizing for us and `Type=forking` would not be needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Service]`部分指向可执行文件，并带有一个指示它分叉的标志。如果它更简单并在前台运行，`systemd`将为我们进行守护进程，`Type=forking`将不需要。'
- en: The `[Install]` section makes it dependent on `multi-user.target` so that our
    server is started when the system goes into multi-user mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Install]`部分使其依赖于`multi-user.target`，这样我们的服务器在系统进入多用户模式时启动。'
- en: 'Once the unit is saved in `/etc/systemd/system/simpleserver.service`, you can
    start and stop it using the `systemctl start simpleserver` and s`ystemctl stop
    simpleserver` commands. You can use this command to find its current status:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单元保存在`/etc/systemd/system/simpleserver.service`中，您可以使用`systemctl start simpleserver`和`systemctl
    stop simpleserver`命令启动和停止它。您可以使用此命令查找其当前状态：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, it will only start and stop on command, as shown. To make it
    persistent, you need to add a permanent dependency to a target. That is the purpose
    of the `[Install]` section in the unit, it says that when this service is enabled
    it will become dependent on `multi-user.target`, and so will be started at boot
    time. You enable it using `systemctl enable`, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，它只会按命令启动和停止，如所示。要使其持久化，您需要向目标添加永久依赖项。这就是单元中`[Install]`部分的目的，它表示当启用此服务时，它将依赖于`multi-user.target`，因此将在启动时启动。您可以使用`systemctl
    enable`来启用它，如下所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now you can see how dependencies are added at runtime without having to edit
    any unit files. A target can have a directory named `<target_name>.target.wants`
    which can contain links to services. This is exactly the same as adding the dependent
    unit to the `[Wants]` list in the target. In this case, you will find that this
    link has been created:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到如何在运行时添加依赖项，而无需编辑任何单元文件。一个目标可以有一个名为`<target_name>.target.wants`的目录，其中可以包含指向服务的链接。这与在目标中的`[Wants]`列表中添加依赖单元完全相同。在这种情况下，您会发现已创建了此链接：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this is were an important service you might want to restart if it failed.
    You can accomplish that by adding this flag to the `[Service]` section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个重要的服务，如果失败，您可能希望重新启动。您可以通过向`[Service]`部分添加此标志来实现：
- en: '`Restart=on-abort`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restart=on-abort`'
- en: Other options for `Restart` are `on-success`, `on-failure`, `on-abnormal`, `on-watchdog`,
    `on-abort`, or `always`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restart`的其他选项是`on-success`、`on-failure`、`on-abnormal`、`on-watchdog`、`on-abort`或`always`。'
- en: Adding a watchdog
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加看门狗
- en: 'Watchdogs are a common requirement in embedded devices: you need to take action
    if a critical service stops working, usually by resetting the system. On most
    embedded SoCs, there is a hardware watchdog which can be accessed via the `/dev/watchdog`
    device node. The watchdog is initialized with a timeout at boot and then must
    be reset within that period, otherwise the watchdog will be triggered and the
    system will reboot. The interface with the watchdog driver is described in the
    kernel source in `Documentation/watchdog`, and the code for the drivers is in
    `drivers/watchdog`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗是嵌入式设备中的常见要求：如果关键服务停止工作，通常需要采取措施重置系统。在大多数嵌入式SoC中，有一个硬件看门狗，可以通过`/dev/watchdog`设备节点访问。看门狗在启动时使用超时进行初始化，然后必须在该期限内进行复位，否则看门狗将被触发，系统将重新启动。与看门狗驱动程序的接口在内核源代码中的`Documentation/watchdog`中有描述，驱动程序的代码在`drivers/watchdog`中。
- en: A problem arises if there are two or more critical services that need to be
    protected by a watchdog. `systemd` has a useful feature that distributes the watchdog
    between multiple services.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个或更多需要由看门狗保护的关键服务，就会出现问题。`systemd`有一个有用的功能，可以在多个服务之间分配看门狗。
- en: '`systemd` can be configured to expect a regular keepalive call from a service
    and take action if it is not received, in other words, a per-service software
    watchdog. For this to work, you have to add code to the daemon to send the keepalive
    messages. It needs to check for a non-zero value in the `WATCHDOG_USEC` environment
    variable and then call `sd_notify(false, "WATCHDOG=1")` within that time (a period
    of half of the watchdog timeout is recommended). There are examples in the `systemd`
    source code.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`可以配置为期望从服务接收定期的保持活动状态的调用，并在未收到时采取行动，换句话说，每个服务的软件看门狗。为了使其工作，您必须向守护程序添加代码以发送保持活动状态的消息。它需要检查`WATCHDOG_USEC`环境变量中的非零值，然后在此期间内调用`sd_notify(false,
    "WATCHDOG=1")`（建议使用看门狗超时的一半时间）。`systemd`源代码中有示例。'
- en: 'To enable the watchdog in the service unit, add something like this to the
    `[Service]` section:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务单元中启用看门狗，向`[Service]`部分添加类似以下内容：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the service expects a keepalive every 30 seconds. If it fails
    to be delivered, the service will be restarted, but if it is restarted more than
    four times in five minutes, `systemd` will force an immediate reboot. Once again,
    there is a full description of these settings in the `systemd` manual.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该服务期望每30秒进行一次保持活动状态的检查。如果未能交付，该服务将被重新启动，但如果在五分钟内重新启动超过四次，`systemd`将强制立即重新启动。再次，在`systemd`手册中有关于这些设置的完整描述。
- en: 'A watchdog like this takes care of individual services, but what if `systemd`
    itself fails, or the kernel crashes, or the hardware locks up. In those cases,
    we need to tell `systemd` to use the watchdog driver: just add `RuntimeWatchdogSec=NN`
    to `/etc/systemd/system.conf`. `systemd` will reset the watchdog within that period,
    and so the system will reset if `systemd` fails for some reason.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的看门狗负责个别服务，但如果`systemd`本身失败，或者内核崩溃，或者硬件锁定。在这些情况下，我们需要告诉`systemd`使用看门狗驱动程序：只需将`RuntimeWatchdogSec=NN`添加到`/etc/systemd/system.conf`。`systemd`将在该期限内重置看门狗，因此如果`systemd`因某种原因失败，系统将重置。
- en: Implications for embedded Linux
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式Linux的影响
- en: '`systemd` has a lot of features that are useful in embedded Linux, including
    many that I have not mentioned in this brief description such as resource control
    using slices (see the man page for `systemd.slice(5)` and `systemd.resource-control(5)`),
    device management (`udev(7)`) and system logging facilities (`journald(5)`).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`在嵌入式Linux中有许多有用的功能，包括我在这个简要描述中没有提到的许多功能，例如使用切片进行资源控制（参见`systemd.slice(5)`和`systemd.resource-control(5)`的手册页）、设备管理（`udev(7)`）和系统日志记录设施（`journald(5)`）。'
- en: 'You have to balance that with its size: even with a minimal build of just the
    core components, `systemd`, `udevd`, and `journald`, it is approaching 10 MiB
    of storage, including the shared libraries.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须权衡其大小：即使只构建了核心组件`systemd`、`udevd`和`journald`，其存储空间也接近10 MiB，包括共享库。
- en: You also have to keep in mind that `systemd` development follows the kernel
    closely, so it will not work on a kernel more than a year or two older than the
    release of `systemd`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须记住，`systemd`的开发与内核紧密相关，因此它不会在比`systemd`发布时间早一年或两年的内核上工作。
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resource has further information about topics introduced in this
    chapter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的进一步信息：
- en: '*systemd system and Service Manager*: [http://www.freedesktop.org/wiki/Software/systemd/](http://www.freedesktop.org/wiki/Software/systemd/)
    (there are a lot of useful links at the bottom of that page)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd系统和服务管理器：[http://www.freedesktop.org/wiki/Software/systemd/](http://www.freedesktop.org/wiki/Software/systemd/)（该页面底部有许多有用的链接）
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Every Linux device needs an `init` program of some kind. If you are designing
    a system which only has to launch a small number of daemons at startup and remains
    fairly static after that, then BusyBox `init` is sufficient for your needs. It
    is usually a good choice if you are using Buildroot as the build system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Linux设备都需要某种类型的“init”程序。如果您正在设计一个系统，该系统只需在启动时启动少量守护程序并在此后保持相对静态，那么BusyBox“init”就足够满足您的需求。如果您使用Buildroot作为构建系统，通常这是一个不错的选择。
- en: If, on the other hand, you have a system that has complex dependencies between
    services at boot time or runtime, and you have the storage space, then `systemd`
    would be the best choice. Even without the complexity, `systemd` has some useful
    features in the way it handles watchdogs, remote logging, and so on, so you should
    certainly give it a serious thought.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您的系统在启动时或运行时服务之间存在复杂的依赖关系，并且您有存储空间，那么“systemd”将是最佳选择。即使没有复杂性，“systemd”在处理看门狗、远程日志记录等方面也具有一些有用的功能，因此您应该认真考虑它。
- en: It is hard to make a case for System V `init` on its own merits, since it has
    few advantages over the simple BusyBox `init`. It will live on for a long time
    nevertheless, just because it is there. For example, if you are building using
    the Yocto Project and you decide against `systemd` then System V `init` is the
    alternative.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 很难仅凭其自身的优点支持System V“init”，因为它几乎没有比简单的BusyBox“init”更多的优势。尽管如此，它仍将长期存在，仅仅因为它存在。例如，如果您正在使用Yocto
    Project进行构建，并决定不使用“systemd”，那么System V“init”就是另一种选择。
- en: In terms of reducing boot time, `systemd` is faster than System V `init` for
    a similar workload. However, if you are looking for a very fast boot, nothing
    can beat a simple BusyBox `init` with minimal boot scripts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在减少启动时间方面，“systemd”比System V“init”更快，但是，如果您正在寻找非常快速的启动，没有什么能比得上简单的BusyBox“init”和最小的启动脚本。
- en: This chapter is about one very important process, `init`. In the next chapter,
    I will describe what a process really is, how it relates to threads, how they
    cooperate, and how they are scheduled. Understanding these things is important
    if you want to create a robust and maintainable embedded system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于一个非常重要的进程，“init”。在下一章中，我将描述进程的真正含义，它与线程的关系，它们如何合作以及它们如何被调度。如果您想创建一个健壮且易于维护的嵌入式系统，了解这些内容是很重要的。
