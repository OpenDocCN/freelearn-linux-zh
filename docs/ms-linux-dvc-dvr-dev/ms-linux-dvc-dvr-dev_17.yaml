- en: '*Chapter 14*: Linux Kernel Debugging Tips and Best Practices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：Linux内核调试技巧和最佳实践'
- en: Most of the time, as part of development, writing code is not the hardest part.
    Things are rendered difficult by the fact that the Linux kernel is a standalone
    software that is at the lowest layer of the operating system. This makes it challenging
    to debug the Linux kernel. However, this is compensated by the fact that the majority
    of the time, we don't need additional tools to debug kernel code because most
    of the kernel debugging tools are part of the kernel itself. We will begin by
    familiarizing ourselves with the Linux kernel release model and you will learn
    the Linux kernel release process and steps. Then, we will look at the Linux kernel
    debugging-related development tips (especially debugging by printing) and finally,
    we will focus on tracing the Linux kernel, ending with off-target debugging and
    learning to leverage kernel oops.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，在开发过程中，编写代码并不是最困难的部分。困难之处在于Linux内核是操作系统最底层的独立软件。这使得调试Linux内核变得具有挑战性。然而，这得到了补偿，因为大多数情况下，我们不需要额外的工具来调试内核代码，因为大多数内核调试工具都是内核本身的一部分。我们将首先熟悉Linux内核发布模型，然后学习Linux内核发布流程和步骤。接下来，我们将关注与Linux内核调试相关的开发技巧（特别是通过打印进行调试），最后，我们将专注于跟踪Linux内核，以离线调试和学习如何利用内核oops结束。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Linux kernel release process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Linux内核发布流程
- en: Linux kernel development tips
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核开发技巧
- en: Linux kernel tracing and performance analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核跟踪和性能分析
- en: Linux kernel debugging tips
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核调试技巧
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机体系结构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，位于[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
- en: Understanding the Linux kernel release process
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Linux内核发布流程
- en: 'According to the Linux kernel release model, there are always three types of
    active kernel release: mainline, the stable release, and the **Long-Term Support**
    (**LTS**) release. First, bug fixes and new features are gathered and prepared
    by subsystem maintainers and then submitted to Linus Torvalds in order for him
    to include them in his own Linux tree, which is called the *mainline Linux tree*,
    also known as the *master* Git repository. This is where every stable release
    originates from.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux内核发布模型，始终存在三种类型的活动内核发布：主线、稳定发布和长期支持（LTS）发布。首先，子系统维护者收集和准备bug修复和新功能，然后提交给Linus
    Torvalds，以便他将它们包含在自己的Linux树中，这被称为主线Linux树，也被称为主Git存储库。这是每个稳定发布的起源。
- en: 'Before each new kernel version is released, it is submitted to the community
    through *release candidate* tags, so that developers can test and polish all the
    new features and, most importantly, share feedback. During this cycle, Linus will
    rely on the feedback in order to decide whether the final version is ready to
    be released. When he is convinced that the new kernel is ready to go, he makes
    (tags it actually) the final release, and we call this release *stable* to indicate
    that it''s no longer a *release candidate*: those releases are *vX.Y* versions.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新内核版本发布之前，它都会通过*发布候选*标签提交给社区，以便开发人员可以测试和完善所有新功能，最重要的是分享反馈。在这个周期内，Linus将依赖反馈来决定最终版本是否准备好发布。当他确信新内核准备就绪时，他会进行（实际上是标记）最终发布，我们称这个发布为*稳定*，以表示它不再是*发布候选*：这些发布是*vX.Y*版本。
- en: There is no strict timeline for making releases. However, new mainline kernels
    are generally released every 2–3 months. Stable kernel releases are based on Linus's
    releases, that is, the mainline tree releases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有制定发布的严格时间表。然而，新的主线内核通常每2-3个月发布一次。稳定内核发布基于Linus的发布，即主线树发布。
- en: Once a mainline kernel is released by Linus, it also appears in the *linux-stable*
    tree (available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    where it becomes a branch and from where it can receive bug fixes for a stable
    release. *Greg Kroah-Hartman* is responsible for maintaining this tree, which
    is also referred to as the stable tree because it is used to track previously
    released stable kernels. That said, in order for a fix to be applied to this tree,
    this fix must first be incorporated in the Linus tree. Because the fix must go
    forth before coming back, it is said that this fix is back-ported. Once the bug
    is fixed in the mainline repository, it can then be applied to previously released
    kernels that are still maintained by the kernel development community. All fixes
    back-ported to stable releases must meet a set of mandatory acceptance criteria
    — and one of these criteria is that they **must already exist in Linus's tree**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Linus发布了主线内核，它也会出现在linux-stable树中（位于[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)），在那里它成为一个分支，并且可以接收稳定发布的bug修复。Greg
    Kroah-Hartman负责维护这个树，它也被称为稳定树，因为它用于跟踪先前发布的稳定内核。也就是说，为了将修复应用到这个树中，这个修复必须首先被合并到Linus的树中。因为修复必须先前进再返回，所以说这个修复是被反向移植的。一旦在主线存储库中修复了bug，它就可以应用到仍由内核开发社区维护的先前发布的内核中。所有反向移植到稳定发布的修复必须符合一组强制接受标准，其中之一是它们必须已经存在于Linus的树中。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Bugfix kernel releases are considered stable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 修复bug的内核发布被认为是稳定的。
- en: For example, the `4.9` kernel is released by Linus, and then the stable kernel
    releases based on this kernel are numbered `4.9.1`, `4.9.2`, `4.9.3`, and so on.
    Such releases are known as *bugfix kernel releases*, and the sequence is usually
    shortened with the number *4.9.y* when referring to their branch in the stable
    kernel release tree. Each stable kernel release tree is maintained by a single
    kernel developer, who is responsible for picking the requisite patches for the
    release, and for performing the review/release process. There are usually only
    a few bugfix kernel releases until the next mainline kernel becomes available,
    unless it is designated a *long-term maintenance kernel*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`4.9`内核由Linus发布，然后基于此内核的稳定内核发布被编号为`4.9.1`，`4.9.2`，`4.9.3`等。这些发布被称为*错误修复内核发布*，通常在稳定内核发布树中引用它们的分支时，序列通常缩短为数字*4.9.y*。每个稳定内核发布树由单个内核开发人员维护，负责挑选发布所需的补丁，并执行审查/发布流程。通常只有几个错误修复内核发布，直到下一个主线内核可用，除非它被指定为*长期维护内核*。
- en: 'Every subsystem and kernel maintainer repository is hosted here: [https://git.kernel.org/pub/scm/linux/kernel/git/](https://git.kernel.org/pub/scm/linux/kernel/git/).
    There, we can also find either Linus or stable trees. In the Linus tree ([https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/)),
    there is only one branch in Linus''s tree, that is, the master branch. Tags in
    there are either stable releases or release candidates. In the stable tree ([https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    there is one branch per stable kernel release (named *<A.B>.y*, where *<A.B>*
    is the release version in the Linus tree) and each branch contains its bugfix
    kernel releases.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子系统和内核维护者存储库都托管在这里：[https://git.kernel.org/pub/scm/linux/kernel/git/](https://git.kernel.org/pub/scm/linux/kernel/git/)。在那里，我们也可以找到Linus或稳定树。在Linus树中([https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/))，Linus的树中只有一个分支，即主分支。其中的标签要么是稳定发布，要么是发布候选版本。在稳定树中([https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/))，每个稳定内核发布都有一个分支(命名为*<A.B>.y*，其中*<A.B>*是Linus树中的发布版本)，每个分支都包含其错误修复内核发布。
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are a few links that you can keep to hand in order to follow the Linux
    kernel release. The first one is [https://www.kernel.org/](https://www.kernel.org/),
    from where you can download kernel archives, and then there is [https://www.kernel.org/category/releases.html](https://www.kernel.org/category/releases.html),
    from where you can access the latest LTS kernel releases and their support timelines.
    You can also refer to this link, [https://patchwork.kernel.org/](https://patchwork.kernel.org/),
    from where you can follow kernel patch submissions on a subsystem basis.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些链接可以随时保留，以便跟踪Linux内核发布。第一个是[https://www.kernel.org/](https://www.kernel.org/)，您可以从这里下载内核存档，然后是[https://www.kernel.org/category/releases.html](https://www.kernel.org/category/releases.html)，您可以访问最新的LTS内核发布及其支持时间表。您还可以参考此链接[https://patchwork.kernel.org/](https://patchwork.kernel.org/)，从这里您可以按子系统基础跟踪内核补丁提交。
- en: Now that we are familiar with the Linux kernel release model, we can delve into
    some development tips and best practices, which helps to consolidate and leverage
    other kernel developer experiences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了Linux内核发布模型，我们可以深入一些开发提示和最佳实践，这有助于巩固和利用其他内核开发人员的经验。
- en: Linux kernel development tips
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核开发提示
- en: The best Linux kernel development practices are inspired by existing kernel
    code. This way, you could certainly learn good practices. That said, we will not
    reinvent the wheel. We will focus on what is necessary for this chapter, that
    is, debugging. The most frequently used debugging method involves logging and
    printing. In order to leverage this time-tested debugging technique, the Linux
    kernel provides suitable logging APIs and exposes a kernel message buffer to store
    the logs. Though it may seem obvious, we will focus on the kernel logging APIs
    and learn how to manage the message buffer, either from within the kernel code
    or from user space.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的Linux内核开发实践是受现有内核代码的启发。这样，您肯定可以学到良好的实践。也就是说，我们不会重复造轮子。我们将专注于本章所需的内容，即调试。最常用的调试方法涉及日志记录和打印。为了利用这种经过时间考验的调试技术，Linux内核提供了适当的日志记录API，并公开了内核消息缓冲区以存储日志。虽然这似乎很明显，我们将专注于内核日志记录API，并学习如何管理消息缓冲区，无论是从内核代码内部还是从用户空间。
- en: Message printing
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息打印
- en: Message printing and logging are inherent to development, irrespective of whether
    we are in kernel space or user space. In a kernel, the `printk()` function has
    long since been the de facto kernel message printing function. It is similar to
    `printf()` in the C library, but with the concept of log levels.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 消息打印和记录是开发的固有部分，无论我们是在内核空间还是用户空间。在内核中，`printk()`函数长期以来一直是事实上的内核消息打印函数。它类似于C库中的`printf()`，但具有日志级别的概念。
- en: 'If you look at an example of actual driver code, you''ll notice it is used
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看实际驱动程序代码的示例，您会注意到它的用法如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<LOG_LEVEL>` is one of the eight different log levels defined in `include/linux/kern_levels.h`
    and specifies the severity of the error message. You should also note that there
    is no comma between the log level and the format string (as the preprocessor concatenates
    both strings).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<LOG_LEVEL>`是`include/linux/kern_levels.h`中定义的八个不同日志级别之一，并指定错误消息的严重程度。您还应该注意，日志级别和格式字符串之间没有逗号(因为预处理器连接了这两个字符串)。
- en: Kernel log levels
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核日志级别
- en: 'The Linux kernel uses the concept of levels to determine how critical the message
    is. There are eight of them, each defined as a string, and they are described
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用级别的概念来确定消息的严重程度。共有八个级别，每个级别都定义为一个字符串，它们的描述如下：
- en: '`KERN_EMERG`, defined as `"0"`. It is to be used for emergency messages, meaning
    the system is about to crash or is unstable (unusable).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_EMERG`，定义为`“0”`。它用于紧急消息，意味着系统即将崩溃或不稳定（无法使用）。'
- en: '`KERN_ALERT`, defined as `"1"`, meaning that something bad happened and action
    must be taken immediately.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_ALERT`，定义为`“1”`，意味着发生了严重的事情，必须立即采取行动。'
- en: '`KERN_CRIT`, defined as `"2"`, meaning that a critical condition occurred,
    such as a serious hardware/software failure.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_CRIT`，定义为`“2”`，意味着发生了严重的条件，例如严重的硬件/软件故障。'
- en: '`KERN_ERR`, defined as `"3"` and used during an error condition, often used
    by drivers to indicate difficulties with the hardware or a failure to interact
    with a subsystem.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_ERR`，定义为`“3”`，在错误情况下使用，通常由驱动程序用于指示与硬件的困难或与子系统的交互失败。'
- en: '`KERN_WARNING`, defined as `"4"` and used as a warning, meaning nothing serious
    by itself, but may indicate problems.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_WARNING`，定义为`“4”`，用作警告，本身并不严重，但可能表示问题。'
- en: '`KERN_NOTICE`, defined as `"5"`, meaning nothing serious, but notable nevertheless.
    This is often used to report security events.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_NOTICE`，定义为`“5”`，意味着没有严重问题，但仍然值得注意。这经常用于报告安全事件。'
- en: '`KERN_INFO`, defined as `"6"`, used for informational messages, for example,
    startup information at driver initialization.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_INFO`，定义为`“6”`，用于信息消息，例如驱动程序初始化时的启动信息。'
- en: '`KERN_DEBUG`, defined as `"7"`, used for debugging purposes, and active only
    if the `DEBUG` kernel option is enabled. Otherwise, its content is simply ignored.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERN_DEBUG`，定义为`“7”`，用于调试目的，仅在启用`DEBUG`内核选项时才有效。否则，它的内容将被简单地忽略。'
- en: If you don't specify a log level in your message, it defaults to `DEFAULT_MESSAGE_LOGLEVEL`
    (usually `"4"` = `KERN_WARNING`), which can be set via the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL`
    kernel configuration option.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在消息中未指定日志级别，则默认为`DEFAULT_MESSAGE_LOGLEVEL`（通常为`“4”` = `KERN_WARNING`），可以通过`CONFIG_DEFAULT_MESSAGE_LOGLEVEL`内核配置选项进行设置。
- en: 'That said, for new drivers, you are encouraged to use more convenient printing
    APIs, which embed the log level in their names. Those printing helpers are `pr_emerg`,
    `pr_alert`, `pr_crit`, `pr_err`, `pr_warning`, `pr_warn`, `pr_notice`, `pr_info`,
    `pr_debug`, or `pr_dbg`. Besides being more concise than the equivalent `printk()`
    calls, they can use a common definition for the format string through the `pr_fmt()`
    macro; for instance, defining this at the top of a source file (before any `#include`
    directive):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于新的驱动程序，建议您使用更方便的打印API，这些API在其名称中嵌入了日志级别。这些打印助手是`pr_emerg`，`pr_alert`，`pr_crit`，`pr_err`，`pr_warning`，`pr_warn`，`pr_notice`，`pr_info`，`pr_debug`或`pr_dbg`。除了比等效的`printk()`调用更简洁之外，它们还可以通过`pr_fmt()`宏使用格式字符串的通用定义；例如，在源文件的顶部（在任何`#include`指令之前）定义这个：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would prefix every `pr_*()` message in that file with the module and function
    name that originated the message. `pr_devel` and `pr_debug` are replaced with
    `printk(KERN_DEBUG …)` if the kernel was compiled with `DEBUG`, otherwise they
    are replaced with an empty statement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在该文件中的每个`pr_*()`消息前缀模块和生成消息的函数名称。如果内核是使用`DEBUG`编译的，则`pr_devel`和`pr_debug`将被替换为`printk(KERN_DEBUG
    …)`，否则它们将被替换为空语句。
- en: 'The `pr_*()` family macros are to be used in core code. For device drivers,
    you should use the device-related helpers, which also accept the concerned device
    structure as a parameter. They also print the name of the relevant device in standard
    form, ensuring that it''s always possible to associate a message with the device
    that generated it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`pr_*()`系列宏应该在核心代码中使用。对于设备驱动程序，您应该使用与设备相关的辅助程序，这些辅助程序还接受相关设备结构作为参数。它们还以标准形式打印相关设备的名称，确保始终可以将消息与生成它的设备关联起来：'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While the concept of log levels is used by the kernel to determine the importance
    of a message, it is also used to decide whether this message should be presented
    to the user immediately, by printing it to the current console (where the console
    could also be a serial line or even a printer, not an `xterm`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志级别的概念被内核用来确定消息的重要性，但它也用于决定是否应立即将此消息呈现给用户，通过将其打印到当前控制台（其中控制台也可以是串行线或甚至打印机，而不是`xterm`）。
- en: In order to decide, the kernel compares the log level of the message with the
    `console_loglevel` kernel variable, and if the message log level importance is
    higher (that is, a lower value) than `console_loglevel`, the message will be printed
    to the current console. Since the default kernel log level is usually `"4"`, this
    is the reason why you don't see `pr_info()` or `pr_notice()` or even `pr_warn()`
    messages on the console, as they have higher or equal values (which means lower
    priority) than the default one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定，内核将消息的日志级别与`console_loglevel`内核变量进行比较，如果消息的日志级别重要性更高（即较低的值）比`console_loglevel`，则消息将被打印到当前控制台。由于默认内核日志级别通常为`“4”`，这就是为什么您在控制台上看不到`pr_info()`或`pr_notice()`甚至`pr_warn()`消息的原因，因为它们具有更高或相等的值（这意味着优先级更低）比默认值。
- en: 'To determine the current `console_loglevel` on your system, you can simply
    type the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定系统上的当前`console_loglevel`，您只需输入以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first integer (`4`) is the current console log level, the second number
    (`4`) is the default one, the third number (`1`) is the minimum console log level
    that can be set, and the fourth number (`7`) is the boot-time default console
    log level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个整数（`4`）是当前控制台日志级别，第二个数字（`4`）是默认值，第三个数字（`1`）是可以设置的最小控制台日志级别，第四个数字（`7`）是启动时的默认控制台日志级别。
- en: 'To change your current `console_loglevel`, simply write to the same file, that
    is, `/proc/sys/kernel/printk`. Hence, in order to get all messages printed to
    the console, perform the following simple command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改当前的`console_loglevel`，只需写入同一文件，即`/proc/sys/kernel/printk`。因此，为了将所有消息打印到控制台，执行以下简单命令：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Every kernel message will appear on your console. You''ll then have the following
    content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每条内核消息都会出现在您的控制台上。然后您将看到以下内容：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another way to change the console log level is to use `dmesg` with the `-n`
    parameter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 改变控制台日志级别的另一种方法是使用带有`-n`参数的`dmesg`：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the preceding command, `console_loglevel` is set to print `KERN_WARNING`
    (`4`) or more severe messages. You can also specify the `console_loglevel` at
    boot time using the `loglevel` boot parameter (refer to `Documentation/kernel-parameters.txt`
    for more details).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述命令，`console_loglevel`被设置为打印`KERN_WARNING`（`4`）或更严重的消息。您还可以在引导时使用`loglevel`引导参数指定`console_loglevel`（有关更多详细信息，请参阅`Documentation/kernel-parameters.txt`）。
- en: Important note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'There are also `KERN_CONT` and `pr_cont`, which are sort of special since they
    do not specify a level of urgency, but rather indicate a continued message. They
    should only be used by core/arch code during early bootup (a continued line is
    not SMP-safe otherwise). This can be useful when part of a message line to be
    printed depends on the result of a computation, as in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`KERN_CONT`和`pr_cont`，它们有点特殊，因为它们不指定紧急级别，而是指示继续的消息。它们只应该在早期引导期间由核心/架构代码使用（否则，继续的行不是SMP安全的）。当要打印的消息行的一部分取决于计算结果时，这可能是有用的，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should keep in mind that only the final print statement has the trailing
    `\n` character.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，只有最终的打印语句才有尾随的`\n`字符。
- en: Kernel log buffer
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核日志缓冲区
- en: Whether they are immediately printed on the console or not, each kernel message
    is logged in a buffer. This kernel message buffer is a fixed-size circular buffer,
    which means that if the buffer fills up, it wraps around and you may lose a message.
    Thus, increasing the buffer size could be helpful. In order to change the kernel
    message buffer size, you can play with the `LOG_BUF_SHIFT` option, the value of
    which is used to left-shift by 1 in order to obtain the final size, the kernel
    log buffer size (for example, `16` => `1<<16` => `64KB`, `17` => `1 << 17` =>
    `128KB`). That said, it is a static size defined at compile time. This size can
    also be defined through kernel boot parameters, by using the `log_buf_len` parameter,
    in other words, `log_buf_len=1M` (accept only power of 2 values).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们是否立即在控制台上打印，每个内核消息都会被记录在一个缓冲区中。这个内核消息缓冲区是一个固定大小的循环缓冲区，这意味着如果缓冲区填满，它会环绕并且您可能会丢失一条消息。因此，增加缓冲区大小可能会有所帮助。为了改变内核消息缓冲区大小，您可以调整`LOG_BUF_SHIFT`选项，其值用于左移1以获得最终大小，即内核日志缓冲区大小（例如，`16`
    => `1<<16` => `64KB`，`17` => `1 << 17` => `128KB`）。也就是说，这是一个在编译时定义的静态大小。这个大小也可以通过内核引导参数定义，通过使用`log_buf_len`参数，换句话说，`log_buf_len=1M`（只接受2的幂值）。
- en: Adding timing information
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加时间信息
- en: 'Sometimes, it is useful to add timing information to the printed messages,
    so you can see when a particular event occurred. The kernel includes a feature
    for doing this, called `printk times`, enabled through the `CONFIG_PRINTK_TIME`
    option. This option is found on the **Kernel Hacking** menu when configuring the
    kernel. Once enabled, this timing information prefixes each log message as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，向打印的消息添加时间信息是有用的，这样您就可以看到特定事件发生的时间。内核包括一个用于执行此操作的功能，称为`printk times`，通过`CONFIG_PRINTK_TIME`选项启用。在配置内核时，此选项可以在**内核调试**菜单中找到。一旦启用，此时间信息将作为每条日志消息的前缀。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The timestamps that are inserted into the kernel message output consist of seconds
    and microseconds (`seconds.microseconds` actually) as absolute values from the
    start of machine operation (or from the start of kernel timekeeping), which corresponds
    to the time when the bootloader passes control to the kernel (when you see something
    like `[ 0.000000] Booting Linux on physical CPU 0x0` on the console).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内核消息输出中插入的时间戳由秒和微秒（实际上是`秒.微秒`）组成，作为从机器操作开始（或从内核时间跟踪开始）的绝对值，对应于引导加载程序将控制权传递给内核时的时间（当您在控制台上看到类似`[
    0.000000] Booting Linux on physical CPU 0x0`的内容）。
- en: 'Printk times can be controlled at runtime by writing to `/sys/module/printk/parameters/time`
    in order to enable and disable `printk` timestamps. The following are examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过写入`/sys/module/printk/parameters/time`来在运行时控制`printk`时间戳，以启用和禁用`printk`时间戳。以下是示例：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It does not control whether the timestamp is logged. It only controls whether
    it is printed while the kernel message buffer is being dumped, at boot time, or
    while using `dmesg`. This may be an area for boot-time optimization. If disabled,
    it would take less time for logs to be printed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它不控制时间戳是否被记录。它只控制在内核消息缓冲区被转储时、在启动时或在使用`dmesg`时是否打印。这可能是启动时优化的一个领域。如果禁用，日志打印所需的时间将更少。
- en: We are now familiar with kernel printing APIs and their log buffer. We have
    seen how to tweak the message buffer, and add or remove information according
    to requirements. Those skills can be used for debugging by printing. However,
    other debugging and tracing tools are shipped in the Linux kernel, and the following
    section will introduce some of them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在熟悉了内核打印API及其日志缓冲区。我们已经看到了如何调整消息缓冲区，并根据需求添加或删除信息。这些技能可以用于通过打印进行调试。然而，Linux内核中还提供了其他调试和跟踪工具，下一节将介绍其中一些。
- en: Linux kernel tracing and performance analysis
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核跟踪和性能分析
- en: Though debugging by printing covers most of the debugging needs, there are situations
    where we need to monitor the Linux kernel at runtime to track strange behavior,
    including latencies, CPU hogging, scheduling issues, and so on. In the Linux world,
    the most useful tool for achieving this is part of the kernel itself. The most
    important is `ftrace`, which is a Linux kernel internal tracing tool, and is the
    main topic of this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过打印进行调试可以满足大部分调试需求，但有时我们需要在运行时监视Linux内核以跟踪奇怪的行为，包括延迟、CPU占用、调度问题等。在Linux世界中，实现这一目标最有用的工具是内核本身的一部分。最重要的是`ftrace`，它是Linux内核内部跟踪工具，也是本节的主要内容。
- en: Using Ftrace to instrument the code
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ftrace来对代码进行仪器化
- en: '**Function Trace**, in short **Ftrace**, does much more than what its name
    says. For example, it can be used to measure the time it takes to process interrupts,
    to track time-consuming functions, calculate the time to activate high-priority
    tasks, to track context switches, and much more.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 功能跟踪，简称Ftrace，不仅仅是其名称所说的那样。例如，它可以用来测量处理中断所需的时间，跟踪耗时的函数，计算激活高优先级任务所需的时间，跟踪上下文切换等等。
- en: Developed by *Steven Rostedt*, Ftrace has been included in the kernel since
    version 2.6.27 in 2008\. This is the framework that provides a debugging ring
    buffer for recording data. This data is gathered by the kernel's integrated tracing
    programs. Ftrace works on top of the `debugfs` filesystem and is, most of the
    time, mounted in its own directory called `tracing` when it is enabled. In most
    modern Linux distributions, it is mounted by default in the `/sys/kernel/debug/`
    directory (this is only available to the root user), meaning that you can leverage
    Ftrace from within `/sys/kernel/debug/tracing/`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由*Steven Rostedt*开发，Ftrace自2008年2.6.27版内核开始已经包含在内核中。这是一个提供用于记录数据的调试环形缓冲区的框架。这些数据是由内核集成的跟踪程序收集的。Ftrace在`debugfs`文件系统之上工作，并且在大多数情况下，在启用时会被挂载在自己的名为`tracing`的目录中。在大多数现代Linux发行版中，默认情况下会在`/sys/kernel/debug/`目录中挂载（这仅对root用户可用），这意味着您可以在`/sys/kernel/debug/tracing/`中利用Ftrace。
- en: 'The following are the kernel options to be enabled in order to support Ftrace
    on your system:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要在系统上启用以支持Ftrace的内核选项：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding options depend on the architecture supporting tracing features
    by having the `CONFIG_HAVE_FUNCTION_TRACER`, `CONFIG_HAVE_DYNAMIC_FTRACE`, and
    `CONFIG_HAVE_FUNCTION_GRAPH_TRACER` options enabled.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的选项取决于支持跟踪功能的架构，需要启用`CONFIG_HAVE_FUNCTION_TRACER`、`CONFIG_HAVE_DYNAMIC_FTRACE`和`CONFIG_HAVE_FUNCTION_GRAPH_TRACER`选项。
- en: 'To mount the `tracefs` directory, you can add the following line to your `/etc/fstab`
    file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载`tracefs`目录，您可以将以下行添加到您的`/etc/fstab`文件中：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you can mount it at runtime with the help of the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用以下命令在运行时挂载它：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The contents of the directory should look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目录的内容应该如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We won''t describe all of these files and subdirectories, as this has already
    been covered in the official documentation. Instead, we''ll just briefly describe
    the files relevant to our context:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会描述所有这些文件和子目录，因为官方文档已经涵盖了这些内容。相反，我们只会简要描述与我们上下文相关的文件：
- en: '`available_tracers`: Available tracing programs.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available_tracers`：可用的跟踪程序。'
- en: '`tracing_cpumask`: This allows selected CPUs to be traced. The mask should
    be specified in a hex string format. For example, to trace only core `0`, you
    should include a `1` in this file. To trace core `1`, you should include a `2`
    in there. For core `3`, the number `8` should be included.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracing_cpumask`：允许对选定的CPU进行跟踪。掩码应该以十六进制字符串格式指定。例如，要跟踪只有核心`0`，你应该在这个文件中包含`1`。要跟踪核心`1`，你应该在其中包含`2`。对于核心`3`，应该包含数字`8`。'
- en: '`current_tracer`: The tracing program that is currently running.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_tracer`：当前正在运行的跟踪程序。'
- en: '`tracing_on`: The system file responsible for enabling or disabling data writing
    to the ring buffer (to enable this, the number `1` has to be added to the file;
    to disable it, the number `0` is added).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracing_on`：负责启用或禁用数据写入环形缓冲区的系统文件（要启用此功能，必须在文件中添加数字`1`；要禁用它，添加数字`0`）。'
- en: '`trace`: The file where tracing data is saved in a human-readable format.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace`：保存跟踪数据的文件，以人类可读的格式。'
- en: Now that we have introduced Ftrace and described its functions, we can delve
    into its usage and learn how useful it can be for tracing and debugging purposes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Ftrace并描述了它的功能，我们可以深入了解其用法，并了解它在跟踪和调试目的中有多么有用。
- en: Available tracers
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用的跟踪器
- en: 'We can view the list of available tracers with the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看可用跟踪器的列表：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a quick look at the features of each tracer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下每个跟踪器的特点：
- en: '`function`: A function call tracer without arguments.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`：无参数的函数调用跟踪器。'
- en: '`function_graph`: A function call tracer with subcalls.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function_graph`：带有子调用的函数调用跟踪器。'
- en: '`blk`: A call and event tracer related to block device I/O operations (this
    is what `blktrace` uses).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blk`：与块设备I/O操作相关的调用和事件跟踪器（这是`blktrace`使用的）。'
- en: '`mmiotrace`: A memory-mapped I/O operation tracer. It traces all the calls
    that a module makes to the hardware. It is enabled with `CONFIG_ MMIOTRACE`, which
    depends on `CONFIG_HAVE_MMIOTRACE_SUPPORT`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmiotrace`：内存映射I/O操作跟踪器。它跟踪模块对硬件的所有调用。它通过`CONFIG_MMIOTRACE`启用，这取决于`CONFIG_HAVE_MMIOTRACE_SUPPORT`。'
- en: '`irqsoff`: Traces the areas that disable interrupts and saves the trace with
    the longest maximum latency. This tracer depends on `CONFIG_IRQSOFF_TRACER`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqsoff`：跟踪禁用中断的区域，并保存具有最长最大延迟的跟踪。此跟踪器取决于`CONFIG_IRQSOFF_TRACER`。'
- en: '`preemptoff`: Depends on `CONFIG_PREEMPT_TRACER`. It is similar to `irqsoff`,
    but traces and records the amount of time for which preemption is disabled.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemptoff`：取决于`CONFIG_PREEMPT_TRACER`。类似于`irqsoff`，但跟踪和记录禁用抢占的时间。'
- en: '`preemtirqsoff`: Similar to `irqsoff` and `preemptoff`, but it traces and records
    the largest time for which irqs and/or preemption is disabled.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemtirqsoff`：类似于`irqsoff`和`preemptoff`，但跟踪和记录中断和/或抢占被禁用的最长时间。'
- en: '`wakeup` and `wakeup_rt`, enabled by `CONFIG_SCHED_TRACER`: The former traces
    and records the maximum latency that it takes for the highest priority task to
    get scheduled after it has been woken up, while the latter traces and records
    the maximum latency that it takes for just `wakeup` tracer does).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup`和`wakeup_rt`，由`CONFIG_SCHED_TRACER`启用：前者跟踪和记录唤醒后最高优先级任务被调度所需的最大延迟，而后者跟踪和记录唤醒后仅`wakeup`跟踪器所需的最大延迟。'
- en: '`nop`: The simplest tracer, which, as the name suggests, doesn''t do anything.
    The `nop` tracer simply displays the output of `trace_printk()` calls.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nop`：最简单的跟踪器，顾名思义，什么也不做。`nop`跟踪器只是显示`trace_printk()`调用的输出。'
- en: '`irqsoff`, `preemptoff`, and `preemtirqsoff` are the so-called latency tracers.
    They measure how long interrupts are disabled for, how long preemption is disabled
    for, and how long interrupts and/or preemption are disabled for. Wakeup latency
    tracers measure how long it takes a process to run after it has been awoken for
    either all tasks or just RT tasks.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`irqsoff`，`preemptoff`和`preemtirqsoff`是所谓的延迟跟踪器。它们测量中断被禁用的时间，抢占被禁用的时间，以及中断和/或抢占被禁用的时间。唤醒延迟跟踪器测量进程在被唤醒后运行所需的时间，可以是所有任务或仅实时任务。'
- en: The function tracer
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数跟踪器
- en: 'We''ll begin our introduction to Ftrace with the function tracer. Let''s look
    at a test script:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从函数跟踪器开始介绍Ftrace。让我们看一个测试脚本：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script is fairly straightforward, but there are a few things worth noting.
    We enable the current tracer by writing its name to the `current_tracer` file.
    Next, we write a `1` to `tracing_on`, which enables the ring buffer. The syntax
    requires a space between `1` and the `>` symbol; `echo1> tracing_on` will not
    work. One line later, we disable it (if `0` is written to `tracing_on`, the buffer
    won't clear and Ftrace won't be disabled).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本非常简单，但有一些值得注意的事情。我们通过将其名称写入`current_tracer`文件来启用当前跟踪器。接下来，我们将`1`写入`tracing_on`，这将启用环形缓冲区。语法要求`1`和`>`符号之间有一个空格；`echo1>
    tracing_on`将无法工作。一行之后，我们将其禁用（如果将`0`写入`tracing_on`，缓冲区将不会清除，Ftrace也不会被禁用）。
- en: 'Why would we do this? Between the two `echo` commands, we see the `sleep 1`
    command. We enable the buffer, run this command, and then disable it. This lets
    the tracer include information relating to all of the system calls that occur
    while the command runs. In the last line of the script, we give the command to
    display tracing data in the console. Once the script has run, we''ll see the following
    printout (this is just a small fragment):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做？在两个`echo`命令之间，我们看到`sleep 1`命令。我们启用缓冲区，运行此命令，然后禁用它。这样可以让跟踪器包含与命令运行时发生的所有系统调用相关的信息。在脚本的最后一行，我们给出了在控制台中显示跟踪数据的命令。脚本运行后，我们将看到以下打印输出（这只是一个小片段）：
- en: '![Figure 14.1 – Ftrace function tracer snapshot'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 - Ftrace函数跟踪器快照'
- en: '](img/Figure_14.1_B10985.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B10985.jpg)'
- en: Figure 14.1 – Ftrace function tracer snapshot
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - Ftrace函数跟踪器快照
- en: 'The printout starts with information pertaining to the number of entries in
    the buffer and the total number of entries written. The difference between these
    two numbers is the number of events lost while filling the buffer. Then, there''s
    a list of functions that includes the following information:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打印开始时包含有关缓冲区中条目数量和已写入的总条目数量的信息。这两个数字之间的差异是填充缓冲区时丢失的事件数量。然后，列出了包括以下信息的函数列表：
- en: The process name (`TASK`).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程名称（`TASK`）。
- en: The process identifier (`PID`).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程标识符（`PID`）。
- en: The CPU the process runs on (`CPU#`).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程运行的CPU（`CPU＃`）。
- en: The function start time (`TIMESTAMP`). This timestamp is the time since boot.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数开始时间（`TIMESTAMP`）。此时间戳是自启动以来的时间。
- en: The name of the function being traced (`FUNCTION`) and the parent function that
    was called following the `<-` symbol. For example, in the first line of our output,
    the `irq_may_run` function was called by `handle_fasteoi_irq`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在跟踪的函数的名称（`FUNCTION`）和在`<-`符号后调用的父函数。例如，在我们输出的第一行中，`irq_may_run`函数是由`handle_fasteoi_irq`调用的。
- en: Now that we are familiar with the function tracer and its specificities, we
    can learn about the next tracer, which is more feature-rich and provides much
    more tracing information, such as the call graph.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了函数跟踪器及其特点，我们可以了解下一个跟踪器，它更加功能丰富，提供了更多的跟踪信息，例如调用图。
- en: The function_graph tracer
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`function_graph`跟踪器'
- en: 'The `function_graph` tracer works just like a function, but in a more detailed
    manner: the entry and exit point is shown for each function. With this tracer,
    we can trace functions with subcalls and measure the execution time of each function.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`function_graph`跟踪器的工作方式类似于函数，但更详细：显示每个函数的入口和出口点。使用此跟踪器，我们可以跟踪具有子调用的函数，并测量每个函数的执行时间。'
- en: 'Let''s edit the script from our previous example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑我们先前示例的脚本：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running this script, we get the following printout:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，我们得到以下打印输出：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this graph, `DURATION` shows the time spent running a function. Pay careful
    attention to the points marked by the `+` and `!` symbols. The plus sign (`+`)
    means the function took more than 10 microseconds, while the exclamation point
    (`!`) means it took more than 100 microseconds. Under `FUNCTION_CALLS`, we find
    information pertaining to each function call. The symbols used to show the initiation
    and completion of each function are the same as in the C programming language:
    bracers (`{}`) demarcate functions, one at the start and one at the end; leaf
    functions that don''t call any other function are marked with a semicolon (`;`).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，`DURATION`显示运行函数所花费的时间。请特别注意标有`+`和`!`符号的点。加号（`+`）表示函数花费的时间超过10微秒，而感叹号（`!`）表示函数花费的时间超过100微秒。在`FUNCTION_CALLS`下，我们找到与每个函数调用相关的信息。用于显示每个函数启动和完成的符号与C编程语言中相同：大括号（`{}`）标记函数，一个在开始，一个在结束；不调用任何其他函数的叶函数用分号（`;`）标记。
- en: 'Ftrace also allows tracing to be restricted just to functions that exceed a
    certain amount of time, using the `tracing_thresh` option. The time threshold
    at which the functions should be recorded must be written in that file in microsecond
    units. This can be used to find routines that are taking a long time in the kernel.
    It may be interesting to use this at kernel startup, to help optimize boot-up
    time. To set the threshold at startup, you can set it in the kernel command line
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace还允许仅对超过一定时间的函数进行跟踪，使用`tracing_thresh`选项。应在微秒单位中将应记录函数的时间阈值写入该文件。这可用于查找在内核中花费很长时间的例程。可能有趣的是在内核启动时使用此功能，以帮助优化启动时间。要在启动时设置阈值，可以在内核命令行中设置如下：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This traces all functions taking longer than 200 microseconds (0.2 ms). You
    can use any duration threshold you want.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跟踪所有执行时间超过200微秒（0.2毫秒）的函数。您可以使用任何持续时间阈值。
- en: At runtime, you can simply execute `echo 200 > tracing_thresh`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，您可以简单地执行`echo 200 > tracing_thresh`。
- en: Function filters
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数过滤器
- en: 'Pick and choose what functions to trace. It goes without saying that fewer
    functions to trace equals less overhead. The Ftrace printout can be big, and finding
    exactly what you''re looking for can be extremely difficult. However, we can use
    filters to simplify our search: the printout will only display information about
    the functions we''re interested in. To do this, we just have to write the name
    of our function in the `set_ftrace_filter` file, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 挑选要跟踪的函数。不言而喻，要跟踪的函数越少，开销就越小。Ftrace的输出可能很大，要找到自己想要的内容可能会非常困难。然而，我们可以使用过滤器来简化搜索：输出将只显示我们感兴趣的函数的信息。为此，我们只需在`set_ftrace_filter`文件中写入我们函数的名称，如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To disable the filter, we add an empty line to this file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用过滤器，我们在这个文件中添加一个空行：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result is the opposite: the printout will give us information about every
    function except `kfree()`. Another useful option is `set_ftrace_pid`. This tool
    is for tracing functions that can be called on behalf of a particular process.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正好相反：输出将给出有关除`kfree()`之外的每个函数的信息。另一个有用的选项是`set_ftrace_pid`。这个工具用于跟踪可以代表特定进程调用的函数。
- en: Ftrace has many more filtering options. For a more detailed look at these, you
    can read the official documentation available at [https://www.kernel.org/doc/Documentation/trace/ftrace.txt](https://www.kernel.org/doc/Documentation/trace/ftrace.txt).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace还有许多其他过滤选项。要更详细地了解这些选项，您可以阅读[https://www.kernel.org/doc/Documentation/trace/ftrace.txt](https://www.kernel.org/doc/Documentation/trace/ftrace.txt)上提供的官方文档。
- en: Tracing events
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪事件
- en: Before introducing trace events, let's talk about **tracepoints**. Tracepoints
    are special code inserts that trigger system events. Tracepoints may be dynamic
    (meaning they have several checks attached to them) or static (no checks attached).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍跟踪事件之前，让我们先谈谈**tracepoints**。Tracepoints是触发系统事件的特殊代码插入。Tracepoints可以是动态的（意味着它们有几个附加的检查），也可以是静态的（没有附加检查）。
- en: 'Static tracepoints do not affect the system in any way; they just add a few
    bytes for the function call at the end of the instrumented function and add a
    data structure in a separate section. Dynamic tracepoints call a trace function
    when the relevant code fragment is executed. Tracing data is written to the ring
    buffer. Tracepoints can be included anywhere in code. In fact, they can already
    be found in a lot of kernel functions. Let''s look at the `kmem_cache_free` function
    excerpt from `mm/slab.c`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 静态tracepoints不会以任何方式影响系统；它们只会在被检测的函数末尾添加几个字节的函数调用，并在一个单独的部分中添加一个数据结构。动态tracepoints在相关代码片段执行时调用跟踪函数。跟踪数据被写入环形缓冲区。Tracepoints可以包含在代码的任何位置。实际上，它们已经可以在许多内核函数中找到。让我们看一下`mm/slab.c`中`kmem_cache_free`函数的摘录：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`kmem_cache_free` is then itself a tracepoint. We can find countless more examples
    just by looking at the source code of other kernel functions.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`kmem_cache_free`本身就是一个tracepoint。我们可以通过查看其他内核函数的源代码找到无数更多的例子。'
- en: The Linux kernel has a special API for working with tracepoints from the user
    space. In the `/sys/kernel/debug/tracing` directory, there is an `events` directory
    where system events are saved. These are available for tracing. System events
    in this context can be understood as the tracepoints included in the kernel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核有一个专门的API用于从用户空间处理tracepoints。在`/sys/kernel/debug/tracing`目录中，有一个`events`目录，其中保存了系统事件。这些事件可供跟踪。在这个上下文中，系统事件可以理解为内核中包含的tracepoints。
- en: 'A list of these can be viewed by running the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，可以查看这些列表：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A long list will be printed out in the console with the `<subsystem>:<tracepoint>`
    pattern. This is slightly inconvenient. We can print out a more structured list
    by using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将打印出一个长列表，格式为`<subsystem>:<tracepoint>`。这有点不方便。我们可以通过使用以下命令打印出更结构化的列表：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All possible events are combined in the subdirectory by subsystem. Before we
    can start tracing events, we will make sure we've enabled writing to the ring
    buffer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的事件都组合在子目录中。在我们开始跟踪事件之前，我们将确保已经启用了对环形缓冲区的写入。
- en: 'In [*Chapter 1*](B10985_01_ePub_AM.xhtml#_idTextAnchor015), *Linux Kernel Concepts
    for Embedded Developers*, we introduced *hrtimers*. By listing the content of
    `/sys/kernel/debug/tracing/events/timer`, we will have timer-related tracepoints,
    including `hrtimer`-related ones, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B10985_01_ePub_AM.xhtml#_idTextAnchor015)中，*嵌入式开发人员的Linux内核概念*，我们介绍了*hrtimers*。通过列出`/sys/kernel/debug/tracing/events/timer`的内容，我们将得到与定时器相关的tracepoints，包括与`hrtimer`相关的内容，如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s now trace the access to `hrtimer`-related kernel functions. For our
    tracer, we''ll use `nop` because `function` and `function_graph` record too much
    information, including event information that we''re just not interested in. The
    following is the script we will use:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们跟踪对`hrtimer`相关内核函数的访问。对于我们的跟踪器，我们将使用`nop`，因为`function`和`function_graph`记录了太多信息，包括我们不感兴趣的事件信息。以下是我们将使用的脚本：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We first disable tracing in case it was already running. Then we clear the
    ring buffer data before setting the current tracer to `nop`. Next, we enable timer-related
    tracepoints, or should we say, we enable timer event tracing. Finally, we enable
    tracing and dump the ring buffer content, which looks like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们禁用跟踪（以防已经在运行）。然后清除环形缓冲区数据，然后将当前tracer设置为`nop`。接下来，我们启用与定时器相关的tracepoints，或者说，我们启用定时器事件跟踪。最后，我们启用跟踪并转储环形缓冲区内容，内容如下：
- en: '![Figure 14.2 – Ftrace event tracing with the nop tracer snapshot'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 - 使用nop tracer快照进行Ftrace事件跟踪'
- en: '](img/Figure_14.2_B10985.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.2_B10985.jpg)'
- en: Figure 14.2 – Ftrace event tracing with the nop tracer snapshot
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - 使用nop tracer快照进行Ftrace事件跟踪
- en: 'At the end of the printout, we''ll find information about `hrtimer` function
    calls (here is a small section). More detailed information about configuring event
    tracing can be found here: [https://www.kernel.org/doc/Documentation/trace/events.txt](https://www.kernel.org/doc/Documentation/trace/events.txt).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印输出的末尾，我们将找到有关`hrtimer`函数调用的信息（这里是一个小节）。有关配置事件跟踪的更详细信息可以在这里找到：[https://www.kernel.org/doc/Documentation/trace/events.txt](https://www.kernel.org/doc/Documentation/trace/events.txt)。
- en: Tracing a specific process with the Ftrace interface
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ftrace接口跟踪特定进程
- en: 'Using Ftrace as is lets you have tracing-enabled kernel tracepoints/functions
    irrespective of the process those functions run on behalf of. To trace just the
    kernel functions executed on behalf of a particular function, you should set the
    pseudo `set_ftrace_pid` variable to the `pgrep`, for example. If the process is
    not already running, you can use a wrapper shell script and the `exec` command
    to execute a command as a known PID, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ftrace可以让您拥有启用跟踪的内核跟踪点/函数，而不管这些函数代表哪个进程运行。要跟踪代表特定函数执行的内核函数，您应该将伪`set_ftrace_pid`变量设置为`pgrep`，例如。如果进程尚未运行，可以使用包装器shell脚本和`exec`命令以已知PID执行命令，如下所示：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, `$$` is the PID of the currently executing process
    (the shell script itself). This is set in the `set_ftrace_pid` variable, and then
    the `function_graph` tracer is enabled, after which this script executes the command
    (specified by the first argument to the script).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`$$`是当前执行进程的PID（即shell脚本本身）。这是在`set_ftrace_pid`变量中设置的，然后启用`function_graph`跟踪器，之后这个脚本执行命令（由脚本的第一个参数指定）。
- en: 'Assuming the script name is `trace_process.sh`, an example of usage could be
    the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设脚本名称为`trace_process.sh`，使用示例可能如下：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we are familiar with tracing events and tracepoints. We are able to track
    and trace specific kernel events or subsystems. While tracing is a must in terms
    of kernel development, there are situations, which, sadly, affect the stability
    of the kernel. Such cases may require off-target analysis, which is addressed
    in debugging, and is discussed in the next section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了跟踪事件和跟踪点。我们能够跟踪特定的内核事件或子系统。虽然在内核开发中跟踪是必须的，但有时会影响内核的稳定性。这种情况可能需要离线分析，这在调试中得到了解决，并在下一节中进行了讨论。
- en: Linux kernel debugging tips
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核调试技巧
- en: Writing the code is not always the hardest aspect of kernel development. Debugging
    is the real bottleneck, even for experienced kernel developers. That said, most
    kernel debugging tools are part of the kernel itself. Sometimes, finding where
    the fault originated is assisted by the kernel via messages called **Oops**. Debugging
    then comes down to analyzing the message.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码并不总是内核开发中最困难的方面。调试才是真正的瓶颈，即使对经验丰富的内核开发人员也是如此。也就是说，大多数内核调试工具都是内核本身的一部分。有时，通过内核消息称为**Oops**来辅助找到故障发生的位置。然后调试就变成了分析消息。
- en: Oops and panic analysis
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oops和紧急情况分析
- en: Oops are messages printed by the Linux kernel when an error or an unhandled
    exception occurs. It tries its best to describe the exception and dumps the callstack
    just before the error or the exception occurs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Oops是Linux内核在发生错误或未处理的异常时打印的消息。它尽力描述异常并在错误或异常发生之前转储调用堆栈。
- en: 'Take the following kernel module, for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内核模块：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding module code, we try to dereference a null pointer in order
    to panic the kernel. Moreover, we use the `__noinline__` attribute in order for
    `create_oops()` not to be inlined, allowing it to appear as a separate function
    during disassembly and in the callstack. This module has been built and tested
    on both the ARM and x86 platforms. Oops messages and content will vary from machine
    to machine:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模块代码中，我们尝试取消引用空指针以使内核发生紧急情况。此外，我们使用`__noinline__`属性，以便`create_oops()`不会被内联，允许它在反汇编和调用堆栈中显示为单独的函数。此模块已在ARM和x86平台上构建和测试。Oops消息和内容将因机器而异：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s have a closer look at the preceding dump to understand some of the important
    bits of information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下上面的转储，以了解一些重要信息：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first line describes the bug and its nature, which in this case states
    that the code tried to dereference a `NULL` pointer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行描述了错误及其性质，本例中指出代码尝试取消引用`NULL`指针：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`create_oops` function, which is located in the `oops` module (which is listed
    in square brackets). The hex numbers indicate that the instruction pointer was
    `24` (`0x18` in hex) bytes into the function, which appears to be `32` (`0x20`
    in hex) bytes long:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_oops`函数位于`oops`模块中（列在方括号中）。十六进制数字表示指令指针位于函数内的`24`（十六进制为`0x18`）字节处，该函数似乎为`32`（十六进制为`0x20`）字节长：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`LR` is the link register, which contains the address to which the program
    counter should be set when it reaches a "return from subroutine" instruction.
    In other words, `LR` holds the address of the function that called the currently
    executing function (the one where `PC` is located). First, this means `my_oops_init`
    is the function that called the executing code. It also means that if the function
    in `PC` had returned, the next line to be executed would be `my_oops_init+0x18`,
    which means the CPU would branch at the `0x18` offset from the start address of
    `my_oops_init`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`LR`是链接寄存器，它包含程序计数器在达到“从子例程返回”指令时应设置的地址。换句话说，`LR`保存调用当前执行函数的函数的地址（`PC`所在的函数）。首先，这意味着`my_oops_init`是调用执行代码的函数。这也意味着如果`PC`中的函数返回，将执行的下一行将是`my_oops_init+0x18`，这意味着CPU将在`my_oops_init`的起始地址偏移`0x18`处分支：'
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding line of code, `pc` and `lr` are the real hexadecimal content
    of `PC` and `LR`, with no symbol name shown. Those addresses can be used with
    the `addr2line` program, which is another tool we can use to find a faulty line.
    This is what we would see in the printout if the kernel was built with the `CONFIG_KALLSYMS`
    option disabled. We can then deduce that the addresses of `create_oops` and `my_oops_init`
    are `0xbf2a8000` and `0xbf045000`, respectively:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`pc`和`lr`是`PC`和`LR`的真实十六进制内容，没有显示符号名称。这些地址可以与`addr2line`程序一起使用，这是另一个我们可以用来找到错误行的工具。这是如果内核是使用`CONFIG_KALLSYMS`选项禁用构建的话，我们在打印输出中会看到的内容。然后我们可以推断`create_oops`和`my_oops_init`的地址分别是`0xbf2a8000`和`0xbf045000`：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**sp** stands for **stack pointer** and holds the current position in the stack,
    while **fp** stands for **frame pointer** and points to the currently active frame
    in the stack. When a function returns, the stack pointer is restored to the frame
    pointer, which is the value of the stack pointer just before the function was
    called. The following example from Wikipedia explains it quite well:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**sp**代表**堆栈指针**，保存堆栈中的当前位置，而**fp**代表**帧指针**，指向堆栈中当前活动的帧。当函数返回时，堆栈指针被恢复到帧指针，即在调用函数之前的堆栈指针的值。维基百科的以下示例解释得很好：'
- en: 'For example, the stack frame of `DrawLine` would have a memory location holding
    the frame pointer value that `DrawSquare` uses. The value is saved upon entry
    to the subroutine and restored upon return:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`DrawLine`的堆栈帧将具有一个内存位置，该位置保存`DrawSquare`使用的帧指针值。该值在进入子例程时保存，并在返回时恢复：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding is the dump of a number of CPU registers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是一些CPU寄存器的转储：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding line shows the process on behalf of which the panic occurred,
    which is `insmod` in this case, and its PID was `20021`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行显示了发生panic的进程，这里是`insmod`，其PID为`20021`。
- en: 'There are also oops where the backtrace is present, a bit like the following,
    which is an excerpt from the oops generated by typing `echo c > /proc/sysrq-trigger`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 也有oops中存在回溯的情况，就像以下这样，这是通过键入`echo c > /proc/sysrq-trigger`生成的oops的摘录：
- en: '![Figure 14.3 – Backtrace excerpt in a kernel oops'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 - 内核oops中的回溯摘录'
- en: '](img/Figure_14.3_B10985.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B10985.jpg)'
- en: Figure 14.3 – Backtrace excerpt in a kernel oops
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 - 内核oops中的回溯摘录
- en: 'The backtrace traces the function call history before the one that generated
    the oops:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯跟踪了生成oops之前的函数调用历史：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Code` is a hex-dump of the section of machine code that was being run at the
    time the oops occurred.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Code`是在oops发生时正在运行的机器代码部分的十六进制转储。'
- en: Trace dump on oops
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: oops上的跟踪转储
- en: When the kernel crashes, it is possible to use `kdump`/`kexec` with the `crash`
    utility in order to examine the state of the system at the point of the crash.
    However, this technique does not let you see what has happened prior to the event
    that caused the crash, which may be a good input for understanding or fixing the
    bug.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核崩溃时，可以使用`kdump`/`kexec`与`crash`实用程序来检查崩溃点的系统状态。但是，这种技术无法让您看到导致崩溃的事件之前发生了什么，这可能是理解或修复错误的良好输入。
- en: Ftrace is shipped with a feature that tries to address this issue. In order
    to enable it, you can either echo a `1` into `/proc/sys/kernel/ftrace_dump_on_oops`
    or enable `ftrace_dump_on_oops` in the kernel boot parameters. Having Ftrace configured
    along with this feature enabled will instruct Ftrace to dump the entire trace
    buffer to the console in ASCII format on oops or panic. Having the console output
    to a serial line makes debugging crashes much easier. This way, you can set everything
    up and just wait for the crash. Once it occurs, you'll see the trace buffer on
    the console. You'll then be able to trace back the events that led up to the crash.
    How far back you can go in tracing events depends on the size of the trace buffer,
    since this is what stores the event history data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace附带了一个试图解决此问题的功能。为了启用它，您可以将`1`回显到`/proc/sys/kernel/ftrace_dump_on_oops`，或者在内核引导参数中启用`ftrace_dump_on_oops`。配置了Ftrace并启用了此功能将指示Ftrace在oops或panic时以ASCII格式将整个跟踪缓冲区转储到控制台。将控制台输出到串行线使得调试崩溃变得更加容易。这样，您可以设置好一切，然后等待崩溃。一旦发生崩溃，您将在控制台上看到跟踪缓冲区。然后，您将能够追溯导致崩溃的事件。您可以追溯多远取决于跟踪缓冲区的大小，因为这是存储事件历史数据的地方。
- en: That said, dumping to the console may take a long time and it is common to shrink
    the trace buffer before putting everything in place, since the default Ftrace
    ring buffer is in excess of 1 megabyte per CPU. You can use `/sys/kernel/debug/tracing/buffer_size_kb`
    in order to reduce the trace buffer size by writing in that file the number of
    kilobytes you want the ring buffer to be. Note that the value is per CPU, and
    not the total size of the ring buffer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，将转储到控制台可能需要很长时间，通常在放置所有内容之前缩小跟踪缓冲区，因为默认的Ftrace环形缓冲区每个CPU超过1兆字节。您可以使用`/sys/kernel/debug/tracing/buffer_size_kb`来通过在该文件中写入所需的环形缓冲区大小（以千字节为单位）来减小跟踪缓冲区的大小。请注意，该值是每个CPU的值，而不是环形缓冲区的总大小。
- en: 'The following is an example of modifying the trace buffer size:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改跟踪缓冲区大小的示例：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding command will shrink the Ftrace ring buffer down to 3 kilobytes
    per CPU (1 kb might be enough; it depends on how far you need to go back prior
    to the crash).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将将Ftrace环形缓冲区缩小到每个CPU的3千字节（1 kb可能足够；这取决于在崩溃之前需要回溯多远）。
- en: Using objdump to identify the faulty code line in the kernel module
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用objdump来识别内核模块中的错误代码行的示例
- en: We can use `objdump` to disassemble the object file and identify the line that
    generated the oops. We use the disassembled code to play with the symbol name
    and offset in order to point to the exact faulty line.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`objdump`来反汇编对象文件并识别生成oops的行。我们使用反汇编代码来调整符号名称和偏移量，以指向确切的错误行。
- en: 'The following line will disassemble the kernel module in the `oops.as` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行将在`oops.as`文件中反汇编内核模块：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The generated output file will have content similar to the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出文件将具有类似以下内容：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Important note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Enabling the debug option while compiling the module would make the debug info
    available in the `.ko` object. In this case, `objdump -S` would interpose the
    source code and assembly for a better view.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译模块时启用调试选项会使调试信息在`.ko`对象中可用。在这种情况下，`objdump -S`会插入源代码和汇编，以便更好地查看。
- en: 'From the oops, we have seen that the PC is at `create_oops+0x18`, which is
    at the `0x18` offset from the address of `create_oops`. This leads us to the `18:
    e5833000 str r3, [r3]` line. In order to understand the line of interest to us,
    let''s describe the line before it, `mov r3, #0`. After this line, we have `r3
    = 0`. Back to our line of interest, for people familiar with ARM assembly language,
    it means writing `r3` to the original address pointed to by `r3` (the C equivalent
    of `[r3]` is `*r3`). Remember, this corresponds to `*(int *)0 = 0` in our code.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '从oops中，我们看到PC位于`create_oops+0x18`，这是在`create_oops`地址的`0x18`偏移处。这将我们带到`18: e5833000
    str r3, [r3]`行。为了理解我们感兴趣的行，让我们描述它之前的行，`mov r3, #0`。在这行之后，我们有`r3 = 0`。回到我们感兴趣的行，对于熟悉ARM汇编语言的人来说，它意味着将`r3`写入到`r3`指向的原始地址（C语言中`[r3]`的等价物是`*r3`）。请记住，这对应于我们代码中的`*(int
    *)0 = 0`。'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced a number of kernel debugging tips, and explained how
    to use Ftrace to trace the code in order to identify strange behavior, such as
    time-consuming functions and irq latencies. We covered the printing of APIs, either
    for core- or device driver-related code. Finally, we learned how to analyze and
    debug kernel oops.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些内核调试技巧，并解释了如何使用Ftrace来跟踪代码，以识别奇怪的行为，比如耗时的函数和中断延迟。我们讨论了API的打印，无论是针对核心代码还是设备驱动程序相关的代码。最后，我们学习了如何分析和调试内核oops。
- en: This chapter marks the end of this book and I hope you have enjoyed the journey
    through this book while reading it as much as I did while writing it. I also hope
    that my best efforts in imparting my knowledge throughout this book will prove
    useful to you.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书的结束，我希望您在阅读本书时和我在写作时一样享受这段旅程。我也希望我在整本书中传授知识的最大努力对您有所帮助。
