["```\nCONFIG_MODULES=y \n```", "```\ninsmod /path/to/mydrv.ko\n\n```", "```\nmodprobe mydrv\n\n```", "```\n#this line is a comment \nuio \niwlwifi \n```", "```\nalias usb:v0403pFF1Cd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0403pFF18d*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0403pDAFFd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0403pDAFEd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0403pDAFDd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0403pDAFCd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio \nalias usb:v0D8Cp0103d*dc*dsc*dp*ic*isc*ip*in* snd_usb_audio \nalias usb:v*p*d*dc*dsc*dp*ic01isc03ip*in* snd_usb_audio \nalias usb:v200Cp100Bd*dc*dsc*dp*ic*isc*ip*in* snd_usb_au \n```", "```\nCONFIG_MODULE_UNLOAD=y \n```", "```\nMODULE_FORCE_UNLOAD=y \n```", "```\nrmmod -f mymodule\n\n```", "```\nmodeprobe -r mymodule\n\n```", "```\nlsmod\n\n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n\nstatic int __init helloworld_init(void) { \n    pr_info(\"Hello world!\\n\"); \n    return 0; \n} \n\nstatic void __exit helloworld_exit(void) { \n    pr_info(\"End of the world\\n\"); \n} \n\nmodule_init(helloworld_init); \nmodule_exit(helloworld_exit); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\n#define __init__section(.init.text) \n#define __exit__section(.exit.text) \n```", "```\nMODULE_INFO(my_field_name, \"What eeasy value\"); \n```", "```\nMODULE_LICENSE (\"GPL\"); \n```", "```\n/* \n * The following license idents are currently accepted as indicating free \n * software modules \n * \n * \"GPL\"                   [GNU Public License v2 or later] \n * \"GPL v2\"                [GNU Public License v2] \n * \"GPL and additional rights\"   [GNU Public License v2 rights and more] \n * \"Dual BSD/GPL\"                [GNU Public License v2 \n *                          or BSD license choice] \n * \"Dual MIT/GPL\"                [GNU Public License v2 \n *                          or MIT license choice] \n * \"Dual MPL/GPL\"                [GNU Public License v2 \n *                          or Mozilla license choice] \n * \n * The following other idents are available \n * \n * \"Proprietary\"                 [Non free products] \n * \n * There are dual licensed components, but when running with Linux it is the \n * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL \n * is a GPL combined work. \n * \n * This exists for several reasons \n * 1\\.    So modinfo can show license info for users wanting to vet their setup \n * is free \n * 2\\.    So the community can ignore bug reports including proprietary modules \n * 3\\.    So vendors can do likewise based on their own policies \n */ \n```", "```\nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\");  \n```", "```\nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_AUTHOR(\"Lorem Ipsum <l.ipsum@foobar.com>\"); \n```", "```\nMODULE_DESCRIPTION(\"Hello, world! Module\"); \n```", "```\n#define  EPERM        1    /* Operation not permitted */ \n#define  ENOENT             2    /* No such file or directory */ \n#define  ESRCH        3    /* No such process */ \n#define  EINTR        4    /* Interrupted system call */ \n#define  EIO          5    /* I/O error */ \n#define  ENXIO        6    /* No such device or address */ \n#define  E2BIG        7    /* Argument list too long */ \n#define  ENOEXEC            8    /* Exec format error */ \n#define  EBADF        9    /* Bad file number */ \n#define  ECHILD            10    /* No child processes */ \n#define  EAGAIN            11    /* Try again */ \n#define  ENOMEM            12    /* Out of memory */ \n#define  EACCES            13    /* Permission denied */ \n#define  EFAULT            14    /* Bad address */ \n#define  ENOTBLK           15    /* Block device required */ \n#define  EBUSY       16    /* Device or resource busy */ \n#define  EEXIST            17    /* File exists */ \n#define  EXDEV       18    /* Cross-device link */ \n#define  ENODEV            19    /* No such device */ \n#define  ENOTDIR           20    /* Not a directory */ \n#define  EISDIR            21    /* Is a directory */ \n#define  EINVAL            22    /* Invalid argument */ \n#define  ENFILE            23    /* File table overflow */ \n#define  EMFILE            24    /* Too many open files */ \n#define  ENOTTY            25    /* Not a typewriter */ \n#define  ETXTBSY           26    /* Text file busy */ \n#define  EFBIG       27    /* File too large */ \n#define  ENOSPC            28    /* No space left on device */ \n#define  ESPIPE            29    /* Illegal seek */ \n#define  EROFS       30    /* Read-only file system */ \n#define  EMLINK            31    /* Too many links */ \n#define  EPIPE       32    /* Broken pipe */ \n#define  EDOM        33    /* Math argument out of domain of func */ \n#define  ERANGE            34    /* Math result not representable */ \n```", "```\ndev = init(&ptr); \nif(!dev) \nreturn -EIO \n```", "```\n#include <errno.h>  /* to access errno global variable */ \n#include <string.h> \n[...] \nif(wite(fd, buf, 1) < 0) { \n    printf(\"something gone wrong! %s\\n\", strerror(errno)); \n} \n[...] \n```", "```\nptr = kmalloc(sizeof (device_t)); \nif(!ptr) { \n        ret = -ENOMEM \n        goto err_alloc; \n} \ndev = init(&ptr); \n\nif(dev) { \n        ret = -EIO \n        goto err_init; \n} \nreturn 0; \n\nerr_init: \n        free(ptr); \nerr_alloc: \n        return ret; \n```", "```\nif (ops1() != ERR) { \n    if (ops2() != ERR) { \n        if ( ops3() != ERR) { \n            if (ops4() != ERR) { \n```", "```\nif (ops1() == ERR) // | \n    goto error1;   // | \nif (ops2() == ERR) // | \n    goto error2;   // | \nif (ops3() == ERR) // | \n    goto error3;   // | \nif (ops4() == ERR) // V \n    goto error4; \nerror5: \n[...] \nerror4: \n[...] \nerror3: \n[...] \nerror2: \n[...] \nerror1: \n[...] \n```", "```\nvoid *ERR_PTR(long error); \nlong IS_ERR(const void *ptr); \nlong PTR_ERR(const void *ptr); \n```", "```\nstatic struct iio_dev *indiodev_setup(){ \n    [...] \n    struct iio_dev *indio_dev; \n    indio_dev = devm_iio_device_alloc(&data->client->dev, sizeof(data)); \n    if (!indio_dev) \n        return ERR_PTR(-ENOMEM); \n    [...] \n    return indio_dev; \n} \n\nstatic int foo_probe([...]){ \n    [...] \n    struct iio_dev *my_indio_dev = indiodev_setup(); \n    if (IS_ERR(my_indio_dev)) \n        return PTR_ERR(data->acc_indio_dev); \n    [...] \n} \n```", "```\n#define KERN_SOH     \"\\001\"            /* ASCII Start Of Header */ \n#define KERN_SOH_ASCII     '\\001' \n\n#define KERN_EMERG   KERN_SOH \"0\"      /* system is unusable */ \n#define KERN_ALERT   KERN_SOH \"1\"      /* action must be taken immediately */ \n#define KERN_CRIT    KERN_SOH \"2\"      /* critical conditions */ \n#define KERN_ERR     KERN_SOH \"3\"      /* error conditions */ \n#define KERN_WARNING KERN_SOH \"4\"      /* warning conditions */ \n#define KERN_NOTICE  KERN_SOH \"5\"      /* normal but significant condition */ \n#define KERN_INFO    KERN_SOH \"6\"      /* informational */ \n#define KERN_DEBUG   KERN_SOH \"7\"      /* debug-level messages */ \n```", "```\nprintk(KERN_ERR \"This is an error\\n\"); \n```", "```\npr_err(\"This is the same error\\n\"); \n```", "```\n cat /proc/sys/kernel/printk\n\n 4 4 1 7\n\n```", "```\n/* integer equivalents of KERN_<LEVEL> */ \n#define LOGLEVEL_SCHED           -2    /* Deferred messages from sched code \n                            * are set to this special level */ \n#define LOGLEVEL_DEFAULT   -1    /* default (or last) loglevel */ \n#define LOGLEVEL_EMERG           0     /* system is unusable */ \n#define LOGLEVEL_ALERT           1     /* action must be taken immediately */ \n#define LOGLEVEL_CRIT            2     /* critical conditions */ \n#define LOGLEVEL_ERR       3     /* error conditions */ \n#define LOGLEVEL_WARNING   4     /* warning conditions */ \n#define LOGLEVEL_NOTICE          5     /* normal but significant condition */ \n#define LOGLEVEL_INFO            6     /* informational */ \n#define LOGLEVEL_DEBUG           7     /* debug-level messages */ \n```", "```\n # echo <level> > /proc/sys/kernel/printk\n\n```", "```\nmodule_param(name, type, perm); \n```", "```\n#include <linux/moduleparam.h> \n[...] \n\nstatic char *mystr = \"hello\"; \nstatic int myint = 1; \nstatic int myarr[3] = {0, 1, 2}; \n\nmodule_param(myint, int, S_IRUGO); \nmodule_param(mystr, charp, S_IRUGO); \nmodule_param_array(myarr, int,NULL, S_IWUSR|S_IRUSR); /*  */ \n\nMODULE_PARM_DESC(myint,\"this is my int variable\"); \nMODULE_PARM_DESC(mystr,\"this is my char pointer variable\"); \nMODULE_PARM_DESC(myarr,\"this is my array of int\"); \n\nstatic int foo() \n{ \n    pr_info(\"mystring is a string: %s\\n\", mystr); \n    pr_info(\"Array elements: %d\\t%d\\t%d\", myarr[0], myarr[1], myarr[2]); \n    return myint; \n} \n```", "```\n# insmod hellomodule-params.ko mystring=\"packtpub\" myint=15 myArray=1,2,3\n\n```", "```\n$ modinfo ./helloworld-params.ko\n\nfilename: /home/jma/work/tutos/sources/helloworld/./helloworld-params.ko\n\nlicense: GPL\n\nauthor: John Madieu <john.madieu@gmail.com>\n\nsrcversion: BBF43E098EAB5D2E2DD78C0\n\ndepends:\n\nvermagic: 4.4.0-93-generic SMP mod_unload modversions\n\nparm: myint:this is my int variable (int)\n\nparm: mystr:this is my char pointer variable (charp)\n\nparm: myarr:this is my array of int (array of int)\n\n```", "```\n obj-y += mymodule.o \n```", "```\nobj-$(CONFIG_MYMODULE) += mymodule.o \n```", "```\nobj-<X> += somedir/ \n```", "```\nobj-m := helloworld.o \n\nKERNELDIR ?= /lib/modules/$(shell uname -r)/build \n\nall default: modules \ninstall: modules_install \n\nmodules modules_install help clean: \n$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@ \n```", "```\nconfig PACKT_MYCDEV \n   tristate \"Our packtpub special Character driver\" \n   default m \n   help \n     Say Y here if you want to support the /dev/mycdev device. \n     The /dev/mycdev device is used to access packtpub. \n```", "```\nobj-$(CONFIG_PACKT_MYCDEV)   += mychardev.o \n```", "```\nCONFIG_PACKT_MYCDEV=m \n```", "```\nCONFIG_PACKT_MYCDEV=m \n```", "```\nmake modules_install\n\n```", "```\n sudo apt-get update\n\n sudo apt-get install linux-headers-$(uname -r)\n\n```", "```\n    jma@jma:~/work/tutos/sources/helloworld$ make\n\n    make -C /lib/modules/4.4.0-79-generic/build \\\n\n        M=/media/jma/DATA/work/tutos/sources/helloworld modules\n\n    make[1]: Entering directory '/usr/src/linux-headers-4.4.0-79-generic'\n\n      CC [M]  /media/jma/DATA/work/tutos/sources/helloworld/helloworld.o\n\n      Building modules, stage 2.\n\n      MODPOST 1 modules\n\n      CC      /media/jma/DATA/work/tutos/sources/helloworld/helloworld.mod.o\n\n      LD [M]  /media/jma/DATA/work/tutos/sources/helloworld/helloworld.ko\n\n    make[1]: Leaving directory '/usr/src/linux-headers-4.4.0-79-generic'\n\n    jma@jma:~/work/tutos/sources/helloworld$ ls\n\n    helloworld.c  helloworld.ko  helloworld.mod.c  helloworld.mod.o  helloworld.o  Makefile  modules.order  Module.symvers\n\n    jma@jma:~/work/tutos/sources/helloworld$ sudo insmod  helloworld.ko\n\n    jma@jma:~/work/tutos/sources/helloworld$ sudo rmmod helloworld\n\n    jma@jma:~/work/tutos/sources/helloworld$ dmesg\n\n    [...]\n\n    [308342.285157] Hello world!\n\n    [308372.084288] End of the world\n\n```", "```\nmake ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- \n\n```"]