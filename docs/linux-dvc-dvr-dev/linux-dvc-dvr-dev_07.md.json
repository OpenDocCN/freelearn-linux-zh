["```\nstruct i2c_driver { \n    /* Standard driver model interfaces */ \nint (*probe)(struct i2c_client *, const struct i2c_device_id *); \nint (*remove)(struct i2c_client *); \n\n    /* driver model interfaces that don't relate to enumeration */ \n    void (*shutdown)(struct i2c_client *); \n\nstruct device_driver driver; \nconst struct i2c_device_id *id_table; \n}; \n```", "```\nstatic int foo_probe(struct i2c_client *client, const struct \n                                              i2c_device_id *id) \n```", "```\nstruct i2c_client { \n  unsigned short flags;  /* div., see below  */ \n  unsigned short addr;   /* chip address - NOTE: 7bit    */ \n                         /* addresses are stored in the  */ \n                         /* _LOWER_ 7 bits               */ \n  char name[I2C_NAME_SIZE]; \n  struct i2c_adapter *adapter; /* the adapter we sit on  */ \n  struct device dev;     /* the device structure         */ \n  intirq;               /* irq issued by device         */ \n  struct list_head detected; \n #if IS_ENABLED(CONFIG_I2C_SLAVE) \n  i2c_slave_cb_t slave_cb; /* callback for slave mode  */ \n #endif \n}; \n```", "```\n/* set the data */ \nvoid i2c_set_clientdata(struct i2c_client *client, void *data); \n\n/* get the data */ \nvoid *i2c_get_clientdata(const struct i2c_client *client); \n```", "```\n/* This is the device specific data structure */ \nstruct mc9s08dz60 { \n   struct i2c_client *client; \n   struct gpio_chip chip; \n}; \n\nstatic int mc9s08dz60_probe(struct i2c_client *client, \nconst struct i2c_device_id *id) \n{ \n    struct mc9s08dz60 *mc9s; \n    if (!i2c_check_functionality(client->adapter, \n               I2C_FUNC_SMBUS_BYTE_DATA)) \n    return -EIO; \n    mc9s = devm_kzalloc(&client->dev, sizeof(*mc9s), GFP_KERNEL); \n    if (!mc9s) \n        return -ENOMEM; \n\n    [...] \n    mc9s->client = client; \n    i2c_set_clientdata(client, mc9s); \n\n    return gpiochip_add(&mc9s->chip); \n} \n```", "```\nstatic int foo_remove(struct i2c_client *client) \n```", "```\nstatic int mc9s08dz60_remove(struct i2c_client *client) \n{ \n    struct mc9s08dz60 *mc9s; \n\n    /* We retrieve our private data */ \n    mc9s = i2c_get_clientdata(client); \n\n    /* Wich hold gpiochip we want to work on */ \n   return gpiochip_remove(&mc9s->chip); \n} \n```", "```\nmodule_i2c_driver(foo_driver); \n```", "```\nstruct i2c_device_id { \n    char name[I2C_NAME_SIZE]; \n    kernel_ulong_tdriver_data;     /* Data private to the driver */ \n}; \n```", "```\nstatic struct i2c_device_id foo_idtable[] = { \n   { \"foo\", my_id_for_foo }, \n   { \"bar\", my_id_for_bar }, \n   { } \n}; \n\nMODULE_DEVICE_TABLE(i2c, foo_idtable); \n\nstatic struct i2c_driver foo_driver = { \n   .driver = { \n   .name = \"foo\", \n   }, \n\n   .id_table = foo_idtable, \n   .probe    = foo_probe, \n   .remove   = foo_remove, \n} \n```", "```\nint i2c_master_send(struct i2c_client *client, const char *buf, int count); \nint i2c_master_recv(struct i2c_client *client, char *buf, int count); \n```", "```\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msg, \n\n                 int num); \n```", "```\nstruct i2c_msg { \n        __u16 addr;    /* slave address */ \n        __u16 flags;   /* Message flags */ \n        __u16 len;     /* msg length */ \n        __u8 *buf;     /* pointer to msg data */ \n}; \n```", "```\nssize_t \neep_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) \n{ \n    [...] \n    int _reg_addr = dev->current_pointer; \n    u8 reg_addr[2]; \n    reg_addr[0] = (u8)(_reg_addr>> 8); \n    reg_addr[1] = (u8)(_reg_addr& 0xFF); \n\n    struct i2c_msg msg[2]; \n    msg[0].addr = dev->client->addr; \n    msg[0].flags = 0;                /* Write */ \n    msg[0].len = 2;                  /* Address is 2bytes coded */ \n    msg[0].buf = reg_addr; \n\n    msg[1].addr = dev->client->addr; \n    msg[1].flags = I2C_M_RD;         /* We need to read */ \n    msg[1].len = count;  \n    msg[1].buf = dev->data; \n\n    if (i2c_transfer(dev->client->adapter, msg, 2) < 0) \n        pr_err(\"ee24lc512: i2c_transfer failed\\n\");  \n\n    if (copy_to_user(buf, dev->data, count) != 0) { \n        retval = -EIO; \n    goto end_read; \n    } \n    [...] \n} \n```", "```\n   s32 i2c_smbus_read_byte_data(struct i2c_client *client, u8 command); \n   s32 i2c_smbus_write_byte_data(struct i2c_client *client, \n                           u8 command, u8 value); \n   s32 i2c_smbus_read_word_data(struct i2c_client *client, u8 command); \n   s32 i2c_smbus_write_word_data(struct i2c_client *client, \n                           u8 command, u16 value); \n   s32 i2c_smbus_read_block_data(struct i2c_client *client, \n                           u8 command, u8 *values); \n   s32 i2c_smbus_write_block_data(struct i2c_client *client, \n                            u8 command, u8 length, const u8 *values); \n```", "```\nstruct mcp23016 { \n   struct i2c_client   *client; \n   structgpio_chip    chip; \n   structmutex        lock; \n}; \n[...] \n/* This function is called when one needs to change a gpio state */ \nstatic int mcp23016_set(struct mcp23016 *mcp, \n             unsigned offset, intval) \n{ \n    s32 value; \n    unsigned bank = offset / 8 ; \n    u8 reg_gpio = (bank == 0) ? GP0 : GP1; \n    unsigned bit = offset % 8 ; \n\n    value = i2c_smbus_read_byte_data(mcp->client, reg_gpio); \n    if (value >= 0) { \n        if (val) \n            value |= 1 << bit; \n        else \n            value &= ~(1 << bit); \n        return i2c_smbus_write_byte_data(mcp->client, \n                                         reg_gpio, value); \n    } else \n        return value; \n} \n[...] \n```", "```\nstruct i2c_board_info { \n    char type[I2C_NAME_SIZE]; \n    unsigned short addr; \n    void *platform_data; \n    int irq; \n}; \n```", "```\nint i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len) \n```", "```\n&i2c2 { /* Phandle of the bus node */ \n    pcf8523: rtc@68 { \n        compatible = \"nxp,pcf8523\"; \n        reg = <0x68>; \n    }; \n    eeprom: ee24lc512@55 { /* eeprom device */ \n        compatible = \"packt,ee24lc512\"; \n        reg = <0x55>; \n       }; \n}; \n```", "```\n/* no extra data for this device */ \nstatic const struct of_device_id foobar_of_match[] = { \n        { .compatible = \"packtpub,foobar-device\" }, \n        {} \n}; \nMODULE_DEVICE_TABLE(of, foobar_of_match); \n```", "```\nstatic struct i2c_driver foo_driver = { \n    .driver = { \n    .name   = \"foo\", \n    .of_match_table = of_match_ptr(foobar_of_match), /* Only this line is added */ \n    }, \n    .probe  = foo_probe, \n    .id_table = foo_id, \n}; \n```", "```\nstatic int my_probe(struct i2c_client *client, const struct i2c_device_id *id) \n{ \n    const struct of_device_id *match; \n    match = of_match_device(mcp23s08_i2c_of_match, &client->dev); \n    if (match) { \n        /* Device tree code goes here */ \n    } else { \n        /*  \n         * Platform data code comes here. \n         * One can use \n         *   pdata = dev_get_platdata(&client->dev); \n         * \n         * or *id*, which is a pointer on the *i2c_device_id* entry that originated \n         * the match, in order to use *id->driver_data* to extract the device \n         * specific data, as described in platform driver chapter. \n         */ \n    } \n    [...] \n} \n```", "```\n    if (!driver->probe || !driver->id_table) \n            return -ENODEV; \n```", "```\n/* \n * An I2C ID table is not mandatory, if and only if, a suitable Device \n * Tree match table entry is supplied for the probing device. \n */ \nif (!driver->id_table && \n    !i2c_of_match_device(dev->driver->of_match_table, client)) \n        return -ENODEV; \n```", "```\n&i2c3 { \n    status = \"okay\"; \n    foo-bar: foo@55 { \n    compatible = \"packtpub,foobar-device\"; \nreg = &lt;55>; \n    }; \n}; \n```"]