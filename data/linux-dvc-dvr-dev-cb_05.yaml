- en: Managing Interrupts and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理中断和并发
- en: 'When implementing a device driver, a developer has to resolve two main problems:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现设备驱动程序时，开发人员必须解决两个主要问题：
- en: How to exchange data with peripherals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与外围设备交换数据
- en: How to manage interrupts that peripherals generate to the CPU
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理外围设备生成的中断到CPU
- en: The first point was covered (at least for char drivers) in previous chapters,
    while the second one (and its related matter) will be the main topic of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个点（至少对于字符驱动程序）在以前的章节中已经涵盖了，而第二个点（及其相关内容）将是本章的主题。
- en: In the kernel, we can consider the CPU (or the internal core executing some
    code) running in two main execution contexts — the **interrupt context** and the
    **process context**. The interrupt context is very easy to understand; in fact,
    the CPU is in this context each time it executes an interrupt handler (that is,
    special code the kernel executes each time an interrupt occurs). In addition to
    this, interrupts can be generated by the hardware or even by the software; that's
    why we talk about hardware interrupts and software interrupts (we'll take a closer
    look at software interrupts in the following sections), which in turn define the
    **hardware interrupt context** and the **software interrupt context**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，我们可以将CPU（或执行某些代码的内部核心）视为运行在两个主要执行上下文中——**中断上下文**和**进程上下文**。中断上下文非常容易理解；事实上，每当CPU执行中断处理程序时（即内核每次发生中断时执行的特殊代码），CPU就处于这种上下文中。除此之外，中断可以由硬件或甚至软件生成；这就是为什么我们谈论硬件中断和软件中断（我们将在接下来的章节中更详细地了解软件中断），从而定义了**硬件中断上下文**和**软件中断上下文**。
- en: On the other hand, the **process context** is when the CPU (or one of its internal
    cores) executes some code of a process in the kernel space (processes also execute
    in the user space, but we are not covering that here), that is, when the CPU executes
    the code of a system call that has been invoked by a process (see [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*). In this situation, it's very common to yield the
    CPU and then suspend the current process because some data from the peripheral
    is not ready to be read; for instance; this can be done by asking to the scheduler
    to take the CPU and then assign it to another process. When this happens we usually
    say that the current **process has gone to sleep,** and when data is newly available
    we say that a **process has been awakened**, and, it restarts its execution where
    it was previously interrupted.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**进程上下文**是指CPU（或其内部核心之一）在内核空间中执行进程的某些代码时（进程也在用户空间中执行，但我们这里不涉及），也就是说，当CPU执行进程调用的系统调用代码时。在这种情况下，很常见的是让出CPU，然后暂停当前进程，因为外围设备的一些数据尚未准备好读取；例如；这可以通过要求调度程序接管CPU，然后将其分配给另一个进程来完成。当这种情况发生时，我们通常说当前**进程已进入睡眠状态**，当数据新可用时，我们说**进程已被唤醒**，并且它会在先前中断的地方重新执行。
- en: In this chapter, we'll see how to do all these actions, how a device driver
    developer can ask the kernel to suspend the current reading process because the
    peripheral is not ready to serve the request, and also how to wake up a sleeping
    process. We'll also see how to manage concurrent access to our driver's methods
    to avoid data corruption due to a race condition, and how to manage time flow
    in order to do a specific action after a well-defined amount of time, respecting
    the possible time constraints a peripheral may require.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何执行所有这些操作，设备驱动程序开发人员如何要求内核暂停当前的读取过程，因为外围设备尚未准备好提供请求，并且还将看到如何唤醒睡眠进程。我们还将看到如何管理对驱动程序方法的并发访问，以避免由于竞争条件导致的数据损坏，以及如何管理时间流以便在经过明确定义的时间后执行特定操作，以尊重外围设备可能需要的时间约束。
- en: 'We will also look at how to exchange data between a char driver and the userspace,
    and how to handle those kernel events a driver should be able to manage. The first
    (and probably the most important) example is how to manage interrupts, followed
    by how to defer a job "later in time," and how to wait for an event. We can do
    all these using the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看看如何在字符驱动程序和用户空间之间交换数据，以及如何处理驱动程序应该能够管理的内核事件。第一个（也可能是最重要的）示例是如何管理中断，其次是如何推迟工作“稍后”，以及如何等待事件。我们可以使用以下方法来执行所有这些操作：
- en: Implementing an interrupt handler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现中断处理程序
- en: Deferring jobs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推迟工作
- en: Managing time with kernel timers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核定时器管理时间
- en: Waiting for an event
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待事件
- en: Doing atomic operations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行原子操作
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For more information on this chapter, you can visit the *Appendix*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章的更多信息，您可以访问*附录*。
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码和其他文件可以从GitHub下载：[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05)。
- en: Implementing an interrupt handler
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现中断处理程序
- en: Inside the kernel, an **interrupt handler** is a function associated with a
    CPU interrupt line (or pin) that Linux executes whenever the peripheral connected
    with this line changes the pin status; when this happens, an interrupt request
    is generated for the CPU, and it's captured by the kernel, which in turn executes
    the proper handler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，**中断处理程序**是与CPU中断线（或引脚）相关联的函数，当连接到该线的外围设备更改引脚状态时，Linux会执行该函数；当这种情况发生时，会为CPU生成中断请求，并且被内核捕获，然后执行适当的处理程序。
- en: In this recipe, we will see how to install an interrupt handler which the kernel
    executes each time an interrupt occurs on a well-defined line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何安装一个中断处理程序，内核每次在一个明确定义的线上发生中断时都会执行该处理程序。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The simplest code to implement an interrupt handler is the code in `linux/drivers/misc/dummy-irq.c`.
    Here is the handler:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中断处理程序的最简单代码是`linux/drivers/misc/dummy-irq.c`中的代码。这是处理程序：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the code to install or to remove it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安装或删除它的代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is really simple, and, as we can see, it calls the `request_irq()`
    function in the `dummy_irq_init()` module initialization function, and the `free_irq()`
    function in the `dummy_irq_exit()` module exit function. Then, these two functions
    respectively ask the kernel to connect the `dummy_interrupt()` interrupt handler
    to the `irq` interrupt line and, in the opposite operation, to detach the handler
    from it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单，正如我们所看到的，它在`dummy_irq_init()`模块初始化函数中调用`request_irq()`函数，并在`dummy_irq_exit()`模块退出函数中调用`free_irq()`函数。然后，这两个函数分别要求内核将`dummy_interrupt()`中断处理程序连接到`irq`中断线，并在相反操作中将处理程序从中断线中分离。
- en: This code briefly shows how to install an interrupt handler; however, it doesn't
    show how a device driver's developer can install its own handler; that's why in
    the next section we're going to do a practical example using a real interrupt
    line simulated with a General Purpose Input Output line (GPIO).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简要地展示了如何安装中断处理程序；然而，它并没有展示设备驱动程序开发人员如何安装自己的处理程序；这就是为什么在下一节中，我们将使用一个真实的中断线的实际示例，使用通用输入输出线（GPIO）模拟。
- en: In order to implement a management for our first **interrupt request** (**IRQ**)
    handler, we can use a normal GPIO as an interrupt line; however, before doing
    so, we have to verify that our GPIO line correctly detects high and low input
    levels.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现对我们的第一个**中断请求**（**IRQ**）处理程序的管理，我们可以使用一个普通的GPIO作为中断线；然而，在这样做之前，我们必须验证我们的GPIO线是否正确检测到高低输入电平。
- en: To manage GPIOs we're going to use its sysfs interface so, first of all, we
    have to verify that it is currently enabled for our kernel by checking if the
    `/sys/class/gpio` directory exists. If not we'll have to enable the `CONFIG_GPIO_SYSFS`
    kernel configuration entry by using the kernel configuration menu (`make menuconfig`);
    the can be done by going to Device Drivers, then GPIO Support, and enabling the
    /sys/class/gpio/... (sysfs interface) menu entry.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理GPIO，我们将使用其sysfs接口，因此，首先，我们必须验证它是否当前对我们的内核启用，方法是检查`/sys/class/gpio`目录是否存在。如果不存在，我们将不得不通过使用内核配置菜单（`make
    menuconfig`）启用`CONFIG_GPIO_SYSFS`内核配置条目；可以通过转到设备驱动程序，然后GPIO支持，启用/sys/class/gpio/...（sysfs接口）菜单条目来完成。
- en: 'A way to quickly check if the entry is enabled is by using the following command
    line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下命令行，我们可以快速检查条目是否已启用：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Otherwise, if it is not enabled, we''ll get the following output, and then
    we must enable it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果它没有被启用，我们将得到以下输出，然后我们必须启用它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If everything is in place, we should get something something similar to the
    following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切就绪，我们应该得到类似以下的内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `gpiochip446` and `gpiochip476` directories represent the two ESPRESSObin's
    GPIOs controller as we saw in the previous chapter describing the device tree.
    (See *The Armada 3720* section in Appendix of [Chapter 4](fdfcddc8-11dc-4e60-8653-a3fd8970d70d.xhtml),
    *Using the Device Tree,* *Configuring CPU's pins for specific peripherals* section).
    The `export` and `unexport` files are used to get access to GPIO lines.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip446`和`gpiochip476`目录代表了两个ESPRESSObin的GPIO控制器，正如我们在上一章中描述设备树时所看到的。（参见附录中的*The
    Armada 3720*部分[第4章](fdfcddc8-11dc-4e60-8653-a3fd8970d70d.xhtml)，*使用设备树*，*为特定外围设备配置CPU引脚*部分）。`export`和`unexport`文件用于访问GPIO线。'
- en: 'To do our job, we need to get access to the MPP2_20 CPU line, which is mapped
    on pin 12 of the ESPRESSObin extension #2; that is, the connector P8 (or J18)
    on the ESPRESSObin schematics. (See the *Technical requirements* section in [Chapter
    1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), I*nstalling the Development System*).
    In the CPU datasheet, we discover that the MPP2_20 line is attached to the second
    pinctrl controller (named south bridge and mapped as `pinctrl_sb: pinctrl@18800`
    in the device tree). To know which is the right gpiochip device to use, we can
    still use the sysfs as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '为了完成我们的工作，我们需要访问映射到ESPRESSObin扩展#2的引脚12的MPP2_20 CPU线；也就是说，在ESPRESSObin原理图上的连接器P8（或J18）。
    （参见[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)中的*技术要求*部分，*安装开发系统*）。在CPU数据表中，我们发现MPP2_20线连接到第二个pinctrl控制器（在设备树中命名为南桥并映射为`pinctrl_sb:
    pinctrl@18800`）。要知道使用哪个正确的gpiochip设备，我们仍然可以使用sysfs如下：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s now clear that we have to use `gpiochip446`. In that directory, we will
    find the `base` file that tells us the corresponding number of the first GPIO
    line, and, since we''re using the 20th line, we should export the `base+20` GPIO
    line as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显我们必须使用`gpiochip446`。在那个目录中，我们会找到`base`文件，告诉我们第一个GPIO线的对应编号，由于我们使用的是第20条线，我们应该将`base+20`
    GPIO线导出如下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything works well, a new `gpio466` entry is now present in the `/sys/class/gpio`
    directory, corresponding to our just exported GPIO line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，现在在`/sys/class/gpio`目录中会出现一个新的`gpio466`条目，对应于我们刚刚导出的GPIO线：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great! The `gpio466` directory is now ready to be used, and, by taking a look
    inside it, we get the following files:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！`gpio466`目录现在已经准备好使用了，通过查看其中的内容，我们得到以下文件：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To see if we are able to modify our GPIO line, we can simply use the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们是否能够修改我们的GPIO线，我们可以简单地使用以下命令：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the line is set to 1, even if unconnected, because this pin is normally
    configured with an internal pull-up that forces the pin state to the high level.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使未连接，该线路也被设置为1，因为该引脚通常配置为内部上拉，强制引脚状态为高电平。
- en: 'This output tells us that the GPIO line 20 is currently high, but, if we connect
    pin 12 of the P8 connector to the ground (pin 1 or 2) of the same connector (P8/J8),
    the GPIO line should go to the downstate and the preceding command should now
    return 0, instead, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们GPIO线20当前处于高电平，但是，如果我们将P8连接器的引脚12连接到同一连接器（P8/J8）的地线（引脚1或2），GPIO线应该转为低电平，前面的命令现在应该返回0，如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the line doesn''t change, you should verify that you''re working on the
    correct pins/connector. Also, you should take a look at the `/sys/class/gpio/gpio466/direction`
    file, which should hold the `in` string, shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线路没有改变，您应该验证您是否在正确的引脚/连接器上工作。此外，您应该查看`/sys/class/gpio/gpio466/direction`文件，其中应该包含`in`字符串，如下所示：
- en: '**`# cat /sys/class/gpio/gpio466/direction`**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**`# cat /sys/class/gpio/gpio466/direction`**'
- en: '`in`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`'
- en: OK. Now we are ready to generate our interrupts!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在我们准备生成我们的中断！
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤来看看如何做：
- en: 'Now, let''s assume that we have a dedicated platform driver named `irqtest`
    , defined as follows in the ESPRESSObin device tree:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们有一个专用的平台驱动程序名为`irqtest`，在ESPRESSObin设备树中定义如下：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember that the ESPRESSObin device tree file is `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，ESPRESSObin设备树文件是`linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts`。
- en: 'Then we have to add a platform driver to the kernel as we did in the previous
    chapter with the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须像在上一章中那样向内核添加一个平台驱动程序，使用以下代码：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that all code presented here can be obtained from the GitHub repository
    by applying the `add_irqtest_module.patch` patch within the root directory of
    kernel sources by executing the `patch` command, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里呈现的所有代码都可以通过在内核源代码的根目录中执行`patch`命令应用`add_irqtest_module.patch`补丁来从GitHub存储库获取，如下所示：
- en: '`**$ patch -p1 < ../linux_device_driver_development_cookbook/chapter_5/add_irqtest_module.patch**`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ patch -p1 < ../linux_device_driver_development_cookbook/chapter_5/add_irqtest_module.patch**`'
- en: 'Now, we know that, once the kernel detects in the device tree that a driver
    is compatible with `ldddc,irqtest`, the following `irqtest_probe()` probing function
    should be executed. This function is very similar to the one in the preceding
    `linux/drivers/misc/dummy-irq.c` file, even if a bit more complex. In fact, first
    we have to read from the device tree which is the GPIO line where interrupts will
    come from, by using the `of_get_gpio()` function:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们知道一旦内核在设备树中检测到与`ldddc,irqtest`兼容的驱动程序，将执行以下`irqtest_probe()`探测函数。这个函数与前面的`linux/drivers/misc/dummy-irq.c`文件中的函数非常相似，即使有点更复杂。实际上，首先我们必须从设备树中读取中断信号来自哪个GPIO线，使用`of_get_gpio()`函数：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we have to ask the kernel for the GPIO line, by using the `devm_gpio_request()`
    function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须使用`devm_gpio_request()`函数向内核请求GPIO线：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we are sure that the GPIO is for us only, we have to set it up as an
    input (interrupts are incoming signals) using the `gpio_direction_input()` function,
    and then we have to get the corresponding interrupt line number (which, very often,
    is a different number) by using the `gpio_to_irq()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定GPIO仅供我们使用后，我们必须将其设置为输入（中断是传入信号），使用`gpio_direction_input()`函数，然后我们必须使用`gpio_to_irq()`函数获取相应的中断线号（通常是不同的号码）：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After that, we have all the necessary information to install our interrupt
    handler using the `request_irq()` function defined in the `linux/include/linux/interrupt.h`
    header file, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们有了所有必要的信息，可以使用`linux/include/linux/interrupt.h`头文件中定义的`request_irq()`函数安装我们的中断处理程序，如下所示：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the `handler` parameter specifies the function to be executed as an
    interrupt handler and `dev` is a pointer, which the kernel will pass as-is to
    the handler when executed. In our example, the interrupt handler is defined as
    follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`handler`参数指定要作为中断处理程序执行的函数，`dev`是一个指针，内核在执行时会原样传递给处理程序。在我们的示例中，中断处理程序定义如下：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *step 1*, the node declares a device compatible with the driver named `ldddc,irqtest`,
    that requires for its usage the GPIO line 20 of the `gpiosb` node, defined as
    follows in the Armada 3270 device tree `arch/arm64/boot/dts/marvell/armada-37xx.dtsi`
    file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，节点声明了一个与驱动程序名为`ldddc,irqtest`兼容的设备，该设备需要使用`gpiosb`节点的GPIO线20，如在Armada
    3270设备树`arch/arm64/boot/dts/marvell/armada-37xx.dtsi`文件中定义的那样：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have the confirmation that the `gpiosb` node is related to MPP2 lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确认`gpiosb`节点与MPP2线相关。
- en: 'In *step 2* we just declare the driver within the kernel while in *step* *3*,
    the function gets GPIO information from the `gpio` property, and, by using the
    second argument set to `0`, we simply ask for the first entry. The return value
    is saved into the module''s data structure, which is now defined as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们只是在内核中声明驱动程序，而在*步骤3*中，该函数从`gpio`属性获取GPIO信息，并且通过将第二个参数设置为`0`，我们只是请求第一个条目。返回值保存在模块的数据结构中，现在定义如下：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In step 4, in reality, the `devm_gpio_request()` call is not strictly needed
    since we're in the kernel and nobody can stop us using a resource; however, if
    all drivers do this, we can ensure that we're informed if someone else is holding
    the resource!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4中，实际上，`devm_gpio_request()`调用并不是严格需要的，因为我们在内核中，没有人可以阻止我们使用资源；但是，如果所有驱动程序都这样做，我们可以确保在有其他人持有资源时得到通知！
- en: We should now notice that the `devm_gpio_request()` function does not have a
    counterpart in the module's `exit()` function `irqtest_remove()` . This is because
    functions with the `devm` prefix are related to managed devices that are able
    to automatically deallocate resources when the owner device is removed from the
    system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该注意到`devm_gpio_request()`函数在模块的`exit()`函数`irqtest_remove()`中没有对应的函数。这是因为带有`devm`前缀的函数与能够在所有者设备从系统中移除时自动释放资源的托管设备相关。
- en: 'In the `linux/drivers/gpio/devres.c` file, where this function is defined,
    we see the following comment, which explains how this function works:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义此函数的`linux/drivers/gpio/devres.c`文件中，我们看到以下注释，解释了此函数的工作原理：
- en: '`/**`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`/**`'
- en: '`* devm_gpio_request - request a GPIO for a managed device`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`* devm_gpio_request - 为托管设备请求GPIO`'
- en: '`* @dev: device to request the GPIO for`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`* @dev: 请求GPIO的设备`'
- en: '`* @gpio: GPIO to allocate`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`* @gpio: 要分配的GPIO`'
- en: '`* @label: the name of the requested GPIO`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`* @label: 请求的GPIO的名称`'
- en: '`*`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`* Except for the extra @dev argument, this function takes the`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 除了额外的@dev参数外，此函数还需要`'
- en: '`* same arguments and performs the same function as`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 使用相同的参数并执行相同的功能`'
- en: '`* gpio_request(). GPIOs requested with this function will be`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`* gpio_request()。使用此功能请求的GPIO将被`'
- en: '`* automatically freed on driver detach.`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 在驱动程序分离时自动释放。`'
- en: '`*`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`* If an GPIO allocated with this function needs to be freed`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 如果使用此功能分配的GPIO需要被释放`'
- en: '`* separately, devm_gpio_free() must be used.`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 另外，必须使用devm_gpio_free()。`'
- en: '`*/`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/`'
- en: 'This is advanced resource management and beyond the scope of this book. However,
    if you are interested, there is a lot of information on the internet, and the
    following is a good article to start with: [https://lwn.net/Articles/222860/](https://lwn.net/Articles/222860/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高级资源管理，超出了本书的范围。但是，如果你感兴趣，互联网上有很多信息，以下是一个很好的文章起点：[https://lwn.net/Articles/222860/](https://lwn.net/Articles/222860/)。
- en: Anyway the normal counterparts of the `devm_gpio_request()` function are the
    `gpio_request()` and `gpio_free()` functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，`devm_gpio_request()`函数的正常对应函数是`gpio_request()`和`gpio_free()`函数。
- en: In step 5, note that a GPIO line number almost never corresponds to an interrupt
    line number; that's why we need to invoke the `gpio_to_irq()` function in order
    to get the correct IRQ line related to our GPIO line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，请注意，GPIO线号几乎永远不对应中断线号；这就是为什么我们需要调用`gpio_to_irq()`函数以获取与我们的GPIO线相关的正确IRQ线的原因。
- en: In step 6, we can see the `request_irq()` function is a special case of the
    `request_threaded_irq()` function, which informs us that an interrupt handler
    can run in an interrupt context, or inside a kernel thread that is in a process
    context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们可以看到`request_irq()`函数是`request_threaded_irq()`函数的一个特例，它告诉我们中断处理程序可以在中断上下文中运行，或者在进程上下文中运行的内核线程中运行。
- en: At the moment, we still don't know what kernel threads are (they will be explained
    in [Chapter 6](ed0f6f71-13aa-413b-ac84-b4e833caa071.xhtml), *Miscellaneous Kernel
    Internals*), but it should be easy to understand that they are something like
    a thread (or process) executed in the kernel space.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们仍然不知道什么是内核线程（它们将在[第6章](ed0f6f71-13aa-413b-ac84-b4e833caa071.xhtml)中解释，*杂项内核内部*），但应该很容易理解它们类似于在内核空间中执行的线程（或进程）。
- en: Also the `request_any_context_irq()` function can be used to delegate the kernel
    to automatically request a normal interrupt handler or a threaded one depending
    of the IRQ line characteristics.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`request_any_context_irq()`函数来委托内核自动请求正常的中断处理程序或线程中的中断处理程序，具体取决于IRQ线的特性。
- en: This a really advanced use of interrupt handlers, which is fundamental when
    we have to manage peripherals (such as I2C or SPI devices) where we need to suspend
    the interrupt handler to be able to read from, or write data to, the peripheral's
    registers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是中断处理程序的一个非常高级的用法，当我们需要管理外围设备（如I2C或SPI设备）时，我们需要挂起中断处理程序才能从外围寄存器中读取或写入数据。
- en: 'Apart from these aspects, all the `request_irq*()` functions take several parameters.
    First of all, the `irq` line, then a symbolic `name` describing the interrupt
    line we can find in the `/proc/interrupts` file, and then we can use the `flags`
    argument to specify some special settings, shown as follows (see the `linux/include/linux/interrupt.h`
    file for a complete list):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方面，所有的`request_irq*()`函数都需要几个参数。首先是`irq`线，然后是一个符号`name`，描述我们可以在`/proc/interrupts`文件中找到的中断线，然后我们可以使用`flags`参数来指定一些特殊设置，如下所示（请参阅`linux/include/linux/interrupt.h`文件以获取完整列表）：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `IRQF_SHARED` flag should be used when the IRQ line is shared with more
    than one peripheral. (Nowadays it is quite useless but, in the past, it was very
    useful, especially on x86 machines.) The `IRQF_ONESHOT` flag is used by the system
    to be sure that even threaded interrupt handlers can run with their own IRQ line
    disabled. The `IRQF_NO_SUSPEND` flag can be used to allow our peripheral to wake
    the system from a suspended state, by sending a proper interrupt request. (See
    the `linux/Documentation/power/suspend-and-interrupts.txt` file for more details.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当IRQ线与多个外围设备共享时，应该使用`IRQF_SHARED`标志。（现在它几乎没有用，但在过去，它非常有用，特别是在x86机器上。）`IRQF_ONESHOT`标志被系统用来确保即使线程中断处理程序也可以在其自己的IRQ线被禁用时运行。`IRQF_NO_SUSPEND`标志可用于允许我们的外围设备从挂起状态唤醒系统，通过发送适当的中断请求。（有关更多详细信息，请参阅`linux/Documentation/power/suspend-and-interrupts.txt`文件。）
- en: Then the `IRQF_TRIGGER_*` flag can be used to specify the IRQ trigger mode for
    our peripheral, that is, if the interrupt must be generated on high or low levels
    or during a rising or falling transition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`IRQF_TRIGGER_*`标志可用于指定我们外围设备的IRQ触发模式，即中断是否必须在高电平或低电平上产生，或在上升或下降转换期间产生。
- en: These last flag groups should be carefully checked against the device tree pinctrl
    settings; otherwise, we might see some unexpected behavior.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最后的标志组应该仔细检查设备树pinctrl设置；否则，我们可能会看到一些意外的行为。
- en: In step 7, since in the `request_irq()` function we set the `dev` parameter
    to the pointer of the `struct irqtest_data` module, when the `irqtest_interrupt()`
    interrupt handler executes, it will find in the `dev_id` argument the same pointer
    we supplied to `request_irq()`. By using this trick, we can get back the `dev`
    value we got from the probing function, and we can safely reuse it as an argument
    of the `dev_info()` function, as earlier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，由于在`request_irq()`函数中我们将`dev`参数设置为`struct irqtest_data`模块的指针，当`irqtest_interrupt()`中断处理程序执行时，它将在`dev_id`参数中找到我们提供给`request_irq()`的相同指针。通过使用这个技巧，我们可以得到从探测函数中得到的`dev`值，并且可以安全地将其重新用作`dev_info()`函数的参数，就像之前一样。
- en: 'In our example, the interrupt handler does almost nothing but display a message.
    However, usually in the interrupt handler, we have to acknowledge the peripheral,
    read from or write data to it, and then wake up all the sleeping processes that
    are waiting for peripheral activities. In any case, at the end, the handler should
    return one value from the ones listed in the `linux/include/linux/irqreturn.h`
    file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，中断处理程序几乎什么都没做，只是显示一条消息。但是，通常在中断处理程序中，我们必须确认外围设备，从中读取或写入数据，然后唤醒所有正在等待外围设备活动的睡眠进程。无论如何，在最后，处理程序应该返回`linux/include/linux/irqreturn.h`文件中列出的一个值：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `IRQ_NONE` value is useful in case we're working on a shared interrupt to
    inform the system that the current IRQ is not for us, and that it must be propagated
    to the next handler, while `IRQ_WAKE_THREAD` should be used in the case of threaded
    IRQ handlers. Of course, `IRQ_HANDLED` must be used to report to the system that
    the IRQ has been served.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRQ_NONE`值在我们正在处理共享中断的情况下非常有用，以通知系统当前的IRQ不是针对我们的，并且必须传递给下一个处理程序，而`IRQ_WAKE_THREAD`应该在使用线程化IRQ处理程序的情况下使用。当然，必须使用`IRQ_HANDLED`来向系统报告IRQ已被处理。'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you wish to check how this works, we can do so by testing our example. We
    have to compile it and then reinstall the kernel with our code compiled as built-in,
    so let''s use the usual `make menuconfig` command and enable our testing code,
    or just use `make oldconfig`, answering `y` when the system asks for a choice,
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要检查这是如何工作的，我们可以通过测试我们的示例来做到这一点。我们必须编译它，然后将内核与我们编译为内置的代码一起重新安装，因此让我们使用通常的`make
    menuconfig`命令并启用我们的测试代码，或者只需使用`make oldconfig`，在系统要求选择时回答`y`，如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, we''ve just to recompile and reinstall the kernel and then reboot
    the ESPRESSObin. If everything works well during the boot sequence, we should
    see kernel messages as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需重新编译和重新安装内核，然后重新启动ESPRESSObin。如果在引导序列期间一切正常，我们应该看到内核消息如下：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the MPP2_20 line has been taken by the kernel and converted into the number
    40 interrupt line. To verify it, we can take a look at the `/proc/interrupts`
    file, which holds all registered interrupt lines within the kernel. Earlier, we
    used the `irqtest` label in the `request_irq()` function during an interrupt handler
    registration, so we have to search for it within the file with `grep` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MPP2_20线已被内核占用，并转换为编号40的中断线。为了验证它，我们可以查看`/proc/interrupts`文件，其中包含内核中所有已注册的中断线。之前，在中断处理程序注册期间，我们在`request_irq()`函数中使用了`irqtest`标签，因此我们必须使用`grep`在文件中搜索它，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'OK. The interrupt line 40 has been assigned to our module, and we notice that
    this IRQ line corresponds to the GPIO line 20 of the GPIO2 group (that is, the
    MPP2_20 line). If we take a look at the beginning of the `/proc/interrupts` file,
    we should get an output as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。中断线40已分配给我们的模块，我们注意到这个IRQ线对应于GPIO2组的GPIO线20（即MPP2_20线）。如果我们查看`/proc/interrupts`文件的开头，我们应该得到以下输出：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first number is the interrupt line; the second and third ones show how many
    interrupts have been served by the CPU0 and CPU1, respectively, so we can use
    this information to verify which CPU served our interrupt.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是中断线；第二个和第三个数字显示CPU0和CPU1分别服务了多少次中断，因此我们可以使用这些信息来验证哪个CPU服务了我们的中断。
- en: 'OK. Now we''re ready to go. Just connect pin 12 to pin 1 of the P8 extension
    connector; at least one interrupt should be generated and a message, such as the
    following, should appear in the kernel messages:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们准备好了。只需将引脚12连接到P8扩展连接器的引脚1；至少应该生成一个中断，并且内核消息中应该出现以下消息：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that you may get several messages due to the fact that, during the short
    circuit operation, the electrical signal may generate several oscillations, which
    in turn will generate several interrupts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于在短路操作期间，电信号可能会产生多次振荡，因此您可能会收到多条消息。
- en: 'As a final note, let''s take a look at what happens if we try to export the
    number 466 GPIO line, as we did earlier, using the sysfs interface:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如果我们尝试使用sysfs接口导出编号466的GPIO线会发生什么，就像我们之前做的那样：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we correctly get a busy error due to the fact such a GPIO has been requested
    by the kernel when we used the `devm_gpio_request()` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于内核在我们使用`devm_gpio_request()`函数时请求了这样一个GPIO，我们正确地得到了一个忙碌错误。
- en: See also
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about interrupts handlers, a good starting point ( even
    if it is slightly outdated) is The Linux Kernel Module Programming Guide at [https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)[.](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关中断处理程序的更多信息，一个很好的起点（即使它有点过时）是Linux内核模块编程指南，网址为[https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)[.](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)
- en: Deferring work
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推迟工作
- en: Interrupts are events generated by peripherals, but, as said earlier, they are
    not the only events that the kernel can handle. In fact, software interrupts exist,
    which are similar to hardware interrupts but generated by software. In this book,
    we'll see two examples of such software interrupts; both of them can be used to
    safely defer a job for a future time. We'll also have a look at a useful mechanism
    that a device driver developer can use to catch special kernel events and perform
    actions as a consequence (for instance, when a network device is enabled, or the
    system is doing a reboot, and so on).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是由外围设备生成的事件，但正如前面所说的，它们并不是内核能够处理的唯一事件。事实上，还存在软件中断，类似于硬件中断，但是由软件生成。在本书中，我们将看到两个此类软件中断的示例；它们都可以用于安全地推迟将来的工作。我们还将看看设备驱动程序开发人员可以使用的一个有用机制，以捕获特殊的内核事件并根据情况执行操作（例如，当网络设备启用时，或系统正在重新启动等）。
- en: In this recipe, we will see how to defer a job when a specific event happens
    within the kernel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何在内核中发生特定事件时推迟工作。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Since tasklets and workqueues were implemented to defer jobs, their main usage
    is in an interrupt handler where we just acknowledge the Interrupt Request (usualy
    named IRQ), and then we invoke the tasklet/workqueue to finish the job.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 tasklet 和 workqueue 是用来推迟工作的，它们的主要用途是在中断处理程序中，我们只需确认中断请求（通常命名为 IRQ），然后调用
    tasklet/workqueue 完成工作。
- en: However, don't forget that this is just only one of the several possible usage
    of tasklets and workqueues that, of course, can be used even without interrupts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要忘记这只是 tasklet 和工作队列的几种可能用法之一，当然，即使没有中断，也可以使用它们。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we're going to present simple examples regarding both tasklets
    and workqueues by using patches against the previous `irqtest.c` example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用针对先前的 `irqtest.c` 示例的补丁，展示关于 tasklet 和工作队列的简单示例。
- en: In the next chapters, whenever needed, we're going to present more complex usages
    of these mechanisms, but, for the moment, we're interested in understanding their
    basic usage only.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，每当需要时，我们将展示这些机制的更复杂用法，但目前我们只关注理解它们的基本用法。
- en: Tasklets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tasklets
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来做：
- en: 'The following modifications are needed to add a custom tasklet invocation to
    our `irqtest_interrupt()` interrupt handler:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要以下修改来将自定义 tasklet 调用添加到我们的 `irqtest_interrupt()` 中断处理程序中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous patch can be found in the GitHub resources in the `add_tasklet_to_irqtest_module.patch`
    file, and it can be applied as usual with the
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的补丁可以在 GitHub 资源中的 `add_tasklet_to_irqtest_module.patch` 文件中找到，并且可以像往常一样应用。
- en: '**`patch -p1 < add_tasklet_to_irqtest_module.patch`** command.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**`patch -p1 < add_tasklet_to_irqtest_module.patch`** 命令。'
- en: Once the tasklet has been defined, it can be invoked by using the `tasklet_schedule()`
    function as shown previously. To stop it, we can use the `tasklet_kill()` function,
    which was in our example for the `irqtest_remove()` function to stop the tasklet
    before unloading the module from the kernel. In fact, we must make sure that every
    resource previously allocated and/or enabled by our driver has been disabled and/or
    released before unloading our module or a memory corruption can occur.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 tasklet 被定义，就可以使用 `tasklet_schedule()` 函数来调用它，就像之前展示的那样。要停止它，我们可以使用 `tasklet_kill()`
    函数，在我们的示例中用于 `irqtest_remove()` 函数来在从内核中卸载模块之前停止 tasklet。实际上，我们必须确保在卸载模块之前，我们的驱动程序之前分配和/或启用的每个资源都已被禁用和/或释放，否则可能会发生内存损坏。
- en: 'Note that the compile-time usage of `DECLARE_TASKLET()` is not the only way
    to declare a tasklet. In fact, the following is an alternate way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`DECLARE_TASKLET()` 的编译时使用并不是声明 tasklet 的唯一方式。实际上，以下是另一种方式：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we create our tasklet as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的 tasklet 如下：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding patch can be found in the GitHub resources in the `add_tasklet_2_to_irqtest_module.patch`
    file, and it can be applied as usual with the
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的补丁可以在 GitHub 资源中的 `add_tasklet_2_to_irqtest_module.patch` 文件中找到，并且可以像往常一样应用。
- en: '**`patch -p1 < add_tasklet_2_to_irqtest_module.patch`** command.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**`patch -p1 < add_tasklet_2_to_irqtest_module.patch`** 命令。'
- en: This second form is useful when we have to embed a tasklet inside a device structure
    and then generate it dynamically.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须在设备结构中嵌入 tasklet 并动态生成它时，这种第二种形式是有用的。
- en: Workqueues
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作队列
- en: 'Let''s now take a look at workqueues. In the following example, we add a custom
    workqueue referenced by the `irqtest_wq` pointer and named `irqtest`, which, in
    turn, executes two different works described by the `work` and `dwork` structures:
    the former is a normal work, while the latter represents a delayed work, that
    is, a work that is executed after a well-known delay.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看工作队列。在下面的示例中，我们添加了一个自定义工作队列，由 `irqtest_wq` 指针引用，并命名为 `irqtest`，它执行两种不同的工作，由
    `work` 和 `dwork` 结构描述：前者是正常工作，而后者代表延迟工作，即在经过一段时间延迟后执行的工作。
- en: 'First of all, we have to add our data structures:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须添加我们的数据结构：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All these modifications can be found in the GitHub resources in the `add_workqueue_to_irqtest_module.patch`
    file and it can be applied as usual with the
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些修改都可以在 GitHub 资源中的 `add_workqueue_to_irqtest_module.patch` 文件中找到，并且可以像往常一样应用。
- en: '**`patch -p1 < add_workqueue_to_irqtest_module.patch`** command.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**`patch -p1 < add_workqueue_to_irqtest_module.patch`** 命令。'
- en: 'Then, we have to create the workqueue and it works. For the workqueue creation,
    we can use the `create_singlethread_workqueue()` function, while the two works
    can be initialized by using `INIT_WORK()` and `INIT_DELAYED_WORK(),`, shown as
    follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建工作队列并使其工作。对于工作队列的创建，我们可以使用 `create_singlethread_workqueue()` 函数，而两个工作可以通过使用
    `INIT_WORK()` 和 `INIT_DELAYED_WORK()` 进行初始化，如下所示：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To create a workqueue, we can also use the `create_workqueue()` function; however,
    this creates a workqueue that has a dedicated thread for each processor on the
    system. In many cases, all those threads are simply overkilled and the single
    worker thread obtained with `create_singlethread_workqueue()` will suffice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建工作队列，我们也可以使用 `create_workqueue()` 函数；然而，这会创建一个在系统上每个处理器都有专用线程的工作队列。在许多情况下，所有这些线程都是多余的，使用
    `create_singlethread_workqueue()` 获得的单个工作线程就足够了。
- en: Note that the Concurrency Managed Workqueue API, available in the kernel's documentation
    file (`linux/Documentation/core-api/workqueue.rst`), states that the `create_*workqueue()`
    functions are deprecated and scheduled for removal. However, they seem to be still
    widely used with kernel sources.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内核文档文件（`linux/Documentation/core-api/workqueue.rst`）中提供的并发管理工作队列 API 表明，`create_*workqueue()`
    函数已被弃用并计划移除。然而，它们似乎仍然广泛用于内核源代码中。
- en: 'Next are the handlers bodies representing the effective workloads for the normal
    workqueue and the delayed workqueue, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是处理程序体，表示正常工作队列和延迟工作队列的有效工作负载，如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that to specify a delay of two seconds we used the `2*HZ `code, where `HZ`
    is a define (see the next section for further information about `HZ`) representing
    how many jiffies are needed to compose one second. So, to have a delay of two
    seconds, we have to multiply `HZ` by two.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了指定两秒的延迟，我们使用了`2*HZ`代码，其中`HZ`是一个定义（有关`HZ`的更多信息，请参见下一节），表示需要多少个jiffies来组成一秒。因此，为了延迟两秒，我们必须将`HZ`乘以二。
- en: 'The interrupt handler now just uses the following `queue_work()` function to
    execute the first workqueue before returning:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断处理程序现在只使用以下`queue_work()`函数来在返回之前执行第一个工作队列：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, when `irqtest_interrupt()` ends, the system invokes `irqtest_work_handler()`
    which in turn, invokes `irqtest_dwork_handler()` with a two-second delay by using
    `queue_delayed_work()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`irqtest_interrupt()`结束时，系统会调用`irqtest_work_handler()`，然后调用`irqtest_dwork_handler()`，使用`queue_delayed_work()`来延迟两秒。
- en: 'Finally, as for tasklets, before exiting the module, we have to cancel all
    works and workqueues (if created) by using `cancel_work_sync()` for normal work,
    `cancel_delayed_work_sync()` for delayed work, and (in our case) `flush_workqueue()`
    to stop the `irqtest` workqueue:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于任务队列，在退出模块之前，我们必须使用`cancel_work_sync()`取消所有工作和工作队列（如果已创建），对于延迟工作，使用`cancel_delayed_work_sync()`，以及（在我们的情况下）使用`flush_workqueue()`来停止`irqtest`工作队列：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can check how it works, by testing our examples. So, we have to apply the
    desired patch and then we have to recompile the kernel, reinstalling and rebooting
    the ESPRESSObin.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测试示例来检查它的工作原理。因此，我们必须应用所需的补丁，然后重新编译内核，重新安装并重新启动ESPRESSObin。
- en: Tasklets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务队列
- en: 'To test tasklets, we can do exactly as before, that is, connecting pin 12 to
    pin 1 of extension connector P8\. The following are the kernel messages we should
    get:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试任务队列，我们可以像以前一样，将引脚12连接到扩展连接器P8的引脚1。以下是我们应该收到的内核消息：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As expected, an IRQ is generated and then managed by the hardware `irqtest_interrupt()`
    interrupt handler that, in turn, executes the `irqtest_tasklet_handler()`. tasklet
    handler.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，会生成一个中断，然后由硬件`irqtest_interrupt()`中断处理程序来管理，然后执行`irqtest_tasklet_handler()`任务处理程序。
- en: Workqueues
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作队列
- en: 'To test workqueues, we have to short circuit our well known pins, and we should
    have an output as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试工作队列，我们必须短接我们熟悉的引脚，然后应该有以下输出：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that, this time, I didn't remove the first part of kernel messages, in
    order to see timings, and to better evaluate delay between the normal work and
    delayed one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我没有删除内核消息的第一部分，以便查看时间，并更好地评估正常工作和延迟工作之间的延迟。
- en: As we can see, as soon as we connect ESPRESSObin pins, we have several interrupts
    followed by the work, but the delayed work is executed just once. This happens
    because, even if scheduled several times, it's just the first invocation that
    takes effect, and so here we can see that the delayed work has been finally executed
    2.025106 seconds after its first `schedule_work()` invocation. This also means
    that it has been effectively executed 25.106 ms later than the required and expected
    two seconds. Such an apparent anomaly is due to the fact that, when you ask the
    kernel to schedule some work to happen at a later point in time with a delayed
    workqueue, the kernel will certainly schedule your work at the desired point in
    the future, but it won't guarantee you that it will be executed at exactly that
    point in time. It will only assure you that such work won't be executed any earlier
    than the requested deadline. The length of such an additional random delay depends
    on the level of system workload at the time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一旦连接ESPRESSObin引脚，我们会有几个中断，然后是工作，但延迟的工作只执行一次。这是因为，即使安排了多次，只有第一次调用才会生效，因此我们可以看到延迟的工作最终在第一次`schedule_work()`调用后的2.025106秒后执行。这也意味着它实际上比所需和预期的两秒晚了25.106毫秒。这种明显的异常是由于当您要求内核安排一些工作在将来的某个时间点执行时，内核肯定会在未来的所需时间点安排您的工作，但它不会保证您会在那个时间点执行。它只会保证这样的工作不会在请求的截止日期之前执行。这种额外的随机延迟的长度取决于当时系统的工作负载水平。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Regarding tasklets, you may wish to take a look at [https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html.](https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于任务队列，您可能希望查看[https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html.](https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html)
- en: For workqueues, more information is available at [https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html](https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关工作队列的更多信息，请访问[https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html](https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html)。
- en: Managing time with kernel timers
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核定时器管理时间
- en: During the device driver development, it may be necessary to perform several
    repeated operations at specific moments in time, or we may have to postpone the
    execution of some code after a well-defined delay. In these situations, kernel
    timers come to help the device driver developer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备驱动程序开发过程中，可能需要在特定时刻执行多次重复操作，或者需要延迟一些代码的执行。在这些情况下，内核定时器可以帮助设备驱动程序开发人员。
- en: In this recipe, we will see how to use kernel timers to do repeated jobs at
    well-defined periods of time, or to defer a job until after a well-defined time
    interval.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何使用内核定时器在明确定义的时间间隔内执行重复的工作，或者在明确定的时间间隔之后延迟工作。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For a simple example of kernel timers, we can still use a kernel module where
    we define a kernel timer during a module's initialization function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内核定时器的一个简单示例，我们仍然可以使用一个内核模块，在模块的初始化函数中定义一个内核定时器。
- en: In the `chapter_05/timer` directory of GitHub resources, there are two simple
    examples about **kernel timers** (**ktimer**) and **high-resolution timers** (**hrtimer**),
    and in the next sections we're going to explain them in detail, starting with
    the new high-resolution implementation, which should be preferred in new drivers.
    An old API is also presented to complete the picture.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub资源的`chapter_05/timer`目录中，有两个关于**内核定时器**（**ktimer**）和**高分辨率定时器**（**hrtimer**）的简单示例，在接下来的章节中，我们将详细解释它们，首先从新的高分辨率实现开始，这应该是新驱动程序中首选的。还介绍了旧的API以完整图片。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following main parts of the `hires_timer.c` file contain a simple example
    about high resolution kernel timers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`hires_timer.c`文件的以下主要部分包含了有关高分辨率内核定时器的简单示例。'
- en: 'Let''s start from the end of the file, with the module `init()` function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从文件的末尾开始，使用模块`init()`函数：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see where the module `exit()` function is located:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模块`exit()`函数的位置：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we can see in module `hires_timer_init()` initialization function, we read
    the `delay_ns` parameter, and, using the `hrtimer_init()` function, we first initialize
    the timer by specifying some features:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在模块`hires_timer_init()`初始化函数中所看到的，我们读取`delay_ns`参数，并且使用`hrtimer_init()`函数，首先通过指定一些特性来初始化定时器：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the `which_clock` argument, we ask the kernel to use a particular clock.
    In our example, we used `CLOCK_MONOTONIC`, which is very useful for reliable timestamps
    and measuring short time intervals accurately (it starts at system boot time but
    stops during suspend), but we can use other values (see `linux/include/uapi/linux/time.h`
    header file for the complete list), for example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`which_clock`参数，我们要求内核使用特定的时钟。在我们的示例中，我们使用了`CLOCK_MONOTONIC`，这对于可靠的时间戳和准确测量短时间间隔非常有用（它从系统启动时间开始，但在挂起期间停止），但我们也可以使用其他值（请参阅`linux/include/uapi/linux/time.h`头文件以获取完整列表），例如：
- en: '`CLOCK_BOOTTIME`: This clock is like `CLOCK_MONOTONIC` but does not stop when
    the system goes into suspend mode. This can be useful for key expiration times
    that need to be synchronized with other machines across a suspend operation.'
  id: totrans-199
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_BOOTTIME`：这个时钟类似于`CLOCK_MONOTONIC`，但当系统进入挂起模式时不会停止。这对于需要与挂起操作同步的关键到期时间非常有用。'
- en: '`CLOCK_REALTIME`: This clock uses the time as relative to the UNIX epoch starting
    in 1970 using the **Coordinated Universal Time** (**UTC**) as `gettimeofday()`
    does in userspace. This is used for all timestamps that need to persist across
    a reboot, since it can jump backward due to a leap second update, **Network Time
    Protocol (NTP)** adjustment with the `settimeofday()` operation from the userspace.
    However, this clock is rarely used for device drivers.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_REALTIME`：这个时钟使用相对于1970年开始的UNIX纪元时间，使用**协调世界时**（**UTC**），就像`gettimeofday()`在用户空间中一样。这用于所有需要在重启后持续存在的时间戳，因为它可能会由于闰秒更新，**网络时间协议（NTP）**调整以及来自用户空间的`settimeofday()`操作而向后跳跃。但是，这个时钟在设备驱动程序中很少使用。'
- en: '`CLOCK_MONOTONIC_RAW`: Like `CLOCK_MONOTONIC` but runs at the same rate as
    the hardware clock source without adjustments for clock drift (like NTP has).
    This is also rarely needed in device drivers.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_MONOTONIC_RAW`：类似于`CLOCK_MONOTONIC`，但以硬件时钟源的相同速率运行，不会对时钟漂移进行调整（例如NTP）。这在设备驱动程序中也很少需要。'
- en: 'After the timer initialization, we have to set up the callback or handler function
    by using the `function` pointer as follows, where we''ve set `timer.function`
    to `hires_timer_handler`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定时器初始化后，我们必须通过使用`function`指针来设置回调或处理函数，如下所示，我们已将`timer.function`设置为`hires_timer_handler`：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This time, the `hires_tinfo` module data structure is defined as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`hires_tinfo`模块数据结构定义如下：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After the timer has been initialized, we can start it by calling `hrtimer_start()`
    where we just set the expiry time with a function like `ns_to_ktime()` , in case
    we have a time interval, or by using `ktime_set()` , in case we have a seconds/nanoseconds
    value.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定时器初始化后，我们可以通过调用`hrtimer_start()`来启动它，在这里我们只需使用`ns_to_ktime()`这样的函数设置到期时间，以防我们有一个时间间隔，或者使用`ktime_set()`，以防我们有秒/纳秒值。
- en: See the `linux/include/linux/ktime.h` header for more of the `ktime*()` functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`linux/include/linux/ktime.h`头文件，了解更多`ktime*()`函数。
- en: 'If we take a look at the `linux/include/linux/hrtimer.h` file, we discover
    that the main function to start a high-resolution timer is `hrtimer_start_range_ns()`
    and `hrtimer_start()` is a particular case of that function, as can be seen in
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`linux/include/linux/hrtimer.h`文件，我们会发现启动高分辨率定时器的主要函数是`hrtimer_start_range_ns()`，而`hrtimer_start()`是该函数的一个特例，如下所示：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We also discover that the `HRTIMER_MODE_SOFT` mode should not be used apart
    from for debugging purposes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现`HRTIMER_MODE_SOFT`模式除了用于调试目的外，不应该使用。
- en: By using the `hrtimer_start_range_ns()` function, we allow a `range_ns` delta
    time, which gives the kernel the freedom to schedule the actual wake up to a time
    that is both power and performance friendly. The kernel gives the normal best
    effort behavior for expiry time plus delta, but may decide to fire the timer earlier,
    but no earlier than the `tim` expiry time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hrtimer_start_range_ns()`函数，我们允许`range_ns`时间差，这使得内核可以自由地安排实际的唤醒时间，以便既节能又性能友好。内核对到期时间加上时间差提供了正常的尽力而为的行为，但可能决定提前触发定时器，但不会早于`tim`到期时间。
- en: 'The `hires_timer_handler()` function from the `hires_timer.c` file is an example
    of the callback function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hires_timer.c`文件中的`hires_timer_handler()`函数是回调函数的一个示例：'
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By using the `container_of()` operator, we can take a pointer to our data structure
    (defined in the example as `struct hires_timer_data`) and, then, having completed
    our job, we call `hrtimer_forward_now()` to set up a new expiry time, and, by
    returning the `HRTIMER_RESTART` value, we ask the kernel to restart the timer.
    For one-shot timers, we can return `HRTIMER_NORESTART`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`container_of()`操作符，我们可以获取指向我们的数据结构的指针（在示例中定义为`struct hires_timer_data`），然后，在完成工作后，我们调用`hrtimer_forward_now()`来设置新的到期时间，并通过返回`HRTIMER_RESTART`值，要求内核重新启动定时器。对于一次性定时器，我们可以返回`HRTIMER_NORESTART`。
- en: On the module exit, within the `hires_timer_exit()` function, we must use the
    `hrtimer_cancel()` function to wait for the timer to stop. It's really important
    to wait for the timer to stop, because timers are asynchronous events and it may
    happen that we remove the `struct hires_timer_data` module freeing structure while
    the timer callback is executing, which can result in a severe memory corruption!
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块退出时，在`hires_timer_exit()`函数中，我们必须使用`hrtimer_cancel()`函数等待定时器停止。等待定时器停止是非常重要的，因为定时器是异步事件，可能会发生我们在定时器回调执行时移除`struct
    hires_timer_data`模块释放结构，这可能导致严重的内存损坏！
- en: Note that syncing is implemented as a sleep (or suspend) `process,` and it means
    that the `hrtimer_cancel()` function cannot be called when we're in interrupt
    context (hard or soft). However, in these situations, we can use `hrtimer_try_to_cancel()`,
    which simply returns a non-negative value if the timer has been correctly stopped
    (or is simply not active).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同步是作为一个睡眠（或挂起）`进程`实现的，这意味着当我们处于中断上下文（硬或软）时，不能调用`hrtimer_cancel()`函数。然而，在这些情况下，我们可以使用`hrtimer_try_to_cancel()`，它只是在定时器正确停止（或根本不活动）时返回一个非负值。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To see how it works, we test our code by simply compiling it as usual and then
    move the code to our ESPRESSObin. When everything is in place, we just have to
    load the module into the kernel as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看它是如何工作的，我们通过简单地编译代码然后将代码移动到我们的ESPRESSObin上来测试我们的代码。当一切就绪时，我们只需要将模块加载到内核中，如下所示：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, in kernel messages, we should get something like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在内核消息中，我们应该得到类似以下的内容：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In *steps 1*, *2*, and *3* we set up the timer, and here we know that it has
    been started with a delay of one second.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*、*2*和*3*中设置了定时器，我们知道它已经以一秒的延迟启动。
- en: 'When the timer expires, thanks to step 4, we execute the kernel timer''s handler:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器到期时，由于步骤4，我们执行内核定时器的处理程序：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I've left the timings so you have an idea about kernel timer's precision.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我留下了时间，这样你就能了解内核定时器的精度。
- en: As we can see, the expiration time is really accurate (a few microseconds).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，到期时间非常准确（几微秒）。
- en: 'Now, thanks to *step 5*, if we remove the module, the timer is stopped, as
    the following shows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于*步骤5*，如果我们移除模块，定时器会停止，如下所示：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Just to complete your understanding, it could be interesting to take a look
    at the legacy kernel timer API.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善你的理解，看一下传统内核定时器API可能会很有趣。
- en: Legacy kernel timers
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统内核定时器
- en: 'The `ktimer.c` file contains a simple example of legacy kernel timers. As usual,
    let''s start from the end of the file where the module `init()` and `exit()` functions
    are located:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ktimer.c`文件包含了传统内核定时器的一个简单示例。和往常一样，让我们从文件末尾开始，那里是模块`init()`和`exit()`函数所在的地方：'
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The module data structure with the handler function is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 具有处理程序函数的模块数据结构如下：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we can see, this implementation is very similar to high-resolution timers.
    In fact in the `ktimer_init()` initialization function, we read the module `delay_ms`
    parameter and, by using `msecs_to_jiffies()`, we translate its value into jiffies,
    which are the unit of measurement of kernel timers. (Remember that legacy kernel
    timers have a lower time limit set to one jiffy.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个实现与高分辨率定时器非常相似。实际上，在`ktimer_init()`初始化函数中，我们读取模块的`delay_ms`参数，并通过使用`msecs_to_jiffies()`将其值转换为jiffies，这是内核定时器的计量单位。（请记住，传统内核定时器的时间限制设置为一个jiffy。）
- en: 'Then, we use the `timer_setup()` and `mod_timer()` functions to respectively
    set up the kernel timer and to start it. The `timer_setup()` function takes three
    arguments:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`timer_setup()`和`mod_timer()`函数分别设置内核定时器并启动它。`timer_setup()`函数接受三个参数：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A variable `timer` of the `struct timer_list` type, a function `callback` (or
    handler), and some flags (within `flags` variable) which can be used to specify
    some particular features of our kernel timer. Just to give you an idea about available
    flags and their meanings, here are some flag definitions from the `linux/include/linux/timer.h`
    file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct timer_list`类型的变量`timer`，一个`callback`（或处理程序）函数，以及一些标志（在`flags`变量中）可以用来指定我们内核定时器的一些特殊特性。为了让你了解可用标志及其含义，以下是`linux/include/linux/timer.h`文件中的一些标志定义：'
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With regard to the callback function, let''s look at `ktimer_handler()` from
    our example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 关于回调函数，让我们看一下我们示例中的`ktimer_handler()`：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By using `from_timer()` , we can take a pointer to our data structure (defined
    in the example as `struct ktimer_data`), then, after having completed our job,
    we can call again `mod_timer()` to reschedule a new timer execution; otherwise,
    everything will stop.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`from_timer()`，我们可以获取到我们数据结构的指针（在示例中定义为`struct ktimer_data`），然后，在完成工作后，我们可以再次调用`mod_timer()`来重新安排新的定时器执行；否则，一切都会停止。
- en: 'Note that the `from_timer()` function still uses `container_of()` to do its
    job, as the following definition from the `linux/include/linux/timer.h` file shows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`from_timer()`函数仍然使用`container_of()`来完成其工作，如`linux/include/linux/timer.h`文件中的以下定义所示：
- en: '`#define from_timer(var, callback_timer, timer_fieldname) \`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define from_timer(var, callback_timer, timer_fieldname) \`'
- en: '`container_of(callback_timer, typeof(*var), timer_fieldname)`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_of(callback_timer, typeof(*var), timer_fieldname)`.'
- en: On the module exit, within the `ktimer_exit()` function, we must use the `del_timer_sync()`
    function to wait for the timer to stop. Whatever we stated previously regarding
    waiting for exit is still valid, so, to stop a kernel timer from an interrupt
    context, we can use `try_to_del_timer_sync()`, which simply returns a non-negative
    value if the timer has been correctly stopped.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块退出时，在`ktimer_exit()`函数中，我们必须使用`del_timer_sync()`函数等待定时器停止。我们之前关于等待退出的陈述仍然有效，因此，要从中断上下文中停止内核定时器，我们可以使用`try_to_del_timer_sync()`，它只是在定时器正确停止时返回一个非负值。
- en: 'To test our code, we simply need to compile and then move it to our ESPRESSObin,
    then we can load the module into the kernel as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的代码，我们只需要编译然后将其移动到我们的ESPRESSObin，然后我们可以按照以下方式将模块加载到内核中：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, in the kernel messages, we should get something like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在内核消息中，我们应该得到类似这样的内容：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Again, I've left the timings to give you an idea about kernel timer's precision.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我留下了时间，让你了解内核定时器的精度。
- en: Here, we discover that 1,000 ms is equal to 250 jiffies; that is, 1 jiffy is
    4 ms, and also we can see that timer's handler is executed more or less every
    second. (With a jitter very near to 4 ms, that is 1 jiffy.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现1000毫秒等于250个jiffies；也就是说，1个jiffy等于4毫秒，我们还可以看到定时器的处理程序大约每秒执行一次。（与4毫秒非常接近的抖动，即1个jiffy。）
- en: 'When we remove the module the timer is stopped as shown as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除模块时，定时器会停止，如下所示：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: See also
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Interesting documentation about high-resolution kernel timers is in the kernel
    sources at `linux/Documentation/timers/hrtimers.txt`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关高分辨率内核定时器的有趣文档在内核源代码中的`linux/Documentation/timers/hrtimers.txt`。
- en: Waiting for an event
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待事件
- en: In previous sections, we saw how to manage an interrupt directly in its handler
    or by deferring the interrupt activities by using tasklets, workqueues, and so
    on. Also, we saw how to do periodic operations or how to delay an action forward
    in time; however, a device driver may need to wait for a specific event, such
    as waiting for some data, waiting for a buffer to become full, or a for a variable
    to reach a desired value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到如何直接在处理程序中管理中断，或者通过使用任务队列、工作队列等来推迟中断活动。此外，我们还看到如何执行周期性操作或如何将操作延迟到未来；然而，设备驱动程序可能需要等待特定事件，例如等待某些数据、等待缓冲区变满，或者等待变量达到所需值。
- en: Please don't confuse events managed by the notifiers, we saw before, which are
    kernel related, with generic events for a specific driver.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要混淆之前看到的由通知程序管理的与特定驱动程序相关的内核相关事件，与通用事件。
- en: When there is no data to be read from a peripheral, the reading process must
    be put on sleep and then awakened when the "data ready" event arrives. Another
    example is when we start a complex job and we wish to be signaled when it's finished;
    in this case, we start the job and then we go to sleep until the "job finished"
    event arrives. All these tasks can be done by using **waiting queues** (waitqueues)
    or **completions** (which are still implemented by waitqueues).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有数据可以从外围设备中读取时，读取进程必须进入睡眠状态，然后在“数据准备就绪”事件到达时被唤醒。另一个例子是当我们启动一个复杂的作业并希望在完成时得到信号；在这种情况下，我们启动作业，然后进入睡眠状态，直到“作业完成”事件到达。所有这些任务都可以通过使用**等待队列**（waitqueues）或**完成**（仍然由等待队列实现）来完成。
- en: A waiting queue (or a completion) is just a queue where one or more processes
    stays waiting for the event related to the queue; when the event arrives, one,
    more than one, or even all sleeping processes are awakened in order to allow someone
    to manage it. In this recipe, we will learn how to use a waitqueue.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 等待队列（或完成）只是一个队列，其中一个或多个进程等待与队列相关的事件；当事件到达时，一个、多个或甚至所有睡眠进程都会被唤醒，以便让某人来管理它。在这个示例中，我们将学习如何使用等待队列。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to prepare a simple example about waiting queues, we can again use
    a kernel module where we define a kernel timer during the module initialization
    function, which has the task of generating our event, and then we use a waitqueue
    or completion to wait for it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备一个关于等待队列的简单示例，我们可以再次使用一个内核模块，在该模块的初始化函数中定义一个内核定时器，该定时器的任务是生成我们的事件，然后我们使用等待队列或完成来等待它。
- en: In the `chapter_05/wait_event` directory of GitHub resources, there are two
    simple examples about waitqueues and completions, then, in the *How it works...*
    section, we're going to explain them in detail.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub资源的`chapter_05/wait_event`目录中，有两个关于等待队列和完成的简单示例，然后在*工作原理...*部分，我们将详细解释它们。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, let's see a simple example regarding a waitqueue used to wait for the
    "data is greater then 5" event.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个关于等待队列用于等待“数据大于5”事件的简单示例。
- en: Waitqueues
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待队列
- en: The following is the main part of the `waitqueue.c` file, which holds a simple
    example about waitqueues.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`waitqueue.c`文件的主要部分，其中包含有关等待队列的简单示例。
- en: 'Again let''s start from the end, to see the module `init()` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从末尾开始，看一下模块的`init()`函数：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After the kernel timer has been started, we can use the `wait_event_interruptible()`
    function to wait for the `wqinfo.data > 5` event on the `wqinfo.waitq` waitqueue,
    shown as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 内核定时器启动后，我们可以使用`wait_event_interruptible()`函数在`wqinfo.waitq`等待队列上等待`wqinfo.data
    > 5`事件，如下所示：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The data structure is now defined, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义了数据结构，如下所示：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: However, before any action can happen on the waitqueue, it must initialized,
    so, before starting the kernel timer, we use the `init_waitqueue_head()` function
    to properly set up `struct wait_queue_head waitq` stored in `struct ktimer_data`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在等待队列上发生任何操作之前，必须进行初始化，因此，在启动内核定时器之前，我们使用`init_waitqueue_head()`函数来正确设置存储在`struct
    ktimer_data`中的`struct wait_queue_head waitq`。
- en: 'If we take a look in the `linux/include/linux/wait.h` header, we can see how
    `wait_event_interruptible()` works:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`linux/include/linux/wait.h`头文件，我们可以看到`wait_event_interruptible()`的工作原理：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To see how to awake the sleeping processes, we should consider the kernel timer
    handler in the `waitqueue.c` file named `ktimer_handler()`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解如何唤醒睡眠进程，我们应该考虑`waitqueue.c`文件中名为`ktimer_handler()`的内核定时器处理程序：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Completions
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成
- en: If we wish to wait for a job to complete, we still can use a waitqueue, but
    it's better to use a completion that (as the name says) is specifically designed
    to carry out such activities. Here is a simple example, which can be retrieved
    from the `completion.c` file of GitHub resources about competitions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望等待作业完成，我们仍然可以使用等待队列，但最好使用完成，因为它专门设计用于执行此类活动。以下是一个简单的示例，可以从GitHub关于竞赛的`completion.c`文件中检索到。
- en: 'First of all, let''s see the module `init()` and `exit()` functions:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看模块`init()`和`exit()`函数：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The module data structure is now like the following:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模块的数据结构如下：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When the job is done, we can signal it as done to the `ktimer_handler ()` kernel
    timer handler by using the `complete()` function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作业完成后，我们可以使用`complete()`函数向`ktimer_handler()`内核定时器处理程序发出完成信号：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When `complete()` is called, a single thread waiting on the completion is signaled:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`complete()`时，等待完成的单个线程被通知：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'While if we call `complete_all()`, all threads waiting for the completion are
    signaled:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 而如果我们调用`complete_all()`，所有等待完成的线程都会被通知：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s see how this works in the following sections:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中看看这是如何工作的：
- en: Waitqueues
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待队列
- en: In step 3, the calling process simply continues its execution if the condition
    is true; otherwise, it goes to sleep until the condition becomes true or a signal
    is received. (In this case the function returns the `-ERESTARTSYS` value.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中，如果条件为真，调用进程将继续执行；否则，它会进入睡眠状态，直到条件变为真或收到信号。（在这种情况下，函数返回`-ERESTARTSYS`值。）
- en: 'For a complete understanding, we should notice that there are two other variants
    of waiting event functions defined in the `linux/include/linux/wait.h` header.
    The first variant is just the `wait_event()` function, which works exactly as
    `wait_event_interruptible()`, but it cannot be interrupted by any signal:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解，我们应该注意`linux/include/linux/wait.h`头文件中定义的另外两个等待事件函数的变体。第一个变体就是`wait_event()`函数，它的工作方式与`wait_event_interruptible()`完全相同，但它不能被任何信号中断：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'While the second is `wait_event_timeout()` or `wait_event_interruptible_timeout()`,
    which works in the same way until a timeout elapses:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 而第二个是`wait_event_timeout()`或`wait_event_interruptible_timeout()`，它的工作方式与之前相同，直到超时为止：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In *step 4*, in this function, we change the value stored into data and then
    we use `wake_up_interruptible()` on the waitqueue in order to signal a sleeping
    process that the data has been changed, and it should awake to test if the conditions
    are true.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，在这个函数中，我们改变了存储在数据中的值，然后我们在等待队列上使用`wake_up_interruptible()`来通知一个正在睡眠的进程数据已经被改变，它应该醒来测试条件是否为真。
- en: 'In the `linux/include/linux/wait.h` header, there are several functions defined
    that are used to wake up one, more than one, or just all waiting processes (interruptible
    or not) by using a common `__wake_up()` function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`linux/include/linux/wait.h`头文件中，定义了几个函数，用于通过使用通用的`__wake_up()`函数唤醒一个、多个或所有等待进程（可中断或不可中断）：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In our example, we asked for data greater than five, so the first five calls
    of `wake_up_interruptible()` should not awake our process; let's verify it in
    the next section!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们要求数据大于五，所以前五次调用`wake_up_interruptible()`不应该唤醒我们的进程；让我们在下一节中验证一下！
- en: Note that the process that will go to sleep is just the `insmod` command, which
    is the one that calls the module initialization function.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将进入睡眠状态的进程只是`insmod`命令，它是调用模块初始化函数的命令。
- en: Completions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成
- en: In *step 1*, we can see the code is quite similar to the previous waitqueue
    example; we simply use the `init_completion()` function to initialize the completion
    as usual, and then we call `wait_for_completion()` on `struct completion done`
    within the `struct ktimer_data` structure to wait for the job ending.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们可以看到代码与之前的等待队列示例非常相似；我们只是使用`init_completion()`函数像往常一样初始化完成，然后在`struct
    ktimer_data`结构中的`struct completion done`上调用`wait_for_completion()`来等待作业结束。
- en: 'As for waitqueues, inside the `linux/include/linux/completion.h` header, we
    can find several variants of the `wait_for_completion()` function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 至于等待队列，在`linux/include/linux/completion.h`头文件中，我们可以找到`wait_for_completion()`函数的几个变体：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's more...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, to test our code in both cases, we have to compile the kernel modules and
    then move them on the ESPRESSObin; moreover, in order to better understand how
    the example works, we should use an SSH connection and then look for the kernel
    messages on the serial console from another terminal window.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在两种情况下测试我们的代码，我们必须编译内核模块，然后将它们移动到ESPRESSObin上；此外，为了更好地理解示例的工作原理，我们应该使用SSH连接，然后从另一个终端窗口查看串行控制台上的内核消息。
- en: Waitqueues
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待队列
- en: 'When we insert the `waitqueue.ko` module with `insmod`, as follows, we should
    notice that the process is suspended until the data becomes greater than five:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`insmod`插入`waitqueue.ko`模块时，应该注意到该进程被挂起，直到数据变大于五为止：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When the `insmod` process is suspended, you should not get the prompt until
    the test is finished.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当`insmod`进程被挂起时，直到测试完成，你不应该得到提示。
- en: 'On the serial console, we should get the following messages:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行控制台上，我们应该收到以下消息：
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As soon as the `got event data > 5` message is shown on the screen, the `insmod`
    process should return, and a new prompt should be displayed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦屏幕上显示了`got event data > 5`的消息，`insmod`进程应该返回，并且应该显示一个新的提示。
- en: 'To verify that `wait_event_interruptible()` returns with `-ERESTARTSYS`, when
    a signal arrives, we can unload the module and the reload it, then just press
    *CTRL*+*C* keys before data reaches 5:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`wait_event_interruptible()`在信号到达时返回`-ERESTARTSYS`，我们可以卸载模块，然后重新加载它，然后在数据达到5之前按下*CTRL*+*C*键：
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This time in the kernel messages, we should get something like the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这次在内核消息中，我们应该得到类似以下的内容：
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Completions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成
- en: 'To test completions, we have to insert the `completion.ko` module into the
    kernel. Now you should notice that if we press *CTRL*+*C* nothing happens because
    we used `wait_for_completion()` instead of `wait_for_completion_interruptible()`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试完成，我们必须将`completion.ko`模块插入内核。现在你应该注意到，如果我们按下*CTRL*+*C*，什么都不会发生，因为我们使用了`wait_for_completion()`而不是`wait_for_completion_interruptible()`：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then the prompt returns after five seconds and the kernel messages are something
    like the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在五秒后提示返回，内核消息类似以下内容：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Although slightly outdated, there is some good information about waitqueues
    at URL [https://lwn.net/Articles/577370/](https://lwn.net/Articles/577370/).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然有点过时，但在[https://lwn.net/Articles/577370/](https://lwn.net/Articles/577370/)的URL上有一些关于等待队列的好信息。
- en: Performing atomic operations
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行原子操作
- en: Atomic operations are a crucial step during device driver development. In fact,
    a driver is not like a normal program that executes from the beginning till the
    end, as it provides several methods (for example, read or write data to a peripheral,
    or set some communication parameters), which can be called asynchronously one
    to another. All these methods operate concurrently on common data structures that
    must be modified in a consistent manner. That's why we need to be able to perform
    atomic operations.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作在设备驱动程序开发中是至关重要的一步。事实上，驱动程序不像一个从头到尾执行的普通程序，因为它提供了多种方法（例如，读取或写入外围设备的数据，或设置一些通信参数），这些方法可以异步地相互调用。所有这些方法都同时在共同的数据结构上操作，这些数据结构必须以一致的方式进行修改。这就是为什么我们需要能够执行原子操作。
- en: The Linux kernel uses a large variety of atomic operations. Each is used for
    different operations, depending on whether the CPU is running in an interrupt
    or process context.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用各种原子操作。每个操作用于不同的操作，取决于CPU是否在中断或进程上下文中运行。
- en: When the CPU is in the process context, we can safely use **mutexes,** which
    can put the current running process to sleep if the mutex is locked; however,
    in an interrupt context "going to sleep" is not allowed so we need another mechanism,
    and Linux gives us **spinlocks**, which allow locking everywhere, but for short
    periods of time. This happens because spinlocks get their job done performing
    a busy-waiting tight-loop on the current CPU, and, if we stay too long, we can
    lose performance.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU处于进程上下文时，我们可以安全地使用**互斥锁**，如果互斥锁被锁定，可以使当前运行的进程进入睡眠状态；然而，在中断上下文中，“进入睡眠”是不允许的，因此我们需要另一种机制，Linux给了我们**自旋锁**，它允许在任何地方进行锁定，但是时间很短。这是因为自旋锁通过在当前CPU上执行一个忙等待的紧密循环来完成工作，如果我们停留时间太长，就会损失性能。
- en: In this recipe, we'll see how to do operations on data in an uninterruptible
    manner in order to avoid data corruption.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何以不可中断的方式对数据进行操作，以避免数据损坏。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Again, to build our examples, we can use a kernel module that defines a kernel
    timer during the module `init()` function, which has the task of generating an
    asynchronous execution where we can use our mutual exclusion mechanism to protect
    our data.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了构建我们的示例，我们可以使用一个定义了内核定时器的内核模块，在模块`init()`函数中，它负责生成一个异步执行，我们可以在其中使用我们的互斥机制来保护我们的数据。
- en: In the `chapter_05/atomic` directory of GitHub resources, there are simple examples
    of mutexes, spinlocks, and atomic data, and, in the next sections, we're going
    to explain them in detail.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub资源的`chapter_05/atomic`目录中，有关互斥锁、自旋锁和原子数据的简单示例，在接下来的章节中，我们将详细解释它们。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this paragraph, we're going to present two examples of how to use mutexes
    and spinlocks. We should consider them as just a demonstration about how to use
    the API, because, in real drivers, their usage is a bit different, and it will
    be covered in [Chapter 7](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml), *Advanced
    Char Driver Operations*, and the following chapters.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本段中，我们将介绍两个如何使用互斥锁和自旋锁的示例。我们应该将它们视为如何使用API的演示，因为在真实的驱动程序中，它们的使用方式有些不同，并且将在[第7章](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml)
    *高级字符驱动程序操作*和接下来的章节中进行介绍。
- en: Mutexes
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'The following is the end of `mutex.c` file where mutexes are defined and initialized
    for the module `init()` function:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`mutex.c`文件的结尾，其中定义了互斥锁并为模块`init()`函数进行了初始化：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And here is the initialization for the module `exit()` function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模块`exit()`函数的初始化：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the module initialization `mut_init()` function, we use `mutex_init()` to
    initialize the `lock` mutex; then we can safely start the timer.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块初始化的`mut_init()`函数中，我们使用`mutex_init()`来初始化`lock`互斥锁；然后我们可以安全地启动定时器。
- en: 'The module data structure is defined as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 模块数据结构定义如下：
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We use `mutex_trylock()` to try to acquire the lock safely:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`mutex_trylock()`来尝试安全地获取锁：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Spinlocks
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自旋锁
- en: 'As usual, the `spinlock.c` file is shown as an example of spinlock usage. Here
    is the module `init()` function:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，`spinlock.c`文件被用作自旋锁使用的示例。以下是模块`init()`函数：
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And here is the module `exit()` function:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模块`exit()`函数：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The module data structure is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 模块数据结构如下：
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the example, we use `spin_lock_init()` to initialize the spinlock, and then
    we use two different function pairs to protect our data: `spin_lock()` and `spin_unlock()`;
    both of these just use the spinlock to avoid race conditions, while `spin_lock_irqsave()`
    and `spin_unlock_irqrestore()` use the spinlock while the current CPU interrupts
    are disabled:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`spin_lock_init()`来初始化自旋锁，然后我们使用两个不同的函数对来保护我们的数据：`spin_lock()`和`spin_unlock()`；这两者都使用自旋锁来避免竞争条件，而`spin_lock_irqsave()`和`spin_unlock_irqrestore()`在当前CPU中断被禁用时使用自旋锁：
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: By using `spin_lock_irqsave()` and `spin_unlock_irqrestore()`, we can be sure
    that nobody can interrupt us because the IRQs are disabled, and that no other
    CPU can execute our code (thanks to the spinlock).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`spin_lock_irqsave()`和`spin_unlock_irqrestore()`，我们可以确保没有人可以中断我们，因为IRQ被禁用，也没有其他CPU可以执行我们的代码（由于自旋锁）。
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's see how mutexes and spinlocks work in the following two sections.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看互斥锁和自旋锁在接下来的两个部分中是如何工作的。
- en: Mutexes
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: In *step 2*, each time we have to modify our data, we can protect it by calling
    the `mutex_lock()` and `mutex_unlock()` pair, passing a pointer to the mutex to
    lock as a parameter; of course, we cannot do it in an interrupt context (as the
    kernel timer handler is), and that's why we use `mutex_trylock()` to try to acquire
    the lock safely.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，每次我们需要修改数据时，我们可以通过调用`mutex_lock()`和`mutex_unlock()`对其进行保护，将互斥锁的指针作为参数传递；当然，我们不能在中断上下文中执行此操作（如内核定时器处理程序），这就是为什么我们使用`mutex_trylock()`来尝试安全地获取锁。
- en: Spinlocks
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自旋锁
- en: 'In step 1, the example is very similar to the previous one, but it shows a
    really important difference between mutexes and spinlocks: the former protects
    code from the process''s concurrency while the latter protects code from the CPU''s
    concurrency! In fact, if the kernel has no symmetric multiprocessing support (`CONFIG_SMP=n`
    in the kernel `.config` file), then spinlocks just vanish into void code.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，示例与之前的示例非常相似，但它展示了互斥锁和自旋锁之间一个非常重要的区别：前者保护代码免受进程的并发影响，而后者保护代码免受CPU的并发影响！实际上，如果内核没有对称多处理支持（在内核`.config`文件中`CONFIG_SMP=n`），那么自旋锁就会消失。
- en: This is a really important concept, which device driver developers should understand
    very well; otherwise, a driver may not work at all, or lead to a severe bug.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的概念，设备驱动程序开发人员应该非常了解；否则，驱动程序可能根本无法工作，或者导致严重的错误。
- en: There's more...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Since the last example is only meant to present the mutexes and spinlocks,
    API testing is quite useless. However, if we wish to do it anyway, the procedure
    is the same: compile modules and then move them to the ESPRESSObin.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后的示例只是为了展示互斥锁和自旋锁，API测试是相当无用的。然而，如果我们仍然希望这样做，程序是一样的：编译模块，然后将它们移动到ESPRESSObin。
- en: Mutexes
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'When we insert the `mutex.ko` module, the output should be something like the
    following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入`mutex.ko`模块时，输出应该类似于以下内容：
- en: '[PRE85]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In step 1, we execute the module `init()` function where we increase `minfo.data`
    within a mutex protected area.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们执行模块`init()`函数，在其中增加了一个在互斥锁保护区域内的`minfo.data`。
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: When we execute the handler, we can be sure that it cannot increase `minfo.data`
    if the module `init()` function is currently holding the mutex.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行处理程序时，我们可以确保如果模块`init()`函数当前持有互斥锁，它就不能增加`minfo.data`。
- en: Spinlocks
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自旋锁
- en: 'When we insert the `spinlock.ko` module, the output should be something like
    the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入`spinlock.ko`模块时，输出应该类似于以下内容：
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As before, in *step 1*, we execute the module `init()` function where we increase
    `minfo.data` within a spinlock protected area.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，在*步骤1*中，我们执行模块`init()`函数，在其中增加了一个在自旋锁保护区域内的`minfo.data`。
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Again, when we execute the handler, we can be sure that it cannot increase `minfo.data`
    if the module `init()` function is currently holding the spinlock.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在执行处理程序时，我们可以确保如果模块`init()`函数当前持有自旋锁，它就不能增加`minfo.data`。
- en: Note that, in the case of mono core machines, spinlocks vanish, and we assure
    the `minfo.data` lock by just disabling interrupts.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在单核机器的情况下，自旋锁会消失，并且我们可以通过禁用中断来确保`minfo.data`的锁。
- en: By using mutexes and spinlocks, we have whatever we need to protect our data
    from race conditions; however, Linux offers us another API, **atomic operations**.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用互斥锁和自旋锁，我们可以保护数据免受竞态条件的影响；然而，Linux为我们提供了另一个API，原子操作。
- en: The atomic data type
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子数据类型
- en: During device driver development, we may need to atomically increment or decrement
    a variable, or more simply, set one or more bits in a variable. To do so, instead
    of using a complex mutual exclusion mechanism, we can use a set of variables and
    operations that are guaranteed to be atomic by the kernel.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备驱动程序开发过程中，我们可能需要以原子方式增加或减少一个变量，或者更简单地在一个变量中设置一个或多个位。为此，我们可以使用一组变量和操作，内核保证这些操作是原子的，而不是使用复杂的互斥机制。
- en: 'In the `atomic.c` file from GitHub resources, we can see a simple example about
    them, where the atomic variables can be defined as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub资源的`atomic.c`文件中，我们可以看到一个关于原子操作的简单示例，其中原子变量可以定义如下：
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Additionally, the following is the module `init()` function:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是模块`init()`函数：
- en: '[PRE90]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And here is the module `exit()` function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模块`exit()`函数：
- en: '[PRE91]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the preceding code, we use `ATOMIC_INIT()` to statically define and initialize
    an atomic variable, while the `atomic_set()` function can be used to do the same
    dynamically. Subsequently, atomic variables can be manipulated by using functions
    with the `atomic_*()` prefix, which are in the `linux/include/linux/atomic.h`
    and `linux/include/asm-generic/atomic.h` files.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`ATOMIC_INIT()`来静态定义和初始化原子变量，而`atomic_set()`函数可以用来动态地做同样的事情。随后，原子变量可以通过使用带有`atomic_*()`前缀的函数来进行操作，这些函数位于`linux/include/linux/atomic.h`和`linux/include/asm-generic/atomic.h`文件中。
- en: 'Finally, the kernel timer handler can be implemented as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内核定时器处理程序可以实现如下：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Atomic data can be added or subtracted by specific values, incremented, decremented,
    OR-ed, AND-ed, XOR-ed, and so on, and all these operations are guaranteed to be
    atomic by the kernel, so their usage is really simple.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 原子数据可以通过特定值进行加法或减法运算，增加、减少、或运算、与运算、异或运算等，所有这些操作都由内核保证是原子的，因此它们的使用非常简单。
- en: 'Again, testing the code is quite useless. However, if we compile and then insert
    the `atomic.ko` module in the ESPRESSObin, the output is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，测试代码是相当无用的。然而，如果我们在ESPRESSObin中编译然后插入`atomic.ko`模块，输出如下：
- en: '[PRE93]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: At this point, `data` stays at `-1` and doesn't decrement any further.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`data`保持在`-1`，不再减少。
- en: See also
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For several examples about kernel locking mechanisms, refer to [https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)[.](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内核锁定机制的几个示例，请参阅[https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)。
- en: For more information about atomic operations, have a look at [https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html](https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html)[.](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关原子操作的更多信息，请参阅[https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html](https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html)。
