["```\nrequest_mem_region(start, n, name);  [...] ; release_mem_region(start, n);\nrequest_region(start, n, name);      [...] ; release_region(start, n);\n```", "```\n#include <asm/io.h>\nvoid __iomem *ioremap(phys_addr_t offset, size_t size)\n```", "```\n#define GPIO_REG_BASE    0x7e200000\n#define GPIO_REG_LEN     164    // 41 * 4\nstatic void __iomem *iobase;\n[...]\nif (!request_mem_region(GPIO_REG_BASE, GPIO_REG_LEN, \"mydriver\")) {\n    dev_warn(dev, \"couldn't get region for MMIO, aborting\\n\");\n    return -EBUSY;   // or -EINVAL, as appropriate\n}\niobase = ioremap(GPIO_REG_BASE, GPIO_REG_LEN);\nif (!iobase) // handle any error\n    [... perform the required IO ... ]\niounmap(iobase);\nrelease_mem_region(GPIO_REG_BASE, GPIO_REG_LEN);\n```", "```\nvoid iounmap(volatile void __iomem *io_addr);\n```", "```\n/** \n * devm_ioremap - Managed ioremap()\n * @dev: Generic device to remap IO address for\n * @offset: Resource address to map\n * @size: Size of map\n *\n * Managed ioremap(). Map is automatically unmapped on driver detach.\n */ \nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\n               resource_size_t size)\n```", "```\n    struct resource *res;\n    [...]\n    res = platform_get_resource(mixer_ctx-pdev, IORESOURCE_MEM, 0);\n    if (res == NULL) {\n        dev_err(dev, \"get memory resource failed.\\n\");\n        return -ENXIO;\n    } \n\n    mixer_ctx->mixer_regs = devm_ioremap(dev, res-start,\n resource_size(res));\n    if (mixer_ctx->mixer_regs == NULL) {\n        dev_err(dev, \"register mapping failed.\\n\");\n        return -ENXIO;\n    }\n    [...]\n```", "```\nvoid __iomem *devm_ioremap_resource(struct device *dev, const struct resource *res);\n```", "```\nstatic int bcm2835_rng_probe(struct platform_device *pdev)\n{\n    [...]\n    struct resource *r; \n    [...]\n    r = platform_get_resource(pdev, IORESOURCE_MEM, 0); \n\n    /* map peripheral */\n    priv->base = devm_ioremap_resource(dev, r); \n    if (IS_ERR(priv->base))\n        return PTR_ERR(priv->base);\n    [...]\n```", "```\n$ sudo cat /proc/iomem \n[sudo] password for llkd: \n00000000-00000fff : Reserved\n00001000-0009fbff : System RAM\n0009fc00-0009ffff : Reserved\n000a0000-000bffff : PCI Bus 0000:00\n000c0000-000c7fff : Video ROM\n000e2000-000ef3ff : Adapter ROM\n000f0000-000fffff : Reserved\n000f0000-000fffff : System ROM\n00100000-3ffeffff : System RAM\n18800000-194031d0 : Kernel code\n194031d1-19e6a1ff : Kernel data\n1a0e2000-1a33dfff : Kernel bss\n3fff0000-3fffffff : ACPI Tables\n40000000-fdffffff : PCI Bus 0000:00\n[...]\nfee00000-fee00fff : Local APIC\nfee00000-fee00fff : Reserved\nfffc0000-ffffffff : Reserved\n$ \n```", "```\npi@raspberrypi:~ $ sudo cat /proc/iomem\n00000000-3b3fffff : System RAM\n00008000-00bfffff : Kernel code\n00d00000-00e74147 : Kernel data\n3f006000-3f006fff : dwc_otg\n3f007000-3f007eff : dma@7e007000\n[...]\n3f200000-3f2000b3 : gpio@7e200000\n3f201000-3f2011ff : serial@7e201000\n3f201000-3f2011ff : serial@7e201000\n3f202000-3f2020ff : mmc@7e202000\n[...]\npi@raspberrypi:~ $ \n```", "```\n#include <linux/io.h>\nu8 ioread8(const volatile void __iomem *addr);\nu16 ioread16(const volatile void __iomem *addr);\nu32 ioread32(const volatile void __iomem *addr);\n#ifdef CONFIG_64BIT\nu64 ioread64(const volatile void __iomem *addr);\n#endif\n```", "```\n#include <linux/io.h>\nvoid iowrite8(u8 value, volatile void __iomem *addr);\nvoid iowrite16(u16 value, volatile void __iomem *addr);\nvoid iowrite32(u32 value, volatile void __iomem *addr);\n#ifdef CONFIG_64BIT\nvoid u64 iowrite64(u64 value, const volatile void __iomem *addr);\n#endif\n```", "```\n#include <linux/io.h>\n\nvoid ioread8_rep(const volatile void __iomem *addr, void *buffer, unsigned int count);\n```", "```\nvoid iowrite8_rep(volatile void __iomem *addr, const void *buffer, unsigned int count);\n```", "```\n#include linux/io.h\n\nvoid memset_io(volatile void __iomem *addr, int value, size_t size);\n```", "```\nvoid memcpy_fromio(void *buffer, const volatile void __iomem *addr, size_t size);\nvoid memcpy_toio(volatile void __iomem *addr, const void *buffer, size_t size);\n```", "```\n#include <linux/io.h>\nu8 inb(unsigned long addr);\nu16 inw(unsigned long addr);\nu32 inl(unsigned long addr);\n```", "```\n#include <linux/io.h>\nvoid outb(u8 value, unsigned long addr);\nvoid outw(u16 value, unsigned long addr);\nvoid outl(u32 value, unsigned long addr);\n```", "```\n// drivers/input/serio/i8042-io.h\n/*\n * Register numbers.\n */\n#define I8042_COMMAND_REG   0x64\n#define I8042_STATUS_REG    0x64\n#define I8042_DATA_REG      0x60\n```", "```\n[...]\nstatic inline int i8042_read_data(void)\n{\n    return inb(I8042_DATA_REG);\n}\nstatic inline int i8042_read_status(void)\n{\n    return inb(I8042_STATUS_REG);\n}\nstatic inline void i8042_write_data(int val)\n{\n    outb(val, I8042_DATA_REG);\n}\nstatic inline void i8042_write_command(int val)\n{\n    outb(val, I8042_COMMAND_REG);\n}\n```", "```\n$ sudo cat /proc/ioports \n[sudo] password for llkd: \n0000-0cf7 : PCI Bus 0000:00\n  0000-001f : dma1\n  0020-0021 : pic1\n  0040-0043 : timer0\n  0050-0053 : timer1\n  0060-0060 : keyboard\n 0064-0064 : keyboard\n  0070-0071 : rtc_cmos\n  0070-0071 : rtc0\n[...]\n  d270-d27f : 0000:00:0d.0\n  d270-d27f : ahci\n$ \n```", "```\n// include/asm-generic/io.h/*\n * {in,out}s{b,w,l}{,_p}() are variants of the above that repeatedly access a\n * single I/O port multiple times.\n */\n*we don't show the complete code below, just the 'signature' as such* \nvoid insb(unsigned long addr, void *buffer, unsigned int count);\nvoid insw(unsigned long addr, void *buffer, unsigned int count);\nvoid insl(unsigned long addr, void *buffer, unsigned int count);\n\nvoid outsb(unsigned long addr, const void *buffer, unsigned int count);\nvoid outsw(unsigned long addr, const void *buffer, unsigned int count);\nvoid outsl(unsigned long addr, const void *buffer, unsigned int count);\n```", "```\nchar val;\nvoid __iomem *base = devm_ioremap_resource(dev, r);\n[...]\nval = ioread8(base+3);\n```"]