["```\nint pipe2(int pipefd[2], int flags);\n```", "```\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n        struct file *files[2];\n        int fd[2];\n        int error;\n\n        error = __do_pipe_flags(fd, files, flags);\n        if (!error) {\n                if (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {\n                        fput(files[0]);\n                        fput(files[1]);\n                        put_unused_fd(fd[0]);\n                        put_unused_fd(fd[1]);\n                        error = -EFAULT;\n                 } else {\n                        fd_install(fd[0], files[0]);\n                        fd_install(fd[1], files[1]);\n                }\n           }\n           return error;\n}\n```", "```\nint mkfifo(const char *pathname, mode_t mode);\n```", "```\nstatic struct file_system_type pipe_fs_type = {\n           .name = \"pipefs\",\n           .mount = pipefs_mount,\n           .kill_sb = kill_anon_super,\n};\n\nstatic int __init init_pipe_fs(void)\n{\n        int err = register_filesystem(&pipe_fs_type);\n\n        if (!err) {\n                pipe_mnt = kern_mount(&pipe_fs_type);\n                if (IS_ERR(pipe_mnt)) {\n                        err = PTR_ERR(pipe_mnt);\n                        unregister_filesystem(&pipe_fs_type);\n                }\n      }\n      return err;\n}\n\nfs_initcall(init_pipe_fs);\n```", "```\nstruct inode {\n        umode_t        i_mode;\n        unsigned short i_opflags;\n        kuid_t         i_uid;\n        kgid_t         i_gid;\n        unsigned int   i_flags;\n        ...\n        ...\n        ...\n         union {\n                 struct pipe_inode_info *i_pipe;\n                 struct block_device *i_bdev;\n                 struct cdev *i_cdev;\n                 char *i_link;\n                 unsigned i_dir_seq;\n         };\n        ...\n        ...\n        ...\n};\n```", "```\nstruct pipe_inode_info {\n        struct mutex mutex;  \n        wait_queue_head_t wait;  \n        unsigned int nrbufs, curbuf, buffers;\n        unsigned int readers;\n        unsigned int writers;\n        unsigned int files;\n        unsigned int waiting_writers;\n        unsigned int r_counter;\n        unsigned int w_counter;\n        struct page *tmp_page;\n        struct fasync_struct *fasync_readers;\n        struct fasync_struct *fasync_writers;\n        struct pipe_buffer *bufs;\n        struct user_struct *user;\n};\n```", "```\nstruct pipe_buffer {\n        struct page *page;    \n        unsigned int offset, len;\n        const struct pipe_buf_operations *ops;\n        unsigned int flags;\n        unsigned long private;\n};\n```", "```\nconst struct file_operations pipefifo_fops = {\n         .open = fifo_open,\n         .llseek = no_llseek,\n         .read_iter = pipe_read,\n         .write_iter = pipe_write,\n         .poll = pipe_poll,\n         .unlocked_ioctl = pipe_ioctl,\n         .release = pipe_release,\n         .fasync = pipe_fasync,\n};\n```", "```\n int msgget(key_t key, int msgflg);\n```", "```\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);\n\nssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n               int msgflg);\n```", "```\n\nstruct msg_queue {\n        struct kern_ipc_perm q_perm;\n        time_t q_stime; /* last msgsnd time */\n        time_t q_rtime; /* last msgrcv time */\n        time_t q_ctime; /* last change time */\n        unsigned long q_cbytes; /* current number of bytes on queue */\n        unsigned long q_qnum; /* number of messages in queue */\n        unsigned long q_qbytes; /* max number of bytes on queue */\n        pid_t q_lspid; /* pid of last msgsnd */\n        pid_t q_lrpid; /* last receive pid */\n\n       struct list_head q_messages; /* message list */\n       struct list_head q_receivers;/* reader process list */\n       struct list_head q_senders;  /*writer process list */\n};\n```", "```\n/* one msg_msg structure for each message */\nstruct msg_msg {\n        struct list_head m_list;\n        long m_type;\n        size_t m_ts; /* message text size */\n        struct msg_msgseg *next;\n        void *security;\n       /* the actual message follows immediately */\n};\n```", "```\nstruct msg_msgseg {\n        struct msg_msgseg *next;\n        /* the next part of the message follows immediately */\n};\n```", "```\nstruct mqueue_inode_info {\n        spinlock_t lock;\n        struct inode vfs_inode;\n        wait_queue_head_t wait_q;\n\n        struct rb_root msg_tree;\n        struct posix_msg_tree_node *node_cache;\n        struct mq_attr attr;\n\n        struct sigevent notify;\n        struct pid *notify_owner;\n        struct user_namespace *notify_user_ns;\n        struct user_struct *user; /* user who created, for accounting */\n        struct sock *notify_sock;\n        struct sk_buff *notify_cookie;\n\n        /* for tasks waiting for free space and messages, respectively */\n        struct ext_wait_queue e_wait_q[2];\n\n        unsigned long qsize; /* size of queue in memory (sum of all msgs) */\n};\n```", "```\n\n struct posix_msg_tree_node {\n         struct rb_node rb_node;\n         struct list_head msg_list;\n         int priority;\n};\n```", "```\nint shmget(key_t key, size_t size, int shmflg);\n```", "```\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n```", "```\nint shmdt(const void *shmaddr);\n```", "```\nstruct shmid_kernel /* private to the kernel */\n{\n        struct kern_ipc_perm shm_perm;\n        struct file *shm_file; /* pointer to shared memory file */\n        unsigned long shm_nattch; /* no of attached process */\n        unsigned long shm_segsz; /* index into the segment */\n        time_t shm_atim; /* last access time */\n        time_t shm_dtim; /* last detach time */\n        time_t shm_ctim; /* last change time */\n        pid_t shm_cprid; /* pid of creating process */\n        pid_t shm_lprid; /* pid of last access */\n        struct user_struct *mlock_user;\n\n        /* The task created the shm object. NULL if the task is dead. */\n        struct task_struct *shm_creator; \n        struct list_head shm_clist; /* list by creator */\n};\n\n```", "```\nint semget(key_t key, int nsems, int semflg)\n```", "```\nint semop(int semid, struct sembuf *sops, unsigned nsops);\n```", "```\n/* One sem_array data structure for each set of semaphores in the system. */\nstruct sem_array {\n        struct kern_ipc_perm ____cacheline_aligned_in_smp sem_perm;                                                                           \n        time_t sem_ctime;               /* last change time */\n        struct sem *sem_base;           /*ptr to first semaphore in array */\n        struct list_head pending_alter; /* pending operations */\n                                        /* that alter the array */\n        struct list_head pending_const; /* pending complex operations */\n                                        /* that do not alter semvals */\n        struct list_head list_id;       /* undo requests on this array */\n        int sem_nsems;                  /* no. of semaphores in array */\n        int complex_count;              /* pending complex operations */\n        bool complex_mode;              /* no parallel simple ops */\n   };\n\n```"]