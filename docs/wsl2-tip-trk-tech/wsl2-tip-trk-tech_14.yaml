- en: '*Chapter 11*: Productivity Tips with Command-Line Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：命令行工具的生产力技巧'
- en: In this chapter, we will cover some tips for working with a few different common
    command-line tools. We'll start by looking at ways to boost your productivity
    and improve the experience of working with Git in WSL. Git is used widely, and
    improving your productivity with it gives improvements in any project where you
    use it for source control. After this, we will look at two `az` for Azure and
    `kubectl` for Kubernetes. With each of these CLIs, we will deploy a simple example
    resource and then show some techniques for querying data with them. As is common
    with many CLIs, both `az` and `kubectl` provide an option for getting data in
    `az` or `kubectl`, the techniques covered in these sections may be relevant to
    other CLIs you are using. By learning how to manipulate JSON effectively, you
    open new possibilities for scripting and automation using a wide range of APIs
    and CLIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些使用几种不同常见命令行工具的技巧。我们将首先看看如何提高在WSL中使用Git的生产力和改善体验。Git被广泛使用，通过提高使用它进行源代码控制的任何项目的生产力，都会得到改善。之后，我们将看看Azure的`az`和Kubernetes的`kubectl`。对于这两个CLI，我们将部署一个简单的示例资源，然后展示一些使用它们查询数据的技巧。与许多CLI一样，`az`和`kubectl`都提供了在`az`或`kubectl`中获取数据的选项，这些部分涵盖的技术可能与您正在使用的其他CLI相关。通过有效地学习如何操作JSON，您可以打开使用各种API和CLI进行脚本编写和自动化的新可能性。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Working with Git
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git
- en: Working with JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON
- en: Working with the Azure CLI (`az`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure CLI（`az`）
- en: Working with the Kubernetes CLI (`kubectl`)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes CLI（`kubectl`）
- en: Let's kick off by exploring some tips for working with Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索一些使用Git的技巧。
- en: Working with Git
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Git
- en: Without a doubt, Git is a commonly used source control system. Originally written
    by Linus Torvalds to use for Linux kernel source code, it is now widely used,
    including by companies such as Microsoft, where it is used extensively, including
    for Windows development (see [https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft)
    for more information).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Git是一个常用的源代码控制系统。最初由Linus Torvalds编写用于Linux内核源代码，现在被广泛使用，包括微软等公司，它被广泛使用，包括用于Windows开发（有关更多信息，请参阅[https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft)）。
- en: In this section, we will look at a few tips for working with Git in WSL. Some
    tips are covered in previous chapters and linked for further information, while
    others are new tips – both are tied together here for handy reference.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些在WSL中使用Git的技巧。一些技巧在之前的章节中已经涵盖，并提供了进一步的信息链接，而另一些是新技巧 - 这两者在这里都联系在一起，方便参考。
- en: 'Let''s start by looking at a quick win for most command-line tools: bash completion.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从大多数命令行工具的快速胜利开始：bash自动补全。
- en: Bash completion with Git
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git的Bash自动补全
- en: When working with many command-line tools, bash completion can save you a lot
    of typing, and `git` is no exception.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用许多命令行工具时，bash自动补全可以节省大量的输入时间，`git`也不例外。
- en: 'For example, `git com<TAB>` will produce `git commit`, and `git chec<TAB>`
    will produce `git checkout`. If the partial command you have entered isn''t sufficient
    to specify a single command, then bash completion will appear not to do anything,
    but pressing *Tab* twice will show the options. Take the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`git com<TAB>`将产生`git commit`，而`git chec<TAB>`将产生`git checkout`。如果你输入的部分命令不足以指定单个命令，那么bash自动补全似乎不会做任何事情，但按两次*Tab*将显示选项。举个例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we see that `git co` could complete to either `git commit` or `git config`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`git co`可以完成为`git commit`或`git config`。
- en: Bash completion doesn't just complete command names either; you can use `git
    checkout my<TAB>` to complete the branch name to `git checkout my-branch`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Bash自动补全不仅仅是完成命令名称；你可以使用`git checkout my<TAB>`来完成分支名称为`git checkout my-branch`。
- en: Once you get used to bash completion, you will find it can be a big productivity
    boost!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了bash自动补全，你会发现它可以大大提高生产力！
- en: Next, let's look at options for authenticating with remote Git repos.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看与远程Git仓库进行身份验证的选项。
- en: Authentication with Git
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Git进行身份验证
- en: One powerful method of authentication with Git is through the use of **Secure
    Shell** (**SSH**) keys. This method of authentication reuses SSH keys that are
    typically used for making SSH connections to remote machines to authenticate via
    Git and is supported across the major Git source control providers. In [*Chapter
    5*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054), *Linux to Windows Interoperability*,
    in the *SSH agent forwarding* section, we saw how to configure WSL to reuse SSH
    keys stored in Windows. If you have set this up, it also enables you to use SSH
    keys with Git in WSL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**Secure Shell**（**SSH**）密钥进行Git身份验证是一种强大的方法。这种身份验证方法重用SSH密钥，通常用于与远程机器建立SSH连接，以通过Git进行身份验证，并且受到主要的Git源代码控制提供者的支持。在[*第5章*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054)，*Linux与Windows的互操作性*，在*SSH代理转发*部分，我们看到如何配置WSL以重用存储在Windows中的SSH密钥。如果你已经设置了这个，它还可以让你在WSL中使用SSH密钥。
- en: 'Alternatively, if you are doing a mixture of development across Windows and
    WSL and want to share Git authentication between them, then you might want to
    configure Git Credential Manager for Windows for use in WSL. This also supports
    using two-factor authentication with providers such as GitHub or Bitbucket (see
    [https://github.com/Microsoft/Git-Credential-Manager-for-Windows](https://github.com/Microsoft/Git-Credential-Manager-for-Windows)
    for more information). To use this, you must have installed Git in Windows. To
    configure, run the following command from your **distribution** (**distro**):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您在Windows和WSL之间进行混合开发并希望在它们之间共享Git身份验证，则可能希望为WSL配置Windows的Git凭据管理器。这也支持在GitHub或Bitbucket等提供商上使用双因素身份验证（有关更多信息，请参见[https://github.com/Microsoft/Git-Credential-Manager-for-Windows](https://github.com/Microsoft/Git-Credential-Manager-for-Windows)）。要使用此功能，您必须在Windows中安装Git。要配置，请从您的**distribution**（**distro**）运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command sets the Git configuration to launch Git Credential Manager for
    Windows to handle the authentication with remote repos. Any credentials stored
    from accessing Git remotes via Windows will be reused by WSL (and vice versa).
    See [https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup](https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup)
    for more details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将Git配置为启动Git Credential Manager for Windows来处理与远程存储库的身份验证。通过Windows访问Git远程存储库存储的任何凭据将被WSL重用（反之亦然）。有关更多详细信息，请参见[https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup](https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup)。
- en: With authentication taken care of, let's look at a few options for viewing history
    in Git.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 认证问题解决后，让我们看一下在Git中查看历史的几个选项。
- en: Viewing Git history
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看Git历史
- en: 'When working with Git in WSL, there are a number of different approaches to
    viewing the history of commits in a Git repo. Here, we will look at the following
    different options:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在WSL中使用Git时，有许多不同的方法可以查看Git存储库中提交的历史记录。在这里，我们将看看以下不同的选项：
- en: Using the `git` CLI
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`git` CLI
- en: Using graphical Git tools from Windows
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Windows的图形Git工具
- en: Using Visual Studio Code Remote-WSL
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code Remote-WSL
- en: 'The first of these options is to use the `git log` command in the CLI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是在CLI中使用`git log`命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the output from `git log`, you can see the result of running the `git log`
    command with a number of additional switches to produce a concise output using
    text art to show branches. This approach can be handy as it can be used directly
    from the command line in WSL and requires nothing installed apart from Git in
    WSL. However, the command can be a bit tedious to type, so you might want to create
    a Git alias, as shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`git log`的输出中，您可以看到使用一些附加开关运行`git log`命令产生了简洁的输出，使用文本艺术来显示分支。这种方法很方便，因为它可以直接从WSL的命令行中使用，并且除了WSL中安装的Git之外不需要安装任何东西。但是，这个命令可能有点繁琐，所以您可能希望创建一个Git别名，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we use the `git config` command to create an alias called `logtree` for
    the previous Git command. After creating this, we can now run `git logtree` to
    produce the previous output.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`git config`命令为先前的Git命令创建了一个名为`logtree`的别名。创建后，我们现在可以运行`git logtree`来生成先前的输出。
- en: 'If you have a graphical tool for Windows that you use with Git, you can point
    it to your Git repo in WSL. In [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, in the *Viewing Git history* section, we looked
    at how to use the `gitk` utility that is included with Git. As an example, we
    can run `gitk.exe --all` from a WSL shell in a Git repo folder to launch the Windows
    `gitk.exe` executable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上使用Git的图形工具，您可以将其指向WSL中的Git存储库。在第9章《Visual Studio Code和WSL》的《查看Git历史》部分中，我们看到了如何使用Git附带的`gitk`实用程序。例如，我们可以从WSL
    shell中的Git存储库文件夹运行`gitk.exe --all`来启动Windows的`gitk.exe`可执行文件：
- en: '![Figure 11.1 – A screenshot showing the gitk utility in Windows showing a
    WSL Git repo'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 显示Windows中gitk实用程序的屏幕截图，显示了WSL Git存储库'
- en: '](img/Figure_11.1_B16412.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16412.jpg)'
- en: Figure 11.1 – A screenshot showing the gitk utility in Windows showing a WSL
    Git repo
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 显示Windows中gitk实用程序的屏幕截图，显示了WSL Git存储库
- en: In this screenshot, we can see the `gitk` utility running in Windows and showing
    the same Git repo we saw previously with `git log`. Because we launched it from
    a shell in WSL, it picked up the `\\wsl$` share that is used to access the shell's
    current folder in WSL from Windows (see [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Windows to Linux Interoperability*, the *Accessing Linux files from Windows*
    section, for more information on the `\\wsl$` share). One potential issue with
    this approach is that access to files via the `\\wsl$` share has a performance
    overhead, and for a large Git repo, this can make Windows Git utilities slow to
    load.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，我们可以看到`gitk`实用程序在Windows中运行，并显示了之前使用`git log`看到的相同的Git存储库。因为我们是从WSL的shell中启动它的，它捕获了`\\wsl$`共享，用于从Windows访问WSL中的shell当前文件夹（有关`\\wsl$`共享的更多信息，请参见第4章《Windows到Linux的互操作性》，《从Windows访问Linux文件》部分）。这种方法的一个潜在问题是通过`\\wsl$`共享访问文件会有性能开销，对于大型Git存储库，这可能会使Windows的Git工具加载缓慢。
- en: 'Another option that we saw in [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, in the *Viewing Git history* section, was to use
    Visual Studio Code. By using the Remote-WSL extension, we can install other extensions
    for Visual Studio Code so that they actually run in WSL. The **Git Graph extension**
    is a handy addition for Visual Studio Code that allows you to view Git history
    graphically and works well with Remote-WSL. You can see an example here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章《Visual Studio Code和WSL》的《查看Git历史》部分中看到的另一个选项是使用Visual Studio Code。通过使用Remote-WSL扩展，我们可以安装其他扩展程序，使它们实际在WSL中运行。**Git
    Graph扩展程序**是Visual Studio Code的一个方便的补充，允许您以图形方式查看Git历史，并且与Remote-WSL配合良好。您可以在这里看到一个例子：
- en: '![Figure 11.2 – A screenshot showing the Git Graph extension in Visual Studio
    Code'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 显示Visual Studio Code中Git Graph扩展程序的屏幕截图'
- en: '](img/Figure_11.2_B16412.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B16412.jpg)'
- en: Figure 11.2 – A screenshot showing the Git Graph extension in Visual Studio
    Code
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 显示 Visual Studio Code 中的 Git Graph 扩展的屏幕截图
- en: This screenshot shows the same Git repo again, but this time using the Git Graph
    extension in Visual Studio Code. Because this extension is being loaded in WSL
    by Remote-WSL, all access to the Git repo is performed directly in WSL and it
    doesn't have the performance overhead of going via the `\\wsl$` share when querying
    Git.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕截图再次显示了相同的 Git 存储库，但这次是在 Visual Studio Code 中使用 Git Graph 扩展。由于这个扩展是通过 Remote-WSL
    在 WSL 中加载的，所有对 Git 存储库的访问都是直接在 WSL 中执行的，而不会通过 `\\wsl$` 共享进行查询时的性能开销。
- en: We've seen a few approaches here, each with their benefits and each useful in
    their own context. The *Git CLI* approach is handy if you are already at the terminal,
    and it runs in WSL so has good performance. For inspecting complex branching and
    history, this is where a graphical tool often comes into its own. However, as
    mentioned, using graphical Git tools from Windows incurs the performance overhead
    of the `\\wsl$` share – normally, this isn't noticeable, but for a Git repo with
    a lot of files or history, it may start to be more significant. In these cases,
    or when I'm already working in the editor, I find a Visual Studio Code extension
    such as Git Graph really useful as a graphical visualization without the performance
    overhead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到了一些方法，每种方法都有其自身的好处，在各自的上下文中都很有用。*Git CLI* 方法在你已经在终端时很方便，并且它在 WSL 中运行，因此性能很好。对于检查复杂的分支和历史记录，图形工具往往是最好的选择。然而，正如前面提到的，从
    Windows 使用图形 Git 工具会产生 `\\wsl$` 共享的性能开销 – 通常情况下这是不明显的，但对于文件或历史记录很多的 Git 存储库来说，它可能开始变得更加显著。在这些情况下，或者当我已经在编辑器中工作时，我发现
    Visual Studio Code 的 Git Graph 等扩展非常有用，它提供了图形化的可视化，而没有性能开销。
- en: Next, we'll take a look at improving our bash prompt when working with Git.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看在使用 Git 时改进我们的 bash 提示。
- en: Git information in the bash prompt
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bash 提示中的 Git 信息
- en: 'When working in bash in a folder within a Git repository, the default prompt
    doesn''t give you any hints about the status of the Git repository. There are
    various options for adding context from a Git repository to bash, and we''ll look
    at a couple of those here. The first option is **bash-git-prompt** (https://github.com/magicmonty/bash-git-prompt),
    which customizes your bash prompt when in a Git repository. You can see an example
    of this here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 存储库中的文件夹中使用 bash 时，默认提示不会给出有关 Git 存储库状态的任何提示。有各种选项可以将 Git 存储库的上下文添加到 bash
    中，我们将在这里看一些选项。第一个选项是 **bash-git-prompt** (https://github.com/magicmonty/bash-git-prompt)，它在
    Git 存储库中自定义了你的 bash 提示。你可以在这里看到一个例子：
- en: '![Figure 11.3 – A screenshot showing bash-git-prompt'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 显示 bash-git-prompt 的屏幕截图'
- en: '](img/Figure_11.3_B16412.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B16412.jpg)'
- en: Figure 11.3 – A screenshot showing bash-git-prompt
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 显示 bash-git-prompt 的屏幕截图
- en: As this screenshot shows, `bash-git-prompt` shows which branch you are currently
    on (`main`, in this example). It also indicates whether your local branch has
    commits to push or whether there are commits to pull from the remote branch via
    the up and down arrows. The up arrow indicates commits to push, and the down arrow
    indicates commits to pull. Lastly, it shows whether you have local changes that
    haven't been committed – the `+1`, in this example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个屏幕截图所示，`bash-git-prompt` 显示了你当前所在的分支（在这个例子中是 `main`）。它还指示了你的本地分支是否有提交要推送，或者是否有要从远程分支拉取的提交，通过上下箭头来表示。上箭头表示有提交要推送，下箭头表示有提交要拉取。最后，它显示了你是否有未提交的本地更改
    – 在这个例子中是 `+1`。
- en: 'To install `bash-git-prompt`, first clone the repository with the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `bash-git-prompt`，首先使用以下命令克隆存储库：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `git clone` command clones the repo into a `.bash-git-prompt` folder in
    your user folder and uses `--depth=1` to only pull the latest commit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `git clone` 命令将存储库克隆到用户文件夹中的 `.bash-git-prompt` 文件夹中，并使用 `--depth=1` 仅拉取最新的提交。
- en: 'Next, add the following to `.bashrc` in your user folder:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的用户文件夹中的 `.bashrc` 中添加以下内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This snippet sets the `GIT_PROMPT_ONLY_IN_REPO` variable to only use the custom
    prompt in folders with a Git repository, and then loads the `git` prompt. Now,
    re-open your terminal and change folders to a Git repository to see `bash-git-prompt`
    in action. For other configuration options, see the documentation at [https://github.com/magicmonty/bash-git-prompt](https://github.com/magicmonty/bash-git-prompt).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段将 `GIT_PROMPT_ONLY_IN_REPO` 变量设置为仅在带有 Git 存储库的文件夹中使用自定义提示，然后加载 `git` 提示。现在，重新打开你的终端并切换到一个
    Git 存储库的文件夹中，看看 `bash-git-prompt` 的效果。有关其他配置选项，请参阅 [https://github.com/magicmonty/bash-git-prompt](https://github.com/magicmonty/bash-git-prompt)
    上的文档。
- en: 'Another option for enriching your bash prompt is `bash-git-prompt` and takes
    over your general prompt experience, adding context to the prompt for things such
    as Git and Kubernetes. See an example of the Powerline prompt in the following
    screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富你的 bash 提示的另一个选项是 `bash-git-prompt`，它接管了你的一般提示体验，为提示添加了 Git 和 Kubernetes 等内容。在下面的屏幕截图中可以看到
    Powerline 提示的一个例子：
- en: '![Figure 11.4 – A screenshot showing a Powerline prompt'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 显示 Powerline 提示的屏幕截图'
- en: '](img/Figure_11.4_B16412.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B16412.jpg)'
- en: Figure 11.4 – A screenshot showing a Powerline prompt
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 显示 Powerline 提示的屏幕截图
- en: As shown in this screenshot, Powerline uses some special font characters, and
    not all fonts have these characters set, so the first step is to ensure we have
    a suitable font. Windows Terminal ships with a font called `CascadiaCodePL.ttf`
    and `CascadiaMonoPL.ttf` from the `ttf` folder by right-clicking in **Windows
    Explorer** and selecting **Install**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个屏幕截图所示，Powerline 使用了一些特殊的字体字符，并非所有字体都设置了这些字符，所以第一步是确保我们有一个合适的字体。Windows
    终端附带了一个名为 `CascadiaCodePL.ttf` 和 `CascadiaMonoPL.ttf` 的字体，可以通过在 **Windows Explorer**
    中右键单击 `ttf` 文件夹中的文件并选择 **安装** 来安装。
- en: 'With the Powerline font installed, we need to configure the terminal to use
    it. If you are using Windows Terminal, then launch it and press *Ctrl* + *,* to
    load the settings and add the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Powerline 字体后，我们需要配置终端来使用它。如果你正在使用 Windows 终端，那么启动它并按下 *Ctrl* + *,* 加载设置，并添加以下内容：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are setting the default `fontFace` value to the `Cascadia Mono PL`
    (Powerline) font we just installed. To change the font for a single profile, see
    [*Chapter 3*](B16412_03_Final_JC_ePub.xhtml#_idTextAnchor037), *Getting Started
    with Windows Terminal*, the *Changing fonts* section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将默认的`fontFace`值设置为我们刚安装的`Cascadia Mono PL`（Powerline）字体。要更改单个配置文件的字体，请参见[*第3章*](B16412_03_Final_JC_ePub.xhtml#_idTextAnchor037)，*开始使用Windows终端*，*更改字体*部分。
- en: 'Now that we have our terminal set up with a Powerline font, we can install
    Powerline. There are several variants, and we will use `powerline-go-linux-amd64`
    version from [https://github.com/justjanne/powerline-go/releases](https://github.com/justjanne/powerline-go/releases)
    and save it as `powerline-go` somewhere in `PATH` in the your WSL distro, for
    example, `/usr/local/bin`. (An alternative option is to install this via **Go**,
    but distro repositories can be stuck on old versions of Go leading to incompatibilities
    – if you prefer to try this option, then refer to the Windows Terminal docs: [https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup](https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup).)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有Powerline字体的终端，我们可以安装Powerline。有几种变体，我们将使用来自[https://github.com/justjanne/powerline-go/releases](https://github.com/justjanne/powerline-go/releases)的`powerline-go-linux-amd64`版本，并将其保存为`powerline-go`，放在WSL发行版的`PATH`中的某个位置，例如`/usr/local/bin`。（另一种选择是通过**Go**安装，但发行版存储库可能停留在旧版本的Go上，导致不兼容-如果您更喜欢尝试此选项，请参考Windows终端文档：[https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup](https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup)。）
- en: 'With `powerline-go` installed, we can configure bash to use it by adding the
    following to `bashrc`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`powerline-go`后，我们可以通过将以下内容添加到`bashrc`来配置bash使用它：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have created an `_update_ps1` function that calls `powerline-go`.
    This is the place to add extra switches to control the behavior of `powerline-go`
    – see the documentation for more details: [https://github.com/justjanne/powerline-go#customization](https://github.com/justjanne/powerline-go#customization).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`_update_ps1`函数，调用了`powerline-go`。这是添加额外开关以控制`powerline-go`行为的地方-有关更多详细信息，请参阅文档：[https://github.com/justjanne/powerline-go#customization](https://github.com/justjanne/powerline-go#customization)。
- en: When working with Git, tailoring your prompt to get context for the Git repository
    presented automatically can make life easier whichever option you pick. Combining
    this with setting up authentication in Git to be shared across Windows and WSL,
    and knowing how best to view Git history in different situations, you are well
    set up for being productive with Git in WSL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Git时，调整提示以自动获取Git仓库的上下文可以使您更轻松地选择任何选项。将此与在Git中设置身份验证以在Windows和WSL之间共享，并了解在不同情况下如何最好地查看Git历史记录相结合，您将能够在WSL中高效地使用Git。
- en: In the next section, we'll take a look at a couple of ways of working with JSON
    data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下几种处理JSON数据的方法。
- en: Working with JSON
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON
- en: Automating complex tasks can save hours of manual toil. In this section, we'll
    explore some techniques for working with JSON data, which is a common format that
    many command-line tools and APIs allow you to use. Later in the chapter, we'll
    show some examples of how you can use these techniques to easily create and publish
    content to a cloud website or Kubernetes cluster.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化复杂任务可以节省数小时的手动劳动。在本节中，我们将探讨一些处理JSON数据的技术，这是许多命令行工具和API允许您使用的常见格式。在本章后面，我们将展示一些示例，说明您可以如何使用这些技术轻松地创建和发布内容到云网站或Kubernetes集群。
- en: 'For this section, there is a sample JSON file in the accompanying code for
    the book. You can clone this code with Git from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques).
    The sample JSON is called `wsl-book.json` and is in the `chapter-11/02-working-with-json`
    folder, and is based around a JSON description of the chapters and headings for
    a book. A snippet of this JSON is shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，书籍的附带代码中有一个示例JSON文件。您可以使用Git从[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)克隆此代码。示例JSON名为`wsl-book.json`，位于`chapter-11/02-working-with-json`文件夹中，基于一本书的章节和标题的JSON描述。此处显示了此JSON的片段：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This snippet shows the structure of the sample JSON. It is worth taking a few
    moments to familiarize yourself with it as it is the basis for the examples in
    this section. Examples in this section assume that you have a shell open in the
    folder containing the sample JSON.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段显示了示例JSON的结构。值得花一些时间熟悉它，因为它是本节示例的基础。本节中的示例假定您在包含示例JSON的文件夹中打开了一个shell。
- en: Let's get started with a popular utility, `jq`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用一个流行的实用程序`jq`。
- en: Using jq
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jq
- en: The first tool we'll look at is `jq`, and it is a fantastically handy utility
    for working with JSON strings and is supported on the major platforms. Full installation
    options are listed on [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/),
    but you can quickly get started on Debian/Ubuntu by running `sudo apt-get install
    jq`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下`jq`，它是一个非常方便的用于处理JSON字符串的实用程序，并且在主要平台上都受支持。完整的安装选项列在[https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/)上，但您可以通过在Debian/Ubuntu上运行`sudo
    apt-get install jq`来快速开始。
- en: 'At its most basic, `jq` can be used to format input. As an example, we can
    pipe a JSON string into `jq`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，`jq`可用于格式化输入。例如，我们可以将JSON字符串传输到`jq`中：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the output from this command, you can see that `jq` has taken the compact
    JSON input and turned it into a nicely formatted output. When working interactively
    with APIs that return compact JSON, this functionality alone can be useful. However,
    the real power of `jq` lies in its querying capabilities, and we will explore
    these as we work through this section. As a taster of what can be achieved, take
    a look at the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令的输出中，你可以看到`jq`已经将紧凑的JSON输入转换成了格式良好的输出。当与返回紧凑JSON的API进行交互时，这个功能本身就很有用。然而，`jq`真正的威力在于它的查询能力，我们将在本节中探讨这些能力。作为一个可以实现的预演，看一下下面的例子：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This output shows `jq` extracting and outputting the `name` values for the
    parts in the sample JSON. This sort of capability is extremely useful when scripting
    with APIs and command-line tools that return JSON data, and we will start with
    some simple queries and build up to more complex ones. You can follow along with
    the examples using the `jq` CLI or with the **jq playground** at [https://jqplay.org](https://jqplay.org),
    as seen in the screenshot here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了`jq`提取和输出样本JSON中部件的`name`值。当使用返回JSON数据的API和命令行工具进行脚本编写时，这种能力非常有用，我们将从一些简单的查询开始，逐渐发展到更复杂的查询。你可以使用`jq`
    CLI或者在[https://jqplay.org](https://jqplay.org)上使用**jq playground**来跟随这些例子，就像在这里的截图中看到的那样。
- en: '![Figure 11.5 – A screenshot showing the jq playground'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 - 展示jq playground的截图'
- en: '](img/Figure_11.5_B16412.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.5_B16412.jpg)'
- en: Figure 11.5 – A screenshot showing the jq playground
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 展示jq playground的截图
- en: This screenshot shows the previous example open in the `jq` playground. In the
    top left, you can see the filter (`.parts[].name`), under that is the input JSON,
    and on the right is the `jq` output. The playground can be a helpful environment
    when you are working on a complex query, and the **Command Line** section at the
    bottom even gives you the command line that you can copy and use in your scripts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图显示了在`jq` playground中打开的前面的例子。在左上角，你可以看到过滤器（`.parts[].name`），在下面是输入的JSON，右边是`jq`的输出。当你在处理复杂的查询时，playground可以是一个有用的环境，底部的**命令行**部分甚至会给出你可以复制并在脚本中使用的命令行。
- en: 'Now that you have a sense of what `jq` can do, let''s start with a simple query.
    The JSON we''re working with has two top-level properties: `title` and `parts`.
    If we want to extract the value of the `title` property, we can use the following
    query:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道`jq`可以做什么了，让我们从一个简单的查询开始。我们要处理的JSON有两个顶级属性：`title`和`parts`。如果我们想提取`title`属性的值，我们可以使用以下查询：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we have used the `.title` filter to extract the value of the `title`
    property. Notice that the value is quoted in the output because `jq` outputs JSON
    by default. To assign this to a variable in a script, we typically want the value
    without quotes, and we can use the `-r` option with `jq` to get the raw output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`.title`过滤器来提取`title`属性的值。注意输出中的值被引号引起来，因为`jq`默认输出JSON。在脚本中将这个值赋给一个变量时，通常希望得到没有引号的值，我们可以使用`jq`的`-r`选项来获得原始输出：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This output shows using the `-r` option to get raw (unquoted) output and assign
    it to a variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了使用`-r`选项来获得原始（未引用）输出并将其赋给一个变量。
- en: 'In this example, we used the `title` property, which is a simple string value.
    The other top-level property is `parts`, which is an array of JSON objects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`title`属性，它是一个简单的字符串值。另一个顶级属性是`parts`，它是一个JSON对象的数组：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the output of this command, we see that retrieving the `parts` property
    returns the full value of the property. We can change the filter to `.parts[0]`
    to pull back the first item in the `parts` array, and then extend the filter further
    if we want to get the name of the first part, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令的输出中，我们看到检索`parts`属性返回了属性的完整值。我们可以将过滤器更改为`.parts[0]`来获取`parts`数组中的第一个项目，然后进一步扩展过滤器，如果我们想要获取第一个部件的名称，就像这样：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we see how we can build up a query to work down the hierarchy of JSON
    data, selecting properties and indexing into arrays to select a specific value.
    Sometimes it is useful to be able to get a list of data – for example, to retrieve
    the name of all the parts. We can do that with the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了如何构建一个查询来沿着JSON数据的层次结构进行选择属性和索引数组以选择特定的值。有时候能够获得一个数据列表是很有用的 - 例如，获取所有部件的名称。我们可以使用以下命令来实现：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see in this example, we omitted the array index from the previous
    filter and `jq` has processed the rest of the filter (`.name`) against each item
    of the `parts` array. As with the single value output, we can add the `-r` option
    to get unquoted strings for ease of working with the output in a script. Alternatively,
    if we are working with APIs, we may want to build up JSON output – for example,
    to output the previous values as an array, we can wrap the filter in square brackets:
    `[.parts[].name]`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个例子中看到的，我们省略了前一个过滤器中的数组索引，`jq`已经处理了剩下的过滤器（`.name`）并针对`parts`数组的每个项目进行了处理。与单一值输出一样，我们可以添加`-r`选项，以便在脚本中更容易地处理输出的未引用字符串。或者，如果我们正在处理API，我们可能希望构建JSON输出
    - 例如，要将前面的值输出为数组，我们可以将过滤器包装在方括号中：`[.parts[].name]`。
- en: 'So far, we have only used a single filter expression, but `jq` allows us to
    chain multiple filters together and pipe the output from one as the input to the
    next. For example, we can rewrite `.parts[].name` as `.parts[] | .name`, which
    will produce the same output. From here, we can change the second filter to `{name}`
    to produce an object with a `name` property, rather than just the name value:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了一个单一的过滤表达式，但是`jq`允许我们将多个过滤器链接在一起，并将一个过滤器的输出作为下一个过滤器的输入。例如，我们可以将`.parts[].name`重写为`.parts[]
    | .name`，这将产生相同的输出。从这里，我们可以将第二个过滤器改为`{name}`，以产生一个带有`name`属性的对象，而不仅仅是名称值：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we see that each value from the `.parts` array is now producing an object
    in the output, rather than just the simple string previously. The `{name}` syntax
    is actually a shorthand for `{name: .name}`. The full syntax makes it easier to
    see how you can control the property names in the output – for example, `{part_name:
    .name}`. With the full syntax, we can also see that the property value is another
    filter. In this example, we used the simple `.name` filter, but we can build up
    with richer filters as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们看到`.parts`数组中的每个值现在都产生了输出中的一个对象，而不仅仅是之前的简单字符串。`{name}`语法实际上是`{name: .name}`的简写。完整的语法使您更容易看到如何控制输出中的属性名称
    - 例如，`{part_name: .name}`。使用完整的语法，我们还可以看到属性值是另一个过滤器。在这个例子中，我们使用了简单的`.name`过滤器，但我们也可以使用更丰富的过滤器来构建：'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we added `.chapters | length` as a filter to specify the value
    of the `chapter_count` property. The `.chapters` expression is applied to the
    value of the `parts` array that is currently being processed and selects the `chapters`
    array, and this is parsed to the `length` function, which returns the array length.
    For more information on the functions available in `jq`, check out the documentation
    at https://stedolan.github.io/jq/manual/#Builtinoperatorsandfunctions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了`.chapters | length`作为一个过滤器来指定`chapter_count`属性的值。`.chapters`表达式被应用于当前正在处理的`parts`数组的值，并选择`chapters`数组，然后将其解析为`length`函数，该函数返回数组长度。有关`jq`中可用函数的更多信息，请查看https://stedolan.github.io/jq/manual/#Builtinoperatorsandfunctions上的文档。
- en: 'For one final example of `jq`, let''s pull together a summary of the parts
    showing the part name, along with a list of the chapter titles:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`jq`的最后一个例子，让我们汇总一下部分的摘要，显示部分名称以及章节标题的列表：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, the `parts` array is piped into a filter that creates an object
    for each array item with the `name` and `chapters` properties. The `chapters`
    property is built up by piping the `chapters` array into a selector for the `title`
    property, and then wrapping that in an array: `[.chapters[] | title]`. The whole
    result is wrapped in an array (using square brackets again) to create a JSON array
    of these summary objects in the output.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`parts`数组被传递到一个过滤器中，该过滤器为每个数组项创建一个带有`name`和`chapters`属性的对象。`chapters`属性是通过将`chapters`数组传递到`title`属性的选择器中，然后将其包装在一个数组中来构建的：`[.chapters[]
    | title]`。整个结果再次被包装在一个数组中（再次使用方括号）以在输出中创建这些摘要对象的JSON数组。
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There are various ways to look up options with command-line tools such as `jq`.
    You can run `jq --help` for a brief help page or `man jq` to view the full man
    page. A handy alternative to these is `tldr` (see [https://tldr.sh](https://tldr.sh)
    for more details and installation instructions). The `tldr` utility describes
    itself as *simplified and community-driven man pages*, and running `tldr jq` will
    give a shorter output than the man pages, with useful examples included.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以使用命令行工具（如`jq`）查找选项。您可以运行`jq --help`获取简要的帮助页面，或者运行`man jq`查看完整的man页面。这些的一个方便的替代品是`tldr`（有关更多详细信息和安装说明，请参见[https://tldr.sh](https://tldr.sh)）。`tldr`实用程序将自己描述为*简化和社区驱动的man页面*，运行`tldr
    jq`将提供比man页面更短的输出，并包含有用的示例。
- en: This whirlwind tour has shown you some of the power that `jq` offers, whether
    for formatting JSON output for readability when working interactively, for quickly
    selecting single values from JSON to use in a script, or for transforming JSON
    input into a new JSON document. When working with JSON, `jq` is an extremely useful
    tool to have to hand, and we will see some more examples of this in later sections
    in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次风风火火的旅行向您展示了`jq`提供的一些功能，无论是在与JSON交互式工作时格式化JSON输出以便阅读，还是快速选择JSON中的单个值以在脚本中使用，或者将JSON输入转换为新的JSON文档时。在处理JSON时，`jq`是一个非常有用的工具，我们将在本章的后续部分中看到更多这方面的例子。
- en: In the next section, we will explore the options for using **PowerShell** to
    handle JSON data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索使用**PowerShell**处理JSON数据的选项。
- en: Using PowerShell to work with JSON
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PowerShell处理JSON
- en: 'In this section, we''ll explore some of the capabilities that PowerShell gives
    us for working with JSON data. PowerShell is a shell and scripting language that
    originated for Windows but is now available for Windows, Linux, and macOS. To
    install in WSL, follow the installation instructions for your distribution at
    https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7\.
    For example, for Ubuntu 18.04, we can use the following commands to install PowerShell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨PowerShell为我们提供的一些处理JSON数据的能力。PowerShell是一个起源于Windows但现在可用于Windows、Linux和macOS的shell和脚本语言。要在WSL中安装，请按照您的发行版的安装说明进行安装，网址为https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7。例如，对于Ubuntu
    18.04，我们可以使用以下命令安装PowerShell：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These steps will register the Microsoft package repository and then install
    PowerShell from there. Once installed, you can launch PowerShell by running `pwsh`,
    and this will give you an interactive shell that we will use for the rest of the
    examples in this section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将注册Microsoft软件包存储库，然后从那里安装PowerShell。安装完成后，您可以通过运行`pwsh`来启动PowerShell，这将为您提供一个交互式的shell，我们将在本节的其余示例中使用它。
- en: 'We can load and parse the example JSON file as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式加载和解析示例JSON文件：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we see the `Get-Content` cmdlet (commands in PowerShell are called `ConvertFrom-Json`
    used to parse the JSON object graph into PowerShell objects. At this point, we
    can use any of the PowerShell features for working with data. For example, we
    could get the title using the `Select-Object` cmdlet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了`Get-Content` cmdlet（PowerShell中的命令称为`ConvertFrom-Json`用于将JSON对象图解析为PowerShell对象。在这一点上，我们可以使用任何用于处理数据的PowerShell功能。例如，我们可以使用`Select-Object`
    cmdlet获取标题：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Select-Object` cmdlet allows us to perform various manipulations on a
    set of objects, such as taking a specified number of items from the start or end
    of the set, or filtering to only unique items. In this example, we used it to
    select a property of the input object to output. An alternative approach for getting
    the title is to work directly with the converted JSON objects, as shown in the
    following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select-Object`命令允许我们对一组对象执行各种操作，例如从集合的开头或结尾获取指定数量的项目，或者仅筛选唯一的项目。在这个例子中，我们使用它来选择要输出的输入对象的属性。获取标题的另一种方法是直接使用转换后的JSON对象，如下面的命令所示：'
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we have saved the result of converting the data from JSON
    into the `$data` variable and then accessed the `title` property directly. Now
    that we have the `$data` variable, we can explore the `parts` property:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们保存了将数据从JSON转换为`$data`变量的结果，然后直接访问了`title`属性。现在我们有了`$data`变量，我们可以探索`parts`属性：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we directly access the `parts` property, which is an array
    of objects. We then pass this array of objects to `Select-Object` to expand the
    `name` property of each part. If we want to generate JSON output (as we did with
    `jq` in the previous section), we can use the `ConvertTo-Json` cmdlet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接访问`parts`属性，这是一个对象数组。然后我们将这个对象数组传递给`Select-Object`来展开每个部分的`name`属性。如果我们想生成JSON输出（就像在上一节中使用`jq`一样），我们可以使用`ConvertTo-Json`命令：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we have used the same command as in the previous example (although we
    have used the `select` alias for `Select-Object` for conciseness) and then passed
    the output into the `ConvertTo-Json` cmdlet. This cmdlet performs the opposite
    of `ConvertFrom-Json` – in other words, it converts a set of PowerShell objects
    into JSON.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了与上一个示例中相同的命令（尽管我们使用了`select`别名作为`Select-Object`的简洁形式），然后将输出传递给`ConvertTo-Json`命令。这个命令执行与`ConvertFrom-Json`相反的操作-换句话说，它将一组PowerShell对象转换为JSON。
- en: 'If we want to output JSON objects with the part names, we can do that using
    the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要输出带有部分名称的JSON对象，可以使用以下命令：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we use `ForEach-Object` instead of `Select-Object`. The `ForEach-Object`
    cmdlet allows us to provide a snippet of PowerShell that is executed for each
    object in the input data and the `$_` variable contains the item in the set for
    each execution. In the snippet inside `ForEach-Object`, we have used the `@{ }`
    syntax to create a new PowerShell object with a property called `Name` that is
    set to the `name` property of the current input object (which is the part name,
    in this case). Finally, we pass the resulting set of objects into `ConvertTo-Json`
    to convert to JSON output.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`ForEach-Object`而不是`Select-Object`。`ForEach-Object`命令允许我们为输入数据中的每个对象提供一个PowerShell片段，并且`$_`变量包含每次执行的集合中的项目。在`ForEach-Object`内部的片段中，我们使用`@{
    }`语法创建一个名为`Name`的新PowerShell对象属性，该属性设置为当前输入对象的`name`属性（在这种情况下是部分名称）。最后，我们将生成的对象集传递给`ConvertTo-Json`以转换为JSON输出。
- en: 'We can use this approach to build up richer output – for example, to include
    the name of the part along with the number of chapters it contains:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法来构建更丰富的输出-例如，包括部分名称以及它包含的章节数：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we have extended the snippet inside `ForEach-Object` to `@{
    "Name" = $_.name; "ChapterCount"=$_.chapters.Count }`. This creates an object
    with two properties: `Name` and `ChapterCount`. The `chapters` property is a PowerShell
    array and so we can use the array''s `Count` property for the value of the `ChapterCount`
    property in the output.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们扩展了`ForEach-Object`内部的片段到`@{ "Name" = $_.name; "ChapterCount"=$_.chapters.Count
    }`。这将创建一个具有两个属性的对象：`Name`和`ChapterCount`。`chapters`属性是一个PowerShell数组，因此我们可以使用数组的`Count`属性作为输出中`ChapterCount`属性的值。
- en: 'If we wanted to output a summary with the chapter names for each part, we can
    combine the approaches we have seen so far:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要输出每个部分的章节名称的摘要，我们可以结合我们迄今为止看到的方法：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we have again used the `ForEach-Object` cmdlet to create PowerShell objects,
    this time with `Name` and `Chapters` properties. To create the `Chapters` property,
    we just want the name of each chapter, and we can use the `Select-Object` cmdlet
    just as we originally did to select part names earlier in this section, but this
    time we use it inside the `ForEach-Object` snippet. Being able to compose commands
    in this way gives us a lot of flexibility.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`ForEach-Object`命令来创建PowerShell对象，这次使用`Name`和`Chapters`属性。要创建`Chapters`属性，我们只需获取每个章节的名称，我们可以像在本节前面选择部分名称时一样使用`Select-Object`命令，但这次我们将其用在`ForEach-Object`片段内。能够以这种方式组合命令使我们具有很大的灵活性。
- en: 'In the previous examples, we have been working with data that we loaded from
    a local file with `Get-Content`. To download data from a URL, PowerShell provides
    a couple of handy cmdlets: `Invoke-WebRequest` and `Invoke-RestMethod`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们一直在处理使用`Get-Content`从本地文件加载的数据。要从URL下载数据，PowerShell提供了一些方便的命令：`Invoke-WebRequest`和`Invoke-RestMethod`。
- en: 'We can use `Invoke-WebRequest` to download the sample data from GitHub:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Invoke-WebRequest`从GitHub下载示例数据：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we see that `Invoke-WebRequest` gives us access to various properties
    of the response, including the status code and content. To load the data as JSON,
    we could pass the `Content` property into `ConvertFrom-JSON`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`Invoke-WebRequest`使我们可以访问响应的各种属性，包括状态代码和内容。要将数据加载为JSON，我们可以将`Content`属性传递给`ConvertFrom-JSON`：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we have used the `iwr` alias as a shorthand for `Invoke-WebRequest`,
    which can be handy when working interactively. We could have passed the output
    from `Invoke-WebRequest` into `Select-Object` to expand the `Content` property
    as we saw previously. Instead, we''ve wrapped the expression in parentheses to
    directly access the property to show an alternate syntax. This content is then
    passed to `ConvertFrom-Json`, which converts the data into PowerShell objects
    as we saw earlier. This composability is handy, but if you are only interested
    in the JSON content (and not in any other properties of the response), then you
    can use the `Invoke-RestMethod` cmdlet to achieve this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`iwr`别名作为`Invoke-WebRequest`的简写，这在交互式工作时可能很方便。我们本可以将`Invoke-WebRequest`的输出传递给`Select-Object`来展开`Content`属性，就像我们之前看到的那样。相反，我们将表达式括在括号中，直接访问属性以显示另一种语法。然后将此内容传递给`ConvertFrom-Json`，将数据转换为PowerShell对象，就像我们之前看到的那样。这种可组合性很方便，但如果您只对JSON内容感兴趣（而不关心响应的其他属性），那么您可以使用`Invoke-RestMethod`命令来实现这一点：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we see the same output as before because the `Invoke-RestMethod` cmdlet
    has determined that the response contains JSON data and automatically performed
    the conversion.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到与之前相同的输出，因为`Invoke-RestMethod`命令已经确定响应包含JSON数据，并自动执行了转换。
- en: Summarizing working with JSON
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结使用JSON
- en: In the last two sections, you've seen how both `jq` and PowerShell give you
    rich capabilities for working with JSON input. In each case, you've seen how to
    extract simple values and to perform more complex manipulation to generate new
    JSON output. With JSON in common use across APIs and CLIs, being able to work
    effectively with JSON is a big productivity boost, as we will see in the rest
    of the chapter. Throughout the rest of the chapter, we will use `jq` in the examples
    where we need an extra tool to help process JSON, but be aware that you could
    also use PowerShell for this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两节中，您已经看到了`jq`和PowerShell如何为您提供处理JSON输入的丰富功能。在每种情况下，您已经看到如何提取简单的值，并执行更复杂的操作以生成新的JSON输出。由于JSON在API和CLI中被广泛使用，能够有效地处理JSON是一个巨大的生产力提升，正如我们将在本章的其余部分中看到的那样。在本章的其余部分，我们将在需要额外工具来处理JSON的示例中使用`jq`，但请注意，您也可以使用PowerShell来实现这一点。
- en: In the next section, we will see how to combine the techniques for working with
    JSON with another command-line tool, this time with some tips for working with
    the Azure CLI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将处理JSON的技术与另一个命令行工具结合使用，这次是一些处理Azure CLI的技巧。
- en: Working with the Azure CLI (az)
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure CLI（az）
- en: The drive toward cloud computing brings a number of benefits, among them the
    ability to stand up computing resources on demand. Being able to automate the
    creation, configuration, and deletion of these resources is a key part of the
    benefits, and this is often performed using the CLI provided by the relevant cloud
    vendor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算的推动带来了许多好处，其中包括能够按需创建计算资源的能力。能够自动化创建、配置和删除这些资源是利益的关键部分，这通常是使用相关云供应商提供的CLI来执行的。
- en: In this section, we will create and publish a simple website, all from the command
    line, and use this as a way to take a look at some tips for working with the Azure
    CLI (`az`). We will see some ways to use `jq` that we saw earlier in the chapter,
    as well as the built-in querying capabilities of `az`. If you want to follow along
    but don't already have an Azure subscription, you can sign up for a free trial
    at https://azure.microsoft.com/free/. Let's get started by installing the CLI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从命令行创建和发布一个简单的网站，并将其作为查看使用Azure CLI（az）的一些技巧的方式。我们将看到如何使用本章前面看到的`jq`以及`az`的内置查询功能。如果您想跟着做，但还没有Azure订阅，您可以在https://azure.microsoft.com/free/免费试用。让我们开始安装CLI。
- en: Installing and configuring the Azure CLI
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置Azure CLI
- en: 'There is a range of options for installing the Azure CLI. The simplest is to
    open a terminal in the WSL distro where you want to install the CLI and run the
    following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Azure CLI有多种选项。最简单的方法是在您想要安装CLI的WSL分发中打开终端，并运行以下命令：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command downloads the installation script and runs it in bash. If you
    prefer not to directly run scripts from the internet, you can either download
    the script first and inspect it or check out the individual installation steps
    here: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令下载安装脚本并在bash中运行。如果您不想直接从互联网运行脚本，您可以先下载脚本并检查它，或者在这里查看单独的安装步骤：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest)。
- en: 'Once installed, you should be able to run `az` from your terminal. To connect
    to your Azure subscription so that you can manage it, run `az login`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该能够从终端运行`az`。要连接到您的Azure订阅，以便管理它，请运行`az login`：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this output from the `az login` command, you can see that `az` has generated
    a code that we can use to log in by visiting [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin).
    Open this URL in your browser and sign in with the account you use for your Azure
    subscription. Shortly after doing this, the `az login` command will output your
    subscription information and finish running.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`az login`命令的输出中，您可以看到`az`生成了一个代码，我们可以通过访问[https://microsoft.com/devicelogin](https://microsoft.com/devicelogin)来使用该代码登录。在浏览器中打开此网址，并使用您用于Azure订阅的帐户登录。在这样做后不久，`az
    login`命令将输出您的订阅信息并完成运行。
- en: If you have multiple subscriptions, you can list them with `az account list`
    and choose which subscription is the default subscription to work with using `az
    account set --subscription YourSubscriptionNameOrId`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个订阅，可以使用`az account list`列出它们，并使用`az account set --subscription YourSubscriptionNameOrId`选择要使用的默认订阅。
- en: 'Now that we are signed in, we can start running commands. In Azure, resources
    live inside resource groups (a logical container), so let''s list our groups:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录，可以开始运行命令了。在Azure中，资源存放在资源组（逻辑容器）中，所以让我们列出我们的组：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, the output from the command shows that there are currently no resource
    groups in the subscription. Note that the output is `[]` – an empty JSON array.
    By default, `az` outputs results as JSON, so running the previous command against
    a subscription with some existing resource groups gives us the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，命令的输出显示订阅中当前没有资源组。请注意，输出是`[]` - 一个空的JSON数组。默认情况下，`az`将结果输出为JSON，因此对具有一些现有资源组的订阅运行先前的命令会给我们以下输出：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding output has been truncated as it gets quite verbose. Fortunately,
    `az` allows us to choose from a number of output formats, including table:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出已经被截断，因为它变得非常冗长。幸运的是，`az`允许我们从多种输出格式中进行选择，包括表格：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this output, we have used the `-o table` switch to configure table output.
    This output format is more concise and generally quite convenient for interactive
    usage of the CLI, but it can be tedious to have to keep adding the switch to commands.
    Fortunately, we can make the table output the default by running the `az configure`
    command. This will present you with a short set of interactive choices, including
    which output format to use by default. Because the default output format can be
    overridden, it is important to specify JSON output if that is what you want in
    scripts in case the user has configured a different default.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们使用了`-o table`开关来配置表格输出。这种输出格式更简洁，通常对CLI的交互使用非常方便，但是不得不不断地在命令中添加开关可能会很繁琐。幸运的是，我们可以通过运行`az
    configure`命令将表格输出设置为默认值。这将为您提供一组简短的交互选择，包括默认使用的输出格式。由于默认输出格式可以被覆盖，因此在脚本中指定JSON输出是很重要的，以防用户配置了不同的默认值。
- en: For more examples of using `az`, including how to create various resources in
    Azure, see the *Samples* section at [https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure).
    In the remainder of this section, we will look at some specific examples of working
    with the CLI for querying information about resources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`az`的更多示例，包括如何在Azure中创建各种资源，请参阅[https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure)上的*示例*部分。在本节的其余部分，我们将看一些关于使用CLI查询有关资源信息的具体示例。
- en: Creating an Azure web app
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Azure Web应用程序
- en: To demonstrate querying with `az`, we will create a simple Azure web app. Azure
    web apps allow you to host web applications written in various languages (including
    .NET, Node.js, PHP, Java, and Python), and have many options for deployment that
    you can pick from based on your preferences. We will keep this simple to ensure
    we focus on the CLI usage, so we will create a single-page static website and
    deploy it via FTP. To find out more about Azure web apps, see the documentation
    at [https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用`az`进行查询，我们将创建一个简单的Azure Web应用程序。Azure Web应用程序允许您托管用各种语言编写的Web应用程序（包括.NET、Node.js、PHP、Java和Python），并且有许多部署选项可供您根据自己的喜好选择。为了确保我们专注于CLI的使用，我们将保持简单，创建一个单页面静态网站，并通过FTP部署它。要了解更多关于Azure
    Web应用程序的信息，请参阅[https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview)上的文档。
- en: 'Before creating the web app, we need to create a resource group:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web应用程序之前，我们需要创建一个资源组：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we use the `az group create` command to create a resource group to contain
    the resources that we will create. Note that we''ve used the line continuation
    character (`\`) to split the command across multiple lines for readability. To
    run a web app, we need an Azure App Service plan to host it in, so we will create
    that first:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`az group create`命令创建一个资源组来包含我们将创建的资源。请注意，我们使用了行继续字符（`\`）将命令分割成多行以便阅读。要运行Web应用程序，我们需要一个Azure应用服务计划来托管它，所以我们将首先创建它：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this snippet, we used the `az appservice plan create` command to create
    a free hosting plan in the resource group we just created. Now, we can create
    a web app using that hosting plan:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用`az appservice plan create`命令在我们刚刚创建的资源组中创建了一个免费的托管计划。现在，我们可以使用该托管计划创建Web应用程序：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we generate a random name for the site (as it needs to be unique) and
    store it in the `WEB_APP_NAME` variable. We then use this with the `az webapp
    create` command. Once this command completes, we have created a new website and
    are ready to start querying with the `az` CLI.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为网站生成一个随机名称（因为它需要是唯一的），并将其存储在`WEB_APP_NAME`变量中。然后我们使用`az webapp create`命令。一旦这个命令完成，我们就创建了一个新的网站，并准备好开始使用`az`
    CLI进行查询。
- en: Querying single values
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询单个值
- en: 'The first thing we want to query for our web app is its URL. We can use the
    `az webapp show` command to list various properties for our web app:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查询Web应用程序的第一件事是它的URL。我们可以使用`az webapp show`命令列出我们的Web应用程序的各种属性：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we have passed the `--output json` switch to ensure that we get JSON output
    regardless of what default format is configured. In this cut-down output, we can
    see that there is a `defaultHostName` property that we can use to build up the
    URL for our site.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了`--output json`开关，以确保无论配置了什么默认格式，我们都能获得JSON输出。在这个简化的输出中，我们可以看到有一个`defaultHostName`属性，我们可以用它来构建我们网站的URL。
- en: 'One way to extract the `defaultHostName` property is to use `jq`, as we saw
    in the *Using jq* section:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提取`defaultHostName`属性的一种方法是使用`jq`，就像我们在*使用jq*部分中看到的那样：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this snippet, we use `jq` to select the `defaultHostName` property and pass
    the `-r` switch to get raw output to avoid it being quoted, and then assign this
    to the `WEB_APP_URL` property so that we could use it in other scripts.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用`jq`选择`defaultHostName`属性，并传递`-r`开关以获得原始输出，避免它被引用，然后将其分配给`WEB_APP_URL`属性，以便我们可以在其他脚本中使用它。
- en: 'The `az` CLI also includes built-in querying capabilities using the `az` run
    a JMESPath query and output the result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`az` CLI还包括使用`az`运行JMESPath查询并输出结果的内置查询功能：'
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we use the `--query` option to pass the `"defaultHostName"` JMESPath query,
    which selects the `defaultHostName` property. We also add `--output tsv` to use
    tab-separated output, which prevents the value from being wrapped in quotes. This
    retrieves the same value as the previous example with `jq`, but does it all with
    `az`. This can be useful when sharing scripts with others as it removes a required
    dependency.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`--query`选项来传递`"defaultHostName"` JMESPath查询，它选择了`defaultHostName`属性。我们还添加了`--output
    tsv`来使用制表符分隔的输出，这样可以防止值被引号包裹。这检索了与之前使用`jq`相同的值，但是使用了`az`完成了所有操作。这在与他人共享脚本时很有用，因为它消除了对依赖的需求。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can find more details about JMESPath, and an interactive query tool, at
    [https://jmespath.org](https://jmespath.org). There is a `jp` CLI for running
    JMESPath queries, which can be installed from [https://github.com/jmespath/jp](https://github.com/jmespath/jp).
    Additionally, there is a `jpterm` CLI that provides an interactive JMESPath in
    your terminal, which can be installed from [https://github.com/jmespath/jmespath.terminal](https://github.com/jmespath/jmespath.terminal).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://jmespath.org](https://jmespath.org)找到有关JMESPath的更多详细信息和交互式查询工具。有一个`jp`
    CLI用于运行JMESPath查询，可以从[https://github.com/jmespath/jp](https://github.com/jmespath/jp)安装。此外，还有一个`jpterm`
    CLI，它在您的终端中提供了一个交互式JMESPath，可以从[https://github.com/jmespath/jmespath.terminal](https://github.com/jmespath/jmespath.terminal)安装。
- en: 'These tools can provide a nice way to explore JMESPath when building up queries.
    Take the following example, with `jpterm`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以为构建查询时探索JMESPath提供一个不错的方式。以`jpterm`为例：
- en: '**az webapp show --name $WEB_APP_NAME --resource-group wsltips-chapter-11-03
    --output json | jpterm**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**az webapp show --name $WEB_APP_NAME --resource-group wsltips-chapter-11-03
    --output json | jpterm**'
- en: Here, you can see piping JSON output to `jpterm`, which then allows you to interactively
    experiment with queries in your terminal.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到将JSON输出传输到`jpterm`，然后可以在终端中交互式地进行查询实验。
- en: 'We''ve seen a couple of ways to retrieve the hostname via `az` and store it
    in the `WEB_APP_URL` variable. Now, either run `echo $WEB_APP_URL` to output the
    value and copy into your browser, or run `wslview https://$WEB_APP_URL` to launch
    the browser from WSL (for more details on `wslview`, see the *Using wslview to
    launch default Windows applications* section in [*Chapter 5*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054),
    *Linux to Windows Interoperability*):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了通过`az`检索主机名并将其存储在`WEB_APP_URL`变量中的几种方法。现在，要么运行`echo $WEB_APP_URL`来输出值并复制到您的浏览器中，要么运行`wslview
    https://$WEB_APP_URL`从WSL启动浏览器（有关`wslview`的更多详细信息，请参见[*第5章*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054)中的*使用wslview启动默认Windows应用程序*部分，*Linux到Windows互操作性*）：
- en: '![Figure 11.6 – A screenshot showing the Azure web app placeholder site'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 - 显示Azure Web应用程序占位符站点的屏幕截图'
- en: '](img/Figure_11.6_B16412.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.6_B16412.jpg)'
- en: Figure 11.6 – A screenshot showing the Azure web app placeholder site
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 显示Azure Web应用程序占位符站点的屏幕截图
- en: In this screenshot, you can see the placeholder site, loaded via the URL that
    we queried through the `az` CLI. Next, let's look at a more complex querying requirement
    as we add some content to our web app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，您可以看到通过`az` CLI查询的URL加载的占位符站点。接下来，让我们看一下在向Web应用程序添加一些内容时，我们将看到更复杂的查询需求。
- en: Querying and filtering multiple values
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询和过滤多个值
- en: 'Now that we have a web app created, let''s upload a simple HTML page. There
    are many options for managing content with Azure web apps (see [https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/))
    but for simplicity, in this section, we will use `curl` to upload a single HTML
    page via FTP. To do this, we need to get the FTP URL along with the username and
    password. These values can be retrieved using the `az webapp deployment list-publishing-profiles`
    command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个Web应用程序，让我们上传一个简单的HTML页面。使用Azure Web应用程序管理内容有许多选项（请参阅[https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/)），但为简单起见，在本节中，我们将使用`curl`通过FTP上传单个HTML页面。为此，我们需要获取FTP
    URL以及用户名和密码。可以使用`az webapp deployment list-publishing-profiles`命令检索这些值：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This truncated output shows a JSON array in the output. The values we need
    are in the second array item (the one with the `publishMethod` property set to
    `FTP`). Let''s look at how we can achieve this with the `--query` approach we
    saw in the previous section:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截断的输出显示了输出中的JSON数组。我们需要的值在第二个数组项目中（具有`publishMethod`属性设置为`FTP`的项目）。让我们看看如何使用我们在上一节中看到的`--query`方法来实现这一点：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have used a JMESPath query of `[?publishMethod == ''FTP'']|[0].publishUrl`.
    We can break the query down into a few parts:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个JMESPath查询`[?publishMethod == 'FTP']|[0].publishUrl`。我们可以将查询分解为几个部分：
- en: '`[?publishMethod == ''FTP'']` is the syntax for filtering an array, and here
    we filter it to only return items that contain a `publishMethod` property with
    a value of `FTP`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[?publishMethod == ''FTP'']`是过滤数组的语法，在这里我们将其过滤为仅返回包含值为`FTP`的`publishMethod`属性的项目。'
- en: The output from the preceding query is still an array of items, so we use `|[0]`
    to pipe the array into an array selector to take the first array item.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面查询的输出仍然是一个项目数组，所以我们使用`|[0]`将数组传输到数组选择器中，以获取第一个数组项目。
- en: Finally, we use `.publishUrl` to select the `publishUrl` property.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`.publishUrl`来选择`publishUrl`属性。
- en: Again, we've used the `--output tsv` switch to avoid the result being wrapped
    in quotes. This query retrieves the publish URL and we can repeat the query, changing
    the property selector to retrieve the username and password.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用了`--output tsv`开关来避免结果被引号包裹。这个查询检索了发布URL，我们可以重复查询，更改属性选择器以检索用户名和密码。
- en: 'A downside of this approach is that we are issuing three queries to `az`, each
    of which returns the information we require, but throwing away all but one value.
    In many situations, this is acceptable, but sometimes the information we require
    is returned to us from a call to create a resource, and in these cases, repeating
    the call isn''t an option. In these situations, we can use a slight variation
    of the `jq` approach we saw previously:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是我们向`az`发出了三个查询，每个查询都返回我们需要的信息，但是丢弃了除一个值之外的所有值。在许多情况下，这是可以接受的，但有时我们需要的信息是从调用创建资源返回给我们的，在这种情况下，重复调用不是一个选项。在这些情况下，我们可以使用我们之前看到的`jq`方法的轻微变体：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we are storing the JSON response from `az`, rather than piping it directly
    into `jq`. We can then pipe the JSON into `jq` multiple times to select the different
    properties we want to retrieve. In this way, we can make a single call to `az`
    and still capture multiple values. The `jq` query `map(select(.publishMethod =="FTP"))[0].publishUrl`
    can be broken down in a similar way to the JMESPath query we just saw. The first
    part (`map(select(.publishMethod =="FTP"))`) is the `jq` way to select items of
    the array where the `publishMethod` property has the value FTP. The remainder
    of the query selects the first array item and then captures the `publishUrl` property
    to output.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存储了来自`az`的JSON响应，而不是直接将其传输到`jq`。然后我们可以多次将JSON传输到`jq`中以选择我们想要检索的不同属性。通过这种方式，我们可以对`az`进行单次调用，仍然捕获多个值。`jq`查询`map(select(.publishMethod
    =="FTP"))[0].publishUrl`可以以与我们刚刚看到的JMESPath查询类似的方式进行分解。查询的第一部分(`map(select(.publishMethod
    =="FTP"))`)是选择数组中`publishMethod`属性值为FTP的项目的`jq`方式。查询的其余部分选择第一个数组项目，然后捕获`publishUrl`属性以进行输出。
- en: 'There is one more option that we''ll look at here, which is a variation of
    the `--query` approach, and allows us to issue a single query without requiring
    `jq`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个选项，我们将在这里看一下，这是`--query`方法的一个变体，允许我们发出单个查询而不需要`jq`：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This snippet builds on the earlier `--query` approach but has a couple of differences
    to call out.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码建立在之前的`--query`方法之上，但有一些不同之处需要注意。
- en: First, we are using `.[publishUrl,userName,userPWD]` instead of simply `.publishUrl`
    as the final selector in the JMESPath query. The result of this is to generate
    an array containing the values of the `publishUrl`, `userName,` and `userPWD`
    properties.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`.[publishUrl,userName,userPWD]`而不是简单的`.publishUrl`作为JMESPath查询中的最终选择器。这样做的结果是生成一个包含`publishUrl`、`userName`和`userPWD`属性值的数组。
- en: 'This array of properties is output as tab-separated values, and the results
    are treated as a bash array by surrounding the results of executing the `az` command
    in parentheses: `CREDS_TEMP=($(az...))`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性数组以制表符分隔的值输出，并且通过将`az`命令的执行结果括在括号中来将结果视为bash数组：`CREDS_TEMP=($(az...))`。
- en: These two steps allow us to return multiple values from a single call to `az`
    using `--query` and store the results in an array. The last lines in the output
    show assigning the array items to the named variables for ease of use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤允许我们使用`--query`从单个`az`调用中返回多个值，并将结果存储在数组中。输出中的最后几行显示将数组项分配给命名变量以便于使用。
- en: 'Whichever option is used to set the publish environment variables, we can now
    upload the `index.html` file from a terminal in the `chapter-11/03-working-with-az`
    folder of the sample content:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种选项来设置发布环境变量，我们现在可以从示例内容的`chapter-11/03-working-with-az`文件夹中的终端上传`index.html`文件：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we are using `curl` to upload the `index.html` file to FTP using the
    URL, username, and password we queried. Now we can go back to the browser and
    reload the page. We will get the following result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`curl`使用我们查询的URL、用户名和密码将`index.html`文件上传到FTP。现在我们可以回到浏览器并重新加载页面。我们将得到以下结果：
- en: '![Figure 11.7 – A screenshot showing the web app with our uploaded content'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - 屏幕截图显示带有我们上传内容的Web应用程序'
- en: '](img/B16412_11.7.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16412_11.7.jpg)'
- en: Figure 11.7 – A screenshot showing the web app with our uploaded content
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 屏幕截图显示带有我们上传内容的Web应用程序
- en: This screenshot shows the web app we previously created now returning the simple
    HTML page we just uploaded.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕截图显示了我们之前创建的Web应用程序现在返回了我们刚刚上传的简单HTML页面。
- en: 'Now that we''re finished with the web app (and App Service plan) we created,
    we can delete them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们创建的Web应用程序（和应用服务计划），我们可以删除它们：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This command will delete the `wsltips-chapter-11-03` resource group that we
    have been using and all the resources we created within it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将删除我们一直在使用的`wsltips-chapter-11-03`资源组以及其中创建的所有资源。
- en: 'The example in this section showed using `curl` to FTP a single page to the
    Azure web app we created, which provided a handy example for querying with `az`,
    but Azure web apps offer a wide range of options for deploying your content –
    see the following article for more details: [https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions](https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions).
    It is also worth noting that for hosting static websites, Azure Storage static
    site hosting can be a great option. For a walkthrough, see [https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例显示了使用`curl`将单个页面FTP到我们创建的Azure Web应用程序，这为使用`az`进行查询提供了一个方便的示例，但Azure Web应用程序提供了多种部署内容的选项-有关更多详细信息，请参阅以下文章：[https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions](https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions)。值得注意的是，对于托管静态网站，Azure存储静态网站托管可能是一个很好的选择。有关操作步骤，请参阅[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli)。
- en: In this section, you've seen a number of approaches to querying using the `az`
    CLI. You've seen how to set the default output to table format for readable interactive
    querying. When scripting, you've seen how you can use JSON output and handle it
    with `jq`. You've learned how to use JMESPath querying with the `--query` switch
    to filter and select values from the responses directly with `az` commands. In
    this section, we've only looked at a narrow slice of the `az` CLI (for web apps)
    – if you're interested in exploring more of the breadth of `az`, then see [https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经看到了使用`az` CLI进行查询的多种方法。您已经了解了如何将默认输出设置为表格格式，以便进行可读的交互式查询。在脚本编写时，您已经了解了如何使用JSON输出并使用`jq`进行处理。您已经学会了如何使用`--query`开关进行JMESPath查询，以便使用`az`命令直接过滤和选择响应中的值。在本节中，我们只看了`az`
    CLI（用于Web应用程序）的一个狭窄片段-如果您有兴趣探索更多`az`的广度，请参阅[https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure)。
- en: In the next section, we'll take a look at another CLI – this time for Kubernetes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看另一个CLI-这次是用于Kubernetes的CLI。
- en: Working with the Kubernetes CLI (kubectl)
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes CLI（kubectl）
- en: When building a containerized application, Kubernetes is a common choice of
    container orchestrator. For an introduction to Kubernetes, see the *Setting up
    Kubernetes in WSL* section in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*. Kubernetes includes a CLI called `kubectl` for
    working with Kubernetes from the command line. In this section, we will deploy
    a basic website in Kubernetes and then look at different ways to query information
    about it using `kubectl`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建容器化应用程序时，Kubernetes是容器编排器的常见选择。有关Kubernetes的介绍，请参阅[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中设置Kubernetes*部分。Kubernetes包括一个名为`kubectl`的CLI，用于从命令行处理Kubernetes。在本节中，我们将在Kubernetes中部署一个基本网站，然后查看使用`kubectl`查询有关它的信息的不同方法。
- en: In [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082), *Working with
    Containers in WSL*, we saw how to set up Kubernetes on our local machine with
    Docker Desktop. Here, we will explore setting up a Kubernetes cluster using a
    cloud provider. The following instructions are for Azure, but if you are familiar
    with another cloud that has a Kubernetes service, then feel to work with that.
    If you want to follow along but don't already have an Azure subscription, you
    can sign up for a free trial at https://azure.microsoft.com/free/.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中使用容器*部分，我们看到了如何使用Docker
    Desktop在本地机器上设置Kubernetes。在这里，我们将探索使用云提供商设置Kubernetes集群。以下说明适用于Azure，但如果您熟悉另一个具有Kubernetes服务的云，则可以使用该云。如果您想跟着操作，但尚未拥有Azure订阅，可以在https://azure.microsoft.com/free/上注册免费试用。
- en: Let's get started by installing `kubectl`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装`kubectl`。
- en: Installing and configuring kubectl
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置kubectl
- en: 'There are various options for installing `kubectl` (which can be found at [https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux](https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux))
    but the simplest is to run the following commands from your WSL distribution:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种选项可用于安装`kubectl`（可以在[https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux](https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux)找到），但最简单的方法是从您的WSL分发版运行以下命令：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These commands download the latest `kubectl` binary, mark it as executable,
    and then move it to your `bin` folder. Once this is done, you should be able to
    run `kubectl version --client` to check that `kubectl` is installed correctly:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令下载最新的`kubectl`二进制文件，将其标记为可执行文件，然后将其移动到您的`bin`文件夹中。完成后，您应该能够运行`kubectl version
    --client`来检查`kubectl`是否正确安装：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we have seen the output from `kubectl` showing that we have installed
    version `v1.19.2`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了来自`kubectl`的输出，显示我们已安装版本`v1.19.2`。
- en: 'The `kubectl` utility has a wide range of commands and enabling bash completion
    can make you more productive. To do this, run the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`实用程序有各种命令，并且启用bash自动补全可以使您更加高效。要做到这一点，请运行以下命令：'
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This adds a command to your `.bashrc` file to auto-load the `kubectl` bash completion
    when bash launches. To try it out, restart bash or run `source ~/.bashrc`. Now,
    you can type `kubectl ver<TAB> --cli<TAB>` to get the previous `kubectl version
    --client` command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的`.bashrc`文件中添加一个命令，以便在bash启动时自动加载`kubectl` bash自动补全。要尝试它，请重新启动bash或运行`source
    ~/.bashrc`。现在，您可以输入`kubectl ver<TAB> --cli<TAB>`来获取以前的`kubectl version --client`命令。
- en: Tip
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you find `kubectl` too much to type, you can create an alias by running
    the following commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得`kubectl`输入太多，可以通过运行以下命令创建一个别名：
- en: '**echo ''alias k=kubectl'' >>~/.bashrc**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**echo ''alias k=kubectl'' >>~/.bashrc**'
- en: '**echo ''complete -F __start_kubectl k'' >>~/.bashrc**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**echo ''complete -F __start_kubectl k'' >>~/.bashrc**'
- en: These commands add to `.bashrc` to configure `k` as an alias for `kubectl` and
    set up bash completion for `k`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将添加到`.bashrc`中，以将`k`配置为`kubectl`的别名，并为`k`设置bash自动补全。
- en: With this, you can use commands such as `k version – client` and still get bash
    completion.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您可以使用命令，比如`k version – client`，并且仍然可以获得bash自动补全。
- en: Now that we have `kubectl` installed and configured, let's create a Kubernetes
    cluster to use it with.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装和配置了`kubectl`，让我们创建一个Kubernetes集群来使用它。
- en: Creating a Kubernetes cluster
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Kubernetes集群
- en: The following instructions will take you through creating a Kubernetes cluster
    using `az`). If you haven't got `az` installed, then refer to the *Installing
    and configuring the Azure CLI* section earlier in this chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明将带您完成使用`az`创建Kubernetes集群的过程。如果您还没有安装`az`，请参考本章前面的*安装和配置Azure CLI*部分。
- en: 'The first step is to create a resource group to contain our cluster:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个资源组来包含我们的集群：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we are creating a resource group called `wsltips-chapter-11-04` in the
    `westeurope` region.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为`wsltips-chapter-11-04`的资源组，位于`westeurope`区域。
- en: 'Next, we create the AKS cluster:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建AKS集群：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This command creates a cluster called `wsltips` in the resource group we just
    created. This command will take a few minutes to run and when it has completed,
    we will have a Kubernetes cluster running with two worker nodes where we can run
    our container workloads.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在我们刚创建的资源组中创建了一个名为`wsltips`的集群。此命令将需要几分钟来运行，当它完成后，我们将拥有一个运行有两个工作节点的Kubernetes集群，我们可以在其中运行我们的容器工作负载。
- en: 'The final step is to set up `kubectl` so that it can connect to the cluster:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是设置`kubectl`，以便它可以连接到集群：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we use `az aks get-credentials` to get the credentials for the cluster
    we created and save them in the configuration file for `kubectl`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`az aks get-credentials`来获取我们创建的集群的凭据，并将它们保存在`kubectl`的配置文件中。
- en: 'Now, we can run commands such as `kubectl get services` to list the defined
    services:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行诸如`kubectl get services`之类的命令来列出已定义的服务：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This output shows the listing of Kubernetes services in the cluster we created,
    demonstrating that we have successfully connected to the cluster.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了我们在创建的集群中Kubernetes服务的列表，证明我们已成功连接到了集群。
- en: Now that we have a Kubernetes cluster and `kubectl` is configured to connect
    to it, let's deploy a test website to it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个Kubernetes集群，并且`kubectl`已配置好连接到它，让我们将一个测试网站部署到它上面。
- en: Deploying a basic website
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署基本网站
- en: To help explore `kubectl`, we will deploy a basic website. We can then use that
    to look at different ways of querying information with `kubectl`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助探索`kubectl`，我们将部署一个基本网站。然后我们可以使用它来查看使用`kubectl`查询信息的不同方式。
- en: 'The accompanying code for the book contains a folder for this section with
    the Kubernetes YAML files. You can get this code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques).
    The content for this section is in the `chapter-11/04-working-with-kubectl` folder.
    The `manifests` folder contains a number of YAML files defining Kubernetes resources
    to deploy:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的附带代码包含了一个用于此部分的文件夹，其中包含了Kubernetes YAML文件。您可以从[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)获取此代码。此部分的内容位于`chapter-11/04-working-with-kubectl`文件夹中。`manifests`文件夹包含了一些定义要部署的Kubernetes资源的YAML文件：
- en: A **ConfigMap** containing a simple HTML page
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个简单HTML页面的**ConfigMap**
- en: A `nginx` image and configures it to load the HTML page from the ConfigMap
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`nginx`镜像，并配置它从ConfigMap加载HTML页面
- en: A `nginx` Deployment
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`nginx`部署
- en: 'To deploy the website, launch your WSL distro and navigate to the `chapter-11/04-working-with-kubectl`
    folder. Then, run the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署网站，请启动您的WSL发行版并导航到`chapter-11/04-working-with-kubectl`文件夹。然后运行以下命令：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we used `kubectl apply -f manifests` to create the resources described
    by the YAML files in the `manifests` folder. The output of the command shows the
    three resources that have been created.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`kubectl apply -f manifests`来创建`manifests`文件夹中的YAML文件描述的资源。命令的输出显示已创建的三个资源。
- en: 'Now, we can run `kubectl get services chapter-11-04` to see the status of the
    created service:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`kubectl get services chapter-11-04`来查看已创建服务的状态：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we see that the `chapter-11-04` service is of type `LoadBalancer`. With
    AKS, a `LoadBalancer` service will automatically be exposed using an *Azure load
    balancer* and this can take a few moments to provision – note the `<pending>`
    value for `EXTERNAL_IP` in the output showing that the load balancer is in the
    process of being provisioned. In the next section, we'll look at how to query
    this IP address.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`chapter-11-04`服务的类型是`LoadBalancer`。在AKS中，`LoadBalancer`服务将自动使用*Azure负载均衡器*暴露，并且这可能需要一些时间来进行配置
    - 请注意输出中`EXTERNAL_IP`的`<pending>`值，显示负载均衡器正在进行配置的过程。在下一节中，我们将看看如何查询此IP地址。
- en: Querying with JSONPath
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSONPath查询
- en: 'As we just saw, the external IP address of the service isn''t available immediately
    after creating the service as the Azure load balancer needs to be provisioned
    and configured. We can see what this looks like in the underlying data structures
    by getting the service output in JSON format:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，创建服务后立即获得服务的外部IP地址是不可用的，因为Azure负载均衡器需要进行配置和配置。我们可以通过以JSON格式获取服务输出来看到底层数据结构是什么样子的：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we see the truncated JSON output from applying the `-o json` option.
    Note the empty value for the `loadBalancer` property under `status`. If we wait
    a short while and then re-run the command, we see the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了应用`-o json`选项的截断JSON输出。请注意`status`下`loadBalancer`属性的空值。如果我们等待一会儿然后重新运行命令，我们会看到以下输出：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we can see that the `loadBalancer` property now contains an `ingress`
    property with an array of IP addresses.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`loadBalancer`属性现在包含一个带有IP地址数组的`ingress`属性。
- en: 'We can use the built-in `jsonpath` functionality of `kubectl` to directly query
    for the IP address:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl`的内置`jsonpath`功能直接查询IP地址：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here, we have used `-o jsonpath` to provide a JSONPath query: `{.status.loadBalancer.ingress[0].ip}`.
    This query maps directly onto the path into the JSON results that we want to query.
    For more details on JSONPath (including an online interactive evaluator), see
    [https://jsonpath.com/](https://jsonpath.com/). This technique is handy to use
    in scripts and the accompanying code has a `scripts/wait-for-load-balancer.sh`
    script that waits for the load balancer to be provisioned and then outputs the
    IP address.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`-o jsonpath`来提供一个JSONPath查询：`{.status.loadBalancer.ingress[0].ip}`。此查询直接映射到我们要查询的JSON结果的路径。有关JSONPath的更多详细信息（包括在线交互式评估器），请参见[https://jsonpath.com/](https://jsonpath.com/)。这种技术在脚本中很方便使用，附带的代码中有一个`scripts/wait-for-load-balancer.sh`脚本，它等待负载均衡器进行配置，然后输出IP地址。
- en: Using JSONPath directly with `kubectl` is convenient, but JSONPath can be somewhat
    limited compared to `jq` and there are times where we need to make the switch.
    We'll take a look at one of these scenarios next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在`kubectl`中使用JSONPath很方便，但与`jq`相比，JSONPath可能有一定的局限性，有时我们需要进行切换。接下来我们将看一个这样的场景。
- en: Scaling the website
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展网站
- en: 'The Deployment we just created only runs a single instance of the `nginx` Pod.
    We can see this by running the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的部署只运行一个`nginx` Pod的实例。我们可以通过运行以下命令来查看：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we list the Pods that match the `app=chapter-11-04` label selector, which
    is specified in the definition in the `deployment.yaml` we applied.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了与`deployment.yaml`中指定的`app=chapter-11-04`标签选择器匹配的Pods。
- en: 'One of the features that Kubernetes Deployment resources provide is the ability
    to easily scale up the number of Pods for a Deployment:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署资源提供的一个功能是轻松地扩展部署的Pod数量：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we specify the Deployment to scale and the number of instances (`replicas`)
    we want to scale it to. If we query the Pods again, we will now see three instances:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定要扩展的部署和我们想要将其扩展到的实例数（`replicas`）。如果我们再次查询Pods，现在将看到三个实例：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This output lists three Pods for the Deployment, but note that one of them is
    in the `Pending` state. The reason for this is that the Deployment definition
    requested a full CPU for each Pod, but the cluster only has two worker nodes.
    While the machine running each node has two CPUs, some of that is reserved for
    the worker node processes themselves. Although this scenario is deliberately constructed
    to illustrate querying with `kubectl`, it is common to encounter similar issues.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出列出了部署的三个Pod，但请注意其中一个处于`Pending`状态。原因是部署定义要求每个Pod使用完整的CPU，但集群只有两个工作节点。虽然每个节点运行的机器都有两个CPU，但其中一些是为工作节点进程本身保留的。尽管这种情况是故意构造出来的，以说明使用`kubectl`进行查询，但遇到类似问题是很常见的。
- en: 'Having found a Pod that isn''t running, we can investigate it further:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个未运行的Pod后，我们可以进一步调查它：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we have requested the JSON for the Pod that isn't running, and the truncated
    output shows a `conditions` property. This has an entry that indicates that the
    Pod can't be scheduled (that is, Kubernetes couldn't find anywhere in the cluster
    to run it). In the next section, we will write a query to find any Pods that can't
    be scheduled from a list of Pods.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求了未运行的Pod的JSON，并且截断的输出显示了一个`conditions`属性。这里有一个条目表明Pod无法被调度（也就是说，Kubernetes找不到集群中的任何位置来运行它）。在下一节中，我们将编写一个查询，从Pod列表中查找任何无法被调度的Pod。
- en: Querying with jq
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jq进行查询
- en: 'Let''s look at how to write a query to find any Pods that have a condition
    with a type of `PodScheduled` with `status` set to `False`. Firstly, we can get
    the names of Pods with the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写一个查询，查找具有`type`为`PodScheduled`且`status`设置为`False`的条件的任何Pod。首先，我们可以使用以下命令获取Pod的名称：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we have piped the JSON output from `kubectl` to `jq` and used a selector
    to extract `metadata.name` for each item in the input `items` array as the `name`
    property in the output. This uses the same techniques we saw earlier in the chapter
    – see the *Using jq* section for more details.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`kubectl`的JSON输出传递给`jq`，并使用选择器提取输入`items`数组中每个项目的`metadata.name`作为输出中的`name`属性。这使用了我们在本章前面看到的相同技术-有关更多详细信息，请参阅*使用jq*部分。
- en: 'Next, we want to include the conditions from the `status` property:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要包括`status`属性中的条件：
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, we have included all of the conditions, but since we''re only looking
    for those that haven''t been scheduled, we want to only include specific conditions.
    To do this, we can use the `jq` `select` filter, which processes an array of values
    and passes through those that match the specified condition. Here, we will use
    it to filter the status conditions to only include those that have `type` set
    to `PodScheduled` and `status` set to `False`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了所有的条件，但由于我们只想要那些尚未被调度的条件，我们只想包括特定的条件。为此，我们可以使用`jq`的`select`过滤器，它处理一个值数组，并通过那些匹配指定条件的值。在这里，我们将使用它来过滤状态条件，只包括那些`type`设置为`PodScheduled`且`status`设置为`False`的条件：
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we applied `select(.type == "PodScheduled" and .status == "False")` to
    the set of conditions being assigned to the `conditions` property. The result
    of the query is just the single item that has the failure status condition.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`select(.type == "PodScheduled" and .status == "False")`应用于被分配给`conditions`属性的条件集。查询的结果只是具有失败状态条件的单个项目。
- en: 'We can make a couple of final tweaks to the query:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对查询进行一些最后的微调：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we''ve made a couple of last updates to the selector. The first is to
    pipe the result of the previous selector into `{name, reason: .conditions.reason,
    message: .conditions.message}` to pull out only the fields we''re interested in
    seeing in the output, making the output easier to read. The second is to wrap
    the whole selector in square brackets so that the output is a JSON array. This
    way, if there are multiple unschedulable pods, we will get valid output that could
    be further processed if we wanted.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们对选择器进行了一些最后的更新。第一个是将先前选择器的结果传递到`{name, reason: .conditions.reason, message:
    .conditions.message}`，以仅提取我们感兴趣的字段，使输出更易于阅读。第二个是将整个选择器包装在方括号中，以便输出是一个JSON数组。这样，如果有多个无法调度的Pod，我们将获得有效的输出，如果需要，可以进一步处理。'
- en: 'If you find yourself using this command regularly, you may want to save it
    as a bash script or even add it to your `.bashrc` file as an alias:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用这个命令，您可能希望将其保存为一个bash脚本，甚至将其添加到您的`.bashrc`文件中作为别名：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we have created a `k-unschedulable` alias for the command to list pods
    that are unschedulable. Note that quotes (`"`) have been escaped with a backslash
    (`\"`).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为列出无法调度的Pod的命令创建了一个`k-unschedulable`别名。请注意，引号（`"`）已经用反斜杠（`\"`）进行了转义。
- en: This technique can be applied to various resources in Kubernetes. For example,
    nodes in Kubernetes have status conditions that indicate whether a node is running
    out of memory or disk space, and this query can be modified to make it easy to
    identify those nodes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以应用于Kubernetes中的各种资源。例如，Kubernetes中的节点具有状态条件，指示节点是否正在耗尽内存或磁盘空间，可以修改此查询以便轻松识别这些节点。
- en: Overall, though, there is a general pattern that we've followed, which starts
    with getting the JSON output for the resource you are interested in. From there,
    if the value you want to retrieve is a simple value, then the JSONPath approach
    is a good one to consider. For more complex filtering or output formatting, `jq`
    is a handy tool in your toolkit. Kubernetes holds a rich set of information for
    its resources, and being comfortable working with `kubectl` and its JSON output
    gives you powerful querying capabilities.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们遵循了一个通用的模式，首先是获取您感兴趣的资源的JSON输出。从那里开始，如果您想要检索的值是一个简单的值，那么JSONPath方法是一个值得考虑的好方法。对于更复杂的过滤或输出格式化，`jq`是您工具包中一个方便的工具。Kubernetes为其资源提供了丰富的信息，熟练使用`kubectl`及其JSON输出可以为您提供强大的查询能力。
- en: 'Now that we''re finished with the cluster, we can delete the containing resource
    group:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了集群，我们可以删除包含的资源组：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This command will delete the `wsltips-chapter-11-04` resource group that we
    have been using and all the resources we created within it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将删除我们一直在使用的`wsltips-chapter-11-04`资源组以及其中创建的所有资源。
- en: In this section, you've covered topics from setting up bash completion for `kubectl`
    to make you more productive when typing `kubectl` commands to approaches for using
    `kubectl` to query information about resources in your Kubernetes cluster. Whether
    you're querying a single value for a specific resource or filtering data over
    sets of resources, using the techniques here opens up great opportunities for
    scripting steps of your workflow.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经涵盖了从设置`kubectl`的bash完成到在Kubernetes集群中使用`kubectl`查询资源信息的方法。无论您是为特定资源查询单个值还是在资源集上过滤数据，使用这里的技术都为脚本化工作流程的步骤打开了巨大的机会。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw ways to improve how you work with Git in WSL. You saw
    how to configure Git Credential Manager for Windows to reuse saved Git credentials
    from Windows in WSL and to prompt you in Windows when new Git credentials are
    needed. After this, you saw a range of options for viewing Git history, with a
    discussion of their pros and cons to enable you to pick the right approach for
    you.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了如何改进在WSL中使用Git的方式。您看到了如何配置Windows的Git凭据管理器，以便在WSL中重用保存的Git凭据，并在需要新的Git凭据时在Windows中提示您。之后，您看到了一系列查看Git历史记录的选项，讨论了它们的优缺点，以便您选择适合您的正确方法。
- en: In the rest of the chapter, you saw how to work with JSON data in WSL, initially
    by diving into `jq` and the JSON capabilities of PowerShell. With this background,
    you then saw some examples of working with JSON through deployments using `az`
    and `kubectl`. As well as covering scenarios that you may face with each of these
    CLIs, the examples demonstrated techniques that can be applied to other CLIs (or
    APIs) that provide JSON data. Being able to work effectively with JSON data gives
    you powerful capabilities that you can use in your scripts to save you time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，您了解了如何在WSL中处理JSON数据，首先是深入了解`jq`和PowerShell的JSON功能。有了这个背景，您还看到了一些使用`az`和`kubectl`进行部署的JSON工作示例。除了涵盖每个CLI可能面临的场景外，示例还演示了可以应用于提供JSON数据的其他CLI（或API）的技术。能够有效地处理JSON数据为您提供了强大的能力，可以在脚本中使用，节省您的时间。
- en: This is the final chapter of the book, and I hope I've managed to impart some
    of my excitement around WSL 2 and the possibilities that it brings. Have fun with
    Linux on Windows!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，我希望我已经成功地传达了我对WSL 2以及它带来的可能性的一些兴奋。在Windows上享受Linux吧！
