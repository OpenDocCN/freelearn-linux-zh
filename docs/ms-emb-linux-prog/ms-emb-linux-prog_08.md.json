["```\n# ls -l /dev/ttyAMA*\n\ncrw-rw----    1 root     root      204,  64 Jan  1  1970 /dev/ttyAMA0\ncrw-rw----    1 root     root      204,  65 Jan  1  1970 /dev/ttyAMA1\ncrw-rw----    1 root     root      204,  66 Jan  1  1970 /dev/ttyAMA2\ncrw-rw----    1 root     root      204,  67 Jan  1  1970 /dev/ttyAMA3\n```", "```\n#define SERIAL_AMBA_MAJOR       204\n#define SERIAL_AMBA_MINOR       64\n```", "```\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main(void)\n{\n  int f;\n  unsigned int rnd;\n  int n;\n  f = open(\"/dev/urandom\", O_RDONLY);\n  if (f < 0) {\n    perror(\"Failed to open urandom\");\n    return 1;\n  }\n  n = read(f, &rnd, sizeof(rnd));\n  if (n != sizeof(rnd)) {\n    perror(\"Problem reading urandom\");\n    return 1;\n  }\n  printf(\"Random number = 0x%x\\n\", rnd);\n  close(f);\n  return 0;\n}\n```", "```\n# ls -l /dev/mmcblk*\n\nbrw-------    1 root root  179,   0 Jan  1  1970 /dev/mmcblk0\nbrw-------    1 root root  179,   1 Jan  1  1970 /dev/mmcblk0p1\nbrw-------    1 root root  179,   2 Jan  1  1970 /dev/mmcblk0p2\nbrw-------    1 root root  179,   8 Jan  1  1970 /dev/mmcblk1\nbrw-------    1 root root  179,   9 Jan  1  1970 /dev/mmcblk1p1\nbrw-------    1 root root  179,  10 Jan  1  1970 /dev/mmcblk1p2\n```", "```\nmy_netdev = alloc_netdev(0, \"net%d\", NET_NAME_UNKNOWN, netdev_setup);\nret = register_netdev(my_netdev);\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <net/if.h>\nint main (int argc, char *argv[])\n{\n  int s;\n  int ret;\n  struct ifreq ifr;\n  int i;\n  if (argc != 2) {\n    printf(\"Usage %s [network interface]\\n\", argv[0]);\n    return 1;\n  }\n  s = socket(PF_INET, SOCK_DGRAM, 0);\n  if (s < 0) {\n    perror(\"socket\");\n    return 1;\n  }\n  strcpy(ifr.ifr_name, argv[1]);\n  ret = ioctl(s, SIOCGIFHWADDR, &ifr);\n  if (ret < 0) {\n    perror(\"ioctl\");\n    return 1;\n  }\n  for (i = 0; i < 6; i++)\n    printf(\"%02x:\", (unsigned char)ifr.ifr_hwaddr.sa_data[i]);\n  printf(\"\\n\");\n  close(s);\n  return 0;\n}\n```", "```\n# cat /proc/devices\n\nCharacter devices:\n\n  1 mem\n  2 pty\n  3 ttyp\n  4 /dev/vc/0\n  4 tty\n  4 ttyS\n  5 /dev/tty\n  5 /dev/console\n  5 /dev/ptmx\n  7 vcs\n 10 misc\n 13 input\n 29 fb\n 81 video4linux\n 89 i2c\n 90 mtd\n116 alsa\n128 ptm\n136 pts\n153 spi\n180 usb\n189 usb_device\n204 ttySC\n204 ttyAMA\n207 ttymxc\n226 drm\n239 ttyLP\n240 ttyTHS\n241 ttySiRF\n242 ttyPS\n243 ttyWMT\n244 ttyAS\n245 ttyO\n246 ttyMSM\n247 ttyAML\n248 bsg\n249 iio\n250 watchdog\n251 ptp\n252 pps\n253 media\n254 rtc\n\nBlock devices:\n\n259 blkext\n  7 loop\n  8 sd\n 11 sr\n 31 mtdblock\n 65 sd\n 66 sd\n 67 sd\n 68 sd\n 69 sd\n 70 sd\n 71 sd\n128 sd\n129 sd\n130 sd\n131 sd\n132 sd\n133 sd\n134 sd\n135 sd\n179 mmc\n```", "```\n# ip link show\n\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n\n2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000\n    link/ether 54:4a:16:bb:b7:03 brd ff:ff:ff:ff:ff:ff\n\n3: usb0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000\n    link/ether aa:fb:7f:5e:a8:d5 brd ff:ff:ff:ff:ff:ff\n```", "```\n# ls /sys\n\nblock  bus  class  dev  devices  firmware  fs  kernel  module  power\n```", "```\n# ls\n /sys/devices\narmv7_cortex_a9  platform      system\nbreakpoint       software      virtual\n```", "```\n# cd  /sys/class/tty/ttyAMA0/\n# ls\nclose_delay      flags            line             uartclk\nclosing_wait     io_type          port             uevent\ncustom_divisor   iomem_base       power            xmit_fifo_size\ndev              iomem_reg_shift  subsystem\ndevice           irq              type\n```", "```\n# cat /sys/class/tty/ttyAMA0/dev\n204:64\n```", "```\n# ls /sys/block/\n\nloop0  loop4  mmcblk0       ram0   ram12  ram2  ram6\nloop1  loop5  mmcblk1       ram1   ram13  ram3  ram7\nloop2  loop6  mmcblk1boot0  ram10  ram14  ram4  ram8\nloop3  loop7  mmcblk1boot1  ram11  ram15  ram5  ram9\n```", "```\n# cd /sys/block/mmcblk1\n# ls\n\nalignment_offset   ext_range     mmcblk1p1  ro\nbdi                force_ro      mmcblk1p2  size\ncapability         holders       power      slaves\ndev                inflight      queue      stat\ndevice             mmcblk1boot0  range      subsystem\ndiscard_alignment  mmcblk1boot1  removable  uevent\n```", "```\n# ls  /sys/class/gpio\nexport  gpiochip0   gpiochip32  gpiochip64  gpiochip96  unexport\n```", "```\n# ls /sys/class/gpio/gpiochip96/\nbase  label   ngpio  power  subsystem  uevent\n```", "```\n# echo 48 > /sys/class/gpio/export\n# ls /sys/class/gpio\nexport      gpio48    gpiochip0   gpiochip32  gpiochip64  gpiochip96  unexport\n```", "```\n# ls /sys/class/gpio/gpio48\nactive_low  direction  edge  power  subsystem   uevent  value\n```", "```\n# echo 48 > /sys/class/gpio/export\n# echo rising > /sys/class/gpio/gpio48/edge\n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <poll.h>\n\nint main (int argc, char *argv[])\n{\n  int f;\n  struct pollfd poll_fds [1];\n  int ret;\n  char value[4];\n  int n;\n  f = open(\"/sys/class/gpio/gpio48\", O_RDONLY);\n  if (f == -1) {\n    perror(\"Can't open gpio48\");\n    return 1;\n  }\n  poll_fds[0].fd = f;\n  poll_fds[0].events = POLLPRI | POLLERR;\n  while (1) {\n    printf(\"Waiting\\n\");\n    ret = poll(poll_fds, 1, -1);\n    if (ret > 0) {\n        n = read(f, &value, sizeof(value));\n        printf(\"Button pressed: read %d bytes, value=%c\\n\",\n        n, value[0]);\n    }\n  }\n  return 0;\n}\n```", "```\n# ls /sys/class/leds\nbeaglebone:green:heartbeat  beaglebone:green:usr2\nbeaglebone:green:mmc0       beaglebone:green:usr3\n```", "```\n# ls /sys/class/leds/beaglebone:green:usr2\nbrightness    max_brightness  subsystem     uevent\ndevice        power           trigger\n```", "```\n# cat /sys/class/leds/beaglebone:green:heartbeat/trigger\nnone mmc0 mmc1 timer oneshot [heartbeat] backlight gpio cpu0 default-on\n```", "```\n# echo timer > /sys/class/leds/beaglebone:green:heartbeat/trigger\n# ls /sys/class/leds/beaglebone:green:heartbeat\nbrightness  delay_on    max_brightness  subsystem   uevent\ndelay_off   device      power           trigger\n# cat /sys/class/leds/beaglebone:green:heartbeat/delay_on\n500\n# cat /sys/class/leds/beaglebone:green:heartbeat/delay_off\n500\n#\n```", "```\n# ls -l /dev/i2c*\ncrw-rw---- 1 root i2c 89, 0 Jan  1 00:18 /dev/i2c-0\ncrw-rw---- 1 root i2c 89, 1 Jan  1 00:18 /dev/i2c-1\ncrw-rw---- 1 root i2c 89, 2 Jan  1 00:18 /dev/i2c-2\ncrw-rw---- 1 root i2c 89, 3 Jan  1 00:18 /dev/i2c-3\n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <i2c-dev.h>\n#include <sys/ioctl.h>\n#define I2C_ADDRESS 0x5d\n#define CHIP_REVISION_REG 0x10\n\nvoid main (void)\n{\n  int f_i2c;\n  int val;\n\n  /* Open the adapter and set the address of the I2C device */\n  f_i2c = open (\"/dev/i2c-1\", O_RDWR);\n  ioctl (f_i2c, I2C_SLAVE, I2C_ADDRESS);\n\n  /* Read 16-bits of data from a register */\n  val = i2c_smbus_read_word_data(f, CHIP_REVISION_REG);\n  printf (\"Sensor chip revision %d\\n\", val);\n  close (f_i2c);\n}\n```", "```\n# ls -l /dev/spi*\ncrw-rw---- 1 root root 153, 0 Jan  1 00:29 /dev/spidev1.0\n```", "```\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#define DEVICE_NAME \"dummy\"\n#define MAJOR_NUM 42\n#define NUM_DEVICES 4\n\nstatic struct class *dummy_class;\nstatic int dummy_open(struct inode *inode, struct file *file)\n{\n  pr_info(\"%s\\n\", __func__);\n  return 0;\n}\n\nstatic int dummy_release(struct inode *inode, struct file *file)\n{\n  pr_info(\"%s\\n\", __func__);\n  return 0;\n}\n\nstatic ssize_t dummy_read(struct file *file,\n  char *buffer, size_t length, loff_t * offset)\n{\n  pr_info(\"%s %u\\n\", __func__, length);\n  return 0;\n}\n\nstatic ssize_t dummy_write(struct file *file,\n  const char *buffer, size_t length, loff_t * offset)\n{\n  pr_info(\"%s %u\\n\", __func__, length);\n  return length;\n}\n\nstruct file_operations dummy_fops = {\n  .owner = THIS_MODULE,\n  .open = dummy_open,\n  .release = dummy_release,\n  .read = dummy_read,\n  .write = dummy_write,\n};\n\nint __init dummy_init(void)\n{\n  int ret;\n  int i;\n  printk(\"Dummy loaded\\n\");\n  ret = register_chrdev(MAJOR_NUM, DEVICE_NAME, &dummy_fops);\n  if (ret != 0)\n    return ret;\n  dummy_class = class_create(THIS_MODULE, DEVICE_NAME);\n  for (i = 0; i < NUM_DEVICES; i++) {\n    device_create(dummy_class, NULL,\n    MKDEV(MAJOR_NUM, i), NULL, \"dummy%d\", i);\n  }\n  return 0;\n}\n\nvoid __exit dummy_exit(void)\n{\n  int i;\n  for (i = 0; i < NUM_DEVICES; i++) {\n    device_destroy(dummy_class, MKDEV(MAJOR_NUM, i));\n  }\n  class_destroy(dummy_class);\n  unregister_chrdev(MAJOR_NUM, DEVICE_NAME);\n  printk(\"Dummy unloaded\\n\");\n}\n\nmodule_init(dummy_init);\nmodule_exit(dummy_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Simmonds\");\nMODULE_DESCRIPTION(\"A dummy driver\");\n```", "```\n# echo hello > /dev/dummy0\n\n[ 6479.741192] dummy_open\n[ 6479.742505] dummy_write 6\n[ 6479.743008] dummy_release\n```", "```\nLINUXDIR := $(HOME)/MELP/build/linux\n\nobj-m := dummy.o\nall:\n        make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- \\\n          -C $(LINUXDIR) M=$(shell pwd)\nclean:\n        make -C $(LINUXDIR) M=$(shell pwd) clean\n```", "```\nobj-m  += dummy.o\n```", "```\nobj-y   += dummy.o\n```", "```\n# insmod /lib/modules/4.1.10/kernel/drivers/dummy.ko\n# lsmod\ndummy 1248 0 - Live 0xbf009000 (O)\n# rmmod dummy\n```", "```\n# depmod -a\n# ls /lib/modules/4.1.10/\nkernel               modules.builtin.bin  modules.order\nmodules.alias        modules.dep          modules.softdep\nmodules.alias.bin    modules.dep.bin      modules.symbols\nmodules.builtin      modules.devname      modules.symbols.bin\n```", "```\nnet@10010000 {\n  compatible = \"smsc,lan91c111\";\n  reg = <0x10010000 0x10000>;\n  interrupts = <25>;\n};\n```", "```\n#define VERSATILE_ETH_BASE     0x10010000\n#define IRQ_ETH                25\nstatic struct resource smc91x_resources[] = {\n  [0] = {\n    .start          = VERSATILE_ETH_BASE,\n    .end            = VERSATILE_ETH_BASE + SZ_64K - 1,\n    .flags          = IORESOURCE_MEM,\n  },\n  [1] = {\n    .start          = IRQ_ETH,\n    .end            = IRQ_ETH,\n    .flags          = IORESOURCE_IRQ,\n  },\n};\nstatic struct platform_device smc91x_device = {\n  .name           = \"smc91x\",\n  .id             = 0,\n  .num_resources  = ARRAY_SIZE(smc91x_resources),\n  .resource       = smc91x_resources,\n};\n```", "```\nvoid __init versatile_init(void)\n{\n  platform_device_register(&versatile_flash_device);\n  platform_device_register(&versatile_i2c_device);\n  platform_device_register(&smc91x_device);\n  [ ...]\n```", "```\nstatic const struct of_device_id smc91x_match[] = {\n  { .compatible = \"smsc,lan91c94\", },\n  { .compatible = \"smsc,lan91c111\", },\n  {},\n};\nMODULE_DEVICE_TABLE(of, smc91x_match);\nstatic struct platform_driver smc_driver = {\n  .probe          = smc_drv_probe,\n  .remove         = smc_drv_remove,\n  .driver         = {\n    .name   = \"smc91x\",\n    .of_match_table = of_match_ptr(smc91x_match),\n  },\n};\nstatic int __init smc_driver_init(void)\n{\n  return platform_driver_register(&smc_driver);\n}\nstatic void __exit smc_driver_exit(void) \\\n{\n  platform_driver_unregister(&smc_driver);\n}\nmodule_init(smc_driver_init);\nmodule_exit(smc_driver_exit);\n```", "```\nstatic int smc_drv_probe(struct platform_device *pdev)\n{\n  struct smc91x_platdata *pd = dev_get_platdata(&pdev->dev);\n  const struct of_device_id *match = NULL;\n  struct resource *res, *ires;\n  int irq;\n\n  res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n  ires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n  [...]\n  addr = ioremap(res->start, SMC_IO_EXTENT);\n  irq = ires->start;\n  [...]\n}\n```", "```\nmatch = of_match_device(of_match_ptr(smc91x_match), &pdev->dev);\nif (match) {\n  struct device_node *np = pdev->dev.of_node;\n  u32 val;\n  [...]\n  of_property_read_u32(np, \"reg-io-width\", &val);\n  [...]\n}\n```"]