- en: Chapter 2. Productive Shells – Reinvent the way you work
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 高效的Shell-重新发明你的工作方式
- en: In this chapter, we will start off with a short introduction to Vim and look
    at the most basic commands to help you get started with basic CRUD (create, read,
    update, delete) operations. We will then upgrade the shell interpreter to zsh
    and also give it superpowers with the awesome `oh-my-zsh` framework. We will look
    at some basic regular expressions such as searching some text using grep. Then,
    we will unleash the power of Unix pipes and run embedded commands using subshells.
    The later part of the chapter will help us understand how we can boost productivity
    and automate a lot of our day-to-day work by showing some of the more advanced
    shell scripting techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从简短介绍Vim开始，然后查看最基本的命令，以帮助您开始进行基本的CRUD（创建、读取、更新、删除）操作。然后，我们将升级shell解释器为zsh，并使用强大的`oh-my-zsh`框架赋予其超能力。我们将介绍一些基本的正则表达式，例如使用grep搜索文本。然后，我们将释放Unix管道的力量，并使用子shell运行嵌入命令。本章的后半部分将帮助我们了解如何通过展示一些更高级的shell脚本技术来提高生产力并自动化我们的许多日常工作。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Working with Vim
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vim工作
- en: Managing zsh using the `oh-my-zsh` framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`oh-my-zsh`框架管理zsh
- en: Writing and running super powerful one line commands using pipes and subshells
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道和子shell编写和运行超强大的一行命令
- en: Exploring the shell scripting libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索shell脚本库
- en: We will focus on editing files. For that we need to choose a file editor. There
    are a bunch of options but considering that the fastest way to edit files is,
    of course, without leaving the terminal. We recommend Vim. Vim is an awesome editor!
    It has a lot of configuration options with a huge community that has produced
    lots of plugins and beautiful themes. It also features advanced text editing,
    which makes it ultra-configurable and super-fast.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于编辑文件。为此，我们需要选择一个文件编辑器。有很多选择，但考虑到最快的编辑文件的方式当然是不离开终端。我们推荐使用Vim。Vim是一个很棒的编辑器！它有很多配置选项，有一个庞大的社区，产生了很多插件和漂亮的主题。它还具有高级文本编辑功能，使其超级可配置和超级快速。
- en: 'So, let''s proceed. Open the terminator and type `sudo apt install vim` to
    install Vim:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续。打开终端并输入`sudo apt install vim`以安装Vim：
- en: '![Productive Shells – Reinvent the way you work](img/image_02_001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![高效的Shell-重新发明你的工作方式](img/image_02_001.jpg)'
- en: Vim is renowned for its exotic keyboard controls and a lot of people avoid using
    Vim because of it. But once you get the basics, it's super easy to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Vim以其奇特的键盘控制而闻名，很多人因此而避免使用Vim。但是一旦掌握了基础知识，它就非常容易使用。
- en: 'Let''s start `vim` with no arguments:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不带参数地启动`vim`：
- en: '![Productive Shells – Reinvent the way you work](img/image_02_002.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![高效的Shell-重新发明你的工作方式](img/image_02_002.jpg)'
- en: This is the default screen; you can see the version on the second line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认屏幕；您可以在第二行看到版本。
- en: To start editing text, press the *Insert* key; this will take us to the insert
    mode, where we can start typing. We can see we are in the insert mode at the bottom
    of the screen:![Productive Shells – Reinvent the way you work](img/image_02_003.jpg)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始编辑文本，请按下*Insert*键；这将带我们进入插入模式，我们可以开始输入。我们可以在屏幕底部看到我们处于插入模式：![高效的Shell-重新发明你的工作方式](img/image_02_003.jpg)
- en: Press the *Insert* key again to go to replace the mode and override text.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次按下*Insert*键进入替换模式并覆盖文本。
- en: Press the *Esc* key to exit insert or replace.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Esc*键退出插入或替换模式。
- en: Type *yy* to copy a line.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入*yy*复制一行。
- en: Type *p* to paste the line.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入*p*粘贴该行。
- en: Type *dd* to cut the line.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入*dd*剪切该行。
- en: Type *:w* to save any changes. Optionally, specify a filename:![Productive Shells
    – Reinvent the way you work](img/image_02_004.jpg)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入*:w*保存任何更改。可选择指定文件名：![高效的Shell-重新发明你的工作方式](img/image_02_004.jpg)
- en: To save the file in editing text, type `vim.txt`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要保存正在编辑的文本文件，请输入`vim.txt`
- en: Type `:q` to exit Vim
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入`:q`退出Vim
- en: 'Let''s open the file again and do a small change:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开文件并进行一些小的更改：
- en: '`:wq`: Write and exit at the same time'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:wq`：写入并同时退出'
- en: '`:q!`: Exit without saving'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:q!`：不保存退出'
- en: Now you are familiar with these commands, we can do basic file editing directly
    from the command line. This is the bare minimum that anybody needs to know when
    working with Vim, and we will use this knowledge in the chapters to come.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了这些命令，我们可以直接从命令行进行基本文件编辑。这是任何人在使用Vim时需要了解的最基本的知识，我们将在接下来的章节中使用这些知识。
- en: We will also have an entire section about Vim, where we will go into more detail
    about being productive in the coolest terminal editor today!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个关于Vim的整个章节，我们将更详细地介绍如何在最酷的终端编辑器中提高生产力！
- en: Oh-my-zsh – your terminal never felt this good before!
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oh-my-zsh-你的终端从未如此好用！
- en: Bash is probably the most commonly used shell. It has lots of features and powerful
    scripting capabilities, but when it comes to user interaction, `zsh` is better.
    Most of its power comes from the awesome framework `oh-my-zsh`. In this section,
    we will be installing `zsh`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Bash可能是最常用的shell。它具有许多功能和强大的脚本能力，但在用户交互方面，`zsh`更好。它的大部分功能来自于强大的`oh-my-zsh`框架。在本节中，我们将安装`zsh`。
- en: 'Let''s get started with the `oh-my-zsh` framework and we will be looking at
    some basic configuration options:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`oh-my-zsh`框架开始，我们将看一些基本的配置选项：
- en: Open the terminator and type `sudo apt install zsh` to install `zsh`, as shown
    in the following image:![Oh-my-zsh – your terminal never felt this good before!](img/image_02_005.jpg)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开终端并输入`sudo apt install zsh`以安装`zsh`，如下图所示：![Oh-my-zsh-你的终端从未如此好用！](img/image_02_005.jpg)
- en: 'After installing it, go to this link, [https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh,),
    and follow the instructions for installing the `oh-my-zsh` framework. The installation
    process is a one-line command with `curl` or `wget`. Let''s install it using both
    the command one by one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完毕后，转到此链接[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)，按照安装`oh-my-zsh`框架的说明进行操作。安装过程是一个使用`curl`或`wget`的一行命令。让我们依次使用这两个命令进行安装：
- en: '**Via curl:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过curl：**'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Via wget:**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过wget：**'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see that the command is giving an error saying that `git` is not installed,
    so we need to install that too. The following command-line is used to install
    git:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到命令给出一个错误，说`git`没有安装，所以我们也需要安装它。以下命令用于安装git：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_006.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – 你的终端从未如此美好！](img/image_02_006.jpg)'
- en: Notice how easy it is to install software in Ubuntu. This is also a big productivity
    booster; every common software package we might need is already prepackaged in
    the remote software repository and it takes us just one command to add new software
    to our computer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在Ubuntu中安装软件是多么容易。这也是一个很大的生产力提升；我们可能需要的每个常见软件包都已经预打包在远程软件仓库中，我们只需要一个命令就可以将新软件添加到我们的计算机中。
- en: Now that we have `git` installed, let's run the command again. We can see that
    this time it's working successfully and it's bringing us to our new shell. `Oh-my-zsh`
    also changes the default shell to `zsh`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`git`，让我们再次运行命令。我们可以看到这次它成功运行，并且将我们带到了新的shell中。`Oh-my-zsh`还将默认shell更改为`zsh`。
- en: 'After installation, the first thing to do is go pick a theme. To see all available
    themes, run this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，首先要做的是选择一个主题。运行以下命令查看所有可用的主题：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_007.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – 你的终端从未如此美好！](img/image_02_007.jpg)'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also go to the `git` repo and check out the themes, together with their
    screenshots. We will be using the *candy* theme, because it has a lot of useful
    information in the prompt: *username*, *hostname*, *time*, *folder* and *git*
    branch/*git* status.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以去`git`仓库查看主题，以及它们的截图。我们将使用*candy*主题，因为它在提示符中有很多有用的信息：*用户名*、*主机名*、*时间*、*文件夹*和*git*分支/*git*状态。
- en: Time can be very useful, for example if you want to know how long a command
    took to execute and you didn't use the *time* utility to measure your command's
    total runtime. Then, you can check out the prompt and see the time when the command
    started and the prompt to know when it was finished, and thus you can calculate
    the total time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 时间非常有用，例如，如果你想知道一个命令执行了多长时间，而你没有使用*time*工具来测量命令的总运行时间。然后，你可以查看提示符，看到命令开始时的时间和提示符，以知道命令何时完成，从而可以计算总时间。
- en: 'To change the theme, `open ~/.zshrc` and modify the `ZSH_THEME` variable. Save
    the file and open a new terminal window. Let''s initialize an empty `git` directory
    so we can see how the prompt looks. You can see we are on the master branch:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改主题，打开`~/.zshrc`并修改`ZSH_THEME`变量。保存文件并打开一个新的终端窗口。让我们初始化一个空的`git`目录，这样我们就可以看到提示符的样子。你可以看到我们在主分支上：
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_008.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – 你的终端从未如此美好！](img/image_02_008.jpg)'
- en: 'Let''s create a file, say `readme.md`. The `*` in the prompt shows that the
    directory is not clean. We can verify this with the `git status` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文件，比如`readme.md`。提示符中的`*`表示目录不干净。我们可以用`git status`命令来验证这一点：
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_009.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – 你的终端从未如此美好！](img/image_02_009.jpg)'
- en: You can see how it gets verified. After we've cleaned up the directory, the
    `*` is gone. If we change branch, the prompt shows that we are on the new branch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它是如何被验证的。在我们清理了目录之后，`*`就消失了。如果我们切换分支，提示符会显示我们在新分支上。
- en: 'Let''s quickly create a demo. Run the following commands on your terminal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个演示。在你的终端上运行以下命令：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_010.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – 你的终端从未如此美好！](img/image_02_010.jpg)'
- en: 'You can now see the branch name in the prompt, and there are some other cool
    features that you might like to explore:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在提示符中看到分支名称，并且还有一些其他很酷的功能可以让你去探索：
- en: '**Command completion**: Start typing, for example, ip, and press *Tab*. We
    can see all the commands that start with IP and we can hit *Tab* again to start
    navigating through the different options. You can use the arrow keys to navigate
    and hit *Enter* for the desired command:![Oh-my-zsh – your terminal never felt
    this good before!](img/image_02_011.jpg)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令补全**：开始输入，例如，ip，然后按下*Tab*。我们可以看到所有以IP开头的命令，我们可以再次按下*Tab*来浏览不同的选项。你可以使用箭头键进行导航，按下*Enter*选择所需的命令：![Oh-my-zsh
    – 你的终端从未如此美好！](img/image_02_011.jpg)'
- en: '**Params completion**: For example type `ls -` and press *Tab*, and we can
    see here all the options and a short description for each. Press *Tab* again to
    start navigating through them and *Enter* to select.![Oh-my-zsh – your terminal
    never felt this good before!](img/image_02_012.jpg)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数补全**：例如输入`ls -`然后按下*Tab*，我们可以在这里看到所有选项和每个选项的简短描述。再次按下*Tab*开始浏览它们，按下*Enter*进行选择。![Oh-my-zsh
    – 你的终端从未如此美好！](img/image_02_012.jpg)'
- en: '**History navigation**: Click on arrow up key to search in history, filtering
    by the string that is written before the cursor. For example, if I type `vim`
    and press the arrow up key, I can see all the files opened with Vim in my history.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史导航**：点击向上箭头键在历史记录中搜索，通过光标前面写的字符串进行过滤。例如，如果我输入`vim`并按向上箭头键，我可以看到我历史记录中所有使用Vim打开的文件。'
- en: '**History search**: Press *Ctrl* + *R* and start typing, and press *Ctrl* +
    *R* again to search the same occurrence in history. For example *~*, and *Ctrl*
    + *R* to see all commands that have *~* in the string.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史搜索**：按下*Ctrl* + *R*开始输入，再次按下*Ctrl* + *R*搜索相同的出现在历史中的命令。例如*~*，然后按下*Ctrl*
    + *R*来查看所有包含*~*的命令。'
- en: '**Navigating**: Here press *Ctrl* + arrow left/right to jump one word, *Ctrl*
    + *W* to delete one word, or *Ctrl* + *U* to delete the whole line.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航**：在这里按下*Ctrl* + 左/右箭头可以跳到一个单词，*Ctrl* + *W*可以删除一个单词，或者*Ctrl* + *U*可以删除整行。'
- en: '**cd completion case insensitive**: For example, `cd doc` will expand into
    `cd Documents`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cd补全不区分大小写**：例如，`cd doc`会扩展为`cd Documents`。'
- en: '**cd directory completion**: If you are lazy and want to specify only a few
    key letters in a path, we can do that too. For example, `cd /us/sh/zs` + *Tab*
    will expand into `cd /usr/share/zsh`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cd directory completion**: 如果您懒惰并且只想在路径中指定几个关键字母，我们也可以这样做。例如，`cd /us/sh/zs`
    + *Tab*将扩展为`cd /usr/share/zsh`。'
- en: '**Kill completion:** Just type `kill` and *Tab* and you will see a list of
    `pids` to kill. From there you can choose which process to kill.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kill completion:** 只需输入`kill`，然后按下*Tab*键，您将看到一个要杀死的`pids`列表。从那里，您可以选择要杀死的进程。'
- en: '**chown completion**: Type `chown` and tab to see a list of users to change
    owner to. The same applies to groups.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**chown completion**: 输入`chown`并按下tab键，您将看到一个要更改所有者的用户列表。同样适用于组。'
- en: '**Argument expansion**: Type `ls *` and hit *Tab*. You see `*` expanded to
    all files and folders in the current directory. For a subset, type `ls Do*` and
    press *Tab*. It will only expand to documents and downloads.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argument expansion**: 输入`ls *`并按下*Tab*键。您会看到`*`扩展到当前目录中的所有文件和文件夹。要获取子集，请输入`ls
    Do*`并按下*Tab*键。它只会扩展到文档和下载。'
- en: '**Adds lots of aliases:** Just type alias to see a full list. Some very useful
    ones are:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Adds lots of aliases:** 只需输入alias即可查看完整列表。一些非常有用的别名是：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_013.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Oh-my-zsh – your terminal never felt this good before!](img/image_02_013.jpg)'
- en: To see a list of shortcuts, run the `bindkey` command. The terminal is one of
    the places where you will spend a lot time, so it's really important to master
    our shell and use it as efficiently as possible. Knowing good shortcuts and viewing
    relevant and condensed information, such as our prompt, can make our job much
    easier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看快捷方式列表，请运行`bindkey`命令。终端是您将花费大量时间的地方之一，因此精通我们的shell并尽可能高效地使用它非常重要。了解好的快捷方式和查看相关和简洁的信息，例如我们的提示符，可以使我们的工作更轻松。
- en: Basic regular expressions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本正则表达式
- en: '*You have a problem and you want to solve it with regular expressions? Now
    you have two problems!* This is just one of the many regular expression jokes
    on the Internet.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*您有一个问题，并且想要使用正则表达式解决它吗？现在您有两个问题了！* 这只是互联网上许多正则表达式笑话之一。'
- en: In this section, you will learn how regular expressions work, as we will be
    using them in the upcoming chapters. We have prepared a file for our playground
    and if you want to try the grep commands on your own, you can take it from the
    GitHub repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习正则表达式的工作原理，因为我们将在接下来的章节中使用它们。我们为我们的游乐场准备了一个文件，如果您想在自己的计算机上尝试grep命令，可以从GitHub存储库中获取。
- en: Let's start by opening our text file so we can see its contents, and then splitting
    the screen so we can see both the file and the command side by side.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先打开我们的文本文件，这样我们就可以看到它的内容，然后分割屏幕，这样我们就可以同时看到文件和命令。
- en: First of all, the simplest and probably the most common regular expression is
    to find a single word.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单且可能最常见的正则表达式是查找单个单词。
- en: 'For this we will use the `grep "joe" file.txt` command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用`grep "joe" file.txt`命令：
- en: '![Basic regular expressions](img/image_02_014.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![基本正则表达式](img/image_02_014.jpg)'
- en: '`joe` is the string we are searching for and `file.txt` is the file where we
    perform the search. You can see that grep printed the line that contained our
    string and the word is highlighted with another color. This will only match the
    exact case of the word (so, if we use lowercase `j`, this regex will not work
    anymore). To do a case insensitive search, `grep` has an `-i` option. What this
    means is that grep will print the line that contains our word even if the word
    is in a different case, like JoE, JOE, joE, and so on:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`joe`是我们要搜索的字符串，`file.txt`是我们执行搜索的文件。您可以看到grep打印了包含我们字符串的行，并且该单词以另一种颜色突出显示。这只会匹配单词的确切大小写（因此，如果我们使用小写的`j`，这个正则表达式将不再起作用）。要进行不区分大小写的搜索，`grep`有一个`-i`选项。这意味着grep将打印包含我们单词的行，即使单词的大小写不同，比如JoE，JOE，joE等等：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Basic regular expressions](img/image_02_015.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![基本正则表达式](img/image_02_015.jpg)'
- en: 'If we don''t know exactly what characters are there in our string, we can use
    `.*` to match any number of characters. For example, to find a sentence beginning
    with "word" and ending with "day", we''d use the `grep "word.*day" file.txt` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定字符串中有哪些字符，我们可以使用`.*`来匹配任意数量的字符。例如，要查找以"word"开头并以"day"结尾的句子，我们将使用`grep
    "word.*day" file.txt`命令：
- en: '`.` - matches any character'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` - 匹配任何字符'
- en: '`*` - matches previous character multiple times'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` - 匹配前一个字符多次'
- en: Here you can see that it matched the first line in the file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到它匹配了文件中的第一行。
- en: 'A very common scenario is to find empty lines in a file. For this we use the
    `grep "^\s$" file.txt` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是在文件中找到空行。为此，我们使用`grep "^\s$" file.txt`命令：
- en: 'Where `\s` : This stands for space,'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中`\s`：表示空格，
- en: '`^` : It''s for the beginning of the line.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：表示行的开头。'
- en: '`$` : It''s for its ending.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：表示行尾。'
- en: We have two empty lines with no space. If we add a space between the lines,
    it will match the lines containing one space. These are called **anchors**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个没有空格的空行。如果在行之间添加一个空格，它将匹配包含一个空格的行。这些被称为**锚点**。
- en: '`grep` can do a neat little trick to count the number of matches. For this,
    we use the `-c` parameter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`可以使用一个小技巧来计算匹配的数量。为此，我们使用`-c`参数：'
- en: '![Basic regular expressions](img/image_02_016.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![基本正则表达式](img/image_02_016.jpg)'
- en: 'To find all the lines that have only letters and space, use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有只包含字母和空格的行，请使用：
- en: '`grep`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`'
- en: '`""`: Open quotes'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`：打开引号'
- en: '`^$`: From the beginning of the line to the end'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^$`：从行的开头到结尾'
- en: '`[]*`: Match these characters any number of times'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]*`：匹配这些字符任意次数'
- en: '`A-Za-z`: Any upper and lower case letter'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A-Za-z`：任何大写和小写字母'
- en: 'If we run the command up to here, we get only the first line. If we add:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行到这里的命令，我们只会得到第一行。如果我们添加：
- en: '- 0-9 any number we match another two lines,'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 0-9 任何数字我们匹配另外两行，'
- en: 'And if we add: - \s any space, we also match the empty lines and the all caps
    line'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加：- \s 任何空格，我们还会匹配空行和全大写行
- en: If we run the command until here, we get only the first line from the output,
    the rest is not displayed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们运行到这里的命令，我们只会得到输出的第一行，其余的不会显示
- en: Then, if we add 0-9 we match any number (so the first two lines get matched)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果我们添加0-9，我们匹配任何数字（所以前两行被匹配）
- en: And if we add \s we match any type of space (so the empty lines are matched
    as well)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加\s，我们将匹配任何类型的空格（因此空行也将匹配）
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Basic regular expressions](img/image_02_017.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![基本正则表达式](img/image_02_017.jpg)'
- en: 'Sometimes we need to search for something that''s not in the string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要搜索不在字符串中的内容：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will find all the lines that do not have only numeric characters.
    `[^]` means match all characters that are not inside, in our case, any non-number.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将找到所有不仅包含数字字符的行。`[^]`表示匹配所有不在其中的字符，在我们的例子中是任何非数字字符。
- en: 'The square brackets are markers in our regular expression. If we want to use
    them in our search string, we have to escape them. So, in order to find lines
    that have content between square brackets, do this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号是我们正则表达式中的标记。如果我们想在搜索字符串中使用它们，我们必须对它们进行转义。因此，为了找到具有方括号之间内容的行，请执行以下操作：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is for any line that has characters in square brackets. To find all lines
    that have these character `!`, type this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何具有方括号中字符的行。要查找所有具有这些字符`!`的行，请键入：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s have a look at a basic `sed,` lets find `Joe` word and replace with
    `All` word:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个基本的`sed`，找到`Joe`单词并替换为`All`单词：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Basic regular expressions](img/image_02_018.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![基本正则表达式](img/image_02_018.jpg)'
- en: This will replace every occurrence of the string `Joe` with the string `All`.
    We will deep dive into this in the upcoming chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将替换字符串`Joe`的每个出现为字符串`All`。我们将在接下来的章节中深入探讨这个问题。
- en: 'Regular expressions, such as Vim, are one of the things many people are afraid
    of because they seem complicated to learn in the beginning. Although they might
    seem cryptic, regular expressions are handy companions once mastered: they are
    not limited to our shell because the syntax is very similar in most programming
    languages, databases, editors, and any other place that includes searching for
    strings. We will go into more detail about regular expressions in the upcoming
    chapters.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（如Vim）是许多人害怕的东西，因为它们在开始时似乎很难学习。尽管它们可能看起来神秘，但一旦掌握，正则表达式就是方便的伙伴：它们不仅限于我们的shell，因为语法在大多数编程语言、数据库、编辑器和任何其他包含字符串搜索的地方非常相似。我们将在接下来的章节中详细介绍正则表达式。
- en: Pipes and subshells – your shell's salt and pepper
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和子shell-你的shell的盐和胡椒
- en: In this section, we will be looking at ways to improve your productivity using
    your shell. The Linux command line is great because it has a variety of tools
    we can use. What makes it even greater is the fact that we can chain these tools
    together to form greater, more powerful tools that will make us even more productive.
    We will not go into basic shell commands; instead we will be looking at some cool
    pipe and subshell combinations that can make our lives easier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何利用shell提高工作效率。Linux命令行非常棒，因为我们可以使用各种工具。更棒的是，我们可以将这些工具链接在一起，形成更强大的工具，使我们的工作更加高效。我们不会介绍基本的shell命令，而是将研究一些酷炫的管道和子shell组合，这些组合可以让我们的生活更轻松。
- en: 'Let''s start with a basic pipe; in this example, we are counting the length
    of the current path using the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本的管道开始；在这个例子中，我们使用以下命令计算当前路径的长度：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_019.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_019.jpg)'
- en: '`pwd,` as you probably know, stands for `print working directory`. The `|`
    is the pipe symbol, and what it does is send the output of the command on the
    left to the command on the right. In our case, `pwd` is sending its output to
    `wc -c`, which counts the number of characters. The coolest thing about pipes
    is that you can create a chain of any number of pipes.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd`，您可能知道，代表`print working directory`。`|`是管道符号，它的作用是将左侧命令的输出发送到右侧的命令。在我们的例子中，`pwd`将其输出发送到`wc
    -c`，它计算字符的数量。管道最酷的事情是您可以创建任意数量的管道链。'
- en: 'Let''s see another example where we will see how to find used space on the
    drive:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，我们将看到如何查找驱动器上的已使用空间：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_020.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_020.jpg)'
- en: '`"df -h"`: This shows the disk usage in a human-readable format'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"df -h"`：以人类可读的格式显示磁盘使用情况'
- en: '`"| grep /home"`: This shows only the home directory'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"| grep /home"`：这只显示主目录'
- en: '`''| tr -s " "''`: This substitutes multiple spaces for just one space'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''| tr -s " "''`: 这将多个空格替换为一个空格'
- en: '`''| cut -f 2 -d " "''`: This selects the second column using a space as the
    delimiter'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''| cut -f 2 -d " "''`: 这使用空格作为分隔符选择第二列'
- en: As you can see, the command printed out `173G`, the size of the `/home` partition.
    This is a common use case when chaining multiple commands, each command reducing
    the output until we get the desired information and nothing else. In our case,
    this is the used disk space.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该命令打印出`173G`，即`/home`分区的大小。这是一个常见的用例，通过链接多个命令，每个命令都减少输出，直到我们获得所需的信息而不是其他信息。在我们的例子中，这是已使用的磁盘空间。
- en: 'To count all the directories in a folder, use the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算文件夹中的所有目录数量，请使用以下命令：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_021.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_021.jpg)'
- en: The basic idea is to count all the lines that end with `/`. Here we can see
    we have only one directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是计算以/结尾的所有行。在这里，我们可以看到我们只有一个目录。
- en: 'Pipes are a great option to find and kill processes. Say we want to find the
    process ID of `nautilus`, and `kill all` running instances. For this we use:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是查找和终止进程的好选择。假设我们想要查找`nautilus`进程的进程ID，并终止所有正在运行的实例。我们可以使用以下命令：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_022.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_022.jpg)'
- en: '`ps aux`: This prints all processes with PID'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps aux`：这将打印出所有带有PID的进程'
- en: '`| grep nautilus`: Find the ones matching nautilus'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| grep nautilus`：查找与nautilus匹配的项'
- en: '`| grep -v grep`: Inverts `grep` to exclude the `grep` process'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| grep -v grep`：反转`grep`以排除`grep`进程'
- en: '`| awk ''{print $2}''`: Selects the second word in the line, which is the PID'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| awk ''{print $2}''`：选择行中的第二个单词，即PID'
- en: '`| xargs kill`: Here `xargs` is used to distribute each PID to a kill command.
    It is especially used for commands that do not read arguments from standard input.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| xargs kill`：这里使用`xargs`将每个PID分发给一个kill命令。它特别用于不从标准输入读取参数的命令。'
- en: Now we've killed `nautilus`. This was purely a demonstrative example. There
    are other ways of doing this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经杀死了`nautilus`。这只是一个演示性的例子。还有其他方法可以做到这一点。
- en: Let's open `nautilus` again and send it to the background by hitting *Ctrl*
    + *Z* followed by the `bg` command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开`nautilus`并通过按下*Ctrl* + *Z*，然后输入`bg`命令将其发送到后台。
- en: 'Now let''s run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行以下命令：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To see all the `pids` of `nautilus` and to send the kill signal to all those
    processes, use the following command line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`nautilus`的所有`pids`并向所有这些进程发送kill信号，请使用以下命令行：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time for some networking! You probably know the `ifconfig` command,
    which is used to print information about the network interfaces. To get the IP
    address of a specific interface (in our case the wireless interface `wlp3s0`),
    run this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一些网络操作的时间！您可能知道`ifconfig`命令，它用于打印有关网络接口的信息。要获取特定接口（在我们的例子中是无线接口`wlp3s0`）的IP地址，请运行以下命令：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_023.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_023.jpg)'
- en: '`ifconfig wlp3s0`: Prints networking information for the `wlp3s0` interface'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifconfig wlp3s0`：打印`wlp3s0`接口的网络信息'
- en: '`| grep "inet addr:"`: Gets the line with the IP address'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| grep "inet addr:"`：获取包含IP地址的行'
- en: '`| awk ''{print $2}''`: Selects the second word in the line (we could have
    used cut as well)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| awk ''{print $2}''`：选择行中的第二个单词（我们也可以使用cut）'
- en: '`| cut -f 2 -d ":"`: This is split by `":"`, and only prints the second word'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| cut -f 2 -d ":"`：这是由`":"`分割的，只打印第二个单词'
- en: And now, we see your `private ip` address on the screen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在屏幕上看到了您的私有IP地址。
- en: A common use case that might also arise is counting the word frequency in a
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例也可能是计算文件中单词的频率。
- en: 'Here we have a standard lorem ipsum text contained in `lorem.txt`. In order
    to get the word frequency, use this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个包含在`lorem.txt`中的标准lorem ipsum文本。为了获取单词频率，请使用以下命令：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Pipes and subshells – your shell''s salt and pepper](img/image_02_024.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![管道和子shell-你的shell的盐和胡椒](img/image_02_024.jpg)'
- en: '`cat lorem.txt`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat lorem.txt`'
- en: '`| tr " " "\n"`: Transforms each space into a new line character'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| tr " " "\n"`：将每个空格转换为换行符'
- en: '`| grep -v "^\s*$"`: Eliminates empty lines'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| grep -v "^\s*$"`：消除空行'
- en: '`| sed "s/[,.]//g"`: Eliminates commas (,) and periods (.) to select only the
    words'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| sed "s/[,.]//g"`：消除逗号（,）和句号（.），只选择单词'
- en: '`| sort`: Sort the results alphabetically'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| sort`：按字母顺序排序结果'
- en: '`| uniq -c`: Show only unique lines'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| uniq -c`：仅显示唯一的行'
- en: '`| sort -n`: Sorts by numerical value'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| sort -n`：按数值排序'
- en: Append `grep -w id` to find the frequency of the word ID, or `grep -w 4` to
    see all words that appear four times.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 附加`grep -w id`以查找单词ID的频率，或者附加`grep -w 4`以查看出现四次的所有单词。
- en: Now let's move on to our first subshell example. Subshells can be written by
    either enclosing them in `$()`, or using backticks (*`*). Backticks are usually
    found under the *Esc* key on your keyboard. In all our examples, we will be using
    the first form because it's easier to read.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续我们的第一个子shell示例。子shell可以通过将它们括在`$()`中或使用反引号（*`*）来编写。反引号通常位于键盘上的*Esc*键下方。在所有示例中，我们将使用第一种形式，因为它更容易阅读。
- en: 'Our first example is to list all the folders in our current folder:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是列出当前文件夹中的所有文件夹：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ls` subshell returns the files and folders in the current directory and
    the `ls` from outside the subshell will list those individually, showing additional
    details:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`子shell返回当前目录中的文件和文件夹，而子shell外部的`ls`将逐个列出它们，显示附加详细信息：'
- en: Counting all files and directories in the current directory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算当前目录中的所有文件和目录的数量
- en: Given the fact that commas (,) and periods (.) are hard links that mark the
    current and parent directory, we need to count all entries minus these two
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到逗号（,）和句号（.）是标记当前目录和父目录的硬链接，我们需要计算除这两个之外的所有条目
- en: This can be done using the `expr $(ls -a | wc -l ) - 2` command:![Pipes and
    subshells – your shell's salt and pepper](img/image_02_025.jpg)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`expr $(ls -a | wc -l ) - 2`命令来完成这个操作：![管道和子shell-你的shell的盐和胡椒](img/image_02_025.jpg)
- en: Here, the subshell will return the number of entries (five, in this case). The
    number we are looking for is the number of entries minus the special folders ("`.`"
    and "`..`"). In order to do arithmetic operations, we use the `expr` command,
    as in our example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，子shell将返回条目的数量（在本例中为五）。我们要找的数字是条目数减去特殊文件夹（"`.`"和"`..`"）的数量。为了进行算术运算，我们使用`expr`命令，就像我们的示例中一样。
- en: Notice that the subshell contains a pipe. The good thing is that we can combine
    pipes and subshells in any way in order to obtain the desired result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子shell包含一个管道。好处是我们可以以任何方式组合管道和子shell，以获得所需的结果。
- en: Imagine pipes and subshells as Lego pieces for your shell. They expand way beyond
    its capabilities and give you access to new possibilities with infinite combinations.
    In the end, it all depends on your imagination and how well you learn to use them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下管道和子shell就像是你的shell的乐高积木。它们远远超出了其功能，并为您提供了无限组合的新可能性。最终，这一切取决于您的想象力和您学会如何使用它们的能力。
- en: Shell scripting for fun and profit
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了娱乐和利润而编写shell脚本
- en: Pipes and subshells are one way of expanding the capabilities of our shell.
    The ultimate way is by writing shell scripts. These scenarios must be taken into
    consideration when dealing with complex tasks that can't be automated with a one-line
    command.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和子shell是扩展我们的shell功能的一种方式。最终的方式是编写shell脚本。在处理无法用一行命令自动化的复杂任务时，必须考虑这些场景。
- en: The good news is that almost all the tasks can be automated with the use of
    shell scripts. We won't go over an introduction to shell scripts. Instead, we
    will be looking at some more advanced use cases for writing them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是几乎所有的任务都可以通过使用shell脚本来自动化。我们不会介绍shell脚本的入门知识。相反，我们将看一些更高级的用例来编写它们。
- en: Let's start our journey into shell scripting! First thing, let's open a file
    called `script.sh` and split the screen so that we can test while writing. Every
    shell should start with `#!`, followed by the interpreter it uses. This line is
    called a **shebang**. We will be using bash as our default interpreter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的shell脚本之旅！首先，让我们打开一个名为`script.sh`的文件，并分割屏幕以便我们在编写时进行测试。每个shell脚本都应该以`#!`开头，后面跟着它使用的解释器。这一行被称为**shebang**。我们将使用bash作为我们的默认解释器。
- en: 'It''s a good idea to use bash, because it''s a common interpreter that comes
    with most Linux distributions and also OS X:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bash是一个好主意，因为它是一个常见的解释器，大多数Linux发行版和OS X都带有它：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s start with a simple use case: reading the arguments passed into the
    command line. We will assign the value of the first command line argument, `$1`,
    to a variable called ARG, and then print it back to the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的用例开始：读取传递到命令行的参数。我们将把第一个命令行参数`$1`的值赋给一个名为ARG的变量，然后将其打印回屏幕：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s save our script, assign it execution permissions, and then run it with
    one argument:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存我们的脚本，赋予它执行权限，然后用一个参数运行它：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Shell scripting for fun and profit](img/image_02_026.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Shell scripting for fun and profit](img/image_02_026.jpg)'
- en: 'As you can see, the value test is printed back to the screen. In some cases,
    we want to assign default values to variables. In order to do this, add ":-" to
    the variable assignment, followed by the default value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，值test被打印回屏幕。在某些情况下，我们希望为变量分配默认值。为了做到这一点，在变量赋值后添加“:-”，然后是默认值：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now if we re-run the script, we can see that passing no arguments will `echo
    default value`. And just like pipes, we can chain multiple default value assignments
    together. We can define another variable `AUX`, assign it the value `123`, and
    use the same syntax to assign its value to the ARG variable, before using the
    `"default value"` script like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新运行脚本，我们可以看到不传递参数将会`echo default value`。就像管道一样，我们可以将多个默认值赋值链接在一起。我们可以定义另一个变量`AUX`，将其赋值为`123`，并使用相同的语法将其值赋给ARG变量，然后使用`"default
    value"`脚本，如下所示：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Shell scripting for fun and profit](img/image_02_027.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Shell scripting for fun and profit](img/image_02_027.jpg)'
- en: In this case, ARG will always receive 123 as its default value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，ARG将始终接收123作为其默认值。
- en: 'Now let''s look at string selectors. To select a substring, use ":", plus the
    starting position plus ":", plus the number of characters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下字符串选择器。要选择一个子字符串，使用“:”，加上起始位置加上“:”，再加上字符数：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Shell scripting for fun and profit](img/image_02_028.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Shell scripting for fun and profit](img/image_02_028.jpg)'
- en: In our case, we will be selecting four characters, starting from the fifth character.
    After running the script, we can see the value `long` printed on the screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将选择四个字符，从第五个字符开始。运行脚本后，我们可以在屏幕上看到值`long`被打印出来。
- en: 'Most shell scripts are designed to run from the command line and receive a
    variable number of arguments. In order to read command line arguments without
    knowing the total number of arguments, we''ll use a `while` statement that checks
    whether the first argument is not null using the -z (or not equal to 0) conditional
    expression. In the while loop, let''s echo the variable''s value and run shift,
    which shifts command line arguments one position to the left:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数shell脚本都设计为从命令行运行并接收可变数量的参数。为了在不知道参数总数的情况下读取命令行参数，我们将使用一个`while`语句，该语句检查第一个参数是否为空，使用-z（或不等于0）条件表达式。在while循环中，让我们回显变量的值并运行shift，将命令行参数向左移动一个位置：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Shell scripting for fun and profit](img/image_02_029.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Shell scripting for fun and profit](img/image_02_029.jpg)'
- en: If we run our script with the arguments *a* *b* *c*, we can see that our while
    looped through the parameters and printed each one on a separate line. Now let's
    extend our CLI arguments parser and add a *case* statement for interpreting the
    arguments.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用参数*a* *b* *c*运行我们的脚本，我们可以看到我们的while循环遍历了参数并将每个参数打印在单独的行上。现在让我们扩展我们的CLI参数解析器，并添加一个用于解释参数的*case*语句。
- en: 'Let''s assume that our script will have a help option. The Posix standard recommends
    doing a long argument version with `--`, and a short version with only one `-`.
    So both `-h` and `--help` will print the help message. Also, it is recommended
    to always have a default case and print a message when the user sends invalid
    options and then exits with a non-zero exit value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的脚本将有一个帮助选项。Posix标准建议使用`--`作为长参数版本，使用一个`-`作为短版本。因此，`-h`和`--help`都将打印帮助消息。此外，建议始终有一个默认情况，并在用户发送无效选项时打印一条消息，然后以非零退出值退出：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Shell scripting for fun and profit](img/image_02_030.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Shell scripting for fun and profit](img/image_02_030.jpg)'
- en: If we run our script with -h, we can see the help message printed, the same
    as if we had used `--help`. If we run the script with any other option, the invalid
    option text is printed and the script exits with the exit code 1\. To get the
    exit code of the last command, use `"$?"`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用-h运行脚本，我们可以看到打印的帮助消息，就像我们使用`--help`一样。如果我们使用任何其他选项运行脚本，将打印无效选项文本，并以退出码1退出脚本。要获取上一个命令的退出码，请使用`"$?"`。
- en: 'Now let''s look at basic functions in shell. The syntax is pretty similar to
    other programming languages. Let''s write a function called `print_ip` that will
    print the IP of the interface specified as the first argument. We will use a subshell
    and assign the value to a variable called IP. We already have the full command
    inside our clipboard; it''s the same one we saw in the lesson about pipes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下shell中的基本函数。语法与其他编程语言非常相似。让我们编写一个名为`print_ip`的函数，它将打印指定为第一个参数的接口的IP。我们将使用子shell并将值赋给名为IP的变量。我们已经将完整的命令复制到剪贴板中；它与我们在关于管道的课程中看到的相同：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Shell scripting for fun and profit](img/image_02_031.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: ！[Shell脚本的乐趣和利润](img/image_02_031.jpg)
- en: 'Now let''s add another case to our switch statement, for the `-i` or `--ip`
    option. The option will be followed by the name of the interface, which we will
    then pass to the `print_ip` function. Having two arguments for one option means
    we need to call the shift command twice:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的switch语句中添加另一个case，用于`-i`或`--ip`选项。该选项后面将跟随接口的名称，然后我们将将其传递给`print_ip`函数。一个选项有两个参数意味着我们需要调用shift命令两次：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's do an `ifconfig` to get the name of our wireless interface. We can see
    it's `wlp3s0`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行`ifconfig`以获取我们的无线接口的名称。我们可以看到它是`wlp3s0`。
- en: 'Now let''s run:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see the IP address. This is a very basic use case, where we can see how
    command line arguments can be passed. We can add unlimited options to our case
    statement, define functions for handling the arguments, and even chain multiple
    options together to form complex scripts that receive well-structured information
    as command line arguments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到IP地址。这是一个非常基本的用例，我们可以看到如何传递命令行参数。我们可以为我们的case语句添加无限选项，为处理参数定义函数，甚至可以将多个选项链接在一起，形成接收命令行参数作为结构化信息的复杂脚本。
- en: Being effective means running tasks faster-- really fast! And when it comes
    to speed, bash is not the first choice in terms of script interpreters. Luckily,
    we still have some tricks up our sleeves! If a shell script needs to run multiple
    independent tasks, we can use the *&* symbol to send the process to the background
    and move forward to the next command.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 高效意味着运行任务更快 - 真的很快！而且当涉及到速度时，bash并不是脚本解释器的首选。幸运的是，我们还有一些诀窍！如果一个shell脚本需要运行多个独立的任务，我们可以使用*&*符号将进程发送到后台，并继续执行下一个命令。
- en: 'Let''s create two functions, `long_running_task 1` and `2`, and add a `sleep`
    command inside, to simulate a `long_running` task:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个函数，`long_running_task 1`和`2`，并在内部添加一个`sleep`命令，以模拟一个`long_running`任务：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first long running task function will sleep for one second, and the next
    will sleep for two seconds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个长时间运行的任务函数将休眠一秒钟，下一个将休眠两秒钟。
- en: 'Then, for testing purposes, let''s add another case to our switch statement,
    called `-p / --`parallel, and run the two long running tasks:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了测试目的，让我们在我们的switch语句中添加另一个case，称为`-p / --`parallel，并运行这两个长时间运行的任务：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, if we run this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It will take a total of three seconds for the script to finish. We can measure
    this with the *time* utility:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将花费总共三秒钟才能完成。我们可以使用*time*实用程序来测量这个时间：
- en: '![Shell scripting for fun and profit](img/image_02_032.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: ！[Shell脚本的乐趣和利润](img/image_02_032.jpg)
- en: 'If we run both functions in the background, we can reduce the running time
    to the longest running time of both functions (because of the wait). When running
    long running tasks, we probably want the script to wait for the longest-running
    task to finish, in our case task 2\. We can achieve this by grabbing the `pid`
    of the second task. Here `$!` is used to grab the `pid` of the last run command.
    Then we use the wait shell built in to wait for the execution to finish:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在后台运行两个函数，我们可以将运行时间减少到两个函数中运行时间最长的时间（因为有等待）。当运行长时间运行的任务时，我们可能希望脚本等待最长运行时间的任务完成，在我们的例子中是任务2。我们可以通过获取第二个任务的`pid`来实现这一点。这里使用`$!`来获取最后一次运行命令的`pid`。然后我们使用等待shell内置命令等待执行完成：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After running the script again with the time utility, we can see it takes us
    a total of two seconds to complete the task.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用时间实用程序运行脚本后，我们可以看到完成任务总共需要两秒钟。
- en: Who would've thought we can do parallel processing in a shell?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 谁会想到我们可以在shell中进行并行处理？
- en: 'If the executions take a longer time, we can add a notification when the script
    finishes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行时间较长，我们可以在脚本完成时添加通知：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Shell scripting for fun and profit](img/image_02_033.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: ！[Shell脚本的乐趣和利润](img/image_02_033.jpg)
- en: This way we can start the script, work on some other tasks, and receive a notification
    when the script finishes. You can let your imagination go wild on the things you
    can achieve with parallel processing and notifications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以启动脚本，在其他任务上工作，并在脚本完成时收到通知。您可以让您的想象力在并行处理和通知方面发挥作用，可以实现的事情多得让人无法想象。
- en: 'In this chapter, we have seen some common predefined shell variables. They
    were:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了一些常见的预定义shell变量。它们是：
- en: '`$1`: First argument'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`：第一个参数'
- en: '`$?`: Return code of the last command'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$?`：最后一次命令的返回代码'
- en: '`$!`: The `pid` of the last command run'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$!`：最后一次运行命令的`pid`'
- en: 'Other commonly used predefined shell variables include:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常用的预定义shell变量包括：
- en: '`$#`: Number of parameters'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$#`：参数个数'
- en: '`$*`: List of parameters'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$*`：参数列表'
- en: '`$@`: All the parameters'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$@`：所有参数'
- en: '`$0`: Name of the shell/script'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0`：shell/脚本的名称'
- en: '`$$`: PID of current running shell'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$$`：当前运行shell的PID'
- en: Bash has a lot of features and we recommend going through its man page to get
    more information about them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Bash有很多功能，我们建议阅读其man页面以获取更多信息。
- en: Shell scripts are amazing when used the right way. They can fine-tune system
    commands, as we saw in our example when we got only the IP address, without the
    whole `ifconfig` output and much more. You, as a pragmatic terminal user, should
    identify what tasks you most commonly do in the command line and what can be automated
    using shell scripts. You should create your own collection of shell scripts and
    add them your path, so that they are easily accessible from any directory.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，Shell脚本是令人惊叹的。它们可以微调系统命令，就像我们在示例中看到的那样，只获取IP地址，而不是整个`ifconfig`输出等等。作为一个务实的终端用户，您应该确定您在命令行中最常见的任务以及可以使用Shell脚本自动化的任务。您应该创建自己的Shell脚本集合并将它们添加到路径中，以便可以从任何目录轻松访问它们。
- en: Shell scripting libraries
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本库
- en: To really take advantage of automating tasks using shell scripts, it's important
    to organize all common tasks into reusable commands and have them available in
    the path. To do this, it's a good idea to create a `bin` folder inside the home
    directory for the scripts, and a `bin/lib` directory for storing common pieces
    of code. When working with lots of shell scripts, it's important to reuse large
    pieces of functionality. This can be achieved by writing library functions for
    your shell scripts, functions that you can call from multiple places.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正利用使用shell脚本自动化任务的优势，将所有常见任务组织成可重用的命令并使其在路径中可用非常重要。为此，最好在主目录中创建一个`bin`文件夹用于存储脚本，并创建一个`bin/lib`目录用于存储常见的代码片段。在处理大量shell脚本时，重用大块功能非常重要。可以通过为shell脚本编写库函数来实现这一点，这些函数可以从多个位置调用。
- en: Here we will create a library script called `util.sh`, which will be sourced
    in other scripts. By sourcing the script, we get access to functions and variables
    from inside the library script.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个名为`util.sh`的库脚本，它将在其他脚本中被引用。通过引用该脚本，我们可以从库脚本内部访问函数和变量。
- en: We will start by adding the `print_ip` function from a previous script.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从先前的脚本中添加`print_ip`函数。
- en: Now we will add another function called `getarg`, which will be used by other
    scripts for reading command line arguments and values. We will simply paste it
    from our clipboard history, using ClipIt to select it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加另一个名为`getarg`的函数，其他脚本将使用它来读取命令行参数和值。我们将简单地从剪贴板历史中粘贴它，使用ClipIt进行选择。
- en: You can learn more about ClipIt by checking out our ClipIt section!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看我们的ClipIt部分来了解更多关于ClipIt的信息！
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Shell scripting libraries](img/image_02_034.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Shell脚本库](img/image_02_034.jpg)'
- en: This is just a simple function that will receive a parameter name as the first
    argument, the list of CLI arguments as the second parameter, and it will search
    inside the list of CLI arguments to find the parameter name. We will see it in
    action later on.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的函数，它将接收参数名称作为第一个参数，CLI参数列表作为第二个参数，并在CLI参数列表中搜索参数名称。我们将在后面看到它的实际应用。
- en: The last function we're going to create is called `get_public_ip`. It is similar
    in terms of functionality to the `print_ip` function, except that it will be used
    to print the computer's public IP. That means that, if you are connected to a
    wireless router and you access the Internet, you will get the IP of the router,
    which is the IP that other sites see. The `print_ip` function just shows the IP
    address from the private subnet.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的最后一个函数称为`get_public_ip`。它在功能上与`print_ip`函数类似，只是它用于打印计算机的公共IP。这意味着，如果您连接到无线路由器并访问Internet，您将获得路由器的IP，这是其他站点看到的IP。`print_ip`函数只显示私有子网的IP地址。
- en: 'The command is already copied in the clipboard. It''s called **dig** and we''re
    using it to access [https://www.opendns.com/](https://www.opendns.com/) in order
    to read the public `ip`. You can find more information about it in its man page
    or by Googling it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令已经复制到剪贴板中。它被称为**dig**，我们使用它来访问[https://www.opendns.com/](https://www.opendns.com/)以读取公共`ip`。您可以在其man页面或通过Google搜索中找到有关它的更多信息：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that we have our library functions in place, let's go and create our productivity
    booster scripts. Let's create a script called **iputils** where we will add some
    common tasks for reading IP addresses.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了库函数，让我们去创建我们的提高生产力的脚本。让我们创建一个名为**iputils**的脚本，在其中添加一些用于读取IP地址的常见任务。
- en: 'We''ll start by adding the shebang, followed by a neat little trick for making
    sure we are always in the same folder as the executed script. We will be using
    the `BASH_SOURCE` variable to determine the value of the **current working directory**
    (or **CWD**) variable. You see here that we are using nested subshells in order
    to achieve this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加shebang，然后是一个巧妙的小技巧，以确保我们始终在与执行的脚本相同的文件夹中。我们将使用`BASH_SOURCE`变量来确定**当前工作目录**（或**CWD**）变量的值。您可以在这里看到我们使用了嵌套子shell来实现这一点：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will source the `util` script, so that the library functions are exported
    into memory. Then, we can access them from the current script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将引用`util`脚本，以便将库函数导出到内存中。然后，我们可以从当前脚本中访问它们：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s add a simple call to our `getarg` function using a subshell, and search
    for the `cmd` argument. Also, let''s echo what we''ve found, so that we can test
    our script:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在使用子shell的情况下向我们的`getarg`函数添加一个简单的调用，并搜索`cmd`参数。此外，让我们输出我们找到的内容，以便测试我们的脚本：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next thing we need to do is to give the script execution rights using the
    `chmod` command. Also, in order to run the script from anywhere, the `bin` folder
    must be in the PATH variable. Echo the variable and check that the bin folder
    is there and, if not, update the variable in `~/.zshrc`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`chmod`命令给脚本赋予执行权限。此外，为了能够从任何位置运行脚本，`bin`文件夹必须在PATH变量中。输出该变量并检查bin文件夹是否存在，如果不存在，则在`~/.zshrc`中更新该变量。
- en: Let's test the script by reading a command line parameter with the `getarg`
    function and echoing it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`getarg`函数读取命令行参数并输出它来测试脚本。
- en: If you are searching for the `iputils` command in the terminal using tab for
    autocomplete and the command doesn't seem to exist, that is probably because you
    need to tell `zsh` to reload its path commands. To do this, issue the "rehash"
    command.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在终端中使用tab键自动补全搜索`iputils`命令，并且命令似乎不存在，那可能是因为您需要告诉`zsh`重新加载其路径命令。要做到这一点，输入"rehash"命令。
- en: 'Now run:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This should work from within any folder, and it should print `ip` on the screen.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在任何文件夹中都可以工作，并在屏幕上打印出`ip`。
- en: 'Now that we''ve verified everything is alright, let''s write some code for
    our command line arguments. If we run the script with the `--cmd ip` flags, the
    script should print that on the screen. This can be done with the already-familiar
    `case` statement. Here we also want to pass in another argument, `--iface,` to
    get the interface that''s needed for printing the IP. It''s also a good practice
    to add a default case and echo a message saying `invalid` argument:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了一切都没问题，让我们为命令行参数编写一些代码。如果我们使用`--cmd ip`标志运行脚本，脚本应该在屏幕上打印出来。这可以通过已经熟悉的`case`语句来实现。在这里，我们还想传入另一个参数`--iface`，以获取打印IP所需的接口。添加一个默认情况并回显一个消息说`invalid`参数也是一个好习惯：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save the script, and let's test it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后让我们测试一下。
- en: 'First, let''s get the interface name from the `ifconfig` command, and then
    let''s go and test the script by running this command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`ifconfig`命令中获取接口名称，然后通过运行此命令来测试脚本：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Shell scripting libraries](img/image_02_035.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Shell脚本库](img/image_02_035.jpg)'
- en: We can see it's printing our private `ip` on the screen.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它在屏幕上打印出了我们的私有`ip`。
- en: 'Now let''s add our last `cmd` to the script: `publicip`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在脚本中添加最后一个`cmd`：`publicip`。
- en: 'For this we just call the `get_public_ip` function from our `lib` utility.
    Save it and run this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们只需从我们的`lib`工具中调用`get_public_ip`函数。保存并运行此命令：
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We see that the command worked; our public `ip` is printed on the screen. Here
    is the complete script:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到命令运行成功；我们的公共`ip`被打印在屏幕上。这是完整的脚本：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To give you an example, a while ago there were a bunch of articles on the Internet
    about a man who used to automate everything that took him more than 90 seconds
    to do. The scripts he wrote included instructing the coffee machine to start making
    a latte, so that by the time he got to the machine, the latte was finished and
    he didn't need to wait. He also wrote a script that sent a text message "late
    at work" to his wife and automatically picked a reason from a preset list whenever
    there was activity with his login on the company's servers after 9 p.m.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，前段时间互联网上有一堆关于一个男人的文章，他习惯于自动化一切超过90秒的工作。他编写的脚本包括指示咖啡机开始制作拿铁，这样当他到达咖啡机时，拿铁已经完成，他不需要等待。他还编写了一个脚本，在晚上9点后，每当他在公司的服务器上登录活动时，自动向妻子发送一条“工作晚了”的短信，并从预设列表中自动选择一个原因。
- en: Of course, this example is a little bit complex, but in the end it's all about
    your imagination. Well-written automation scripts can take care of your routine
    work and leave you to explore your creative potential.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子有点复杂，但最终都是关于你的想象力。写得好的自动化脚本可以处理你的例行工作，让你有时间发掘你的创造潜力。
