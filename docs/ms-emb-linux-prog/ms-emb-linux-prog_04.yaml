- en: Chapter 4. Porting and Configuring the Kernel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。移植和配置内核
- en: The kernel is the third element of embedded Linux. It is the component that
    is responsible for managing resources and interfacing with hardware and so affects
    almost every aspect of your final software build. It is usually tailored to your
    particular hardware configuration although, as we saw in [Chapter 3](ch03.html
    "Chapter 3. All About Bootloaders"), *All About Bootloaders*, device trees allow
    you to create a generic kernel that is tailored to particular hardware by the
    contents of the device tree.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是嵌入式Linux的第三个元素。它是负责管理资源和与硬件接口的组件，因此几乎影响到最终软件构建的每个方面。它通常根据您的特定硬件配置进行定制，尽管正如我们在[第3章](ch03.html
    "第3章。关于引导加载程序")中看到的，设备树允许您通过设备树的内容创建一个通用内核，以适应特定硬件。
- en: In this chapter, we will look at how to get a kernel for a board and how to
    configure and compile it. We will look again at bootstrap, this time focusing
    on the part the kernel plays. We will also look at device drivers and how they
    pick up information from the device tree.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何为板载获取内核，以及如何配置和编译它。我们将再次看看引导加载程序，这次重点放在内核所扮演的角色上。我们还将看看设备驱动程序以及它们如何从设备树中获取信息。
- en: What does the kernel do?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核的主要作用是什么？
- en: Linux began in 1991 when Linus Torvalds started writing an operating system
    for Intel 386 and 486-based personal computers. He was inspired by the Minix operating
    system written by Andrew S. Tanenbaum four years earlier. Linux differed in many
    ways from Minix, the main differences being that it was a 32-bit virtual memory
    kernel and the code was open source, later released under the GPL 2 license.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux始于1991年，当时Linus Torvalds开始为基于Intel 386和486的个人计算机编写操作系统。他受到了四年前Andrew S.
    Tanenbaum编写的Minix操作系统的启发。Linux在许多方面与Minix不同，主要区别在于它是一个32位虚拟内存内核，代码是开源的，后来发布在GPL
    2许可下。
- en: He announced it on the 25th August 1991 on the *comp.os.minix* newsgroup in
    a famous post that begins as *Hello everybody out there using minix - I'm doing
    a (free) operating system (just a hobby, won't be big and professional like gnu)
    for 386(486) AT clones. This has been brewing since april, and is starting to
    get ready. I'd like any feedback on things people like/dislike in minix, as my
    OS resembles it somewhat (same physical layout of the file-system (due to practical
    reasons) among other things)*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年8月25日，他在*comp.os.minix*新闻组上宣布了这一消息，这是一篇著名的帖子，开头是*大家好，所有使用minix的人 - 我正在为386(486)
    AT克隆机做一个(免费)操作系统(只是一项爱好，不会像gnu那样大而专业)。这个想法从四月份开始酝酿，现在已经开始准备。我想听听大家对minix中喜欢/不喜欢的东西的反馈，因为我的操作系统在某种程度上类似(minix)（由于实际原因，文件系统的物理布局相同，等等）*。
- en: To be strictly accurate, Linus did not write an operating system, he wrote a
    kernel instead, which is one component of an operating system. To create a working
    system, he used components from the GNU project, especially the toolchain, C library,
    and basic command-line tools. That distinction remains today, and gives Linux
    a lot of flexibility in the way it is used. It can be combined with a GNU user
    space to create a full Linux distribution that runs on desktops and servers, which
    is sometimes called GNU/Linux; it can be combined with an Android user space to
    create the well-known mobile operating system or it can be combined with a small
    Busybox-based user space to create a compact embedded system. Contrast this with
    the BSD operating systems, FreeBSD, OpenBSD, and NetBSD, in which the kernel,
    the toolchain, and the user space are combined into a single code base.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Linus并没有编写操作系统，而是编写了一个内核，这是操作系统的一个组成部分。为了创建一个工作系统，他使用了GNU项目的组件，特别是工具链、C库和基本命令行工具。这种区别至今仍然存在，并且使Linux在使用方式上具有很大的灵活性。它可以与GNU用户空间结合，创建一个在台式机和服务器上运行的完整Linux发行版，有时被称为GNU/Linux；它可以与Android用户空间结合，创建著名的移动操作系统；或者它可以与基于Busybox的小型用户空间结合，创建一个紧凑的嵌入式系统。与BSD操作系统（FreeBSD、OpenBSD和NetBSD）形成对比，其中内核、工具链和用户空间组合成一个单一的代码库。
- en: 'The kernel has three main jobs: to manage resources, to interface with hardware,
    and to provide an API that offers a useful level of abstraction to user space
    programs, as summarized in the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有三个主要任务：管理资源、与硬件接口和提供API，为用户空间程序提供有用的抽象级别，如下图所示：
- en: '![What does the kernel do?](img/B03982_04_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![内核的主要作用是什么？](img/B03982_04_01.jpg)'
- en: Applications running in user space run at a low CPU privilege level. They can
    do very little other than make library calls. The primary interface between the
    user space and the kernel space is the C library, which translates user level
    functions such as those defined by POSIX into kernel system calls. The system
    call interface uses an architecture-specific method such as a trap or a software
    interrupt to switch the CPU from the low privilege user mode to the high privilege
    kernel mode, which allows access to all memory addresses and CPU registers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间运行的应用程序以较低的CPU特权级别运行。除了进行库调用之外，它们几乎无法做任何事情。用户空间和内核空间之间的主要接口是C库，它将用户级函数（如POSIX定义的函数）转换为内核系统调用。系统调用接口使用特定于体系结构的方法，如陷阱或软件中断，将CPU从低特权用户模式切换到高特权内核模式，从而允许访问所有内存地址和CPU寄存器。
- en: 'The system call handler dispatches the call to the appropriate kernel subsystem:
    scheduling calls to the scheduler, the filesystem, calls to the filesystem code,
    and so on. Some of those calls require input from the underlying hardware and
    will be passed down to a device driver. In some cases, the hardware itself invokes
    a kernel function by raising an interrupt. Interrupts can only be handled in a
    device driver, never by a user space application.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用处理程序将调用分派到适当的内核子系统：调度调用调度程序，文件系统调用文件系统代码等。其中一些调用需要来自底层硬件的输入，并将被传递给设备驱动程序。在某些情况下，硬件本身通过引发中断来调用内核函数。中断只能由设备驱动程序处理，而不能由用户空间应用程序处理。
- en: In other words, all the useful things that your application does, it does them
    through the kernel. The kernel, then, is one of the most important elements in
    the system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，您的应用程序执行的所有有用的功能都是通过内核完成的。因此，内核是系统中最重要的元素之一。
- en: Choosing a kernel
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择内核
- en: The next step is to choose the kernel for your project, balancing the desire
    to always use the latest version of software against the need for vendor-specific
    additions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择适合您项目的内核，平衡了始终使用最新软件版本的愿望和对特定供应商添加的需求。
- en: Kernel development cycle
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核开发周期
- en: 'Linux has been developed at a fast pace, with a new version being released
    every 8 to 12 weeks. The way that the version numbers are constructed has changed
    a bit in recent years. Before July 2011, there was a three number version scheme
    with version numbers that looked like 2.6.39\. The middle number indicated whether
    it was a developer or stable release, odd numbers (2.1.x, 2.3.x, 2.5.x) were for
    developers and even numbers were for end users. From version 2.6 onwards, the
    idea of a long-lived development branch (the odd numbers) was dropped as it slowed
    down the rate at which new features were made available to users. The change in
    numbering from 2.6.39 to 3.0 in July 2011 was purely because Linus felt that the
    numbers were becoming too large: there was no huge leap in the features or architecture
    of Linux between those two versions. He also took the opportunity to drop the
    middle number. Since then, in April 2015, he bumped the major from 3 to 4, again
    purely for neatness, not because of any large architectural shift.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux已经以快速的速度发展，每8到12周发布一个新版本。近年来，版本号的构造方式有所改变。2011年7月之前，版本号采用了三位数的版本方案，版本号看起来像2.6.39。中间的数字表示它是开发人员还是稳定版本，奇数（2.1.x、2.3.x、2.5.x）是给开发人员的，偶数是给最终用户的。从2.6版本开始，长期的开发分支（奇数）的概念被放弃了，因为它减缓了新功能向用户提供的速度。从2.6.39到2011年7月的3.0的编号变化纯粹是因为Linus觉得数字变得太大了：在这两个版本之间，Linux的功能或架构没有发生巨大的飞跃。他还趁机去掉了中间的数字。从那时起，2015年4月，他将主要版本从3提升到4，也纯粹是为了整洁，而不是因为有任何重大的架构变化。
- en: 'Linus manages the development kernel tree. You can follow him by cloning his
    git tree like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Linus管理开发内核树。您可以通过克隆他的git树来关注他：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will check out into subdirectory `linux`. You can keep up to date by running
    the command `git pull` in that directory from time to time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检出到子目录`linux`。您可以通过在该目录中不时运行`git pull`命令来保持最新。
- en: Currently, a full cycle of kernel development begins with a merge window of
    two weeks, during which Linus will accept patches for new features. At the end
    of the merge window, a stabilization phase begins, during which Linus will produce
    release candidates with version numbers ending in -rc1, -rc2, and so on, usually
    up to -rc7 or -rc8\. During this time, people test the candidates and submit bug
    reports and fixes. When all significant bugs have been fixed, the kernel is released.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，内核开发的完整周期始于两周的合并窗口期，在此期间Linus将接受新功能的补丁。合并窗口结束后，稳定化阶段开始，Linus将发布版本号以-rc1、-rc2等结尾的候选版本，通常会发布到-rc7或-rc8。在此期间，人们测试候选版本并提交错误报告和修复。当所有重要的错误都被修复后，内核就会发布。
- en: The code incorporated during the merge window has to be fairly mature already.
    Usually, it is pulled from the repositories of the many subsystem and architecture
    maintainers of the kernel. By keeping to a short development cycle, features can
    be merged when they are ready. If a feature is deemed not sufficiently stable
    or well developed by the kernel maintainers, it can simply be delayed until the
    next release.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 合并窗口期间合并的代码必须已经相当成熟。通常，它是从内核的许多子系统和架构维护者的存储库中提取的。通过保持短的开发周期，可以在功能准备就绪时合并功能。如果内核维护人员认为某个功能不够稳定或发展不够完善，它可以简单地延迟到下一个发布版本。
- en: Keeping a track of what has changed from release to release is not easy. You
    can read the commit log in Linus' git repository but, with roughly 10,000 or more
    entries per release, it is not easy to get an overview. Thankfully, there is the
    *Linux Kernel Newbies* website, [http://kernelnewbies.org](http://kernelnewbies.org)
    where you will find a succinct overview of each version, at [http://kernelnewbies.org/LinuxVersions](http://kernelnewbies.org/LinuxVersions).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每个版本之间的变化并不容易。您可以阅读Linus的git存储库中的提交日志，但是每个发布版本大约有10,000个或更多的条目，很难得到一个概述。幸运的是，有*Linux
    Kernel Newbies*网站，[http://kernelnewbies.org](http://kernelnewbies.org)，您可以在[http://kernelnewbies.org/LinuxVersions](http://kernelnewbies.org/LinuxVersions)找到每个版本的简要概述。
- en: Stable and long term support releases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定和长期支持版本
- en: The rapid rate of change of Linux is a good thing in that it brings new features
    into the mainline code base, but it does not fit very well with the longer life
    cycle of embedded projects. Kernel developers address this in two ways. Firstly,
    it is acknowledged that a release may contain bugs that need to be fixed before
    the next kernel release comes around. That is the role of the stable Linux kernel,
    maintained by Greg Kroah-Hartman. After release, the kernel moves from being **mainline**
    (maintained by Linus) to **stable** (maintained by Greg). Bug fix releases of
    the stable kernel are marked by a third number, 3.18.1, 3.18.2, and so on. Before
    version 3, there were four release numbers, 2.6.29.1, 2.6.39.2, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的快速变化速度是一件好事，因为它将新功能引入了主线代码库，但它并不太适合嵌入式项目的较长生命周期。内核开发人员以两种方式解决了这个问题。首先，他们承认一个发布版本可能包含需要在下一个内核发布版本之前修复的错误。这就是由Greg
    Kroah-Hartman维护的稳定Linux内核的作用。发布后，内核从“主线”（由Linus维护）转变为“稳定”（由Greg维护）。稳定内核的错误修复版本由第三个数字标记，如3.18.1、3.18.2等。在3版本之前，有四个发布数字，如2.6.29.1、2.6.39.2等。
- en: 'You can get the stable tree by using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取稳定树：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can use `git chckout` to get a particular version, for example version
    4.1.10:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`git chckout`获取特定版本，例如版本4.1.10：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Usually, the stable kernel is maintained only until the next mainline release,
    8 to 12 weeks later, so you will see that there is just one or sometimes two stable
    kernels at [kernel.org](http://kernel.org). To cater for those users who would
    like updates for a longer period of time and be assured that any bugs will be
    found and fixed, some kernels are labeled **long term** and maintained for two
    or more years. There is at least one long term kernel each year. Looking at [kernel.org](http://kernel.org)
    at the time of writing, there are a total of eight long term kernels: 4.1, 3.18,
    3.14, 3.12, 3.10, 3.4, 3.2, and 2.6.32\. The latter has been maintained for five
    years and is at version 2.6.32.68\. If you are building a product that you will
    have to maintain for this length of time the latest long term kernel might well
    be a good choice.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，稳定的内核只维护到下一个主线发布，通常是8到12周后，因此您会发现在[kernel.org](http://kernel.org)上只有一个或两个稳定的内核。为了满足那些希望在更长时间内获得更新并确保任何错误都将被发现和修复的用户，一些内核被标记为**长期**，并维护两年或更长时间。每年至少有一个长期内核。在撰写本文时，[kernel.org](http://kernel.org)上总共有八个长期内核：4.1、3.18、3.14、3.12、3.10、3.4、3.2和2.6.32。后者已经维护了五年，目前版本为2.6.32.68。如果您正在构建一个需要维护这么长时间的产品，最新的长期内核可能是一个不错的选择。
- en: Vendor support
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商支持
- en: 'In an ideal world, you would be able to download a kernel from [kernel.org](http://kernel.org)
    and configure it for any device that claims to support Linux. However, that is
    not always possible: in fact mainline Linux has solid support for only a small
    subset of the many devices that can run Linux. You may find support for your board
    or SoC from independent open source projects, Linaro or the Yocto Project, for
    example, or from companies providing third party support for embedded Linux, but
    in many cases you will be obliged to look to the vendor of your SoC or board for
    a working kernel. As we also know, some are better than others.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，您可以从[kernel.org](http://kernel.org)下载内核，并为任何声称支持Linux的设备进行配置。然而，这并不总是可能的：事实上，主线Linux只对可以运行Linux的许多设备中的一小部分具有坚实的支持。您可能会从独立的开源项目、Linaro或Yocto项目等地方找到对您的板子或SoC的支持，或者从提供嵌入式Linux第三方支持的公司那里找到支持，但在许多情况下，您将被迫寻求您的SoC或板子的供应商提供一个可用的内核。正如我们所知，有些供应商比其他供应商更好。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: My only advice at this point is to choose vendors who give good support or who,
    even better, take the trouble to get their kernel changes into the mainline.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这一点上唯一的建议是选择给予良好支持的供应商，或者更好的是，让他们的内核更改进入主线。
- en: Licensing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可
- en: The Linux source code is licensed under GPL v2, which means that you must make
    the source code of your kernel available in one of the ways specified in the license.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Linux源代码根据GPL v2许可，这意味着您必须以许可中指定的一种方式提供内核的源代码。
- en: The actual text of the license for the kernel is in the file `COPYING`. It begins
    with an addendum written by Linus that states that code calling the kernel from
    user space via the system call interface is not considered a derivative work of
    the kernel and so is not covered by the license. Hence, there is no problem with
    proprietary applications running on top of Linux.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 内核许可的实际文本在`COPYING`文件中。它以Linus撰写的附录开头，附录指出通过系统调用接口从用户空间调用内核的代码不被视为内核的衍生作品，因此不受许可的约束。因此，在Linux上运行专有应用程序没有问题。
- en: 'However, there is one area of Linux licensing that causes endless confusion
    and debate: kernel modules. A kernel module is simply a piece of code that is
    dynamically linked with the kernel at runtime, thereby extending the functionality
    of the kernel. The GPL makes no distinction between static and dynamic linking,
    so it would appear that the source for kernel modules is covered by the GPL. But,
    in the early days of Linux, there were debates about exceptions to this rule,
    for example, in connection with the Andrew filesystem. This code predates Linux
    and therefore (it was argued) is not a derivative work, and so the license does
    not apply. Similar discussions took place over the years with respect to other
    pieces of code, with the result that it is now accepted practice that the GPL
    does not necessarily apply to kernel modules. This is codified by the kernel `MODULE_LICENSE`
    macro, which may take the value `Proprietary` to indicate that it is not released
    under the GPL. If you plan to use the same arguments yourself, you may want to
    read though an oft-quoted email thread titled *Linux GPL and binary module exception
    clause?* ([http://yarchive.net/comp/linux/gpl_modules.html](http://yarchive.net/comp/linux/gpl_modules.html)).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个Linux许可的领域引起了无休止的混乱和争论：内核模块。内核模块只是在运行时与内核动态链接的一段代码，从而扩展了内核的功能。GPL对静态链接和动态链接没有区别，因此内核模块的源代码似乎受到GPL的约束。但是，在Linux的早期，关于这一规则的例外情况进行了辩论，例如与Andrew文件系统有关。这段代码早于Linux，因此（有人认为）不是衍生作品，因此许可不适用。多年来，关于其他代码的类似讨论也进行了讨论，结果是现在普遍认为GPL不一定适用于内核模块。这由内核`MODULE_LICENSE`宏所规定，该宏可以取值`Proprietary`，表示它不是根据GPL发布的。如果您打算自己使用相同的论点，您可能需要阅读一篇经常引用的电子邮件主题，标题为*Linux
    GPL和二进制模块例外条款？*（[http://yarchive.net/comp/linux/gpl_modules.html](http://yarchive.net/comp/linux/gpl_modules.html)）。
- en: The GPL should be considered a good thing because it guarantees that when you
    and I are working on embedded projects, we can always get the source code for
    the kernel. Without it, embedded Linux would be much harder to use and more fragmented.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GPL应该被视为一件好事，因为它保证了当你和我在嵌入式项目上工作时，我们总是可以获得内核的源代码。没有它，嵌入式Linux将会更难使用，更加分散。
- en: Building the kernel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建内核
- en: Having decided which kernel to base your build on, the next step is to build
    it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定基于哪个内核构建您的构建之后，下一步是构建它。
- en: Getting the source
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'Let''s assume that you have a board that is supported in mainline. You can
    get the source code through git or by downloading a tarball. Using git is better
    because you can see the commit history, you can easily see any changes you may
    make and you can switch between branches and versions. In this example, we are
    cloning the stable tree and checking out the version tag 4.1.10:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个在主线上受支持的板子。您可以通过git获取源代码，也可以通过下载tarball获取。使用git更好，因为您可以查看提交历史，轻松查看您可能进行的任何更改，并且可以在分支和版本之间切换。在此示例中，我们正在克隆稳定树并检出版本标签4.1.10：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you could download the tarball from [https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz](https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从[https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz](https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz)下载tarball。
- en: 'There is a lot of code here. There are over 38,000 files in the 4.1 kernel
    containing C source code, header files, and assembly code, amounting to a total
    of over 12.5 million lines of code (as measured by the cloc utility). Nevertheless,
    it is worth knowing the basic layout of the code and to know, approximately, where
    to look for a particular component. The main directories of interest are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多代码。在4.1内核中有超过38,000个文件，包含C源代码、头文件和汇编代码，总共超过1250万行代码（由cloc实用程序测量）。尽管如此，了解代码的基本布局并大致知道在哪里寻找特定组件是值得的。感兴趣的主要目录有：
- en: '`arch`: This contains architecture-specific files. There is one subdirectory
    per architecture.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`: 这包含特定于体系结构的文件。每个体系结构都有一个子目录。'
- en: '`Documentation`: This contains kernel documentation. Always look here first
    if you want to find more information about an aspect of Linux.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documentation`: 这包含内核文档。如果您想要找到有关Linux某个方面的更多信息，首先请查看这里。'
- en: '`drivers`: This contains device drivers, thousands of them. There is a subdirectory
    for each type of driver.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`: 这包含设备驱动程序，成千上万个。每种类型的驱动程序都有一个子目录。'
- en: '`fs`: This contains filesystem code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`: 这包含文件系统代码。'
- en: '`include`: This contains kernel header files, including those required when
    building the toolchain.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`: 这包含内核头文件，包括构建工具链时所需的头文件。'
- en: '`init`: This contains the kernel start-up code.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`: 这包含内核启动代码。'
- en: '`kernel`: This contains core functions, including scheduling, locking, timers,
    power management, and debug/trace code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`: 这包含核心功能，包括调度、锁定、定时器、电源管理和调试/跟踪代码。'
- en: '`mm`: This contains memory management.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm`: 这包含内存管理。'
- en: '`net`: This contains network protocols.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`: 这包含网络协议。'
- en: '`scripts`: This contains many useful scripts including the device tree compiler,
    dtc, which I described in [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"),
    *All About Bootloaders*.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`: 这包含许多有用的脚本，包括设备树编译器dtc，我在[第3章](ch03.html "第3章。关于引导加载程序的一切")中描述了*关于引导加载程序的一切*。'
- en: '`tools`: This contains many useful tools, including the Linux performance counters
    tool, perf, which I will describe in [Chapter 13](ch13.html "Chapter 13. Profiling
    and Tracing"), *Profiling and Tracing*.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工具`: 这包含许多有用的工具，包括Linux性能计数器工具perf，在[第13章](ch13.html "第13章。性能分析和跟踪")中我会描述*性能分析和跟踪*。'
- en: Over a period of time, you will become familiar with this structure, and realize
    that, if you are looking for the code for the serial port of a particular SoC,
    you will find it in `drivers/tty/serial` and not in `arch/$ARCH/mach-foo` because
    it is a device driver and not something central to the running of Linux on that
    SoC.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您将熟悉这种结构，并意识到，如果您正在寻找特定SoC的串行端口代码，您将在`drivers/tty/serial`中找到它，而不是在`arch/$ARCH/mach-foo`中找到，因为它是设备驱动程序，而不是Linux在该SoC上运行的核心部分。
- en: Understanding kernel configuration
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解内核配置
- en: One of the strengths of Linux is the degree to which you can configure the kernel
    to suit different jobs, from a small dedicated device such as a smart thermostat
    to a complex mobile handset. In current versions there are many thousands of configuration
    options. Getting the configuration right is a task in itself but, before that,
    I want to show you how it works so that you can better understand what is going
    on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是您可以根据不同的工作需求配置内核，从小型专用设备（如智能恒温器）到复杂的移动手持设备。在当前版本中有成千上万的配置选项。正确配置配置本身就是一项任务，但在此之前，我想向您展示它是如何工作的，以便您更好地理解正在发生的事情。
- en: The configuration mechanism is called `Kconfig`, and the build system that it
    integrates with is called `Kbuild`. Both are documented in `Documentation/kbuild/`.
    `Kconfig/Kbuild` is used in a number of other projects as well as the kernel,
    including crosstool-NG, U-Boot, Barebox, and BusyBox.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置机制称为`Kconfig`，与之集成的构建系统称为`Kbuild`。两者都在`Documentation/kbuild/`中有文档。`Kconfig/Kbuild`在内核以及其他项目中都有使用，包括crosstool-NG、U-Boot、Barebox和BusyBox。
- en: 'The configuration options are declared in a hierarchy of files named `Kconfig`
    using a syntax described in `Documentation/kbuild/kconfig-language.txt`. In Linux,
    the top level `Kconfig` looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项在名为`Kconfig`的文件层次结构中声明，使用`Documentation/kbuild/kconfig-language.txt`中描述的语法。在Linux中，顶层`Kconfig`看起来像这样：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last line includes the architecture-dependent configuration file which
    sources other `Kconfig` files depending on which options are enabled. Having the
    architecture play such a role has two implications: firstly, that you must specify
    an architecture when configuring Linux by setting `ARCH=[architecture]`, otherwise
    it will default to the local machine architecture, and second that the layout
    of the top level menu is different for each architecture.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行包括与体系结构相关的配置文件，该文件根据启用的选项源自其他`Kconfig`文件。体系结构发挥如此重要的作用有两个含义：首先，在配置Linux时必须通过设置`ARCH=[architecture]`指定体系结构，否则它将默认为本地机器体系结构；其次，每个体系结构的顶级菜单布局都不同。
- en: The value you put into `ARCH` is one of the subdirectories you find in directory
    `arch`, with the oddity that `ARCH=i386` and `ARCH=x86_64` both have the source
    `arch/x86/Kconfig`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您放入`ARCH`的值是您在`arch`目录中找到的子目录之一，其中有一个奇怪之处，即`ARCH=i386`和`ARCH=x86_64`都具有源`arch/x86/Kconfig`。
- en: 'The `Kconfig` files consist largely of menus, delineated by `menu`, `menu title`,
    and `endmenu` keywords, and menu items marked by `config`. Here is an example,
    taken from `drivers/char/Kconfig`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig`文件主要由菜单组成，由`menu`、`menu title`和`endmenu`关键字界定，菜单项由`config`标记。以下是一个例子，取自`drivers/char/Kconfig`：'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The parameter following `config` names a variable that, in this case, is `DEVMEM`.
    Since this option is a Boolean, it can only have two values: if it is enabled
    it is assigned to `y`, if not the variable is not defined at all. The name of
    the menu item that is displayed on the screen is the string following the `bool`
    keyword.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`后面的参数命名了一个变量，在这种情况下是`DEVMEM`。由于这个选项是一个布尔值，它只能有两个值：如果启用了，它被赋值为`y`，如果没有，这个变量根本就没有定义。在屏幕上显示的菜单项的名称是在`bool`关键字后面的字符串。'
- en: 'This configuration item, along with all the others, is stored in a file named
    `.config` (note that the leading dot ''`.`'' means that it is a hidden file that
    will not be shown by the `ls` command unless you type `ls -a` to show all files).
    The variable names stored in `.config` are prefixed with `CONFIG_`, so if `DEVMEM`
    is enabled, the line reads:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置项，以及所有其他配置项，都存储在一个名为`.config`的文件中（注意，前导点'`.`'表示它是一个隐藏文件，不会被`ls`命令显示，除非你输入`ls
    -a`来显示所有文件）。存储在`.config`中的变量名都以`CONFIG_`为前缀，所以如果`DEVMEM`被启用，那么这一行就是：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several other data types in addition to `bool`. Here is the list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`bool`之外，还有几种其他数据类型。以下是列表：
- en: '`bool`: This is either `y` or not defined.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`: 这要么是`y`，要么未定义。'
- en: '`tristate`: This is used where a feature can be built as a kernel module or
    built into the main kernel image. The values are `m` for a module, `y` to be built
    in, and not defined if the feature is not enabled.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tristate`: 这用于一个功能可以作为内核模块构建，也可以构建到主内核映像中。值为`m`表示模块，`y`表示构建，如果未启用该功能，则未定义。'
- en: '`int`: This is an integer value written using decimal notation.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 这是使用十进制表示的整数值。'
- en: '`hex`: This is an unsigned integer value written using hexadecimal notation.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hex`: 这是使用十六进制表示的无符号整数值。'
- en: '`string`: This is a string value.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`: 这是一个字符串值。'
- en: 'There may be dependencies between items, expressed by the `depends on` phrase,
    as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 项目之间可能存在依赖关系，通过`depends on`短语表示，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If `CONFIG_MTD` has not been enabled elsewhere, this menu option is not shown
    and so cannot be selected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CONFIG_MTD`在其他地方没有被启用，这个菜单选项就不会显示，因此也无法选择。
- en: 'There are also reverse dependencies: the `select` keyword enables other options
    if this one is enabled. The `Kconfig` file in `arch/$ARCH` has a large number
    of `select` statements that enable features specific to the architecture, as can
    be seen here for arm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有反向依赖关系：`select`关键字如果启用了其他选项，则启用了这个选项。`arch/$ARCH`中的`Kconfig`文件有大量的`select`语句，启用了特定于架构的功能，如arm中所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are several configuration utilities that can read the `Kconfig` files
    and produce a `.config` file. Some of them display the menus on screen and allow
    you to make choices interactively. `Menuconfig` is probably the one most people
    are familiar with, but there is also `xconfig` and `gconfig`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个配置实用程序可以读取`Kconfig`文件并生成一个`.config`文件。其中一些在屏幕上显示菜单，并允许你进行交互式选择。`Menuconfig`可能是大多数人熟悉的一个，但还有`xconfig`和`gconfig`。
- en: 'You launch each one via `make`, remembering that, in the case of the kernel,
    you have to supply an architecture, as illustrated here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`make`启动每一个，记住，在内核的情况下，你必须提供一个架构，就像这里所示的那样：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, you can see `menuconfig` with the `DEVMEM` `config` option highlighted
    in the previous paragraph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在前一段中突出显示了`DEVMEM` `config`选项的`menuconfig`：
- en: '![Understanding kernel configuration](img/B03982_04_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![理解内核配置](img/B03982_04_02.jpg)'
- en: Kernel configuration using menuconfig
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用menuconfig进行内核配置
- en: The star (`*)` to the left of an item means that it is selected (`="y"`) or,
    if it is an `M,` that it has been selected to be built as a kernel module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 星号(`*`)在项目的左侧表示它被选中(`="y"`)，或者如果是`M`，表示它已被选中以构建为内核模块。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You often see instructions like `enable CONFIG_BLK_DEV_INITRD,` but with so
    many menus to browse through, it can take a while to find the place where that
    configuration is set. All configuration editors have a `search` function. You
    can access it in `menuconfig` by pressing the forward slash key, `/`. In xconfig,
    it is in the edit menu but, in this case make sure you miss off the `CONFIG_`
    part of the variable you are searching for.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会看到像`enable CONFIG_BLK_DEV_INITRD,`这样的指令，但是要浏览这么多菜单，找到设置这个配置的地方可能需要一段时间。所有的配置编辑器都有一个`search`功能。你可以在`menuconfig`中按下斜杠键`/`来访问它。在xconfig中，它在编辑菜单中，但是在这种情况下，确保你省略了你要搜索的变量的`CONFIG_`部分。
- en: 'With so many things to configure, it is unreasonable to start with a clean
    sheet each time you want to build a kernel so there are a set of known working
    configuration files in `arch/$ARCH/configs`, each containing suitable configuration
    values for a single SoC or a group of SoCs. You can select one with `make [configuration
    file name]`. For example, to configure Linux to run on a wide range of SoCs using
    the armv7-a architecture, which includes the BeagleBone Black AM335x, you would
    type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多东西要配置，每次构建内核时都从零开始是不合理的，所以在`arch/$ARCH/configs`中有一组已知的工作配置文件，每个文件包含了单个SoC或一组SoC的合适配置值。你可以用`make
    [配置文件名]`来选择其中一个。例如，要配置Linux在使用armv7-a架构的各种SoC上运行，其中包括BeagleBone Black AM335x，你可以输入：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a generic kernel that runs on various different boards. For a more specialized
    application, for example when using a vendor-supplied kernel, the default configuration
    file is part of the board support package; you will need to find out which one
    to use before you can build the kernel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的内核，可以在不同的板上运行。对于更专业的应用，例如使用供应商提供的内核时，默认的配置文件是板支持包的一部分；在构建内核之前，你需要找出要使用哪一个。
- en: 'There is another useful configuration target named `oldconfig`. This takes
    an exiting `.config` file and asks you to supply configuration values for any
    options that don''t have them. You would use it when moving a configuration to
    a newer kernel version: copy `.config` from the old kernel to the new source directory
    and run `make ARCH=arm oldconfig` to bring it up to date. It can also be used
    to validate a `.config` file that you have edited manually (ignoring the text
    `Automatically generated file; DO NOT EDIT` that occurs at the top: sometimes
    it is OK to ignore warnings).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有用的配置目标名为`oldconfig`。这需要一个现有的`.config`文件，并要求您为任何没有配置值的选项提供配置值。当将配置移动到更新的内核版本时，您将使用它：将`.config`从旧内核复制到新的源目录，并运行`make
    ARCH=arm oldconfig`来使其保持最新。它还可以用于验证您手动编辑的`.config`文件（忽略顶部出现的文本`自动生成的文件；请勿编辑`：有时可以忽略警告）。
- en: If you do make changes to the configuration, the modified `.config` file becomes
    part of your device and needs to be placed under source code control.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对配置进行更改，修改后的`.config`文件将成为设备的一部分，并需要放置在源代码控制下。
- en: When you start the kernel build, a header file, `include/generated/autoconf.h`,
    is generated which contains a `#define` for each configuration value so that it
    can be included in the kernel source, exactly as with U-Boot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动内核构建时，将生成一个头文件`include/generated/autoconf.h`，其中包含每个配置值的`#define`，以便它可以像U-Boot一样包含在内核源中。
- en: Using LOCALVERSION to identify your kernel
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LOCALVERSION标识您的内核
- en: 'You can discover the kernel version that you have built using the `make kernelversion`
    target:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`make kernelversion`目标来查找您构建的内核版本：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is reported at runtime through the `uname` command and is also used in
    naming the directory where kernel modules are stored.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这在运行时通过`uname`命令报告，并且还用于命名存储内核模块的目录。
- en: 'If you change the configuration from the default it is advisable to append
    your own version information, which you can configure by setting `CONFIG_LOCALVERSION`,
    which you will find in the **General setup configuration** menu. It is also possible
    (but discouraged) to do the same by editing the top level makefile and appending
    it to the line that begins with `EXTRAVERSION`. As an example, if I wanted to
    mark the kernel I am building with an identifier `melp` and version 1.0, I would
    define the local version in the `.config` file like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从默认配置更改，建议附加您自己的版本信息，您可以通过设置`CONFIG_LOCALVERSION`来配置，您将在**常规设置配置**菜单中找到它。也可以（但不建议）通过编辑顶层makefile并将其附加到以`EXTRAVERSION`开头的行来执行相同的操作。例如，如果我想要使用标识符`melp`和版本1.0标记我正在构建的内核，我会在`.config`文件中定义本地版本如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running `make kernelversion` produces the same output as before but now, if
    I run `make kernelrelease,` I see:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make kernelversion`会产生与以前相同的输出，但现在，如果我运行`make kernelrelease`，我会看到：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is also printed at the beginning of the kernel log:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会在内核日志的开头打印：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I can now identify and track my custom kernel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以识别和跟踪我的自定义内核。
- en: Kernel modules
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块
- en: I have mentioned kernel modules several times already. Desktop Linux distributions
    use them extensively so that the correct device and kernel functions can be loaded
    at runtime depending on the hardware detected and features required. Without them,
    every single driver and feature would have to be statically linked in to the kernel,
    making it unfeasibly large.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到内核模块。桌面Linux发行版广泛使用它们，以便根据检测到的硬件和所需的功能在运行时加载正确的设备和内核功能。没有它们，每个驱动程序和功能都必须静态链接到内核中，使其变得不可行大。
- en: 'On the other hand, with embedded devices, the hardware and kernel configuration
    is usually known at the time the kernel is built so modules are not so useful.
    In fact, they cause a problem because they create a version dependency between
    the kernel and the root filesystem which can cause boot failures if one is updated
    but not the other. Consequently, it is quite common for embedded kernels to be
    built without any modules at all. Here are a few cases where kernel modules are
    a good idea:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于嵌入式设备来说，硬件和内核配置通常在构建内核时就已知，因此模块并不那么有用。实际上，它们会造成问题，因为它们在内核和根文件系统之间创建了版本依赖关系，如果一个更新了而另一个没有更新，可能会导致启动失败。因此，嵌入式内核通常会构建为完全没有任何模块。以下是一些适合使用内核模块的情况：
- en: When you have proprietary modules, for the licensing reasons given in the preceding
    section.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有专有模块时，出于前一节中给出的许可原因。
- en: To reduce boot time by deferring the loading of non-essential drivers.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推迟加载非必要驱动程序来减少启动时间。
- en: When there are a number of drivers that could be loaded and it would take up
    too much memory to compile them statically. For example, you have a USB interface
    to support a range of devices. This is essentially the same argument as is used
    in desktop distributions.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有多个驱动程序可以加载并且将占用太多内存以静态编译它们时。例如，您有一个USB接口来支持一系列设备。这与桌面发行版中使用的论点基本相同。
- en: Compiling
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译
- en: 'The kernel build system, `kbuild`, is a set of `make` scripts that take the
    configuration information from the `.config` file, work out the dependencies and
    compile everything that is necessary to produce a kernel image containing all
    the statically linked components, possibly a device tree binary and possibly one
    or more kernel modules. The dependencies are expressed in the makefiles that are
    in each directory with buildable components. For instance, these two lines are
    taken from `drivers/char/Makefile`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建系统`kbuild`是一组`make`脚本，它从`.config`文件中获取配置信息，计算出依赖关系，并编译所有必要的内容，以生成包含所有静态链接组件的内核映像，可能还包括设备树二进制文件和一个或多个内核模块。这些依赖关系在每个可构建组件的目录中的makefile中表示。例如，以下两行摘自`drivers/char/Makefile`：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `obj-y` rule unconditionally compiles a file to produce the target, so `mem.c`
    and `random.c` are always part of the kernel. In the second line, `ttyprintk.c`
    is dependent on a configuration parameter. If `CONFIG_TTY_PRINTK` is `y` it is
    compiled as a built in, if it is `m` it is built as a module and, if the parameter
    is undefined, it is not compiled at all.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj-y`规则无条件地编译文件以生成目标，因此`mem.c`和`random.c`始终是内核的一部分。在第二行中，`ttyprintk.c`取决于配置参数。如果`CONFIG_TTY_PRINTK`是`y`，它将被编译为内置模块，如果是`m`，它将作为模块构建，如果参数未定义，则根本不会被编译。'
- en: For most targets, just typing `make` (with the appropriate `ARCH` and `CROSS_COMPILE`)
    will do the job, but it is instructive to take it one step at a time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数目标，只需键入`make`（带有适当的`ARCH`和`CROSS_COMPILE`）即可完成工作，但逐步进行也是有益的。
- en: Compiling the kernel image
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译内核映像
- en: 'To build a kernel image, you need to know what your bootloader expects. This
    is a rough guide:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建内核映像，您需要知道您的引导加载程序期望什么。这是一个粗略的指南：
- en: '**U-Boot**: Traditionally U-Boot has required a uImage, but newer versions
    can load a `zImage` file using the `bootz` command'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**U-Boot**：传统上，U-Boot需要一个uImage，但较新版本可以使用`bootz`命令加载`zImage`文件'
- en: '**x86 targets**: It requires a `bzImage` file'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86目标：它需要一个`bzImage`文件
- en: '**Most other bootloaders**: It requires a `zImage` file'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大多数其他引导加载程序**：它需要一个`zImage`文件'
- en: 'Here is an example of building a `zImage` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建`zImage`文件的示例：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `-j 4` option tells `make` how many jobs to run in parallel, which reduces
    the time taken to build. A rough guide is to run as many jobs as you have CPU
    cores.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j 4`选项告诉`make`并行运行多少个作业，从而减少构建所需的时间。一个粗略的指南是运行与CPU核心数量相同的作业。'
- en: It is the same when building `bzImage` and `uImage` targets.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`bzImage`和`uImage`目标时也是一样的。
- en: There is a small issue with building a `uImage` file for ARM with multi-platform
    support, which is the norm for the current generation of ARM SoC kernels. Multi-platform
    support for ARM was introduced in Linux 3.7\. It allows a single kernel binary
    to run on multiple platforms and is a step on the road toward having a small number
    of kernels for all ARM devices. The kernel selects the correct platform by reading
    the machine number or the device tree passed to it by the bootloader. The problem
    occurs because the location of physical memory might be different for each platform,
    and so the relocation address for the kernel (usually 0x8000 bytes from the start
    of physical RAM) might also be different. The relocation address is coded into
    the `uImage` header by the `mkimage` command when the kernel is built, but it
    will fail if there is more than one relocation address to choose from. To put
    it another way, the `uImage` format is not compatible with multi-platform images.
    You can still create a uImage binary from a multi-platform build so long as you
    give the `LOADADDR` of the particular SoC you are hoping to boot this kernel on.
    You can find the load address by looking in `mach-[your SoC]/Makefile.boot` and
    noting the value of `zreladdr-y`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有多平台支持的ARM的`uImage`文件存在一个小问题，这是当前一代ARM SoC内核的常态。 ARM的多平台支持是在Linux 3.7中引入的。它允许单个内核二进制文件在多个平台上运行，并且是朝着为所有ARM设备拥有少量内核的道路上的一步。内核通过读取引导加载程序传递给它的机器号或设备树来选择正确的平台。问题出在因为每个平台的物理内存位置可能不同，因此内核的重定位地址（通常是从物理RAM的起始位置偏移0x8000字节）也可能不同。当内核构建时，重定位地址由`mkimage`命令编码到`uImage`头中，但如果有多个重定位地址可供选择，则会失败。换句话说，`uImage`格式与多平台映像不兼容。您仍然可以从多平台构建创建一个uImage二进制文件，只要您为希望在其上引导此内核的特定SoC提供`LOADADDR`。您可以通过查看`mach-[your
    SoC]/Makefile.boot`并注意`zreladdr-y`的值来找到加载地址。
- en: 'In the case of a BeagleBone Black, the full command would look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeagleBone Black，完整的命令如下：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A kernel build generates two files in the top level directory: `vmlinux` and
    `System.map`. The first, `vmlinux`, is the kernel as an ELF binary. If you have
    compiled your kernel with debug enabled (`CONFIG_DEBUG_INFO=y`), it will contain
    debug symbols which can be used with debuggers like `kgdb`. You can also use other
    ELF binary tools such as `size`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建在顶层目录中生成两个文件：`vmlinux`和`System.map`。第一个`vmlinux`是内核的ELF二进制文件。如果您已启用调试编译内核（`CONFIG_DEBUG_INFO=y`），它将包含可用于像`kgdb`这样的调试器的调试符号。您还可以使用其他ELF二进制工具，如`size`：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`System.map` contains the symbol table in human readable form.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.map`以人类可读的形式包含符号表。'
- en: 'Most bootloaders cannot handle ELF code directly. There is a further stage
    of processing which takes `vmlinux` and places those binaries in `arch/$ARCH/boot`
    that are suitable for the various bootloaders:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数引导加载程序不能直接处理ELF代码。还有一个进一步的处理阶段，它将`vmlinux`放置在`arch/$ARCH/boot`中，这些二进制文件适用于各种引导加载程序：
- en: '`Image`: `vmlinux` converted to raw binary.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：将`vmlinux`转换为原始二进制文件。'
- en: '`zImage`: For the PowerPC architecture, this is just a compressed version of
    `Image`, which implies that the bootloader must do the decompression. For all
    other architectures, the compressed `Image` is piggybacked onto a stub of code
    that decompresses and relocates it.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zImage`：对于PowerPC架构，这只是`Image`的压缩版本，这意味着引导加载程序必须进行解压缩。对于所有其他架构，压缩的`Image`被附加到一个解压缩和重定位它的代码存根上。'
- en: '`uImage`: `zImage` plus a 64-byte U-Boot header.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uImage`：`zImage`加上64字节的U-Boot头。'
- en: 'While the build is running, you will see a summary of the commands being executed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，您将看到正在执行的命令的摘要：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sometimes, when the kernel build fails, it is useful to see the actual commands
    being executed. To do that, add `V=1` to the command line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当内核构建失败时，查看实际执行的命令很有用。要做到这一点，请在命令行中添加`V=1`：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compiling device trees
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译设备树
- en: 'The next step is to build the device tree, or trees if you have a multi-platform
    build. The dtbs target builds device trees according to the rules in `arch/$ARCH/boot/dts/Makefile`
    using the device tree source files in that directory:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建设备树，或者如果您有多平台构建，则构建多个设备树。dtbs目标根据`arch/$ARCH/boot/dts/Makefile`中的规则使用该目录中的设备树源文件构建设备树：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `.dtb` files are generated in the same directory as the sources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dtb`文件生成在与源文件相同的目录中。'
- en: Compiling modules
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译模块
- en: 'If you have configured some features to be built as modules, you can build
    them separately using the `modules` target:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经配置了一些功能作为模块构建，可以使用`modules`目标单独构建它们：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The compiled modules have a `.ko` suffix and are generated in the same directory
    as the source code, meaning that they are scattered all around the kernel source
    tree. Finding them is a little tricky but you can use the `modules_install` make
    target to install them in the right place. The default location is `/lib/modules`
    in your development system, which is almost certainly not what you want. To install
    them into the staging area of your root filesystem (we will talk about root filesystems
    in the next chapter), provide the path using `INSTALL_MOD_PATH`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的模块具有`.ko`后缀，并且生成在与源代码相同的目录中，这意味着它们散布在整个内核源代码树中。找到它们有点棘手，但您可以使用`modules_install`
    make目标将它们安装到正确的位置。默认位置是开发系统中的`/lib/modules`，这几乎肯定不是您想要的位置。要将它们安装到根文件系统的暂存区域（我们将在下一章讨论根文件系统），请使用`INSTALL_MOD_PATH`提供路径：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Kernel modules are put into the directory `/lib/modules/[kernel version]`, relative
    to the root of the filesystem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块被放置在相对于文件系统根目录的目录`/lib/modules/[kernel version]`中。
- en: Cleaning kernel sources
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理内核源代码
- en: 'There are three make targets for cleaning the kernel source tree:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个用于清理内核源代码树的make目标：
- en: '`clean`: removes object files and most intermediates.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理：删除对象文件和大部分中间文件。
- en: '`mrproper`: removes all intermediate files, including the `.config` file. Use
    this target to return the source tree to the state it was in immediately after
    cloning or extracting the source code. If you are curious about the name, Mr Proper
    is a cleaning product common in some parts of the world. The meaning of `make
    mrproper` is to give the kernel sources a really good scrub.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mrproper`：删除所有中间文件，包括`.config`文件。使用此目标将源树恢复到克隆或提取源代码后的状态。如果您对名称感到好奇，Mr Proper是一种在世界某些地区常见的清洁产品。`make
    mrproper`的含义是给内核源代码进行彻底的清洁。'
- en: '`distclean`: This is the same as mrproper but also deletes editor backup files,
    patch leftover files, and other artifacts of software development.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distclean`：这与mrproper相同，但还会删除编辑器备份文件、补丁剩余文件和软件开发的其他工件。'
- en: Booting your kernel
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导您的内核
- en: Booting is highly device-dependent, but here is an example using U-Boot on a
    BeagleBone Black and QEMU:.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 引导高度依赖于设备，但以下是在BeagleBone Black和QEMU上使用U-Boot的一个示例：。
- en: BeagleBone Black
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BeagleBone Black
- en: 'The following U-Boot commands show how to boot Linux on a BeagleBone Black:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下U-Boot命令显示了如何在BeagleBone Black上启动Linux：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we set the kernel command line to `console=ttyO0,115200`. That tells
    Linux which device to use for console output which, in this case, is the first
    UART on the board, device `ttyO0`, at a speed of 115,200 bits per second. Without
    this, we would not see any messages after `Starting the kernel ...` and therefore
    would not know if it was working or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将内核命令行设置为`console=ttyO0,115200`。这告诉Linux要使用哪个设备进行控制台输出，在本例中是板上的第一个UART设备`ttyO0`，速度为每秒115,200位。如果没有这个设置，我们将在`Starting
    the kernel ...`后看不到任何消息，因此将不知道它是否工作。
- en: QEMU
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QEMU
- en: 'Assuming that you have already installed `qemu-system-arm`, you can launch
    it with the multi_v7 kernel and the `.dtb` file for the ARM Versatile Express,
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经安装了`qemu-system-arm`，您可以使用multi_v7内核和ARM Versatile Express的`.dtb`文件启动它，如下所示：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that setting `QEMU_AUDIO_DRV` to `none` is just to suppress error messages
    from QEMU about missing configurations for the audio drivers, which we do not
    use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将`QEMU_AUDIO_DRV`设置为`none`只是为了抑制关于音频驱动程序缺少配置的QEMU的错误消息，我们不使用音频驱动程序。
- en: To exit from QEMU, type `Ctrl-A` then `x` (two separate keystrokes).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出QEMU，请键入`Ctrl-A`，然后键入`x`（两个单独的按键）。
- en: Kernel panic
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核恐慌
- en: 'While things started off well, they ended badly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切开始得很顺利，但最终却以失败告终：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is a good example of a kernel panic. A panic occurs when the kernel encounters
    an unrecoverable error. By default, it will print out a message to the console
    and then halt. You can set the `panic` command line parameter to allow a few seconds
    before it reboots following a panic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核恐慌的一个很好的例子。当内核遇到不可恢复的错误时，就会发生恐慌。默认情况下，它会在控制台上打印一条消息，然后停止。您可以设置`panic`命令行参数，以允许在恐慌后重新启动之前等待几秒钟。
- en: 'In this case, the unrecoverable error is because there is no root filesystem,
    illustrating that a kernel is useless without a user space to control it. You
    can supply a user space by providing a root filesystem either as a ramdisk or
    on a mountable mass storage device. We will talk about how to create a root filesystem
    in the next chapter but, to get things up and running, assume that we have a ramdisk
    in the file `uRamdisk` and you can then boot to a shell prompt by entering these
    commands into U-Boot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不可恢复的错误是因为没有根文件系统，说明内核没有用户空间来控制它是无用的。您可以通过提供根文件系统作为ramdisk或可挂载的大容量存储设备来提供用户空间。我们将在下一章讨论如何创建根文件系统，但是为了让事情正常运行，假设我们有一个名为`uRamdisk`的ramdisk文件，然后您可以通过在U-Boot中输入以下命令来引导到shell提示符：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, I have added `rdinit=/bin/sh` to the command line so that the kernel
    will run a shell and give us a shell prompt. Now, the output on the console looks
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已经在命令行中添加了`rdinit=/bin/sh`，这样内核将运行一个shell并给我们一个shell提示符。现在，控制台上的输出看起来像这样：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At last, we have a prompt and can interact with our device.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了一个提示符，可以与我们的设备交互。
- en: Early user space
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期用户空间
- en: In order to transition from kernel initialization to user space, the kernel
    has to mount a root filesystem and execute a program in that root filesystem.
    This can be via a ramdisk, as shown in the previous section, or by mounting a
    real filesystem on a block device. The code for all of this is in `init/main.c`,
    starting with the function `rest_init()` which creates the first thread with PID
    1 and runs the code in `kernel_init()`. If there is a ramdisk, it will try to
    execute the `program /init`, which will take on the task of setting up the user
    space.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从内核初始化到用户空间的过渡，内核必须挂载一个根文件系统并在该根文件系统中执行一个程序。这可以通过ramdisk来实现，就像前一节中所示的那样，也可以通过在块设备上挂载一个真实的文件系统来实现。所有这些代码都在`init/main.c`中，从`rest_init()`函数开始，该函数创建了PID为1的第一个线程，并运行`kernel_init()`中的代码。如果有一个ramdisk，它将尝试执行`program
    /init`，这将承担设置用户空间的任务。
- en: 'If it fails to find and run `/init`, it tries to mount a filesystem by calling
    the function `prepare_namespace()` in `init/do_mounts.c`. This requires a `root=`
    command line to give the name of the block device to use for mounting, usually
    in the form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到并运行`/init`，它将尝试通过在`init/do_mounts.c`中调用`prepare_namespace()`函数来挂载文件系统。这需要一个`root=`命令行来指定用于挂载的块设备的名称，通常的形式是：
- en: '`root=/dev/<disk name><partition number>`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root=/dev/<disk name><partition number>`'
- en: '`root=/dev/<disk name>p<partition number>`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root=/dev/<disk name>p<partition number>`'
- en: For example, for the first partition on an SD card, that would be `root=/dev/mmcblk0p1`.
    If the mount succeeds, it will try to execute `/sbin/init`, followed by `/etc/init`,
    `/bin/init`, and then `/bin/sh`, stopping at the first one that works.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于SD卡上的第一个分区，应该是`root=/dev/mmcblk0p1`。如果挂载成功，它将尝试执行`/sbin/init`，然后是`/etc/init`，`/bin/init`，然后是`/bin/sh`，在第一个有效的停止。
- en: The `init` program can be overridden on the command line. For a ramdisk, use
    `rdinit=`, (I used `rdinit=/bin/sh` earlier to execute a shell) and, for a filesystem,
    use `init=`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序可以在命令行上被覆盖。对于ramdisk，使用`rdinit=`（我之前使用`rdinit=/bin/sh`来执行shell），对于文件系统，使用`init=`。'
- en: Kernel messages
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核消息
- en: 'Kernel developers are fond of printing out useful information through liberal
    use of `printk()` and similar functions. The messages are categorized according
    to importance, 0 being the highest:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发人员喜欢通过大量使用`printk()`和类似的函数来打印有用的信息。消息根据重要性进行分类，0是最高级别：
- en: '| Level | Value | Meaning |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Level | Value | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `KERN_EMERG` | 0 | The system is unusable |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_EMERG` | 0 | 系统无法使用 |'
- en: '| `KERN_ALERT` | 1 | Action must be taken immediately |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ALERT` | 1 | 必须立即采取行动 |'
- en: '| `KERN_CRIT` | 2 | Critical conditions |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_CRIT` | 2 | 临界条件 |'
- en: '| `KERN_ERR` | 3 | Error conditions |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ERR` | 3 | 错误条件 |'
- en: '| `KERN_WARNING` | 4 | Warning conditions |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_WARNING` | 4 | 警告条件 |'
- en: '| `KERN_NOTICE` | 5 | Normal but significant conditions |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_NOTICE` | 5 | 正常但重要的条件 |'
- en: '| `KERN_INFO` | 6 | Informational |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_INFO` | 6 | 信息 |'
- en: '| `KERN_DEBUG` | 7 | Debug-level messages |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_DEBUG` | 7 | 调试级别的消息 |'
- en: They are first written to a buffer, `__log_buf`, the size of which is two to
    the power of `CONFIG_LOG_BUF_SHIFT`. For example, if it is 16, then `__log_buf`
    is 64 KiB. You can dump the entire buffer using the command `dmesg`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它们首先被写入一个缓冲区`__log_buf`，其大小为`CONFIG_LOG_BUF_SHIFT`的2次幂。例如，如果是16，那么`__log_buf`就是64
    KiB。您可以使用命令`dmesg`来转储整个缓冲区。
- en: If the level of a message is less than the console log level, it is displayed
    on the console as well as being placed in `__log_buf`. The default console log
    level is 7, meaning that messages of level 6 and lower are displayed, filtering
    out `KERN_DEBUG` which is level 7\. You can change the console log level in several
    ways, including by using the kernel parameter `loglevel=<level>` or the command
    `dmesg -n <level>`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息的级别低于控制台日志级别，则会在控制台上显示该消息，并放置在`__log_buf`中。默认控制台日志级别为7，这意味着级别为6及以下的消息会被显示，过滤掉级别为7的`KERN_DEBUG`。您可以通过多种方式更改控制台日志级别，包括使用内核参数`loglevel=<level>`或命令`dmesg
    -n <level>`。
- en: Kernel command line
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核命令行
- en: The kernel command line is a string that is passed to the kernel by the bootloader,
    via the `bootargs` variable in the case of U-Boot; it can also be defined in the
    device tree, or set as part of the kernel configuration in `CONFIG_CMDLINE`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个字符串，由引导加载程序通过`bootargs`变量传递给内核，在U-Boot的情况下；它也可以在设备树中定义，或作为内核配置的一部分在`CONFIG_CMDLINE`中设置。
- en: 'We have seen some examples of the kernel command line already but there are
    many more. There is a complete list in `Documentation/kernel-parameters.txt`.
    Here is a smaller list of the most useful ones:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些内核命令行的示例，但还有许多其他的。在`Documentation/kernel-parameters.txt`中有一个完整的列表。这里是一个更小的最有用的列表：
- en: '| Name | Description |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `debug` | Sets the console log level to the highest level, eight, to ensure
    that you see all the kernel messages on the console. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `debug` | 将控制台日志级别设置为最高级别8，以确保您在控制台上看到所有内核消息。 |'
- en: '| `init=` | The `init` program to run from a mounted root filesystem, which
    defaults to `/sbin/init`. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `init=` | 从挂载的根文件系统中运行的`init`程序，默认为`/sbin/init`。 |'
- en: '| `lpj=` | Sets the `loops_per_jiffy` to a given constant, see the following
    paragraph. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `lpj=` | 将`loops_per_jiffy`设置为给定的常数，参见下一段。 |'
- en: '| `panic=` | Behavior when the kernel panics: if it is greater than zero, it
    gives the number of seconds before rebooting; if it is zero, it waits forever
    (this is the default); or if it is less than zero, it reboots without any delay.
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `panic=` | 内核发生panic时的行为：如果大于零，则在重新启动之前等待的秒数；如果为零，则永远等待（这是默认值）；如果小于零，则立即重新启动。'
- en: '| `quiet` | Sets the console log level to one, suppressing all but emergency
    messages. Since most devices have a serial console, it takes time to output all
    those strings. Consequently, reducing the number of messages using this option
    reduces boot time. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `quiet` | 将控制台日志级别设置为1，抑制除紧急消息之外的所有消息。由于大多数设备都有串行控制台，输出所有这些字符串需要时间。因此，使用此选项减少消息数量可以减少启动时间。
    |'
- en: '| `rdinit=` | The `init` program to run from a ramdisk, it defaults to `/init`.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `rdinit=` | 从ramdisk运行的`init`程序，默认为`/init`。 |'
- en: '| `ro` | Mounts the root device as read-only. Has no effect on a ramdisk which
    is always read/write. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '`ro` | 将根设备挂载为只读。对于始终是读/写的ramdisk没有影响。'
- en: '| `root=` | Device to mount the root filesystem. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '`root=` | 要挂载根文件系统的设备。'
- en: '| `rootdelay=` | The number of seconds to wait before trying to mount the root
    device, defaults to zero. Useful if the device takes time to probe the hardware,
    but also see `rootwait`. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '`rootdelay=` | 在尝试挂载根设备之前等待的秒数，默认为零。如果设备需要时间来探测硬件，则此参数很有用，但也请参阅`rootwait`。'
- en: '| `rootfstype=` | The filesystem type for the root device. In many cases, it
    is auto-detected during mount, but it is required for `jffs2` filesystems. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '`rootfstype=` | 根设备的文件系统类型。在许多情况下，在挂载期间会自动检测到，但对于`jffs2`文件系统是必需的。'
- en: '| `rootwait` | Waits indefinitely for the root device to be detected. Usually
    necessary with `mmc` devices. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '`rootwait` | 无限期等待根设备被检测到。通常在使用`mmc`设备时是必需的。'
- en: '| `rw` | Mounts the root device as read-write (default). |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '`rw` | 将根设备挂载为读/写（默认）。'
- en: 'The `lpj` parameter is often mentioned in connection with reducing the kernel
    boot time. During initialization, the kernel loops for approximately 250 ms to
    calibrate a delay loop. The value is stored in the variable `loops_per_jiffy`,
    and reported like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`lpj`参数经常在减少内核启动时间方面提到。在初始化期间，内核循环大约250毫秒来校准延迟循环。该值存储在变量`loops_per_jiffy`中，并且报告如下：'
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the kernel always runs on the same hardware it will always calculate the
    same value. You can shave 250 ms off the boot time by adding `lpj=4980736` to
    the command line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核始终在相同的硬件上运行，它将始终计算相同的值。通过在命令行中添加`lpj=4980736`，可以缩短250毫秒的启动时间。
- en: Porting Linux to a new board
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Linux移植到新板子
- en: The scope of the task depends on how similar your board is to an existing development
    board. In [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"), *All About
    Bootloaders* we ported U-Boot to a new board, named Nova, which is based on the
    BeagleBone Black (when I say based, it actually is one) so, in this case, there
    are very few changes to the kernel code to be made. If you are porting to completely
    new and innovative hardware, there will be more to do. I am only going to consider
    the simple case.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的范围取决于您的板子与现有开发板有多相似。在[第3章](ch03.html "第3章。关于引导加载程序的一切")中，*关于引导加载程序*，我们将U-Boot移植到了一个名为Nova的新板子上，该板子基于BeagleBone
    Black（实际上就是基于它），因此在这种情况下，需要对内核代码进行的更改很少。如果要移植到全新和创新的硬件上，则需要做更多工作。我只会考虑简单的情况。
- en: The organization of architecture-specific code in `arch/$ARCH` differs from
    one system to another. The x86 architecture is pretty clean because hardware details
    are detected at runtime. The PowerPC architecture puts SoC and board-specific
    files in subdirectory platforms. The ARM architecture has the most board and SoC-specific
    files of all because there are a lot of ARM boards and SoCs. Platform-dependent
    code is in directories named `mach-*` in `arch/arm`, approximately one per SoC.
    There are other directories named `plat-*` which contain code common to several
    versions of an SoC. In the case of the Nova board, the relevant directory is `mach-omap2`.
    Don't be fooled by the name, though, it contains support for OMAP2, 3, and 4 chips.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch/$ARCH`中的特定于体系结构的代码组织因系统而异。x86体系结构非常干净，因为硬件细节在运行时被检测到。PowerPC体系结构将SoC和特定于板子的文件放在子目录平台中。ARM体系结构具有所有ARM板子和SoC中最多的特定于板子和SoC的文件。特定于平台的代码位于`arch/arm`中名为`mach-*`的目录中，大约每个SoC一个。还有其他名为`plat-*`的目录，其中包含适用于某个SoC的几个版本的通用代码。在Nova板的情况下，相关目录是`mach-omap2`。不过，不要被名称所迷惑，它包含对OMAP2、3和4芯片的支持。'
- en: In the following sections, I am going do the port to the Nova board in two different
    ways. Firstly, I am going to show you how to do this with a device tree, and then
    without, since there are a lot of devices in the field that fit in this category.
    You will see that it is much simpler when you have a device tree.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将以两种不同的方式对Nova板进行移植。首先，我将向您展示如何使用设备树进行移植，然后再进行移植，因为现场有很多符合此类别的设备。您会发现，当您有设备树时，这将更加简单。
- en: With a device tree
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有设备树
- en: 'The first thing to do is create a device tree for the board and modify it to
    describe the additional or changed hardware on the board. In this simple case,
    we will just copy `am335x-boneblack.dts` to `nova.dts` and change the board name:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是为板子创建一个设备树，并修改它以描述板子上的附加或更改的硬件。在这种简单情况下，我们将只是将`am335x-boneblack.dts`复制到`nova.dts`，并更改板子名称：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can build `nova.dtb` explicitly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以显式构建`nova.dtb`：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, if we want `nova.dtb` to be produced by default for the OMAP2 platform
    with `make ARCH=arm dtbs` then we could add the following line to `arch/arm/boot/dts/Makefile`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们希望`nova.dtb`在OMAP2平台上默认生成，可以使用`make ARCH=arm dtbs`，然后我们可以将以下行添加到`arch/arm/boot/dts/Makefile`中：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can boot the same `zImage` file as before, configured with `multi_v7_defconfig`,
    but load the `nova.dtb` as we can see here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像以前一样启动相同的`zImage`文件，使用`multi_v7_defconfig`进行配置，但是加载`nova.dtb`，如下所示：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could create a custom configuration by taking a copy of `multi_v7_defconfig`
    and adding in those features we need, and cutting down code size by leaving out
    those we don't.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过复制`multi_v7_defconfig`来创建自定义配置，并添加我们需要的功能，并通过留出不需要的功能来减小代码大小。
- en: Without a device tree
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有设备树
- en: Firstly, we need to create a configuration name for the board, in this case,
    it is `NOVABOARD`. We need to add this to the `Kconfig` file of the `mach-` directory
    for your SoC and we need to add a dependency for the SoC support itself, which
    is `OMAPAM33XX`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为板子创建一个配置名称，本例中为`NOVABOARD`。我们需要将其添加到您的SoC的`mach-`目录的`Kconfig`文件中，并且需要为SoC支持本身添加一个依赖项，即`OMAPAM33XX`。
- en: 'These lines are added to `arch/arm/mach-omap2/Kconfig`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行添加到`arch/arm/mach-omap2/Kconfig`中：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is a source file named `board-*.c` for each board, which contains code
    and configurations which are specific to the target. In our case, it is `board-nova.c`,
    based on a copy of `board-am335xevm.c`. There must be a rule to compile it, conditional
    on `CONFIG_MACH_NOVABOARD`, which this addition to `arch/arm/mach-omap2/Makefile`
    takes care of:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个板卡都有一个名为`board-*.c`的源文件，其中包含特定于目标的代码和配置。在我们的情况下，它是基于`board-am335xevm.c`的`board-nova.c`。必须有一个规则来编译它，条件是`CONFIG_MACH_NOVABOARD`，这个添加到`arch/arm/mach-omap2/Makefile`中的内容会处理：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since we are not using the device tree to identify the board, we will have
    to use the older machine number mechanism. This is a number unique to each board
    that is passed by the bootloader in register r1, and which the ARM start code
    will use to select the correct board support. The definitive list of ARM machine
    numbers is held at: [www.arm.linux.org.uk/developer/machines/download.php](http://www.arm.linux.org.uk/developer/machines/download.php).
    You can request a new machine number from: [www.arm.linux.org.uk/developer/machines/?action=new#](http://www.arm.linux.org.uk/developer/machines/?action=new#).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用设备树来识别板卡，我们将不得不使用较旧的机器编号机制。这是由引导加载程序传递给寄存器r1的每个板卡的唯一编号，ARM启动代码将使用它来选择正确的板卡支持。ARM机器编号的权威列表保存在：[www.arm.linux.org.uk/developer/machines/download.php](http://www.arm.linux.org.uk/developer/machines/download.php)。您可以从[www.arm.linux.org.uk/developer/machines/?action=new#](http://www.arm.linux.org.uk/developer/machines/?action=new#)请求一个新的机器编号。
- en: 'If we hijack machine number `4242`, we could add it to `arch/arm/tools/mach-types,`
    as shown:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们劫持机器编号`4242`，我们可以将其添加到`arch/arm/tools/mach-types`中，如下所示：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we build the kernel, it will be used to create the `mach-types.h` header
    file present in `include/generated/`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建内核时，它将用于创建`include/generated/`中存在的`mach-types.h`头文件。
- en: 'The machine number and the board support are tied together by a structure which
    is defined like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 机器编号和板卡支持是通过一个结构绑定在一起的，该结构定义如下：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that there may be more than one machine structure in a board file, allowing
    us to create a kernel that will run on several different boards. The machine number
    passed by the bootloader selects the correct one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个板卡文件中可能有多个机器结构，允许我们创建一个可以在多个不同板卡上运行的内核。引导加载程序传递的机器编号将选择正确的机器结构。
- en: 'Finally, we need a new default configuration for our board, which selects `CONFIG_MACH_NOVABOARD`
    and other configuration options specific to it. In the following example, it would
    be in `arch/arm/configs/novaboard_defconfig`. Now you can build the kernel image
    as usual:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的板卡选择一个新的默认配置，该配置选择`CONFIG_MACH_NOVABOARD`和其他特定于它的配置选项。在下面的示例中，它将位于`arch/arm/configs/novaboard_defconfig`。现在您可以像往常一样构建内核映像：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is still one step before the job is finished. The bootloader needs to
    be modified to pass the right machine number. Assuming that you are using U-Boot,
    you need to copy the machine numbers generated by Linux in `arch/arm/include/asm/mach-types.h`
    to U-Boot file `arch/arm/include/asm/mach-types.h`. Then you need to update the
    configuration header file for Nova, `include/configs/nova.h`, and add the following
    line:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 工作完成之前还有一步。引导加载程序需要修改以传递正确的机器编号。假设您正在使用U-Boot，您需要将Linux生成的机器编号复制到U-Boot文件`arch/arm/include/asm/mach-types.h`中。然后，您需要更新Nova的配置头文件`include/configs/nova.h`，并添加以下行：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, at last, you can build U-Boot and use it to boot the new kernel on the
    Nova board:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，您可以构建U-Boot并使用它来引导Nova板上的新内核：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Additional reading
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的更多信息：
- en: '*Linux Kernel Newbies*, [kernelnewbies.org](http://kernelnewbies.org)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核新手*，[kernelnewbies.org](http://kernelnewbies.org)'
- en: '*Linux Weekly News*, [www.lwn.net](http://www.lwn.net)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux每周新闻*，[www.lwn.net](http://www.lwn.net)'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Linux is a very powerful and complex operating system kernel that can be married
    to various types of user space ranging from a simple embedded device, to increasingly
    complex mobile devices using Android, to a full server operating system. One of
    its strengths is the degree of configurability. The definitive place to get the
    source code is [www.kerenl.org](http://www.kerenl.org), but you will probably
    need to get the source for a particular SoC or board from the vendor of that device
    or a third-party that supports that device. The customization of the kernel for
    a particular target may consist of changes to the core kernel code, additional
    drivers for devices that are not in mainline Linux, a default kernel configuration
    file and, a device tree source file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一个非常强大和复杂的操作系统内核，可以与各种类型的用户空间结合，从简单的嵌入式设备到使用Android的日益复杂的移动设备，再到完整的服务器操作系统。其优势之一是可配置性。获取源代码的权威位置是[www.kerenl.org](http://www.kerenl.org)，但您可能需要从该设备的供应商或支持该设备的第三方获取特定SoC或板卡的源代码。为特定目标定制内核可能包括对核心内核代码的更改，为不在主线Linux中的设备添加额外的驱动程序，一个默认的内核配置文件和一个设备树源文件。
- en: Normally you start with the default configuration for your target board, and
    then tweak it by running one of the configuration tools such as `menuconfig`.
    One of the things you should consider at this point is whether kernel features
    and drivers should be compiled as modules or built-in. Kernel modules are usually
    no great advantage for embedded systems, where the feature set and hardware are
    usually well defined. However, modules are often used as a way to import proprietary
    code into the kernel, and also to reduce boot time by loading non-essential drivers
    after boot. Building the kernel produces a compressed kernel image file, named
    `zImage`, `bzImage`, or `uImage` depending on the bootloader you will be using
    and the target architecture. A kernel build will also generate any kernel modules
    (as `.ko` files) that you have configured, and device tree binaries (as `.dtb`
    files) if your target requires them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您会从目标板的默认配置开始，然后通过运行诸如`menuconfig`之类的配置工具进行调整。在这一点上，您应该考虑的一件事是内核功能和驱动程序是否应该编译为模块或内置。内核模块通常对嵌入式系统没有太大优势，因为功能集和硬件通常是明确定义的。然而，模块通常被用作将专有代码导入内核的一种方式，还可以通过在引导后加载非必要驱动程序来减少启动时间。构建内核会生成一个压缩的内核映像文件，根据您将要使用的引导加载程序和目标架构的不同，它的名称可能是`zImage`、`bzImage`或`uImage`。内核构建还会生成您配置的任何内核模块（作为`.ko`文件），以及设备树二进制文件（作为`.dtb`文件），如果您的目标需要的话。
- en: Porting Linux to a new target board can be quite simple or very difficult depending
    on how different the hardware is from that in the mainline or vendor supplied
    kernel. If your hardware is based on a well-known reference design, then it may
    be just a question of making changes to the device tree or to the platform data.
    You may well need to add device drivers, which I discuss in [Chapter 8](ch08.html
    "Chapter 8. Introducing Device Drivers"), *Introducing Device Drivers*. However,
    if the hardware is radically different to a reference design, you may need additional
    core support, which is outside the scope of this book.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将Linux移植到新的目标板可能非常简单，也可能非常困难，这取决于硬件与主线或供应商提供的内核有多大不同。如果您的硬件是基于一个众所周知的参考设计，那么可能只需要对设备树或平台数据进行更改。您可能需要添加设备驱动程序，这在[第8章](ch08.html
    "第8章。介绍设备驱动程序")中有讨论，*介绍设备驱动程序*。然而，如果硬件与参考设计有根本的不同，您可能需要额外的核心支持，这超出了本书的范围。
- en: The kernel is the core of a Linux based system, but it cannot work by itself.
    It requires a root filesystem that contains user space. The root filesystem can
    be a ramdisk or a filesystem accessed via a block device, which will be the subject
    of the next chapter. As we have seen, booting a kernel without a root filesystem
    results in a kernel panic.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是基于Linux的系统的核心，但它不能单独工作。它需要一个包含用户空间的根文件系统。根文件系统可以是一个ramdisk或通过块设备访问的文件系统，这将是下一章的主题。正如我们所看到的，没有根文件系统启动内核会导致内核恐慌。
