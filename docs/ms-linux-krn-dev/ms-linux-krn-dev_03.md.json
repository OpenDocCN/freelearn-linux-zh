["```\n#define _NSIG 64\n#define _NSIG_BPW __BITS_PER_LONG\n#define _NSIG_WORDS (_NSIG / _NSIG_BPW)\n\n#define SIGHUP 1\n#define SIGINT 2\n#define SIGQUIT 3\n#define SIGILL 4\n#define SIGTRAP 5\n#define SIGABRT 6\n#define SIGIOT 6\n#define SIGBUS 7\n#define SIGFPE 8\n#define SIGKILL 9\n#define SIGUSR1 10\n#define SIGSEGV 11\n#define SIGUSR2 12\n#define SIGPIPE 13\n#define SIGALRM 14\n#define SIGTERM 15\n#define SIGSTKFLT 16\n#define SIGCHLD 17\n#define SIGCONT 18\n#define SIGSTOP 19\n#define SIGTSTP 20\n#define SIGTTIN 21\n#define SIGTTOU 22\n#define SIGURG 23\n#define SIGXCPU 24\n#define SIGXFSZ 25\n#define SIGVTALRM 26\n#define SIGPROF 27\n#define SIGWINCH 28\n#define SIGIO 29\n#define SIGPOLL SIGIO\n/*\n#define SIGLOST 29\n*/\n#define SIGPWR 30\n#define SIGSYS 31\n#define SIGUNUSED 31\n\n/* These should not be considered constants from userland. */\n#define SIGRTMIN 32\n#ifndef SIGRTMAX\n#define SIGRTMAX _NSIG\n#endif\n```", "```\n +--------------------+------------------+\n * | POSIX signal     | default action |\n * +------------------+------------------+\n * | SIGHUP           | terminate \n * | SIGINT           | terminate \n * | SIGQUIT          | coredump \n * | SIGILL           | coredump \n * | SIGTRAP          | coredump \n * | SIGABRT/SIGIOT   | coredump \n * | SIGBUS           | coredump \n * | SIGFPE           | coredump \n * | SIGKILL          | terminate\n * | SIGUSR1          | terminate \n * | SIGSEGV          | coredump \n * | SIGUSR2          | terminate\n * | SIGPIPE          | terminate \n * | SIGALRM          | terminate \n * | SIGTERM          | terminate \n * | SIGCHLD          | ignore \n * | SIGCONT          | ignore \n * | SIGSTOP          | stop\n * | SIGTSTP          | stop\n * | SIGTTIN          | stop\n * | SIGTTOU          | stop\n * | SIGURG           | ignore \n * | SIGXCPU          | coredump \n * | SIGXFSZ          | coredump \n * | SIGVTALRM        | terminate \n * | SIGPROF          | terminate \n * | SIGPOLL/SIGIO    | terminate \n * | SIGSYS/SIGUNUSED | coredump \n * | SIGSTKFLT        | terminate \n * | SIGWINCH         | ignore \n * | SIGPWR           | terminate \n * | SIGRTMIN-SIGRTMAX| terminate \n * +------------------+------------------+\n * | non-POSIX signal | default action |\n * +------------------+------------------+\n * | SIGEMT           | coredump |\n * +--------------------+------------------+\n```", "```\n #include <signal.h>\n int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n\n The sigaction structure is defined as something like:\n\n struct sigaction {\n void (*sa_handler)(int);\n void (*sa_sigaction)(int, siginfo_t *, void *);\n sigset_t sa_mask;\n int sa_flags;\n void (*sa_restorer)(void);\n };\n```", "```\n      void handler_fn(int signo, siginfo_t *info, void *context);\n```", "```\n siginfo_t {\n int si_signo; /* Signal number */\n int si_errno; /* An errno value */\n int si_code; /* Signal code */\n int si_trapno; /* Trap number that caused hardware-generated signal (unused on most           architectures) */\n pid_t si_pid; /* Sending process ID */\n uid_t si_uid; /* Real user ID of sending process */\n int si_status; /* Exit value or signal */\n clock_t si_utime; /* User time consumed */\n clock_t si_stime; /* System time consumed */\n sigval_t si_value; /* Signal value */\n int si_int; /* POSIX.1b signal */\n void *si_ptr; /* POSIX.1b signal */\n int si_overrun; /* Timer overrun count; POSIX.1b timers */\n int si_timerid; /* Timer ID; POSIX.1b timers */\n void *si_addr; /* Memory location which caused fault */\n long si_band; /* Band event (was int in glibc 2.3.2 and earlier) */\n int si_fd; /* File descriptor */\n short si_addr_lsb; /* Least significant bit of address (since Linux 2.6.32) */\n void *si_call_addr; /* Address of system call instruction (since Linux 3.5) */\n int si_syscall; /* Number of attempted system call (since Linux 3.5) */\n unsigned int si_arch; /* Architecture of attempted system call (since Linux 3.5) */\n }\n```", "```\n    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); \n```", "```\n    int sigpending(sigset_t *set);\n```", "```\n int kill(pid_t pid, int sig);\n int sigqueue(pid_t pid, int sig, const union sigval value);\n\n union sigval {\n int sival_int;\n void *sival_ptr;\n };\n```", "```\n/* queue signal to specific thread in a thread group */\nint tgkill(int tgid, int tid, int sig);\n\n/* queue signal and data to a thread group */\nint rt_sigqueueinfo(pid_t tgid, int sig, siginfo_t *uinfo);\n\n/* queue signal and data to specific thread in a thread group */\nint rt_tgsigqueueinfo(pid_t tgid, pid_t tid, int sig, siginfo_t *uinfo);\n\n```", "```\nint sigsuspend(const sigset_t *mask);\nint sigwaitinfo(const sigset_t *set, siginfo_t *info);\nint sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);\n```", "```\n #include <sys/signalfd.h>\n int signalfd(int fd, const sigset_t *mask, int flags);\n```", "```\nstruct task_struct {\n\n....\n....\n....\n/* signal handlers */\n struct signal_struct *signal;\n struct sighand_struct *sighand;\n\n sigset_t blocked, real_blocked;\n sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */\n struct sigpending pending;\n\n unsigned long sas_ss_sp;\n size_t sas_ss_size;\n unsigned sas_ss_flags;\n  ....\n  ....\n  ....\n  ....\n\n};\n```", "```\nstruct signal_struct {\n atomic_t sigcnt;\n atomic_t live;\n int nr_threads;\n struct list_head thread_head;\n\n wait_queue_head_t wait_chldexit; /* for wait4() */\n\n /* current thread group signal load-balancing target: */\n struct task_struct *curr_target;\n\n /* shared signal handling: */\n struct sigpending shared_pending; \n /* thread group exit support */\n int group_exit_code;\n /* overloaded:\n * - notify group_exit_task when ->count is equal to notify_count\n * - everyone except group_exit_task is stopped during signal delivery\n * of fatal signals, group_exit_task processes the signal.\n */\n int notify_count;\n struct task_struct *group_exit_task;\n\n /* thread group stop support, overloads group_exit_code too */\n int group_stop_count;\n unsigned int flags; /* see SIGNAL_* flags below */\n\n```", "```\nstruct sigpending {\n struct list_head list; // head to double linked list of struct sigqueue\n sigset_t signal; // bit mask of pending signals\n};\n```", "```\nstruct k_sigaction {\n struct sigaction sa;\n#ifdef __ARCH_HAS_KA_RESTORER \n __sigrestore_t ka_restorer;\n#endif\n};\n\nstruct sighand_struct {\n atomic_t count;\n struct k_sigaction action[_NSIG];\n spinlock_t siglock;\n wait_queue_head_t signalfd_wqh;\n};\n\n```", "```\n static int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n int group)\n{\n int from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n from_ancestor_ns = si_fromuser(info) &&\n !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n return __send_signal(sig, info, t, group, from_ancestor_ns);\n}\n```", "```\n /*\n * fast-pathed signals for kernel-internal things like SIGSTOP\n * or SIGKILL.\n */\n if (info == SEND_SIG_FORCED)\n goto out_set;\n....\n....\n....\nout_set:\n signalfd_notify(t, sig);\n sigaddset(&pending->signal, sig);\n complete_signal(sig, t, group);\n\n```", "```\n q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n override_rlimit);\n```", "```\nif (q) {\n list_add_tail(&q->list, &pending->list);\n switch ((unsigned long) info) {\n case (unsigned long) SEND_SIG_NOINFO:\n       q->info.si_signo = sig;\n       q->info.si_errno = 0;\n       q->info.si_code = SI_USER;\n       q->info.si_pid = task_tgid_nr_ns(current,\n       task_active_pid_ns(t));\n       q->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n       break;\n case (unsigned long) SEND_SIG_PRIV:\n       q->info.si_signo = sig;\n       q->info.si_errno = 0;\n       q->info.si_code = SI_KERNEL;\n       q->info.si_pid = 0;\n       q->info.si_uid = 0;\n       break;\n default:\n      copy_siginfo(&q->info, info);\n      if (from_ancestor_ns)\n      q->info.si_pid = 0;\n      break;\n }\n\n```", "```\n sigaddset(&pending->signal, sig);\n complete_signal(sig, t, group);\n```", "```\n struct pt_regs {\n/*\n * C ABI says these regs are callee-preserved. They aren't saved on kernel entry\n * unless syscall needs a complete, fully filled \"struct pt_regs\".\n */\n unsigned long r15;\n unsigned long r14;\n unsigned long r13;\n unsigned long r12;\n unsigned long rbp;\n unsigned long rbx;\n/* These regs are callee-clobbered. Always saved on kernel entry. */\n unsigned long r11;\n unsigned long r10;\n unsigned long r9;\n unsigned long r8;\n unsigned long rax;\n unsigned long rcx;\n unsigned long rdx;\n unsigned long rsi;\n unsigned long rdi;\n/*\n * On syscall entry, this is syscall#. On CPU exception, this is error code.\n * On hw interrupt, it's IRQ number:\n */\n unsigned long orig_rax;\n/* Return frame for iretq */\n unsigned long rip;\n unsigned long cs;\n unsigned long eflags;\n unsigned long rsp;\n unsigned long ss;\n/* top of stack page */\n};\n```", "```\nvoid do_signal(struct pt_regs *regs)\n{\n struct ksignal ksig;\n if (get_signal(&ksig)) {\n /* Whee! Actually deliver the signal. */\n handle_signal(&ksig, regs);\n return;\n }\n /* Did we come from a system call? */\n if (syscall_get_nr(current, regs) >= 0) {\n /* Restart the system call - no handlers present */\n switch (syscall_get_error(current, regs)) {\n case -ERESTARTNOHAND:\n case -ERESTARTSYS:\n case -ERESTARTNOINTR:\n regs->ax = regs->orig_ax;\n regs->ip -= 2;\n break;\n case -ERESTART_RESTARTBLOCK:\n regs->ax = get_nr_restart_syscall(regs);\n regs->ip -= 2;\n break;\n }\n }\n /*\n * If there's no signal to deliver, we just put the saved sigmask\n * back.\n */\n restore_saved_sigmask();\n}\n```", "```\n signr = dequeue_signal(current, &current->blocked, &ksig->info);\n```", "```\nka = &sighand->action[signr-1]; \n```", "```\nif (ka->sa.sa_handler == SIG_IGN) /* Do nothing. */\n continue;\n```", "```\n  if (ka->sa.sa_handler != SIG_DFL) {\n /* Run the handler. */\n ksig->ka = *ka;\n\n if (ka->sa.sa_flags & SA_ONESHOT)\n ka->sa.sa_handler = SIG_DFL;\n\n break; /* will return non-zero \"signr\" value */\n }\n```", "```\nget_signal() that initiates the default action as per the set disposition:\n```", "```\n/*\n * Now we are doing the default action for this signal.\n */\n if (sig_kernel_ignore(signr)) /* Default is nothing. */\n continue;\n\n /*\n * Global init gets no signals it doesn't want.\n * Container-init gets no signals it doesn't want from same\n * container.\n *\n * Note that if global/container-init sees a sig_kernel_only()\n * signal here, the signal must have been generated internally\n * or must have come from an ancestor namespace. In either\n * case, the signal cannot be dropped.\n */\n if (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n !sig_kernel_only(signr))\n continue;\n\n if (sig_kernel_stop(signr)) {\n /*\n * The default action is to stop all threads in\n * the thread group. The job control signals\n * do nothing in an orphaned pgrp, but SIGSTOP\n * always works. Note that siglock needs to be\n * dropped during the call to is_orphaned_pgrp()\n * because of lock ordering with tasklist_lock.\n * This allows an intervening SIGCONT to be posted.\n * We need to check for that and bail out if necessary.\n */\n if (signr != SIGSTOP) {\n spin_unlock_irq(&sighand->siglock);\n\n /* signals can be posted during this window */\n\n if (is_current_pgrp_orphaned())\n goto relock;\n\n spin_lock_irq(&sighand->siglock);\n }\n\n if (likely(do_signal_stop(ksig->info.si_signo))) {\n /* It released the siglock. */\n goto relock;\n }\n\n /*\n * We didn't actually stop, due to a race\n * with SIGCONT or something like that.\n */\n continue;\n }\n\n spin_unlock_irq(&sighand->siglock);\n\n /*\n * Anything else is fatal, maybe with a core dump.\n */\n current->flags |= PF_SIGNALED;\n\n if (sig_kernel_coredump(signr)) {\n if (print_fatal_signals)\n print_fatal_signal(ksig->info.si_signo);\n proc_coredump_connector(current);\n /*\n * If it was able to dump core, this kills all\n * other threads in the group and synchronizes with\n * their demise. If we lost the race with another\n * thread getting here, it set group_exit_code\n * first and our do_group_exit call below will use\n * that value and ignore the one we pass it.\n */\n do_coredump(&ksig->info);\n }\n\n /*\n * Death signals, no core dump.\n */\n do_group_exit(ksig->info.si_signo);\n /* NOTREACHED */\n }\n```", "```\nsetup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\n{\n int usig = ksig->sig;\n sigset_t *set = sigmask_to_save();\n compat_sigset_t *cset = (compat_sigset_t *) set;\n\n /* Set up the stack frame */\n if (is_ia32_frame(ksig)) {\n if (ksig->ka.sa.sa_flags & SA_SIGINFO)\n return ia32_setup_rt_frame(usig, ksig, cset, regs); // for 32bit systems with SA_SIGINFO\n else\n return ia32_setup_frame(usig, ksig, cset, regs); // for 32bit systems without SA_SIGINFO\n } else if (is_x32_frame(ksig)) {\n return x32_setup_rt_frame(ksig, cset, regs);// for systems with x32 ABI\n } else {\n return __setup_rt_frame(ksig->sig, ksig, set, regs);// Other variants of x86\n }\n}\n```", "```\n/*arch/x86/include/asm/sigframe.h */\n#ifdef CONFIG_X86_64\n\nstruct rt_sigframe {\n char __user *pretcode;\n struct ucontext uc;\n struct siginfo info;\n /* fp state follows here */\n};\n\n-----------------------  \n\n/*arch/x86/kernel/signal.c */\nstatic int __setup_rt_frame(int sig, struct ksignal *ksig,\n sigset_t *set, struct pt_regs *regs)\n{\n struct rt_sigframe __user *frame;\n void __user *restorer;\n int err = 0;\n void __user *fpstate = NULL;\n\n /* setup frame with Floating Point state */\n frame = get_sigframe(&ksig->ka, regs, sizeof(*frame), &fpstate);\n\n if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n return -EFAULT;\n\n put_user_try {\n put_user_ex(sig, &frame->sig);\n put_user_ex(&frame->info, &frame->pinfo);\n put_user_ex(&frame->uc, &frame->puc);\n\n /* Create the ucontext. */\n if (boot_cpu_has(X86_FEATURE_XSAVE))\n put_user_ex(UC_FP_XSTATE, &frame->uc.uc_flags);\n else \n put_user_ex(0, &frame->uc.uc_flags);\n put_user_ex(0, &frame->uc.uc_link);\n save_altstack_ex(&frame->uc.uc_stack, regs->sp);\n\n /* Set up to return from userspace. */\n restorer = current->mm->context.vdso +\n vdso_image_32.sym___kernel_rt_sigreturn;\n if (ksig->ka.sa.sa_flags & SA_RESTORER)\n restorer = ksig->ka.sa.sa_restorer;\n put_user_ex(restorer, &frame->pretcode);\n\n /*\n * This is movl $__NR_rt_sigreturn, %ax ; int $0x80\n *\n * WE DO NOT USE IT ANY MORE! It's only left here for historical\n * reasons and because gdb uses it as a signature to notice\n * signal handler stack frames.\n */\n put_user_ex(*((u64 *)&rt_retcode), (u64 *)frame->retcode);\n } put_user_catch(err);\n\n err |= copy_siginfo_to_user(&frame->info, &ksig->info);\n err |= setup_sigcontext(&frame->uc.uc_mcontext, fpstate,\n regs, set->sig[0]);\n err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n if (err)\n return -EFAULT;\n\n /* Set up registers for signal handler */\n regs->sp = (unsigned long)frame;\n regs->ip = (unsigned long)ksig->ka.sa.sa_handler;\n regs->ax = (unsigned long)sig;\n regs->dx = (unsigned long)&frame->info;\n regs->cx = (unsigned long)&frame->uc;\n\n regs->ds = __USER_DS;\n regs->es = __USER_DS;\n regs->ss = __USER_DS;\n regs->cs = __USER_CS;\n\n return 0;\n}\n```", "```\n(include/uapi/asm-generic/errno-base.h)\n #define EPERM 1 /* Operation not permitted */\n #define ENOENT 2 /* No such file or directory */\n #define ESRCH 3 /* No such process */\n #define EINTR 4 /* Interrupted system call */\n #define EIO 5 /* I/O error */\n #define ENXIO 6 /* No such device or address */\n #define E2BIG 7 /* Argument list too long */\n #define ENOEXEC 8 /* Exec format error */\n #define EBADF 9 /* Bad file number */\n #define ECHILD 10 /* No child processes */\n #define EAGAIN 11 /* Try again */\n #define ENOMEM 12 /* Out of memory */\n #define EACCES 13 /* Permission denied */\n #define EFAULT 14 /* Bad address */\n #define ENOTBLK 15 /* Block device required */\n #define EBUSY 16 /* Device or resource busy */\n #define EEXIST 17 /* File exists */\n #define EXDEV 18 /* Cross-device link */\n #define ENODEV 19 /* No such device */\n #define ENOTDIR 20 /* Not a directory */\n #define EISDIR 21 /* Is a directory */\n #define EINVAL 22 /* Invalid argument */\n #define ENFILE 23 /* File table overflow */\n #define EMFILE 24 /* Too many open files */\n #define ENOTTY 25 /* Not a typewriter */\n #define ETXTBSY 26 /* Text file busy */\n #define EFBIG 27 /* File too large */\n #define ENOSPC 28 /* No space left on device */\n #define ESPIPE 29 /* Illegal seek */\n #define EROFS 30 /* Read-only file system */\n #define EMLINK 31 /* Too many links */\n #define EPIPE 32 /* Broken pipe */\n #define EDOM 33 /* Math argument out of domain of func */\n #define ERANGE 34 /* Math result not representable */\n linux/errno.h)\n #define ERESTARTSYS 512\n #define ERESTARTNOINTR 513\n #define ERESTARTNOHAND 514 /* restart if no handler.. */\n #define ENOIOCTLCMD 515 /* No ioctl command */\n #define ERESTART_RESTARTBLOCK 516 /* restart by calling sys_restart_syscall */\n #define EPROBE_DEFER 517 /* Driver requests probe retry */\n #define EOPENSTALE 518 /* open found a stale dentry */\n```"]