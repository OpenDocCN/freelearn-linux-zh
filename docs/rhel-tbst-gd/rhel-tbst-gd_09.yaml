- en: Chapter 9. Using System Tools to Troubleshoot Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 使用系统工具来排除应用程序问题
- en: In the previous chapter, we covered troubleshooting hardware issues. Specifically,
    you learned what to do when hard disks have been removed from a RAID and cannot
    be read.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了故障排除硬件问题。具体来说，您学会了当硬盘从RAID中移除并且无法读取时该怎么做。
- en: In this chapter, we will get back to troubleshooting applications, but unlike
    earlier examples, we will not be troubleshooting a popular open source application
    such as WordPress. In this chapter, we will focus on a custom application that
    will be much more difficult to troubleshoot than a well-known one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到排除应用程序问题，但与之前的例子不同，我们将不再排除像WordPress这样的流行开源应用程序。在本章中，我们将专注于一个自定义应用程序，这将比一个知名应用程序更难排除故障。
- en: Open source versus home-grown applications
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源与自制应用程序
- en: Popular open source projects often have an online community or bug/issue tracker.
    As we experienced in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    these can be useful resources for troubleshooting application issues. Often, the
    issue has already been reported or asked about in these communities, with the
    majority of these posts also containing a solution for the issue.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的开源项目通常有在线社区或错误/问题跟踪器。正如我们在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "第3章 故障排除Web应用程序")中所经历的，*故障排除Web应用程序*，这些资源对于排除应用程序问题非常有用。通常，问题已经在这些社区中报告或询问过，其中大多数帖子也包含了问题的解决方案。
- en: These solutions are posted on the Internet in open forums; any errors from the
    application can also simply be searched for on Google. Most of the time, the search
    will show multiple possible answers. It is a pretty rare occurrence when an error
    from a popular open source application produces zero search results on Google.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案被发布在互联网上的开放论坛上；应用程序的任何错误也可以直接在谷歌上搜索。大多数情况下，搜索结果会显示多个可能的答案。当一个流行的开源应用程序的错误在谷歌上产生零搜索结果时，这是一个非常罕见的情况。
- en: With custom applications, however, application errors might not always be resolved
    with a quick Google search. Sometimes, an application provides a generic error
    such as **Permission Denied** or **File not found**. On other occasions, however,
    they produce no error or application-specific errors such as the issue we will
    be working with today.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于自定义应用程序，应用程序错误可能并不总是可以通过快速的谷歌搜索来解决。有时，应用程序会提供通用错误，比如**权限被拒绝**或**文件未找到**。然而，有时候它们不会产生错误，或者产生特定于应用程序的错误，比如我们今天将要处理的问题。
- en: When faced with nondescriptive errors in open source tools, you can always ask
    for help on an online site of some sort. With custom applications, however, you
    might not always have the option of asking a developer what the error means.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 面对开源工具中不明确的错误时，您总是可以在某个在线网站上寻求帮助。然而，对于自定义应用程序，您可能并不总是有机会询问开发人员错误的含义。
- en: Sometimes, it is up to the systems administrator to fix the application with
    little to no help from the developer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，系统管理员需要在开发人员几乎没有帮助的情况下修复应用程序。
- en: When those situations occur, there are a myriad of tools at the administrator's
    disposal. In today's chapter, we will be exploring some of these tools while,
    of course, troubleshooting a custom application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现这种情况时，管理员手头有很多工具可供使用。在今天的章节中，我们将探索其中一些工具，当然，也会排除自定义应用程序的故障。
- en: When the application won't start
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当应用程序无法启动时
- en: For this chapter's problem, we will start as we have with most other problems,
    except today, rather than receiving an alert or phone call, we are actually asked
    a question by another systems administrator.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的问题，我们将像处理大多数其他问题一样开始，但今天，我们不是收到警报或电话，而是被另一位系统管理员问了一个问题。
- en: The systems administrator is attempting to start an application on the blog
    web server. When they attempt to start the application, it appears to be starting;
    however, at the end, it simply prints an error message and exits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员正在尝试在博客Web服务器上启动一个应用程序。当他们尝试启动应用程序时，它似乎正在启动；然而，在最后，它只是打印出一个错误消息并退出。
- en: Our first response to this scenario is of course the first step in the troubleshooting
    process—duplicate it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们的第一个反应当然是故障排除过程中的第一步——复制它。
- en: 'The other systems administrator informs us that they are starting the application
    by performing the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位系统管理员告诉我们，他们通过执行以下步骤来启动应用程序：
- en: Logging into the server as the `vagrant` user
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`vagrant`用户登录服务器
- en: Moving to the directory `/opt/myapp`
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到目录`/opt/myapp`
- en: Running the script `start.sh`
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本`start.sh`
- en: 'Before going any further, let''s attempt those same steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步进行之前，让我们尝试同样的步骤：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding steps, we follow the same steps as the previous administrator
    and get the same results. The application appears to have failed to start.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们按照之前的管理员的步骤进行，并得到了相同的结果。应用程序似乎未能启动。
- en: In the preceding example, the `whoami` command was used to show that we were
    logged in as the `vagrant` user. This command is very handy when dealing with
    applications as it can be used to ensure the proper system user is performing
    the start process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用`whoami`命令显示我们以`vagrant`用户登录。在处理应用程序时，这个命令非常方便，因为它可以用来确保正确的系统用户执行启动过程。
- en: 'We can see from the preceding startup attempt that the application failed to
    start with the following message:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的启动尝试中看到，应用程序未能启动，并显示以下消息：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, we need to know why it failed to start and whether the process truly
    failed
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要知道为什么它无法启动，以及进程是否真的失败了
- en: 'To answer the question on whether the process truly failed or not is actually
    quite simple. To do this, we can simply check the exit code of the application,
    which is done by printing the `$?` variable after executing the `start.sh` script,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回答关于进程是否真正失败的问题实际上非常简单。为了做到这一点，我们可以简单地检查应用程序的退出代码，方法是在执行`start.sh`脚本后打印`$?`变量，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Exit codes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出代码
- en: On Linux and Unix systems, programs have the ability to pass a value to their
    parent process while they terminate. This value is called an **exit code**. Programs
    that are terminating or "exiting" use exit codes to tell the process that invoked
    it whether that program was successful or unsuccessful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Unix系统上，程序在终止时有能力向其父进程传递一个值。这个值被称为**退出代码**。正在终止或“退出”的程序使用退出代码来告诉调用它的进程该程序是成功还是失败。
- en: For POSIX systems (such as Red Hat Enterprise Linux), the standard convention
    is for programs to exit with a 0 status code for success and a non-zero status
    code for failure. Since our preceding example exited with a status code of 1,
    this means the application exited with a failure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于POSIX系统（如Red Hat Enterprise Linux），标准约定是程序成功退出时以0状态代码退出，失败时以非零状态代码退出。由于我们前面的示例以状态代码1退出，这意味着应用程序以失败退出。
- en: 'To understand exit codes a little better, let''s write a quick little script
    that performs a successful task:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解退出代码，让我们编写一个快速的脚本来执行一个成功的任务：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This quick little shell script performs one task, it runs the `touch` command
    on the file `/var/tmp/file.txt`. If that file exists, the touch command simply
    updates the access time on that file. If the file does not exist, the touch command
    will create it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速的小shell脚本执行一个任务，它在文件`/var/tmp/file.txt`上运行`touch`命令。如果该文件存在，touch命令只会更新该文件的访问时间。如果文件不存在，touch命令将创建它。
- en: 'Since `/var/tmp` is a temporary directory with open permissions, this script,
    when executed as the vagrant user, should be successful:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`/var/tmp`是一个具有开放权限的临时目录，这个脚本在vagrant用户执行时应该是成功的：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After executing the command, we can see the exit code by using the BASH special
    variable `$?`. This variable is a special variable in the BASH shell that can
    only be used to read the exit code of the last program executed. This variable
    is one of a few special variables in the BASH shell that can only be read and
    never written.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，我们可以通过使用BASH特殊变量`$?`来查看退出代码。这个变量是BASH shell中的一个特殊变量，只能用于读取上一个程序的退出代码。这个变量是BASH
    shell中的几个特殊变量之一，只能读取，不能写入。
- en: 'To see the exit status of our script, we can `echo` the value of `$?` to our
    screen:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们脚本的退出状态，我们可以将`$?`的值`echo`到屏幕上：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It looks like this script returned a `0` exit status. This means the script
    executed successfully and most likely updated or created the file `/var/tmp/file.txt`.
    We can validate that the file was updated by performing an `ls -la` on the file
    itself:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个脚本返回了`0`退出状态。这意味着脚本成功执行，很可能更新或创建了文件`/var/tmp/file.txt`。我们可以通过对文件本身执行`ls
    -la`来验证文件是否已更新：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the output of the `ls` command, it appears the file was updated or created
    recently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ls`命令的输出中，看起来文件最近已更新或创建。
- en: 'The preceding example shows what happens when a script is successful, but what
    about when the script is unsuccessful? With a modified version of the preceding
    script, we can easily see what happens when a script fails:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了脚本成功时会发生什么，但是当脚本失败时会发生什么呢？通过前面脚本的修改版本，我们可以很容易地看到脚本失败时会发生什么：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The modified version will attempt to create a file in a directory that does
    not exist. That script will then fail and exit with an exit code that indicates
    failure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的版本将尝试在不存在的目录中创建文件。该脚本将因此失败并以指示失败的退出代码退出：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see from the output of the script that the `touch` command failed, but
    what about the exit code?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本的输出中，我们可以看到`touch`命令失败了，但是退出代码呢？
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The exit code also shows that the script has failed. The standard for exit
    codes is `0` for a success and anything non-zero is a failure. In general, you
    will see either a `0` or `1` exit code. Some applications, however, will use other
    exit codes to indicate specific failures:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 退出代码还显示了脚本失败了。退出代码的标准是成功为`0`，任何非零值都表示失败。一般来说，你会看到`0`或`1`的退出代码。然而，一些应用程序会使用其他退出代码来指示特定的失败：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, if we were to execute a command that does not exist from the BASH
    shell, the exit code provided will be `127`. This exit code is a convention used
    to indicate that the command was not found. The following is a list of exit codes
    that are used for specific purposes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们从BASH shell执行一个不存在的命令，提供的退出代码将是`127`。这个退出代码是一个用来指示命令未找到的约定。以下是用于特定目的的退出代码列表：
- en: '`0`: Success'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：成功'
- en: '`1`: General failure has occurred'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：发生了一般性失败'
- en: '`2`: Misuse of shell built-ins'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：对shell内置的误用'
- en: '`126`: Command invoked could not be executed'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`126`：无法执行调用的命令'
- en: '`127`: Command not found'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127`：命令未找到'
- en: '`128`: Invalid argument passed to the `exit` command'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128`：传递给`exit`命令的无效参数'
- en: '`130`: Command stopped with *Ctrl* + *C* keys'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`130`：使用*Ctrl* + *C*键停止命令'
- en: '`255`: Exit code provided is out of the `0 - 255` range'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255`：提供的退出代码超出了`0 - 255`范围'
- en: This list is a good general guide for exit codes. However, since each application
    can provide its own exit codes you might find that a command or application provides
    an exit code that is not within the preceding list. For open source applications,
    you can generally look up what the exit code means. For custom applications, however,
    you may or may not have the ability to look up what the exit codes means.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是退出代码的一个很好的通用指南。然而，由于每个应用程序都可以提供自己的退出代码，你可能会发现一个命令或应用程序提供的退出代码不在上述列表中。对于开源应用程序，你通常可以查找退出代码的含义。然而，对于自定义应用程序，你可能有也可能没有查找退出代码含义的能力。
- en: Is the script failing, or the application?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本失败了，还是应用程序失败了？
- en: One interesting thing about shell scripts and exit codes is that when a shell
    script is executed, the exit code for that script will be the exit code of the
    last command executed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于shell脚本和退出码的一个有趣的事情是，当执行shell脚本时，该脚本的退出码将是最后一个执行的命令的退出码。
- en: 'To put this in perspective, we can modify our test script again:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们可以再次修改我们的测试脚本：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command should produce an interesting result. The `touch` command
    will fail; however, the echo command will be successful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该产生一个有趣的结果。`touch`命令将失败；然而，echo命令将成功。
- en: 'What this means is that when executed, even though the `touch` command fails,
    the `echo` command is successful so the exit code from the command line should
    show the script as successful:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当执行时，即使`touch`命令失败，`echo`命令也成功，因此命令行的退出码应该显示脚本成功：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command is an example of a script that does not handle errors
    gracefully. If we were to rely on this script to provide us with the correct status
    of the execution solely by the exit code, we would have incorrect results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令是一个不优雅处理错误的脚本的例子。如果我们依赖这个脚本仅通过退出码来提供正确的执行状态，我们将得到错误的结果。
- en: It is always good for a systems administrator to be a bit skeptical of unknown
    scripts. I have found many occasions (and written a few myself) where scripts
    have no error checking. For this reason, one of the first steps we should perform
    with our issue is to validate that the exit code of 1 is actually coming from
    the application being launched.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于系统管理员来说，对于未知脚本持有一些怀疑态度总是好的。我发现许多情况（并且自己写了一些）脚本没有错误检查。因此，我们应该执行的第一步是验证退出码1是否确实来自正在启动的应用程序。
- en: 'To do this, we will need to read the start script:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要阅读启动脚本：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From the look of things, the start script is very basic. It looks like the script
    simply sets the `$HOMEDIR` variable to `/opt/myapp` and then runs the application
    by running the command `$HOMEDIR/bin/application`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，启动脚本非常基础。看起来脚本只是将`$HOMEDIR`变量设置为`/opt/myapp`，然后通过运行命令`$HOMEDIR/bin/application`来运行应用程序。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After the value of `$HOMEDIR` is set to `/opt/myapp`, you can assume that any
    future reference to `$HOMEDIR` is actually the value `/opt/myapp`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`$HOMEDIR`的值设置为`/opt/myapp`之后，您可以假设将来对`$HOMEDIR`的任何引用实际上是值`/opt/myapp`。
- en: From the preceding script, we can see that the last command executed is the
    application, meaning the exit code we received was from the application and not
    another command. This proves that we are receiving the true exit status of this
    application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的脚本中，我们可以看到最后执行的命令是应用程序，这意味着我们收到的退出码来自应用程序而不是其他命令。这证明我们收到了这个应用程序的真实退出状态。
- en: 'The start script does provide us with a bit more information than just which
    command provides the exit code. If we take a look at the application''s command
    line parameters, we can understand even more about this application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本确实为我们提供了比仅提供退出码的命令更多的信息。如果我们看一下应用程序的命令行参数，我们可以更多地了解这个应用程序：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the command that actually starts the application within the `start.sh`
    script. The script is running the command `/opt/myapp/bin/application` with the
    arguments `--daemon` and `--config /opt/myapp/conf/config.yml`. While we might
    not know much about this application, we can make some assumptions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际在`start.sh`脚本中启动应用程序的命令。该脚本正在使用参数`--daemon`和`--config /opt/myapp/conf/config.yml`运行命令`/opt/myapp/bin/application`。虽然我们可能对这个应用程序了解不多，但我们可以做一些假设。
- en: One assumption we can make is that the `--daemon` flag causes this application
    to daemonize itself. On Unix and Linux systems, a process that runs continuously
    as a background process is referred to as a daemon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设`--daemon`标志导致这个应用程序使自己成为守护进程。在Unix和Linux系统上，作为后台进程持续运行的进程被称为守护进程。
- en: Typically, a daemon process is a service that doesn't require user input. A
    few easily recognizable examples of daemons are Apache or MySQL. These processes
    run in the background and perform a service rather than running in a user's desktop
    or shell.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，守护进程是一个不需要用户输入的服务。一些容易识别的守护进程的例子是Apache或MySQL。这些进程在后台运行并提供服务，而不是在用户的桌面或shell中运行。
- en: With the preceding flag, we can safely assume that this process is designed
    to run in the background once it is started successfully.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的标志，我们可以安全地假设一旦成功启动，这个进程就被设计为在后台运行。
- en: Another assumption we can make based on the command line parameters is that
    the file `/opt/myapp/conf/config.yml` is used as a configuration file for the
    application. This seems pretty straightforward considering the flag is named `--config`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于命令行参数，我们可以做出另一个假设，即文件`/opt/myapp/conf/config.yml`被用作应用程序的配置文件。考虑到标志被命名为`--config`，这似乎很简单明了。
- en: The preceding assumptions are pretty easy to recognize because the flags use
    the long format `--option`. However, not all applications or services use the
    long format for command line flags. Often, these are single character flags.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的假设很容易识别，因为标志使用长格式`--option`。然而，并非所有应用程序或服务都使用命令行标志的长格式。通常，这些是单字符标志。
- en: 'While every application has its own command line flags and might differ from
    application to application, common flags such as `--config` and `--deamon` are
    often shortened to `-c` and `-d` or `-D`. If our application was provided with
    single character flags, it would have looked more like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个应用程序都有自己的命令行标志，并且可能因应用程序而异，但常见的标志，如`--config`和`--deamon`通常被缩写为`-c`和`-d`或`-D`。如果我们的应用程序提供了单字符标志，它看起来会更像下面的样子：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even with the shortened options, we can safely identify that `-c` specifies
    a configuration file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了缩短的选项，我们仍然可以安全地确定`-c`指定了一个配置文件。
- en: A wealth of information in the configuration file
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件中包含大量信息
- en: 'We know that this application is using the configuration file `/opt/myapp/conf/config.yml`.
    If we read this file, we might find information about the application and what
    task it is trying to perform:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个应用程序正在使用配置文件`/opt/myapp/conf/config.yml`。如果我们读取这个文件，我们可能会找到关于应用程序以及它正在尝试执行的任务的信息：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The configuration file for this application is quite short, but there is quite
    a bit of useful information within it. The first configuration item is interesting,
    as it seems to specify port `25` as a port for the application to use. Without
    knowing exactly what this application does, this information is not immediately
    useful but might be useful to us later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的配置文件非常简短，但其中包含了相当多有用的信息。第一个配置项很有趣，因为它似乎指定端口`25`作为应用程序使用的端口。不知道这个应用程序具体做什么，这个信息并不立即有用，但以后可能对我们有用。
- en: The second item seems to suggest the application is in a debug mode. Often applications
    or services might have a `debug` mode, which causes them to log or output debugging
    information for troubleshooting. In our case, it seems the debug option is enabled,
    as the value of this item is `True`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项似乎表明应用程序处于调试模式。通常应用程序或服务可能有一个`debug`模式，导致它们记录或输出调试信息以进行故障排除。在我们的情况下，似乎调试选项已启用，因为这个项目的值是`True`。
- en: The third and final item is what appears to be a directory path for logs. Log
    files are always useful for troubleshooting applications. Often, you are able
    to find information about the application issue within log files. This is especially
    true if the application is in a `debug` state, which appears to be the case for
    our application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项和最后一项是一个看起来是日志的目录路径。日志文件对于故障排除应用程序总是有用的。通常情况下，您可以在日志文件中找到有关应用程序问题的信息。如果应用程序处于`debug`状态，这对我们的应用程序似乎是正确的情况。
- en: 'Since our application seems to be in the `debug` mode and we know the location
    of the log directory. We can check that log directory for any log files that might
    have been created during the application''s start process:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用似乎处于`debug`模式，并且我们知道日志目录的位置。我们可以检查日志目录是否有在应用启动过程中创建的日志文件：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run an `ls -la` in the log directory, we can see a `debug.out` file.
    Based on the name, this file is most likely the debug output from the application
    but not necessarily the application''s primary log file. This file, however, might
    be even more useful than a standard log as it might contain the reason the application
    startup is failing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在日志目录中运行`ls -la`，我们可以看到一个`debug.out`文件。根据名称，这个文件很可能是应用程序的调试输出，但不一定是应用程序的主要日志文件。然而，这个文件可能比标准日志文件更有用，因为它可能包含应用程序启动失败的原因：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Based on the contents of this file it appears that this file contains logs from
    multiple executions of this application. We can see this based on a repeated pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个文件的内容，似乎这个文件包含了多次执行该应用程序的日志。我们可以根据重复的模式看到这一点。
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This seems to be the first item printed each time the application starts. We
    can see these lines a total of four times; most likely, this means this application
    has been started at least four times in the past.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是每次应用程序启动时打印的第一项。我们总共可以看到这些行四次；很可能，这意味着这个应用程序过去至少启动了四次。
- en: 'Within this file, we can see an important log message:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们可以看到一个重要的日志消息：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It seems that the second time this application was started the application startup
    was successful. However, each time it was started afterwards the application failed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，这个应用程序第二次启动时应用程序启动成功。然而，之后每次启动都失败。
- en: Watching log files during startup
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动过程中观看日志文件
- en: Since the debug file's contents do not include timestamps, it is somewhat difficult
    to know whether the debug output from this file was written when we started the
    application or during a previous startup.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调试文件的内容不包括时间戳，很难知道调试输出是否是在我们启动应用程序时编写的，还是在以前的启动过程中编写的。
- en: 'Since we don''t know which lines were written during our last attempt as compared
    to other attempts, we will need to try and identify how many log entries are written
    each time the application is started. To do this, we can use the `tail` command
    with the `-f` or `--follow` flag:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道哪些行是在我们上次尝试时写入的，而不是其他尝试，我们需要尝试确定每次启动应用程序时写入了多少日志条目。为此，我们可以使用`tail`命令与`-f`或`--follow`标志：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When first starting the `tail` command with the `-f` (follow) flag, the last
    10 lines of the file are printed. This is also the default behavior of tail if
    it is run with no flags.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次使用`-f`（跟踪）标志启动`tail`命令时，将打印文件的最后10行。如果没有使用任何标志运行，这也是`tail`的默认行为。
- en: However, the `-f` flag doesn't simply stop at the last 10 lines. When run with
    the `-f` flag, `tail` will continuously monitor the specified file for new data.
    Once `tail` sees new data written to the specified file, the data will then be
    written to the output of `tail`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`-f`标志并不仅仅停留在最后10行。当使用`-f`标志运行时，`tail`将持续监视指定文件的新数据。一旦`tail`看到指定文件写入新数据，数据将被写入`tail`的输出。
- en: 'By running tail `-f` against the `debug.out` file, we will be able to identify
    any new debug logs being written by the application. If we once again execute
    the `start.sh` script we should see any possible debug data being printed by the
    application during startup:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`debug.out`文件运行`tail -f`，我们将能够识别应用程序写入的任何新的调试日志。如果我们再次执行`start.sh`脚本，我们应该看到应用程序在启动过程中打印的任何可能的调试数据：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `start.sh` script''s output is the same as last time, which is not much
    of a surprise at this point. However, now that we are watching the `debug.out`
    file, we might find something useful:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`start.sh`脚本的输出与上次相同，这在这一点上并不奇怪。然而，现在我们正在观看`debug.out`文件，我们可能会找到一些有用的东西：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From the `tail` command, we can see that the preceding three lines were printed
    during the execution of `start.sh`. While this in itself does not explain why
    the application is unable to start, it does tell us something interesting:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从“tail”命令中，我们可以看到前面三行是在执行“start.sh”时打印的。虽然这本身并不能解释为什么应用程序无法启动，但它确实告诉了我们一些有趣的东西：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Given that when the application fails to start, "`Failed`" messages from the
    preceding command are printed, and we can see that the last three times the `start.sh`
    script was executed, it failed. However, the instance before that was successful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到当应用程序无法启动时，“失败”消息会从之前的命令中打印出来，我们可以看到“start.sh”脚本执行的最后三次都失败了。然而，在那之前的实例是成功的。
- en: So far, I executed the start script twice and the other admin executed the script
    once. This would account for the three failures we see at the end of the `debug.out`
    file. The interesting thing about this is that the instance before those the application
    successfully started.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我执行了启动脚本两次，另一位管理员执行了一次。这可以解释我们在“debug.out”文件末尾看到的三次失败。有趣的是，在这些失败之前，应用程序成功启动了。
- en: This is interesting because it indicates a strong possibility that a previous
    instance of the application might be running.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为它表明应用程序的先前实例可能正在运行。
- en: Checking whether the application is already running
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查应用程序是否已经在运行
- en: One very common cause for this type of problem is simply that the application
    is already running. Some applications should only be started once, and the application
    itself will check whether another instance is running before completing a startup.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题的一个非常常见的原因是应用程序已经在运行。有些应用程序应该只启动一次，在完成启动之前，应用程序本身会检查是否有另一个实例正在运行。
- en: In general, if this scenario were the case, we would expect the application
    to print an error to the screen or the `debug.out` file. However, not every application
    has appropriate error handling or messaging. This is especially true for custom
    applications, and it seems to be true for the application we are working with
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果是这种情况，我们期望应用程序会在屏幕上或“debug.out”文件中打印错误。然而，并非每个应用程序都有适当的错误处理或消息传递。这对于定制应用程序尤其如此，似乎也适用于我们正在处理的应用程序。
- en: At the moment, we are making the assumption that our issue is caused by another
    instance of the application. This is an educated guess based on debug messages
    and previous experience. While we do not have any hard facts (yet) that tell us
    whether another instance is running or not; this scenario is quite common.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们假设我们的问题是由应用程序的另一个实例引起的。这是基于调试消息和以往经验的一个有根据的猜测。虽然我们还没有任何确凿的事实告诉我们是否有另一个实例正在运行，但这种情况是相当常见的。
- en: This situation is a perfect example of an **Educated Guesser** using previous
    experience to build a hypothesis of a root cause. Of course, after forming a hypothesis,
    our next step is to validate whether or not it is correct. Even if our hypothesis
    turns out to be incorrect we at least can eliminate a potential cause of our problem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是一个**有经验的猜测者**利用以往的经验来建立根本原因的假设的完美例子。当然，在形成假设之后，我们的下一步是验证它是否正确。即使我们的假设最终被证明是错误的，我们至少可以排除我们问题的一个潜在原因。
- en: 'Since our current hypothesis is that we might already have an instance of the
    application running, we can validate it by executing the ps command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前的假设是我们可能已经有一个应用程序的实例在运行，我们可以通过执行ps命令来验证它：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From this, it appears that our hypothesis might be incorrect. However, the preceding
    command simply performs a process list and searches that output for any instance
    of the word application. While this command might be enough, some applications
    during startup (especially ones that daemonize) will launch another process that
    might not match the string "`application`".
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，我们的假设可能是不正确的。然而，之前的命令只是执行进程列表，并在输出中搜索任何包含单词“应用程序”的实例。虽然这个命令可能足够了，但是一些应用程序在启动过程中（特别是那些变成守护进程的应用程序）会启动另一个进程，这个进程可能不匹配字符串“应用程序”。
- en: 'Since we have been starting the application as the "`vagrant`" user it seems
    likely that even if the application daemonized, the processes would be running
    as the vagrant user. Using the same command we can also search the process list
    for processes running as the `vagrant` user:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直以“vagrant”用户启动应用程序，即使应用程序变成守护进程，进程也会以vagrant用户的身份运行。使用相同的命令，我们还可以搜索以“vagrant”用户身份运行的进程列表：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command gave us quite a bit more output, but unfortunately none of these
    processes are the application we are looking for.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令给了我们更多的输出，但不幸的是，这些进程中没有一个是我们正在寻找的应用程序。
- en: Checking open files
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查打开的文件
- en: The preceding process list commands did not provide any results that would indicate
    that an instance of our application is running. However, before assuming that
    it is in fact not running we should perform one final check.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的进程列表命令没有提供任何结果，表明我们的应用程序的实例正在运行。然而，在假设它实际上没有运行之前，我们应该进行最后一次检查。
- en: Since we know that the application we are working with appears to be installed
    into `/opt/myapp` and we can see both configuration files and logs within that
    directory.It is pretty safe to assume that the application in question might open
    one or more of the files located within `/opt/myapp`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们正在处理的应用程序似乎安装在“/opt/myapp”中，我们可以在该目录中看到配置文件和日志。可以很肯定地假设所讨论的应用程序可能会打开“/opt/myapp”目录中的一个或多个文件。
- en: One very useful command is the **lsof** command. With this command, we can list
    all of the open files on the system. While this might not sound very powerful
    at first, let's take a detailed look at this command to understand how much information
    it can actually provide.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的命令是**lsof**命令。通过这个命令，我们可以列出系统上所有打开的文件。虽然这一开始可能听起来不太强大，但让我们详细看看这个命令，了解它实际上可以提供多少信息。
- en: When running the `lsof` command, permissions become very critical to understand.
    When executing `lsof` with no parameters, the command will print a list of all
    open files for every process it can identify. If we run this command as an unprivileged
    user such as the "`vagrant`" user, the output will only consist of processes that
    are running as the vagrant user. If we run the command as the root user, however,
    this command will print open files for all processes on the system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`lsof`命令时，权限变得非常重要。当不带任何参数执行`lsof`时，该命令将打印出它能识别的每个进程的所有打开文件的列表。如果我们以非特权用户（如“`vagrant`”用户）身份运行此命令，输出将只包含作为vagrant用户运行的进程。然而，如果我们以root用户身份运行该命令，该命令将打印系统上所有进程的打开文件。
- en: 'To put into perspective just how many files this translates to, we will run
    the `lsof` command and redirect the output to the `wc -l` command, which will
    count the number of lines provided in the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这意味着多少文件，我们将运行`lsof`命令并将输出重定向到`wc -l`命令，这将计算输出中提供的行数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the `wc` command, we can see that there are currently `3840` files open
    on this system. Now some of these files might be duplicated, as it is possible
    for more than one process to open the same file. However, the sheer number of
    open files on this system is quite large. To put it in further perspective, this
    system is also a fairly underutilized system and is not running many applications
    in general. Do not be surprised if after executing the preceding commands on a
    well-utilized system the number of open files is exponentially higher.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从`wc`命令中，我们可以看到当前系统上有`3840`个文件打开。现在，其中一些文件可能是重复的，因为可能有多个进程打开同一个文件。然而，当前系统上打开文件的数量非常大。为了进一步了解，这个系统也是一个相当未被充分利用的系统，一般并没有运行很多应用程序。如果在一个充分利用的系统上执行上述命令后，打开文件的数量呈指数级增长，也不要感到惊讶。
- en: 'Since looking at `3840` open files is not very practical, let''s get a better
    understanding of `lsof` by taking a look at the first 10 files from the `lsof`
    output. We can do this by redirecting the command''s output to the `head` command,
    which, like the `tail` command, will print 10 lines by default. However, where
    the `tail` command prints the last 10 lines, the `head` command prints the first
    10:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查看`3840`个打开文件并不是很实际，让我们通过查看`lsof`输出的前10个文件来更好地理解`lsof`。我们可以通过将命令的输出重定向到`head`命令来实现这一点，`head`命令将默认打印10行，就像`tail`命令一样。然而，`tail`命令打印最后10行，而`head`命令打印前10行：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, the `lsof` command, when executed as the root, is able to provide
    us with quite a bit of useful information. Let''s just look at the first line
    of output to understand what `lsof` displays:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，以root身份执行的`lsof`命令能够为我们提供相当多有用的信息。让我们只看一下输出的第一行，以了解`lsof`显示了什么：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `lsof` command prints 10 columns with each open file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof`命令打印10列，每个打开文件。'
- en: The first column is the `COMMAND` column. This field contains the name of the
    executable that has the file open. This is very useful when identifying which
    processes have a specific file open.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是`COMMAND`列。这个字段包含打开文件的可执行文件的名称。当识别哪些进程打开了特定文件时，这是非常有用的。
- en: For our use case, this will tell us which processes have the files we are interested
    in open and might tell us the process name of the application we are looking for.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，这将告诉我们哪些进程打开了我们感兴趣的文件，并可能告诉我们正在寻找的应用程序的进程名称。
- en: The second column is the `PID` column. This field is just as useful as the first
    as this shows the process ID of the application that has opened the files displayed.
    This value will allow us to narrow down the application to a specific process
    if it is in fact running.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列是`PID`列。这个字段和第一个一样有用，因为它显示了打开显示的文件的应用程序的进程ID。如果实际上正在运行，这个值将允许我们将应用程序缩小到特定的进程。
- en: The third column is the `TID` column, which in our output is blank. This column
    contains the thread ID of the process in question. In Linux, multithreaded applications
    are able to spawn threads, which are also known as lightweight processes. These
    threads are similar to a regular process but are able to share resources such
    as file descriptors and memory maps. You might hear these referred to as threads
    or lightweight processes but these are essentially the same thing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列是`TID`列，在我们的输出中是空白的。这一列包含了所讨论进程的线程ID。在Linux中，多线程应用程序能够生成线程，这些线程也被称为轻量级进程。这些线程类似于常规进程，但能够共享资源，如文件描述符和内存映射。你可能听说过这些被称为线程或轻量级进程，但它们本质上是一样的。
- en: In order to see the `TID` field, we can add the `-K` (show threads) flag to
    the `lsof` command. This will cause `lsof` to print all of the lightweight processes
    as well as the full processes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到`TID`字段，我们可以在`lsof`命令中添加`-K`（显示线程）标志。这将导致`lsof`打印所有轻量级进程以及完整进程。
- en: The fourth column of the `lsof` output is the `USER` field. This field will
    print the username or `UID` (if a username is not found) of the process that has
    opened the file. It is important to know that this field is the user the process
    is executing and not the owner of the file itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof`输出的第四列是`USER`字段。这个字段将打印打开文件的进程的用户名或`UID`（如果找不到用户名）。重要的是要知道，这个字段是进程正在执行的用户，而不是文件本身的所有者。'
- en: For example, if a process running as `rotot` had opened a file owned by `vagrant`,
    the USER field in `lsof` will show root. The reason for this is because the `lsof`
    command is used to show which processes have files open and is utilized to display
    information about the process, not necessarily the files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果作为`rotot`运行的进程打开了一个由`vagrant`拥有的文件，`lsof`中的USER字段将显示root。这是因为`lsof`命令用于显示哪些进程打开了文件，并且用于显示有关进程的信息，而不一定是文件。
- en: Understanding file descriptors
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解文件描述符
- en: The fifth column is very interesting as this is the field for **File Descriptor**
    (**FD**); which is a tricky Unix and Linux topic to understand.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第五列非常有趣，因为这是**文件描述符**（**FD**）的字段；这是一个棘手的Unix和Linux主题。
- en: File descriptors are part of the POSIX **application programming interface**
    (**API**), which is a standard that all modern Linux and Unix operating systems
    follow. From a program's perspective, the file descriptor is an object that is
    represented by a nonnegative number. This number is used as an identifier for
    a table of open files managed by the kernel on a per-process basis.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是POSIX应用程序编程接口（API）的一部分，这是所有现代Linux和Unix操作系统遵循的标准。从程序的角度来看，文件描述符是一个由非负数表示的对象。这个数字被用作内核在每个进程基础上管理的打开文件表的标识符。
- en: 'Since the kernel maintains this on a per-process level, the data is contained
    within the `/proc` file system. We can see this open file table by performing
    an `ls -la` in the `/proc/<process id>/fd` directory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内核在每个进程级别上维护这个数据，数据包含在`/proc`文件系统中。我们可以通过在`/proc/<process id>/fd`目录中执行`ls
    -la`来查看这个打开文件表：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a file descriptor table for the `systemd` process. As you can see, there
    is a number and that number is linked to a file/object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`systemd`进程的文件描述符表。正如你所看到的，有一个数字，这个数字与一个文件/对象相关联。
- en: What is not easily represented in this output is that this is ever-changing.
    When a file/object is closed, the file descriptor number then becomes reusable
    for the kernel to assign it to a new open file/object. Depending on how often
    a process is opening and closing files, if we were to repeat the same ls, we might
    see a completely different set of open file in this table.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出中不容易表示的是这是一个不断变化的过程。当一个文件/对象被关闭时，文件描述符号就可以被内核重新分配给一个新的打开的文件/对象。根据进程打开和关闭文件的频率，如果我们重复相同的ls命令，我们可能会在这个表中看到完全不同的一组打开文件。
- en: With this, we would expect the FD field in `lsof` to always show a number. However,
    the FD field in the `lsof` output can actually contain more than just the file
    descriptor number. This is because `lsof` actually shows more open items than
    just files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们期望`lsof`中的FD字段总是显示一个数字。然而，`lsof`输出中的FD字段实际上可以包含不止文件描述符号。这是因为`lsof`实际上显示的不仅仅是文件。
- en: 'When executed, the `lsof` command will print many different types of open objects;
    not all of these are files. An example of this can be seen in the first line of
    output from our `lsof` command earlier:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，`lsof`命令将打印许多不同类型的打开对象；并非所有这些都是文件。我们之前`lsof`命令输出的第一行就是一个例子：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding item is not a file, but rather a directory. Because this is a
    directory the FD field shows `cwd`, which is used to represent the current working
    directory of the open item. This is actually a very different output from what
    would be printed when the open item is a file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的项目不是一个文件，而是一个目录。因为这是一个目录，FD字段显示`cwd`，用于表示打开对象的当前工作目录。这实际上与打开对象为文件时打印的输出非常不同。
- en: 'To better show the difference, we can run an `lsof` command against a specific
    file by providing the file as an argument to `lsof`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地显示区别，我们可以通过将文件作为`lsof`的参数来运行`lsof`命令来针对特定文件运行`lsof`：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding output, we are able to not only see that many processes have
    `/dev/null` open, but that the `FD` field is quite different for each line. If
    we look at the first line, we can see that the `systemd` process has `/dev/null`
    open and that the `FD` field has a value of `0u`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，我们不仅能够看到许多进程打开了`/dev/null`，而且每行的`FD`字段也有很大不同。如果我们看第一行，我们可以看到`systemd`进程打开了`/dev/null`，而`FD`字段的值是`0u`。
- en: When `lsof` is displaying an open item that is a standard file, the `FD` field
    will contain the file descriptor number associated with that open file in the
    kernels table, `0` in this case.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当`lsof`显示一个标准文件的打开对象时，`FD`字段将包含与内核表中该打开文件相关联的文件描述符号，本例中为`0`。
- en: 'If we look back at the `/proc/1/fd` directory, we can actually see this represented
    in the kernels table:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下`/proc/1/fd`目录，我们实际上可以在内核表中看到这个表示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The file descriptor number can potentially be followed by two more values depending
    on how the file is opened and whether it is locked.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符号可能会跟随两个值，这取决于文件的打开方式以及它是否被锁定。
- en: The first potential value shows the mode that the file is opened in. From our
    example, this is represented by the `u` in the `0u` value. The lowercase `u` represents
    that the file is opened for both read and write access.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个潜在的值显示了文件的打开模式。从我们的例子中，这由`0u`值中的`u`表示。小写的`u`表示文件同时以读写方式打开。
- en: 'The following is a list of potential modes that `lsof` will display:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`lsof`将显示的潜在模式列表：
- en: '`r`: The lowercase `r` represents that the file is opened for read only'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：小写的`r`表示文件只能读取'
- en: '`w`: The lowercase `w` represents that the file is opened for writes only'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：小写的`w`表示文件只能写入打开'
- en: '`u`: The lowercase `u` represents that the file is opened for both read and
    writes'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：小写的`u`表示文件同时以读写方式打开'
- en: '<space>: The blank space is used to depict that the mode the file is open in
    is unknown and that there is no lock currently on the file'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <space>：空格用于表示文件打开的模式未知，并且当前文件上没有锁
- en: '`-`: The hyphen is used to depict that the mode the file is open in is unknown
    and that there is currently a lock on the file'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：连字符用于表示文件打开的模式未知，并且当前文件上有锁'
- en: The last two values are actually quite interesting as they bring us to the second
    potential value after the file descriptor number.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个值实际上非常有趣，因为它们将我们带到文件描述符号后的第二个潜在值。
- en: 'Processes on Linux and Unix systems are allowed to request files to be locked
    when they are opened. There are multiple types of locks and this is shown in the
    `lsof` output as well:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和Unix系统上的进程在打开文件时允许请求文件被锁定。有多种类型的锁，这也在`lsof`输出中显示出来：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, the `FD` field contained `10uW`. From the previous
    examples we know that 10 is the file descriptor number and that `u` denotes that
    this file is open for both read and write but the `W` is new. This W shows what
    type of lock the process has on this file; a write lock for this example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`FD`字段包含`10uW`。根据先前的示例，我们知道10是文件描述符号，`u`表示此文件已打开以进行读写，但`W`是新的。这个W显示了进程对该文件的锁的类型；对于这个示例来说，是写锁。
- en: 'Like the file open mode, there are many different types of locks that can be
    seen from `lsof`. This is a list of possible locks shown by `lsof`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件打开模式一样，从`lsof`中可以看到许多不同类型的锁。以下是`lsof`显示的可能锁的列表：
- en: '`N`: This is used for Solaris NFS locks of unknown types'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N`：用于Solaris未知类型的NFS锁'
- en: '`r`: This is a read lock on part of a file'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：这是对文件的部分读取锁'
- en: '`R`: This is a read lock on an entire file'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：这是对整个文件的读取锁'
- en: '`w`: This is a write lock on part of a file'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：这是对文件的部分写锁'
- en: '`W`: This is a write lock on an entire file'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`：这是对整个文件的写锁'
- en: '`u`: This is a read and write lock of any length'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：这是任意长度的读写锁'
- en: '`U`: This is a read and write lock of unknown type'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U`：未知类型的读写锁'
- en: '`x`: This is a SCO Openserver Xenix lock of a partial file'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：这是SCO Openserver Xenix对部分文件的锁'
- en: '`X`: This is a SCO Openserver Xenix lock of a full file'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`：这是SCO Openserver Xenix对整个文件的锁'
- en: You might notice that there are several possible locks that are not Linux-specific.
    This is because `lsof` is a tool widely used in both Linux and Unix and supports
    many Unix distributions such as Solaris and SCO.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到有几种可能的锁并非特定于Linux。这是因为`lsof`是一种广泛用于Linux和Unix的工具，并支持许多Unix发行版，如Solaris和SCO。
- en: 'Now that we have covered how `lsof` displays the `FD` field for actual files,
    let''s take a look at how it displays open objects that are not necessarily files:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`lsof`如何显示实际文件的`FD`字段，让我们看看它如何显示不一定是文件的打开对象：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With this, we can see quite a few different `FD` values in this list, such
    as `cwd`, `rtd`, `txt`, and `mem`. We already know from an earlier example that
    `cwd` is used to show a `Current Working Directory` but the others are quite new.
    There are actually quite a few possible file types depending on the object that
    is open. The following list contains all of the possible values that can be displayed
    if a file descriptor number is not used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们可以在这个列表中看到很多不同的`FD`值，比如`cwd`、`rtd`、`txt`和`mem`。我们已经从之前的示例中知道，`cwd`用于显示`当前工作目录`，但其他的都是新的。实际上，根据打开的对象，可能有许多不同的可能文件类型。以下列表包含了所有可能的值，如果不使用文件描述符号，则可以显示：
- en: '`cwd`: Current working directory'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cwd`：当前工作目录'
- en: '`Lnn`: Library reference for AIX systems (`nn` is a number value)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lnn`：AIX系统的库引用（`nn`是一个数值）'
- en: '`err`: File descriptor information error'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`：文件描述符信息错误'
- en: '`jld`: FreeBSD jailed directory'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jld`：FreeBSD监禁目录'
- en: '`ltx`: Shared library text'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ltx`：共享库文本'
- en: '`Mxx`: Hex memory mapped (xx is a type number)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mxx`：十六进制内存映射（xx是类型编号）'
- en: '`m86`: DOS merged mapped file'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m86`：DOS合并映射文件'
- en: '`mem`: Memory mapped file'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem`：内存映射文件'
- en: '`mmap`: Memory mapped device'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`：内存映射设备'
- en: '`pd`: Parent directory'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd`：父目录'
- en: '`rtd`: Root directory'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rtd`：根目录'
- en: '`tr`: Kernel trace file'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tr`：内核跟踪文件'
- en: '`txt`: Program text'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`txt`：程序文本'
- en: '`v86`: VP/ix mapped file'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v86`：VP/ix映射文件'
- en: 'We can see that there are many possible values for the `FD` field. Now that
    we have seen the possible values, let''s take a look at the preceding example
    to better understand what types of open items were shown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`FD`字段有许多可能的值。既然我们已经看到了可能的值，让我们看一下前面的示例，以更好地理解显示的打开项目的类型：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first two lines are interesting as they are both for the "`/`" directory.
    However, the first line shows the "`/`" directory as `cwd`, which means it is
    the current working directory. The second line shows the "`/`" directory as `rtd`,
    which means this is also the root directory for the `iprupdate` program.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行很有趣，因为它们都是针对"`/`"目录。但是，第一行显示"`/`"目录为`cwd`，这意味着它是当前工作目录。第二行显示"`/`"目录为`rtd`，这意味着这也是`iprupdate`程序的根目录。
- en: The third line shows that `/usr/sbin/iprupdate` is the program itself as it
    has a `FD` field value of `txt`. This means the open file is the code of the program.
    The fourth line for the open item `/usr/lib64/libc-2.17.so` shows a FD of `mem`.
    This means the file `/usr/lib64/libc-2.17.so` has been read and placed into memory
    for the `iprupdate` process. This means that this file can be accessed as a memory
    object. This is a common practice for library files such as `libc-2.17.so`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行显示`/usr/sbin/iprupdate`是程序本身，因为它的`FD`字段值为`txt`。这意味着打开的文件是程序的代码。第四行打开项目`/usr/lib64/libc-2.17.so`显示了一个`mem`的FD。这意味着文件`/usr/lib64/libc-2.17.so`已被读取并放入内存中供`iprupdate`进程使用。这意味着这个文件可以被当作内存对象访问。这对于诸如`libc-2.17.so`之类的库文件是一种常见做法。
- en: Getting back to the lsof output
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到`lsof`输出
- en: Now that we have thoroughly explored the FD field, let's move to the sixth column
    of the `lsof` output, the `TYPE` field. This field shows the type of file that
    is being opened. As there are quite a large number of possible types, it would
    be a bit tricky to list them here; however, you can always find this referenced
    in the `lsof` man page, which is accessible online or via the "`man lsof`" command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经彻底探讨了`lsof`输出的`FD`字段，让我们转到第六列，即`TYPE`字段。该字段显示正在打开的文件类型。由于可能的类型相当多，要在这里列出它们可能有点棘手；但是，您可以在`lsof`手册页中找到这些信息，该手册页可以在线访问，也可以通过"`man
    lsof`"命令访问。
- en: 'While we will not be listing every possible file type, we can take a quick
    look at a few file types captured from our example system:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会列出每种可能的文件类型，但我们可以快速查看一下从我们的示例系统中捕获的一些文件类型：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first example item shows a `TYPE` of `REG`. This `TYPE` is very common as
    the item being listed is a `Regular` file. The second example item shows **Character
    special file** (**CHR**). The CHR denotes special files that present themselves
    as files but are actually an interface for a device. The item listed `/dev/null`
    is a perfect example of a character file as it is used as input to nothing. Anything
    that is written to `/dev/null` is nullified and if you were to read this file,
    you would receive no output.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例项显示`TYPE`为`REG`。这种`TYPE`非常常见，因为被列出的项目是一个`Regular`文件。第二个示例项显示**Character
    special file** (**CHR**)。CHR表示特殊文件，它们表现为文件，但实际上是设备的接口。列出的`/dev/null`就是一个字符文件的完美例子，因为它被用作输入到空。任何写入`/dev/null`的内容都会被清空，如果您读取此文件，将不会收到任何输出。
- en: The third item shows `DIR`, it should not be a surprise that `DIR` stands for
    a directory. This is a very common `TYPE` as many processes at some level will
    require a directory to be opened.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项显示`DIR`，这应该不足为奇，`DIR`代表目录。这是一个非常常见的`TYPE`，因为许多进程在某个级别上都需要打开一个目录。
- en: The fourth item shows `unix`, which shows that this open item is a Unix socket
    file. Unix socket files are special files that are used as input/output devices
    for process communication. These files should show up quite often in the `lsof`
    output.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第四项显示了`unix`，表明此打开项目是Unix套接字文件。Unix套接字文件是用作进程通信的输入/输出设备的特殊文件。这些文件应该经常出现在`lsof`输出中。
- en: As we can see from the preceding example, on Linux systems, there are several
    different types of files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的示例中看到的，在Linux系统上有几种不同类型的文件。
- en: 'Now that we have looked at the sixth column of the output in `lsof`, the `TYPE`
    column, let''s take a quick look at the seventh, the `DEVICE` column:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了`lsof`输出中的第六列，即`TYPE`列，让我们快速看一下第七列，即`DEVICE`列：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we look at the preceding item, we can see the `DEVICE` column has a value
    of `253,1`. These numbers represent the major and minor numbers of the device
    that this item is on. Major and minor numbers in Linux are used by the system
    to determine how a device is accessed. The major number, which in this case is
    `253`, is used to determine which driver the system should use. Once the driver
    is selected, the minor number, 1 in our case, is then used to narrow down how
    exactly this device should be accessed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看前面的项目，我们可以看到`DEVICE`列的值为`253,1`。这些数字代表此项目所在设备的主设备号和次设备号。Linux中的主设备号和次设备号被系统用来确定如何访问设备。主设备号，在本例中为`253`，用于确定系统应该使用哪个驱动程序。一旦选择了驱动程序，次设备号，在我们的情况下为1，然后用于进一步确定如何访问这个设备。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Major and minor numbers are actually an important part of Linux and how it uses
    devices. While we will not be covering this topic in depth within this book, it
    is something I would suggest learning more about as this information is incredibly
    useful when troubleshooting issues with hardware devices.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备号和次设备号实际上是Linux及其设备使用的重要部分。虽然我们不会在本书中深入讨论这个主题，但我建议您多了解一些，因为这些信息在故障排除硬件设备问题时非常有用。
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have explored the `DEVICE` column, let's take a look at the eighth
    column of the `lsof` output, `SIZE/OFF`. The `SIZE/OFF` column is used to display
    either the size of the open item or the **offset**. Offsets are generally displayed
    with devices such as socket files and character files. When this column contains
    an offset, it will be preceded with "`0t`". In the above example, we can see the
    character file `/dev/null` has an offset value of `0t0`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了`DEVICE`列，让我们来看一下`lsof`输出的第八列，`SIZE/OFF`。`SIZE/OFF`列用于显示打开项目的大小或**偏移量**。偏移通常与套接字文件和字符文件一起显示。当此列包含偏移量时，它将以"`0t`"开头。在上面的示例中，我们可以看到字符文件`/dev/null`的偏移值为`0t0`。
- en: The `SIZE` value is used when referring to open items such as regular files.
    This value is actually the size of the file in bytes. For example, we can see
    that the `SIZE` column for `/usr/lib64/ld-2.17.so` is `160240`. This means this
    file is roughly 160 KB in size.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIZE`值用于指代常规文件等打开项目的大小。这个值实际上是文件的大小（以字节为单位）。例如，我们可以看到`/usr/lib64/ld-2.17.so`的`SIZE`列为`160240`。这意味着这个文件大约有160
    KB大小。'
- en: 'The ninth column in the `lsof` output is the `NODE` column:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof`输出中的第九列是`NODE`列：'
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For regular files, the `NODE` column will show the **inode** number of the file.
    Within a filesystem, every file has an inode, this inode is used as an index that
    contains all of the individual files' metadata. This metadata consists of items
    such as the file's location on disk, file permissions, the creation time, and
    modification time of the file. Like major and minor numbers, I suggest taking
    a deeper dive into inodes and what they contain, as inodes are a core component
    to how files exist on a Linux system.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规文件，`NODE`列将显示文件的**inode**编号。在文件系统中，每个文件都有一个inode，这个inode被用作包含所有单个文件元数据的索引。这些元数据包括文件在磁盘上的位置、文件权限、创建时间和修改时间等。与主设备号和次设备号一样，我建议深入了解inode及其包含的内容，因为inode是文件在Linux系统上存在的核心组件。
- en: You can see, from the first item in the preceding example, the inode of `/var/log/httpd/error_log`
    is `134812768`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面示例中的第一项看到，`/var/log/httpd/error_log`的inode是`134812768`。
- en: The second line, however, shows the `NODE` as TCP, which is not an inode. The
    reason it shows TCP is because the open item is a TCP Socket, which is not a file
    on a filesystem. Like the `TYPE` column, the `NODE` column will change based on
    the open item. However, on most systems, you will generally see an inode number,
    TCP or UDP (for UDP Sockets).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二行显示`NODE`为TCP，这不是一个inode。它显示TCP的原因是因为打开项目是TCP套接字，它不是文件系统上的文件。与`TYPE`列一样，`NODE`列将根据打开项目而改变。然而，在大多数系统上，您通常会看到一个inode编号、TCP或UDP（用于UDP套接字）。
- en: 'The tenth and final column in the `lsof` output is pretty self-explanatory,
    as we have referenced it several times already. The tenth column is the `NAME`
    field, which is as simple as it sounds; it lists the name of the open item:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof`输出中的第十列是非常容易理解的，因为我们已经多次引用过它。第十列是`NAME`字段，就像它听起来那样简单；它列出了打开项目的名称：'
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using lsof to check whether we have a previously running process
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lsof来检查是否有先前运行的进程
- en: Now that we know a lot more about how `lsof` works and how it can help us, let's
    use this command to check whether there are any running instances of our application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`lsof`的工作原理和它如何帮助我们有了更多了解，让我们使用这个命令来检查是否有任何正在运行的应用程序实例。
- en: 'If we simply ran the `lsof` command as the root user, we would see all of the
    open files on this system. However, that output can be quite overwhelming even
    when we redirect the output to commands such as `less` or `grep`. Luckily, `lsof`
    will allow us to specify files and directories to look for:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是以root用户身份运行`lsof`命令，我们将看到系统上所有打开的文件。然而，即使我们将输出重定向到`less`或`grep`等命令，输出也可能会非常庞大。幸运的是，`lsof`允许我们指定要查找的文件和目录：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, by specifying a file in the preceding command, we limited the
    output to processes that have the file open.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过指定前面的命令中的一个文件，我们将输出限制为具有该文件打开的进程。
- en: 'If we specify a directory, the output is similar:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定一个目录，输出是类似的：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From this, we can see that two processes have the `/opt/myapp` directory open.
    Another way we could limit the output of `lsof` is to specify the `+D` (directory
    contents) flag, followed by a directory. This flag will tell `lsof` to look for
    any open items from that directory and below.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到两个进程打开了`/opt/myapp`目录。我们可以限制`lsof`的输出的另一种方法是指定`+D`（目录内容）标志，后跟一个目录。这个标志将告诉`lsof`查找该目录及其以下的任何打开项目。
- en: For example, we saw that when using `lsof` against the configuration file, the
    `less` process had it opened. We could also see that when used against the `/opt/myapp/`
    directory, two processes had the directory open.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们看到当使用`lsof`针对配置文件时，`less`进程已经打开了它。我们还可以看到，当用于`/opt/myapp/`目录时，两个进程打开了该目录。
- en: 'We can see all of these items with just one command using the `+D` flag:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`+D`标志一次查看所有这些项目：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This would also show us any other items located under the `/opt/myapp` directory.
    Since we are looking to check whether another instance of the application is running
    let''s take a look at the preceding `lsof` output and see what can be learned:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会显示位于`/opt/myapp`目录下的任何其他项目。由于我们要检查应用程序是否有另一个实例正在运行，让我们看一下前面的`lsof`输出，并看看可以学到什么：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first open item shows a process of `bash`, running as the `vagrant` user
    with a file descriptor of a current working directory. This line is most likely
    our own `bash` process that is currently in the `/opt/myapp` directory, currently
    executing the less command on the `/opt/myapp/conf/config.yml` file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个打开的项目显示了一个`bash`进程，以`vagrant`用户身份运行，具有当前工作目录的文件描述符。这一行很可能是我们自己的`bash`进程，目前正在`/opt/myapp`目录中，当前正在执行`/opt/myapp/conf/config.yml`文件上的`less`命令。
- en: 'We can check this by using the `ps` command and `grep` for the string `3474`,
    the process ID of the `bash` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ps`命令并`grep`字符串`3474`来检查这一点，`bash`命令的进程ID：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I opted to use the `grep` command in this case, as we will also be able to
    see any child processes that reference process ID `3474`. The same thing can be
    performed without the `grep` command as well by running the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我选择使用`grep`命令，因为我们还将能够看到引用进程ID`3474`的任何子进程。也可以通过运行以下命令来执行相同的操作，而不使用`grep`命令：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Overall, both produce the same results; however, the first method is easier
    to remember.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，两种方法都会产生相同的结果；然而，第一种方法更容易记住。
- en: If we look at the process list output, we can see that the `bash` command is
    in fact related to our shell as its child process is the `less` command that we
    know we have running in another window.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看进程列表输出，我们可以看到`bash`命令实际上与我们的shell相关，因为它的子进程是我们知道在另一个窗口中正在运行的`less`命令。
- en: 'We can also see the process ID of the `less` command: `3509`. The same process
    ID is shown in the `less` command in the `lsof` output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到`less`命令的进程ID：`3509`。相同的进程ID在`lsof`输出中显示了`less`命令：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since the output only shows our own processes, it is safe to assume that there
    is not a previous application instance running in the background.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出只显示我们自己的进程，可以安全地假设在后台没有运行先前的应用程序实例。
- en: Finding out more about the application
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多关于应用程序的信息
- en: We now know that the problem is not that another instance of this application
    is running. At this point, we should try and identify more about this application
    and what it is doing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道问题不是另一个此应用程序实例正在运行。在这一点上，我们应该尝试并识别更多关于这个应用程序以及它在做什么的信息。
- en: 'The first thing to do when trying to find out more information about this application
    is to see what type of file the application is. We can do this by using the `file`
    command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试查找有关此应用程序的更多信息时，首先要做的是查看应用程序的文件类型。我们可以使用`file`命令来做到这一点：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `file` command is a very useful command to have in your tool belt, as this
    command will identify the file type of the file being specified. In the preceding
    example, we can see that the "`application`" file is a compiled binary. We can
    see that it is compiled by this particular output: `ELF 64-bit LSB executable`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`命令是一个非常有用的命令，因为这个命令将识别指定文件的文件类型。在前面的例子中，我们可以看到"`application`"文件是一个已编译的二进制文件。我们可以看到它是由这个特定的输出编译的：`ELF
    64位LSB可执行文件`。'
- en: This line also tells us that the application is compiled as a 64-bit application.
    This is interesting as there are quite a few differences between 64-bit and 32-bit
    applications. One very common scenario is due to the amount of resources a 64-bit
    application can consume; 32-bit applications are often much more limited than
    a 64-bit version.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这行还告诉我们应用程序是作为64位应用程序编译的。这很有趣，因为64位应用程序和32位应用程序之间有很多区别。一个非常常见的情况是由于64位应用程序可以消耗的资源量；32位应用程序通常比64位版本受限得多。
- en: Another common issue is when trying to execute a 64-bit application on a 32-bit
    kernel. We have yet to validate whether we are running on a 64-bit kernel; if
    we are attempting to run a 64-bit executable with a 32-bit kernel, we are bound
    to receive some errors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是尝试在32位内核上执行64位应用程序。我们尚未验证是否在64位内核上运行；如果我们试图在32位内核上运行64位可执行文件，我们肯定会收到一些错误。
- en: 'The types of errors seen by trying to execute a 64-bit application on a 32-bit
    kernel are pretty specific and not very likely to be the cause of our issue. Even
    though it is not a likely cause, we can check whether the kernel is a 64-bit kernel
    or not with the `uname –a` command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在32位内核上执行64位应用程序时出现的错误类型非常具体，不太可能是我们问题的原因。尽管这不太可能是原因，我们可以使用`uname -a`命令来检查内核是否为64位内核：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: From the output of the uname `-a` command, we can see that the kernel is in
    fact a 64-bit kernel by the presence of this string "`x86_64`".
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从`uname -a`命令的输出中，我们可以看到内核实际上是64位内核，因为存在这个字符串"`x86_64`"。
- en: Tracing an application with strace
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用strace跟踪应用程序
- en: Since we know that the application is a compiled binary and we do not have the
    source code, this makes reading the code within the application fairly difficult.
    What we can do, however, is trace the system calls that the application is performing
    to see if we can find any information as to why it is not starting.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道应用程序是编译后的二进制文件，没有源代码，这使得在应用程序内部阅读代码相当困难。然而，我们可以追踪应用程序执行的系统调用，以查看是否能找到任何关于它为何无法启动的信息。
- en: What is a system call?
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是系统调用？
- en: '**System calls** are the primary interface between an application and the kernel.
    Simply put, a system call is a method of requesting the kernel to perform an action.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统调用**是应用程序和内核之间的主要接口。简而言之，系统调用是请求内核执行操作的方法。'
- en: Most applications do not need to worry about system calls, as system calls are
    generally called by low-level libraries, such as the GNU C Library. While the
    programmer need not worry about system calls, it is important to know that every
    action performed by an application drills down to some sort of system call.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序不需要担心系统调用，因为系统调用通常由低级库（如GNU C库）调用。虽然程序员不需要担心系统调用，但重要的是要知道应用程序执行的每个操作都归结为某种系统调用。
- en: This is important to know because we can trace these system calls to determine
    what exactly an application is doing. Much like we use `tcpdump` to trace network
    traffic on a system, we can use a command called `strace` to trace the system
    calls of a process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们可以追踪这些系统调用来确定应用程序到底在做什么。就像我们使用`tcpdump`来追踪系统上的网络流量一样，我们可以使用一个叫做`strace`的命令来追踪进程的系统调用。
- en: To get the feel of `strace`, let's use `strace` to perform a system call trace
    on our `exitcodes.sh` script from earlier. To do this, we will run the `strace`
    command followed by the `exitcodes.sh` script.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受`strace`，让我们使用`strace`对之前的`exitcodes.sh`脚本进行系统调用跟踪。为此，我们将运行`strace`命令，然后是`exitcodes.sh`脚本。
- en: 'When executed, the `strace` command will start up and then execute the `exitcodes.sh`
    script. While the `exitcodes.sh` script is running, the `strace` command will
    print every system call and the arguments provided to them from the `exitcodes.sh`
    script:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，`strace`命令将启动，然后执行`exitcodes.sh`脚本。在`exitcodes.sh`脚本运行时，`strace`命令将打印`exitcodes.sh`脚本中提供的每个系统调用和参数：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is only a small portion of the output from `strace`. The full output is
    actually several pages long. However, the `exitcodes.sh` script isn''t very long.
    In fact, it''s a simple three-line script:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是`strace`的输出的一小部分。完整的输出实际上有好几页长。然而，`exitcodes.sh`脚本并不是很长。事实上，它只是一个简单的三行脚本：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This script is a good example as to how much heavy lifting higher-level programming
    languages, such as bash, provide. Now that we know what the `exitcodes.sh` script
    does, let's take a look at some of the system calls it performs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很好地展示了高级编程语言（如bash）提供了多少重要的功能。现在我们知道`exitcodes.sh`脚本的作用，让我们来看一下它执行的一些系统调用。
- en: 'We will start with the first eight lines:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前八行开始：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As system calls are quite extensive and some of them are complicated to understand.
    We will focus our breakdown on system calls that are common and a bit easier to
    understand.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统调用非常广泛，有些系统调用很难理解。我们将把重点放在常见且较容易理解的系统调用上。
- en: 'The first system call that we will examine is the `access()` system call:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个系统调用是`access()`系统调用：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Most system calls have a name that roughly explains the function it performs.
    The `access()` system call is no different, as this system call is used to check
    whether the application calling it has sufficient access to open the file specified.
    In the preceding example, the file specified is `/etc/ld.so.preload`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统调用都有一个名字，大致解释它执行的功能。`access()`系统调用也不例外，因为这个系统调用用于检查调用它的应用程序是否有足够的权限打开指定的文件。在前面的例子中，指定的文件是`/etc/ld.so.preload`。
- en: An interesting thing about `strace` is not only does it show the system call,
    it also shows the return value. In our preceding example, the `access()` system
    call received a return value of `-1`, which is the typical value for errors. When
    the return value is an error, `strace` will also provide the error string. In
    this case, the `access()` call received the error `-1 ENOENT (No such file or
    directory)`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`strace`的一个有趣的事情是它不仅显示系统调用，还显示返回值。在我们前面的示例中，`access()`系统调用收到了一个返回值`-1`，这是错误的典型值。当返回值是错误时，`strace`还会提供错误字符串。在这种情况下，`access()`调用收到了错误`-1
    ENOENT (No such file or directory)`。
- en: The preceding error is pretty self-explanatory, as it seems the file `/etc/ld.so.preload`
    simply does not exist.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误非常容易理解，因为似乎文件`/etc/ld.so.preload`根本不存在。
- en: 'The next system call is one that will be seen quite often; it is the `open()`
    system call:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个系统调用是一个经常见到的系统调用；它就是`open()`系统调用：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `open()` system call performs just what it says, it is used to open (or
    create and open) a file or device. From the preceding example, we can see that
    the file specified is the `/etc/ld.so.cache` file. We can also see that one of
    the arguments passed to this system call is "`O_RDONLY`". This argument tells
    the `open()` call to open the file in the read only mode.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`系统调用执行了它所说的内容，它用于打开（或创建并打开）文件或设备。从前面的示例中，我们可以看到指定的文件是`/etc/ld.so.cache`文件。我们还可以看到传递给这个系统调用的参数之一是"`O_RDONLY`"。这个参数告诉`open()`调用以只读模式打开文件。'
- en: 'Even if we didn''t already know that the `O_RDONLY` argument tells the open
    command to open the file in read only, the name is almost self-descriptive. For
    system calls that are not self-descriptive, the information can be found with
    a fairly quick Google search, as system calls are very well documented:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不知道`O_RDONLY`参数告诉打开命令以只读模式打开文件，这个名字几乎是自我描述的。对于那些不够自我描述的系统调用，可以通过相当快速的谷歌搜索找到相关信息，因为系统调用都有很好的文档记录：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next system call to look at is the `fstat()` system call. This system call
    will pull the status of a file. The information this system call provides includes
    things such as the inode number, user ownership, and size of the file. By itself,
    the `fstat()` system call might not look very important but when we look at the
    next system call, `mmap()`, the information it provides can be important.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要看的系统调用是`fstat()`系统调用。这个系统调用将获取文件的状态。这个系统调用提供的信息包括诸如inode号、用户所有权和文件大小等内容。单独看，`fstat()`系统调用可能看起来并不重要，但当我们看下一个系统调用`mmap()`时，它提供的信息可能就很重要了。
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This system call can be used to map or unmap a file into memory. If we look
    at the `fstat()` line and look at the `mmap()` line, we will see two numbers that
    coincide. The fstat() line has `st_size=24646`, which is the second argument provided
    to `mmap()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统调用可以用来将文件映射或取消映射到内存中。如果我们看一下`fstat()`行和`mmap()`行，我们会看到两个相符的数字。`fstat()`行有`st_size=24646`，这是提供给`mmap()`的第二个参数。
- en: Even without knowing the details of these system calls it is pretty easy to
    build the assumption that the `mmap()` system call mapped the file from the `fstat()`
    call into the memory.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不知道这些系统调用的细节，也很容易得出这样的假设，即`mmap()`系统调用将文件从`fstat()`调用映射到内存中。
- en: 'The final system call from the preceding example is very simple to understand:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的最后一个系统调用非常容易理解：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `close()` system call simply closes the open file or device. Given that
    earlier we opened the file `/etc/ld.so.cache`, it only makes sense that this `close()`
    system call was used to close that file. Before we get back to debugging our application,
    let''s take a quick look at the last four lines put together:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()`系统调用只是关闭打开的文件或设备。考虑到我们之前打开了文件`/etc/ld.so.cache`，这个`close()`系统调用被用来关闭那个文件是很合理的。在我们回到调试应用程序之前，让我们快速看一下最后四行放在一起的内容：'
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we look at these four system calls, we can start to see a pattern. The `open()`
    call is used to open the `/etc/ld.so.cache` file and is given a return value of
    `3`. The `fstat()` command is provided `3` as input and gets `st_size=24646` as
    output. The `mmap()` function is given `24646` and `3` as input and the `close()`
    function is provided with `3` as input.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看这四个系统调用时，我们可以开始看到一个模式。`open()`调用用于打开`/etc/ld.so.cache`文件，并返回值为`3`。`fstat()`命令提供了`3`作为输入，并得到了`st_size=24646`作为输出。`mmap()`函数被给予了`24646`和`3`作为输入，`close()`函数被提供了`3`作为输入。
- en: Given that the output of the `open()` call is `3` and the value `3` has been
    used multiple times in these four system calls, it is safe to conclude that this
    number `3` is the file descriptor number of the open file `/etc/ld.so.cache`.
    With that conclusion, it is also pretty safe to assume that the preceding four
    system calls perform the actions of opening the file `/etc/ld.so.cache`, determining
    the size of the file, mapping that file into memory, and then closing the file
    descriptor.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`open()`调用的输出是`3`，并且这个值在这四个系统调用中被多次使用，可以安全地得出结论，即这个数字`3`是打开文件`/etc/ld.so.cache`的文件描述符号。有了这个结论，我们也可以相当肯定，前面的四个系统调用执行了打开文件`/etc/ld.so.cache`、确定文件大小、将文件映射到内存，然后关闭文件描述符的操作。
- en: As you can see, this is quite a bit of information from just four simple system
    calls. Let's put what you just learned into practice and use `strace` to trace
    the application process.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，仅仅通过四个简单的系统调用就得到了相当多的信息。让我们将刚学到的知识付诸实践，使用`strace`来跟踪应用程序进程。
- en: Using strace to identify why the application will not start
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用strace来确定应用程序为什么无法启动
- en: Earlier, when we ran `strace`, we simply provided it with a command to execute.
    This is one way you can invoke `strace`, but what do you do if the process is
    already running? Well, `strace` can also trace running processes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，当我们运行`strace`时，我们只是提供了一个要执行的命令。这是你可以调用`strace`的一种方式，但如果进程已经在运行，你该怎么办呢？嗯，`strace`也可以跟踪正在运行的进程。
- en: When tracing an existing process, we can start `strace` with the `–p` (process)
    flag followed by the process ID to trace. This causes `strace` to bind to that
    process and start tracing it. For tracing our application startup, we are going
    to use this method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪现有进程时，我们可以使用`-p`（进程）标志加上要跟踪的进程ID来启动`strace`。这会导致`strace`绑定到该进程并开始跟踪它。为了跟踪我们的应用程序启动，我们将使用这种方法。
- en: 'To do this, we are going to execute the `start.sh` script in the background
    and then run `strace` against the process ID of the `start.sh` script:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在后台执行`start.sh`脚本，然后对`start.sh`脚本的进程ID运行`strace`：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'By adding & to the end of the command line, we are telling the start script
    to run in the background. The output provides us with the process ID of the running
    script, `3353`. However, in another window as the root user, we can use `strace`
    to trace this process with the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行的末尾添加&，我们告诉启动脚本在后台运行。输出提供了正在运行的脚本的进程ID，`3353`。然而，在另一个窗口中作为root用户，我们可以使用以下命令对该进程进行跟踪：
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding command adds a few more options than just `–p` and the process
    ID. We also add the `–o /var/tmp/app.out` arguments. This option will tell `strace`
    to save the traced data to the output file `/var/tmp/app.out`. The earlier `strace`
    that we ran provided quite a bit of output; by specifying that the data should
    be written to a file, the data will be a bit more manageable to search.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令比只有`-p`和进程ID多了一些选项。我们还添加了`-o /var/tmp/app.out`参数。这个选项告诉`strace`将跟踪的数据保存到输出文件`/var/tmp/app.out`中。我们之前运行的`strace`提供了相当多的输出；通过指定数据应该写入文件，数据将更容易搜索。
- en: 'The other new option we added is `–f`; this argument tells `strace` to follow
    child processes. Since the start script starts the application, the application
    itself is considered a child process of the start script. In the preceding example
    we can see that `strace` was attached to two processes. We can assume that the
    second process received the process ID of `3360`, this is important to know, as
    we will need to reference that process ID while looking through the trace output:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的另一个新选项是`-f`；这个参数告诉`strace`跟踪子进程。由于启动脚本启动了应用程序，应用程序本身被认为是启动脚本的子进程。在前面的例子中，我们可以看到`strace`附加到了两个进程。我们可以假设第二个进程收到了进程ID`3360`，这一点很重要，因为在浏览跟踪输出时我们需要引用该进程ID：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s get started reading the `strace` output and attempt to identify what
    is happening. While going through this output, we will limit it to only sections
    that are useful for identifying our issue:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始阅读`strace`输出并尝试识别发生了什么。在浏览输出时，我们将限制它只包括对识别我们问题有用的部分：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first system call that appears interesting is the `execve()` system call.
    This particular call of `execve()` appears to be executing the `/opt/myapp/bin/application`
    binary.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有趣的第一个系统调用是`execve()`系统调用。这个特定的`execve()`调用似乎是在执行`/opt/myapp/bin/application`二进制文件。
- en: One important item to point out is that, with this output, we can see a number
    before the system call. This number, `3360`, is the process ID of the process
    that executed the system call. The process ID will only be shown when the strace
    command is tracing multiple processes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的一个重要事项是，通过这个输出，我们可以看到系统调用之前有一个数字。这个数字`3360`是执行系统调用的进程ID。只有在strace命令跟踪多个进程时才会显示进程ID。
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: From the preceding group, we can see that the application is opening the `config.yml`
    file in read only and did not receive an error. We can also see that the `read()`
    system call (which appears to be reading from file descriptor 3) is reading the
    `config.yml` file.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的一组中，我们可以看到应用程序以只读方式打开了`config.yml`文件，并且没有收到错误。我们还可以看到`read()`系统调用（似乎是从文件描述符3读取）正在读取`config.yml`文件。
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It appears further down the file that this file descriptor is closed using
    the `close()` system call. This information is useful as it tells us that we are
    able to read the `config.yml` file and that our issue is not related to permissions
    on the configuration file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的更下方显示，使用`close()`系统调用关闭了这个文件描述符。这个信息很有用，因为它告诉我们我们能够读取`config.yml`文件，而我们的问题与配置文件的权限无关：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we continue, we can see that our configuration is taking effect as well,
    as the process has opened the `debug.out` file for writing using the `open()`
    call and written to it with the `write()` call.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续，我们还可以看到我们的配置也在生效，因为进程已经使用`open()`调用打开了`debug.out`文件进行写入，并使用`write()`调用写入了它。
- en: For applications that have many log files, system calls such as the above can
    be useful for identifying log messages that might not have been obvious.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有许多日志文件的应用程序，上述的系统调用等可以用于识别可能不太明显的日志消息。
- en: When looking through system calls, you can roughly understand the context of
    when the message was generated and possibly why. This context can be extremely
    useful depending on the issue.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览系统调用时，您可以大致了解生成消息的上下文以及可能的原因。这个上下文可能会根据问题的严重程度非常有用。
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Speaking of context, the preceding system calls explain our problem specifically,
    one system call. While the `strace` file contained many system calls that returned
    errors, the majority of them were like the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 说到上下文，前面的系统调用明确解释了我们的问题，一个系统调用。虽然`strace`文件包含了许多返回错误的系统调用，但其中大部分都像下面这样：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is fairly common, as it simply means the process attempted to access a
    file that is not present. In the trace file, however, there is one error that
    sticks out more than the others:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当常见的，因为它只是意味着进程尝试访问一个不存在的文件。然而，在跟踪文件中，有一个错误比其他的更显眼：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding system call `bind()` is a system call that binds a socket. The
    preceding example appears to binding a network socket. If we think back to our
    configuration file, we know that port `25` is specified:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的系统调用`bind()`是一个绑定套接字的系统调用。前面的例子似乎是在绑定网络套接字。如果我们回想一下我们的配置文件，我们知道指定了端口`25`：
- en: '[PRE70]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the system call, we can see the string `sin_port=htons(25)`, which might
    mean this bind system call is trying to bind to port `25`. From the return value
    provided, we can see that the `bind()` call received an error. The message of
    that error suggests "`Address is already in use`".
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统调用中，我们可以看到字符串`sin_port=htons(25)`，这可能意味着这个绑定系统调用正在尝试绑定到端口`25`。从提供的返回值中，我们可以看到`bind()`调用收到了一个错误。该错误的消息表明“地址已经在使用”。
- en: Since we know that the application is configured to utilize port `25` in some
    way and we can see a `bind()` system call, it stands to reason that this application
    might not be starting simply because port `25` is already being used by another
    process, which at this point, is our new hypothesis.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道应用程序配置为以某种方式利用端口`25`，并且我们可以看到一个`bind()`系统调用，因此可以推断出这个应用程序可能之所以没有启动，只是因为端口`25`已经被另一个进程使用，这在这一点上是我们的新假设。
- en: Resolving the conflict
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决冲突
- en: 'As you learned in the networking chapter, we can verify that a process has
    port `25` in use with a quick `netstat` command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在网络章节中学到的，我们可以通过快速的`netstat`命令来验证进程是否使用端口`25`：
- en: '[PRE71]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When we run `netstat` as the root user and add the `–p` flag, the command will
    include the process ID and name of process for each LISTEN-ing socket. From this,
    we can see that port `25` is in fact being used and the process 1588 is the one
    listening.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以root用户身份运行`netstat`并添加`-p`标志时，该命令将包括每个LISTEN-ing套接字的进程ID和进程名称。从中，我们可以看到端口`25`实际上正在被使用，而进程1588是正在监听的进程。
- en: 'To get a better understanding of what process this is, we can once again utilize
    the `ps` command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这个进程是什么，我们可以再次利用`ps`命令：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: It appears that the `postfix` service is the one listening on port `25`, which
    is not very surprising since this port is generally used for SMTP communication
    and postfix is an e-mail service.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`postfix`服务是在端口`25`上监听，这并不奇怪，因为这个端口通常用于SMTP通信，而postfix是一个电子邮件服务。
- en: The question now is, should postfix be listening on this port or should the
    application? Unfortunately, there is no easy answer to that question, as it truly
    depends on the systems and what they are doing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，后缀应该在这个端口上监听，还是应用程序？不幸的是，对于这个问题没有简单的答案，因为它确实取决于系统和它们正在做什么。
- en: For the sake of this exercise, we will assume the answer is that the custom
    application should be using port `25`, and postfix should not be running.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习，我们将假设答案是自定义应用程序应该使用端口`25`，而后缀不应该运行。
- en: 'To stop postfix from listening on port `25`, we will first stop postfix using
    the `systemctl` commands:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止后缀在端口`25`上监听，我们将首先使用`systemctl`命令停止后缀：
- en: '[PRE73]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This stops the postfix service where the next command will disable it from
    starting up again on the next reboot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止后缀服务，下一个命令将禁止它在下次重新启动时再次启动：
- en: '[PRE74]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Disabling the postfix service is an important step to resolving this issue.
    Currently, we believe the issue is caused by a port conflict between the custom
    application and postfix. If we do not disable the postfix service, the next time
    the system reboots it will be started again. This will then prevent the custom
    application from being started as well.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用后缀服务是解决此问题的重要步骤。目前，我们认为问题是由自定义应用程序和后缀之间的端口冲突引起的。如果我们不禁用后缀服务，下次系统重新启动时它将被重新启动。这将阻止自定义应用程序的启动。
- en: While this might seem basic, I want to stress the importance of this step as,
    on numerous occasions, I've seen an issue happen repeatedly, simply because the
    person who resolved it the first time didn't disable a service.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来很基础，但我想强调这一步的重要性，因为在许多情况下，我曾见过一个问题反复发生，只是因为第一次解决它的人没有禁用一个服务。
- en: 'If we run the `systemctl` status command, we can now see that the postfix service
    is stopped and disabled:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`systemctl`状态命令，我们现在可以看到后缀服务已停止并禁用：
- en: '[PRE75]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With the `postfix` service stopped, we can now once again start the application
    to see if the issue is resolved.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过停止`postfix`服务，我们现在可以再次启动应用程序，看看问题是否已解决。
- en: '[PRE76]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It appears the issue was in fact resolved by stopping the `postfix` service.
    We can see this by the "`[Success]`" message printed from the startup process.
    We can also see this if we run the `lsof` command again:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来问题实际上是通过停止`postfix`服务解决的。我们可以通过启动过程中打印的“[Success]”消息来看到这一点。如果我们再次运行`lsof`命令，也可以看到这一点：
- en: '[PRE77]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now that the application is running, we can see several processes have open
    items in the `/opt/myapp` directory. We can also see that one of those processes
    is the application command with a process ID of `3588`. To get a better look at
    what the application is doing we can once again run `lsof`, but this time we will
    search only for files open by the process ID `3588`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，我们可以看到几个进程在`/opt/myapp`目录中有打开的项目。我们还可以看到其中一个进程是带有进程ID`3588`的应用程序命令。为了更好地了解应用程序正在做什么，我们可以再次运行`lsof`，但这次我们只搜索进程ID`3588`打开的文件：
- en: '[PRE78]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `–p` (process) flag will filter the `lsof` output to a specific process.
    In this case, we limited the output to the custom application we just started:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`（进程）标志将`lsof`输出过滤到特定进程。在这种情况下，我们将输出限制为刚刚启动的自定义应用程序。'
- en: '[PRE79]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the last line, we can see that the application has a TCP socket open. Given
    the status messages from the application and the results from `lsof`, it is pretty
    safe to say the application has started and started correctly.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行中，我们可以看到应用程序有一个TCP套接字打开。根据应用程序的状态消息和`lsof`的结果，可以非常肯定地说应用程序已经启动并且启动正确。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We took an application issue and used common Linux tools such as `lsof` and
    `strace` to find the root cause, a port conflict. What is even more important
    is that we did this with no prior knowledge of the application or the tasks it
    was attempting to perform.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个应用程序问题，并使用了常见的Linux工具，如`lsof`和`strace`来找到根本原因，即端口冲突。更重要的是，我们在没有关于应用程序或其尝试执行的任务的先前知识的情况下做到了这一点。
- en: With the example from this chapter, we can easily see how having access to and
    knowledge of basic Linux tools, together with an understanding of the troubleshooting
    process, can enable you to solve almost any issue, whether that issue is an application
    issue or a systems issue.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的示例，我们可以很容易地看到，拥有基本Linux工具的访问权限和知识，再加上对故障排除过程的理解，可以使您能够解决几乎任何问题，无论是应用程序问题还是系统问题。
- en: In the next chapter, we will examine the Linux user and kernel limits, and how
    they can sometimes cause issues.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究Linux用户和内核限制，以及它们有时可能会引起问题。
