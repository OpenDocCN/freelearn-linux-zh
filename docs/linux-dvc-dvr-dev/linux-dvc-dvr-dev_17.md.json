["```\n#include <linux/input.h> \n```", "```\nstruct input_dev { \n  const char *name; \n  const char *phys; \n\n  unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; \n  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; \n  unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; \n  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; \n  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; \n\n  unsigned int repeat_key; \n\n  int rep[REP_CNT]; \n  struct input_absinfo *absinfo; \n  unsigned long key[BITS_TO_LONGS(KEY_CNT)]; \n\n  int (*open)(struct input_dev *dev); \n  void (*close)(struct input_dev *dev); \n\n  unsigned int users; \n  struct device dev; \n\n  unsigned int num_vals; \n  unsigned int max_vals; \n  struct input_value *vals; \n\n  bool devres_managed; \n}; \n```", "```\nset_bit(EV_KEY, my_input_dev->evbit); \nset_bit(EV_REL, my_input_dev->evbit); \n```", "```\nvoid input_set_abs_params(struct input_dev *dev, unsigned int axis, \n\n                             int min, int max, int fuzz, int flat) \n```", "```\n#define ABSMAX_ACC_VAL 0x01FF \n#define ABSMIN_ACC_VAL -(ABSMAX_ACC_VAL) \n[...] \nset_bit(EV_ABS, idev->evbit); \ninput_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \ninput_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \ninput_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \n```", "```\nstruct input_dev *input_allocate_device(void) \nstruct input_dev *devm_input_allocate_device(struct device *dev) \n\nvoid input_free_device(struct input_dev *dev) \nstatic void devm_input_device_unregister(struct device *dev, \n                                         void *res) \nint input_register_device(struct input_dev *dev) \nvoid input_unregister_device(struct input_dev *dev) \n```", "```\nstruct input_dev *idev; \nint error; \n\nidev = input_allocate_device(); \nif (!idev) \n    return -ENOMEM; \n\nidev->name = BMA150_DRIVER; \nidev->phys = BMA150_DRIVER \"/input0\"; \nidev->id.bustype = BUS_I2C; \nidev->dev.parent = &client->dev; \n\nset_bit(EV_ABS, idev->evbit); \ninput_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \ninput_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \ninput_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL, \n                     ABSMAX_ACC_VAL, 0, 0); \n\nerror = input_register_device(idev); \nif (error) { \n    input_free_device(idev); \n    return error; \n} \n\nerror = request_threaded_irq(client->irq, \n            NULL, my_irq_thread, \n            IRQF_TRIGGER_RISING | IRQF_ONESHOT, \n            BMA150_DRIVER, NULL); \nif (error) { \n    dev_err(&client->dev, \"irq request failed %d, error %d\\n\", \n            client->irq, error); \n    input_unregister_device(bma150->input); \n    goto err_free_mem; \n} \n```", "```\nstruct input_polled_dev { \n    void *private; \n\n    void (*open)(struct input_polled_dev *dev); \n    void (*close)(struct input_polled_dev *dev); \n    void (*poll)(struct input_polled_dev *dev); \n    unsigned int poll_interval; /* msec */ \n    unsigned int poll_interval_max; /* msec */ \n    unsigned int poll_interval_min; /* msec */ \n\n    struct input_dev *input; \n\n    bool devres_managed; \n}; \n```", "```\nstruct input_polled_dev *devm_input_allocate_polled_device(struct             device *dev) \nstruct input_polled_dev *input_allocate_polled_device(void) \nvoid input_free_polled_device(struct input_polled_dev *dev) \n```", "```\nint input_register_polled_device(struct input_polled_dev *dev) \nvoid  input_unregister_polled_device(struct input_polled_dev *dev) \n```", "```\nstatic int button_probe(struct platform_device *pdev) \n{ \n    struct my_struct *ms; \n    struct input_dev *input_dev; \n    int retval; \n\n    ms = devm_kzalloc(&pdev->dev, sizeof(*ms), GFP_KERNEL); \n    if (!ms) \n        return -ENOMEM; \n\n    ms->poll_dev = input_allocate_polled_device(); \n    if (!ms->poll_dev){ \n        kfree(ms); \n        return -ENOMEM; \n    } \n\n    /* This gpio is not mapped to IRQ */ \n    ms->reset_btn_desc = gpiod_get(dev, \"reset\", GPIOD_IN); \n\n    ms->poll_dev->private = ms ; \n    ms->poll_dev->poll = my_btn_poll; \n    ms->poll_dev->poll_interval = 200; /* Poll every 200ms */ \n    ms->poll_dev->open = my_btn_open; /* consist */ \n\n    input_dev = ms->poll_dev->input; \n    input_dev->name = \"System Reset Btn\"; \n\n    /* The gpio belong to an expander sitting on I2C */ \n    input_dev->id.bustype = BUS_I2C;  \n    input_dev->dev.parent = &pdev->dev; \n\n    /* Declare the events generated by this driver */ \n    set_bit(EV_KEY, input_dev->evbit); \n    set_bit(BTN_0, input_dev->keybit); /* buttons */ \n\n    retval = input_register_polled_device(mcp->poll_dev); \n    if (retval) { \n        dev_err(&pdev->dev, \"Failed to register input device\\n\"); \n        input_free_polled_device(ms->poll_dev); \n        kfree(ms);   \n    } \n    return retval; \n} \n```", "```\nstruct my_struct { \n    struct gpio_desc *reset_btn_desc; \n    struct input_polled_dev *poll_dev; \n} \n```", "```\nstatic void my_btn_open(struct input_polled_dev *poll_dev) \n{ \n    struct my_strut *ms = poll_dev->private; \n    dev_dbg(&ms->poll_dev->input->dev, \"reset open()\\n\"); \n} \n```", "```\nvoid input_report_abs(struct input_dev *dev, \n                      unsigned int code, int value) \nvoid input_report_key(struct input_dev *dev, \n                      unsigned int code, int value) \nvoid input_report_rel(struct input_dev *dev, \n                      unsigned int code, int value) \n```", "```\nvoid input_sync(struct input_dev *dev) \n```", "```\nstatic void threaded_report_xyz(struct bma150_data *bma150) \n{ \n  u8 data[BMA150_XYZ_DATA_SIZE]; \n  s16 x, y, z; \n  s32 ret; \n\n  ret = i2c_smbus_read_i2c_block_data(bma150->client, \n      BMA150_ACC_X_LSB_REG, BMA150_XYZ_DATA_SIZE, data); \n  if (ret != BMA150_XYZ_DATA_SIZE) \n    return; \n\n  x = ((0xc0 & data[0]) >> 6) | (data[1] << 2); \n  y = ((0xc0 & data[2]) >> 6) | (data[3] << 2); \n  z = ((0xc0 & data[4]) >> 6) | (data[5] << 2); \n\n  /* sign extension */ \n  x = (s16) (x << 6) >> 6; \n  y = (s16) (y << 6) >> 6; \n  z = (s16) (z << 6) >> 6; \n\n  input_report_abs(bma150->input, ABS_X, x); \n  input_report_abs(bma150->input, ABS_Y, y); \n  input_report_abs(bma150->input, ABS_Z, z); \n  /* Indicate this event is complete */ \n  input_sync(bma150->input); \n} \n```", "```\nstatic void my_btn_poll(struct input_polled_dev *poll_dev) \n{ \n    struct my_struct *ms = poll_dev->private; \n    struct i2c_client *client = mcp->client; \n\n    input_report_key(poll_dev->input, BTN_0, \n                     gpiod_get_value(ms->reset_btn_desc) & 1); \n    input_sync(poll_dev->input); \n} \n```", "```\nstruct input_event { \n  struct timeval time; \n  __u16 type; \n  __u16 code; \n  __s32 value; \n} \n```", "```\n#include <unistd.h> \n#include <fcntl.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <linux/input.h> \n#include <sys/select.h> \n\n#define INPUT_DEVICE \"/dev/input/event1\" \n\nint main(int argc, char **argv) \n{    \n    int fd; \n    struct input_event event; \n    ssize_t bytesRead; \n\n    int ret; \n    fd_set readfds; \n\n    fd = open(INPUT_DEVICE, O_RDONLY); \n    /* Let's open our input device */ \n    if(fd < 0){ \n        fprintf(stderr, \"Error opening %s for reading\", INPUT_DEVICE); \n        exit(EXIT_FAILURE); \n    } \n\n    while(1){  \n        /* Wait on fd for input */ \n        FD_ZERO(&readfds); \n        FD_SET(fd, &readfds); \n\n        ret = select(fd + 1, &readfds, NULL, NULL, NULL); \n        if (ret == -1) { \n            fprintf(stderr, \"select call on %s: an error ocurred\", \n                    INPUT_DEVICE); \n            break; \n        } \n        else if (!ret) { /* If we have decided to use timeout */ \n            fprintf(stderr, \"select on %s: TIMEOUT\", INPUT_DEVICE); \n            break; \n        } \n\n        /* File descriptor is now ready */ \n        if (FD_ISSET(fd, &readfds)) { \n            bytesRead = read(fd, &event, \n                             sizeof(struct input_event)); \n            if(bytesRead == -1) \n                /* Process read input error*/ \n            if(bytesRead != sizeof(struct input_event)) \n                /* Read value is not an input even */ \n\n            /*  \n             * We could have done a switch/case if we had \n             * many codes to look for \n             */ \n            if(event.code == BTN_0) { \n                /* it concerns our button */ \n                if(event.value == 0){ \n                    /* Process Release */ \n                    [...] \n                } \n                else if(event.value == 1){ \n                    /* Process KeyPress */ \n                    [...] \n                } \n            } \n        } \n    } \n    close(fd); \n    return EXIT_SUCCESS; \n} \n```", "```\nif(client->irq > 0){ \n    /* Use generic input device */ \n} else { \n    /* Use polled device */ \n} \n```", "```\n#include <linux/kernel.h> \n#include <linux/module.h> \n#include <linux/slab.h> \n#include <linux/of.h>                   /* For DT*/ \n#include <linux/platform_device.h>      /* For platform devices */ \n#include <linux/gpio/consumer.h>        /* For GPIO Descriptor interface */ \n#include <linux/input.h> \n#include <linux/input-polldev.h> \n\nstruct poll_btn_data { \n   struct gpio_desc *btn_gpiod; \n   struct input_polled_dev *poll_dev; \n}; \n\nstatic void polled_btn_open(struct input_polled_dev *poll_dev) \n{ \n    /* struct poll_btn_data *priv = poll_dev->private; */ \n    pr_info(\"polled device opened()\\n\"); \n} \n\nstatic void polled_btn_close(struct input_polled_dev *poll_dev) \n{ \n    /* struct poll_btn_data *priv = poll_dev->private; */ \n    pr_info(\"polled device closed()\\n\"); \n} \n\nstatic void polled_btn_poll(struct input_polled_dev *poll_dev) \n{ \n    struct poll_btn_data *priv = poll_dev->private; \n\n    input_report_key(poll_dev->input, BTN_0, gpiod_get_value(priv->btn_gpiod) & 1); \n    input_sync(poll_dev->input); \n} \n\nstatic const struct of_device_id btn_dt_ids[] = { \n    { .compatible = \"packt,input-polled-button\", }, \n    { /* sentinel */ } \n}; \n\nstatic int polled_btn_probe(struct platform_device *pdev) \n{ \n    struct poll_btn_data *priv; \n    struct input_polled_dev *poll_dev; \n    struct input_dev *input_dev; \n    int ret; \n\n    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL); \n    if (!priv) \n        return -ENOMEM; \n\n    poll_dev = input_allocate_polled_device(); \n    if (!poll_dev){ \n        devm_kfree(&pdev->dev, priv); \n        return -ENOMEM; \n    } \n\n    /* We assume this GPIO is active high */ \n    priv->btn_gpiod = gpiod_get(&pdev->dev, \"button\", GPIOD_IN); \n\n    poll_dev->private = priv; \n    poll_dev->poll_interval = 200; /* Poll every 200ms */ \n    poll_dev->poll = polled_btn_poll; \n    poll_dev->open = polled_btn_open; \n    poll_dev->close = polled_btn_close; \n    priv->poll_dev = poll_dev; \n\n    input_dev = poll_dev->input; \n    input_dev->name = \"Packt input polled Btn\"; \n    input_dev->dev.parent = &pdev->dev; \n\n    /* Declare the events generated by this driver */ \n    set_bit(EV_KEY, input_dev->evbit); \n    set_bit(BTN_0, input_dev->keybit); /* buttons */ \n\n    ret = input_register_polled_device(priv->poll_dev); \n    if (ret) { \n        pr_err(\"Failed to register input polled device\\n\"); \n        input_free_polled_device(poll_dev); \n        devm_kfree(&pdev->dev, priv); \n        return ret; \n    } \n\n    platform_set_drvdata(pdev, priv); \n    return 0; \n} \n\nstatic int polled_btn_remove(struct platform_device *pdev) \n{ \n   struct poll_btn_data *priv = platform_get_drvdata(pdev); \n   input_unregister_polled_device(priv->poll_dev); \n    input_free_polled_device(priv->poll_dev); \n    gpiod_put(priv->btn_gpiod); \n   return 0; \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = polled_btn_probe, \n    .remove     = polled_btn_remove, \n    .driver     = { \n        .name     = \"input-polled-button\", \n        .of_match_table = of_match_ptr(btn_dt_ids),   \n        .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Polled input device\"); \n```", "```\n#include <linux/kernel.h> \n#include <linux/module.h> \n#include <linux/slab.h> \n#include <linux/of.h>                   /* For DT*/ \n#include <linux/platform_device.h>      /* For platform devices */ \n#include <linux/gpio/consumer.h>        /* For GPIO Descriptor interface */ \n#include <linux/input.h> \n#include <linux/interrupt.h> \n\nstruct btn_data { \n   struct gpio_desc *btn_gpiod; \n   struct input_dev *i_dev; \n   struct platform_device *pdev; \n   int irq; \n}; \n\nstatic int btn_open(struct input_dev *i_dev) \n{ \n    pr_info(\"input device opened()\\n\"); \n    return 0; \n} \n\nstatic void btn_close(struct input_dev *i_dev) \n{ \n    pr_info(\"input device closed()\\n\"); \n} \n\nstatic irqreturn_t packt_btn_interrupt(int irq, void *dev_id) \n{ \n    struct btn_data *priv = dev_id; \n\n   input_report_key(priv->i_dev, BTN_0, gpiod_get_value(priv->btn_gpiod) & 1); \n    input_sync(priv->i_dev); \n   return IRQ_HANDLED; \n} \n\nstatic const struct of_device_id btn_dt_ids[] = { \n    { .compatible = \"packt,input-button\", }, \n    { /* sentinel */ } \n}; \n\nstatic int btn_probe(struct platform_device *pdev) \n{ \n    struct btn_data *priv; \n    struct gpio_desc *gpiod; \n    struct input_dev *i_dev; \n    int ret; \n\n    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL); \n    if (!priv) \n        return -ENOMEM; \n\n    i_dev = input_allocate_device(); \n    if (!i_dev) \n        return -ENOMEM; \n\n    i_dev->open = btn_open; \n    i_dev->close = btn_close; \n    i_dev->name = \"Packt Btn\"; \n    i_dev->dev.parent = &pdev->dev; \n    priv->i_dev = i_dev; \n    priv->pdev = pdev; \n\n    /* Declare the events generated by this driver */ \n    set_bit(EV_KEY, i_dev->evbit); \n    set_bit(BTN_0, i_dev->keybit); /* buttons */ \n\n    /* We assume this GPIO is active high */ \n    gpiod = gpiod_get(&pdev->dev, \"button\", GPIOD_IN); \n    if (IS_ERR(gpiod)) \n        return -ENODEV; \n\n    priv->irq = gpiod_to_irq(priv->btn_gpiod); \n    priv->btn_gpiod = gpiod; \n\n    ret = input_register_device(priv->i_dev); \n    if (ret) { \n        pr_err(\"Failed to register input device\\n\"); \n        goto err_input; \n    } \n\n    ret = request_any_context_irq(priv->irq, \n                           packt_btn_interrupt, \n                           (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING), \n                           \"packt-input-button\", priv); \n    if (ret < 0) { \n        dev_err(&pdev->dev, \n            \"Unable to acquire interrupt for GPIO line\\n\"); \n        goto err_btn; \n    } \n\n    platform_set_drvdata(pdev, priv); \n    return 0; \n\nerr_btn: \n    gpiod_put(priv->btn_gpiod); \nerr_input: \n    printk(\"will call input_free_device\\n\"); \n    input_free_device(i_dev); \n    printk(\"will call devm_kfree\\n\"); \n    return ret; \n} \n\nstatic int btn_remove(struct platform_device *pdev) \n{ \n    struct btn_data *priv; \n    priv = platform_get_drvdata(pdev); \n    input_unregister_device(priv->i_dev); \n    input_free_device(priv->i_dev); \n    free_irq(priv->irq, priv); \n    gpiod_put(priv->btn_gpiod); \n    return 0; \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = btn_probe, \n    .remove     = btn_remove, \n    .driver     = { \n    .name     = \"input-button\", \n    .of_match_table = of_match_ptr(btn_dt_ids),   \n    .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Input device (IRQ based)\"); \n```", "```\n# udevadm info /dev/input/event0\n\nP: /devices/platform/input-button.0/input/input0/event0\n\nN: input/event0\n\nS: input/by-path/platform-input-button.0-event\n\nE: DEVLINKS=/dev/input/by-path/platform-input-button.0-event\n\nE: DEVNAME=/dev/input/event0\n\nE: DEVPATH=/devices/platform/input-button.0/input/input0/event0\n\nE: ID_INPUT=1\n\nE: ID_PATH=platform-input-button.0\n\nE: ID_PATH_TAG=platform-input-button_0\n\nE: MAJOR=13\n\nE: MINOR=64\n\nE: SUBSYSTEM=input\n\nE: USEC_INITIALIZED=74842430\n\n```", "```\n# evtest /dev/input/event0\n\ninput device opened()\n\nInput driver version is 1.0.1\n\nInput device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0\n\nInput device name: \"Packt Btn\"\n\nSupported events:\n\nEvent type 0 (EV_SYN)\n\nEvent type 1 (EV_KEY)\n\nEvent code 256 (BTN_0)\n\n```", "```\n$ cat /proc/interrupts | grep packt\n\n160: 0 0 0 0 gpio-mxc 0 packt-input-button\n\n```", "```\n$ cat /sys/kernel/debug/gpio | grep button\n\ngpio-193 (button-gpio ) in hi\n\n$ cat /sys/kernel/debug/gpio | grep button\n\ngpio-193 (button-gpio ) in lo\n\n```"]