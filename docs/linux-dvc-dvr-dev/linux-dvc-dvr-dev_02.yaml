- en: Device Driver Basis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序基础
- en: A driver is a piece of software whose aim is to control and manage a particular
    hardware device; hence the name device driver. From an operating system point
    of view, it can be either in the kernel space (running in privileged mode) or
    in the user space (with lower privilege). This book only deals with kernel space
    drivers, especially Linux kernel drivers. Our definition is a device driver exposes
    the functionality of the hardware to user programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序是一种旨在控制和管理特定硬件设备的软件。因此得名设备驱动程序。从操作系统的角度来看，它可以在内核空间（以特权模式运行）或用户空间（权限较低）中。本书只涉及内核空间驱动程序，特别是Linux内核驱动程序。我们的定义是设备驱动程序向用户程序公开硬件的功能。
- en: 'This book''s aim is not to teach you how to become a Linux guru—I''m not even
    one at all—but there are some concepts you should understand prior to writing
    a device driver. C programming skills are mandatory; you should be at least familiar
    with pointers. You should also be familiar with some of the manipulating functions.
    Some hardware skills are required too. So this chapter essentially discusses:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的不是教你如何成为Linux大师——我自己也不是——但在编写设备驱动程序之前，你应该了解一些概念。C编程技能是必需的；你至少应该熟悉指针。你还应该熟悉一些操作函数。还需要一些硬件技能。因此，本章主要讨论：
- en: Module building processes, as well as their loading and unloading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块构建过程，以及它们的加载和卸载
- en: Driver skeletons, and debugging message management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序骨架和调试消息管理
- en: Error handling in the driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序中的错误处理
- en: User space and kernel space
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间和内核空间
- en: The concept of kernel space and user space is a bit abstract. It is all about
    memory and access rights. One may consider the kernel to be privileged, whereas
    the user apps are restricted. It is a feature of a modern CPU, allowing it to
    operate either in privileged or unprivileged mode. This concept will be clearer
    to you in [Chapter 11](http://post%2011) , *Kernel Memory Management* .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 内核空间和用户空间的概念有点抽象。这一切都与内存和访问权限有关。人们可能认为内核是特权的，而用户应用程序是受限制的。这是现代CPU的一个特性，允许它在特权或非特权模式下运行。这个概念在[第11章](http://post%2011)
    *内核内存管理*中会更清楚。
- en: '![](img/Image00004.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00004.jpg)'
- en: User space and kernel space
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间和内核空间
- en: 'The preceding figure introduces the separation between kernel and user space,
    and highlights the fact that system calls represent the bridge between them (we
    discuss this later in this chapter). One can describe each space as following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图介绍了内核空间和用户空间之间的分离，并强调了系统调用代表它们之间的桥梁（我们稍后在本章讨论这一点）。可以描述每个空间如下：
- en: '**Kernel space:** This is a set of addresses where the kernel is hosted and
    where it runs. Kernel memory (or kernel space) is a memory range, owned by the
    kernel, protected by access flags, preventing any user apps from messing with
    the kernel (un)knowingly. On the other hand the kernel can access the whole system
    memory, since it runs with the higher priority on the system. In kernel mode,
    the CPU can access the whole memory (both kernel space and user space).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核空间：**这是内核托管和运行的一组地址。内核内存（或内核空间）是一段内存范围，由内核拥有，受到访问标志的保护，防止任何用户应用程序无意中干扰内核。另一方面，内核可以访问整个系统内存，因为它以更高的优先级在系统上运行。在内核模式下，CPU可以访问整个内存（包括内核空间和用户空间）。'
- en: '**User space:** This is a set of addresses (locations) where normal programs
    (such as gedit and so on) are restricted to run. You may consider it as a sand-box
    or a jail, so that a user program can''t mess with memory or any other resource
    owned by another program. In user mode, the CPU can only access memory tagged
    with user-space access rights. The only way for the user app to run into the kernel
    space is through system calls. Some of these are `read` , `write` , `open` , `close`
    , `mmap` , and so on. User-space code runs with lower priority. When a process
    performs a system call, a software interrupt is sent to the kernel, which turns
    on privileged mode so that the process can run in kernel space. When the system
    call returns, the kernel turns off the privileged mode and the process is jailed
    again.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间：**这是正常程序（如gedit等）受限制运行的一组地址（位置）。你可以把它看作是一个沙盒或监狱，这样用户程序就不能干扰其他程序拥有的内存或其他资源。在用户模式下，CPU只能访问带有用户空间访问权限标记的内存。用户应用程序运行的优先级较低。当进程执行系统调用时，会向内核发送软件中断，内核会打开特权模式，以便进程可以在内核空间中运行。当系统调用返回时，内核关闭特权模式，进程再次被限制。'
- en: The concept of modules
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的概念
- en: 'A module is to the Linux kernel what a plugin (add-on) is to user software
    (Firefox is an example). It dynamically extends the kernel functionalities without
    even the need to restart the computer. Most of the time, kernel modules are plug
    and play. Once inserted, they are ready to be used. In order to support modules,
    the kernel must have been built with the following option enabled:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块对于Linux内核来说就像插件（Firefox就是一个例子）对于用户软件一样。它动态扩展了内核的功能，甚至不需要重新启动计算机。大多数情况下，内核模块都是即插即用的。一旦插入，它们就可以被使用。为了支持模块，内核必须已经使用以下选项构建：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Module dependencies
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块依赖
- en: In Linux, a module can provide functions or variables, exporting them using
    the `EXPORT_SYMBOL` macro, which makes them available for other modules. These
    are called symbols. A dependency of module B on module A is that module B is using
    one of the symbols exported by module A.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，模块可以提供函数或变量，并使用`EXPORT_SYMBOL`宏导出它们，使它们对其他模块可用。这些被称为符号。模块B对模块A的依赖是，模块B使用了模块A导出的符号之一。
- en: depmod utility
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: depmod实用程序
- en: '`depmod` is a tool that you run during the kernel build process to generate
    module dependency files. It does that by reading each module in `/lib/modules/<kernel_release>/`
    to determine what symbols it should export and what symbols it needs. The result
    of that process is written to the file `modules.dep` , and its binary version
    `modules.dep.bin` . It is a kind of module indexing.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`depmod` 是在内核构建过程中运行的工具，用于生成模块依赖文件。它通过读取`/lib/modules/<kernel_release>/`中的每个模块来确定它应该导出哪些符号以及它需要哪些符号。该过程的结果被写入文件`modules.dep`，以及它的二进制版本`modules.dep.bin`。它是一种模块索引。'
- en: Module loading and unloading
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块加载和卸载
- en: For a module to be operational, one should load it into the kernel, either by
    using `insmod` given the module path as argument, which is the preferred method
    during development, or by using `modprobe` , a clever command but that one prefered
    in production systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模块运行，应该将其加载到内核中，可以使用`insmod`给定模块路径作为参数来实现，这是开发过程中首选的方法，也可以使用`modprobe`，这是一个聪明的命令，但在生产系统中更受欢迎。
- en: Manual loading
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动加载
- en: 'Manual loading needs the intervention of a user, which should have root access.
    The two classical methods to achieve this are described as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 手动加载需要用户的干预，用户应该具有root访问权限。实现这一点的两种经典方法如下所述：
- en: modprobe and insmod
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: modprobe和insmod
- en: 'During development, one usually uses `insmod` in order to load a module and
    it should be given the path of the module to load:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，通常使用`insmod`来加载模块，并且应该给出要加载的模块的路径：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is low-level form of module loading, which forms the base of other module
    loading methods, and the one we will use in this book. On the other hand, there
    is `modprobe` , mostly used by sysadmin or in a production system. `modprobe`
    is a clever command that parses the file `modules.dep` in order to load dependencies
    first, prior to loading the given module. It automatically handles module dependencies,
    as a package manager does:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种低级形式的模块加载，它构成了其他模块加载方法的基础，也是本书中我们将使用的方法。另一方面，有`modprobe`，主要由系统管理员或在生产系统中使用。`modprobe`是一个聪明的命令，它解析文件`modules.dep`以便先加载依赖项，然后再加载给定的模块。它自动处理模块依赖关系，就像软件包管理器一样：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whether one can use `modprobe` or not depends on `depmod` being aware of module
    installation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以使用`modprobe`取决于`depmod`是否知道模块安装。
- en: /etc/modules-load.d/<filename>.conf
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /etc/modules-load.d/<filename>.conf
- en: 'If you want some module to be loaded at boot time, just create the file `/etc/modules-load.d/<filename>.conf`
    , and add the module''s name that should be loaded, one per line. `<filename>`
    should be meaningful to you, and people usually use module: `/etc/modules-load.d/modules.conf`
    . You may create as many `.conf` files as you need:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望某个模块在启动时加载，只需创建文件`/etc/modules-load.d/<filename>.conf`，并添加应该加载的模块名称，每行一个。`<filename>`应该对您有意义，人们通常使用模块：`/etc/modules-load.d/modules.conf`。您可以根据需要创建多个`.conf`文件：
- en: 'An example of `/etc/modules-load.d/mymodules.conf` is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/modules-load.d/mymodules.conf`的一个例子如下：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Auto-loading
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动加载
- en: 'The `depmod` utility doesn''t only build `modules.dep` and `modules.dep.bin`
    files. It does more than that. When a kernel developer actually writes a driver,
    they know exactly what hardware the driver will support. They are then responsible
    for feeding the driver with the product and vendor IDs of all devices supported
    by the driver. `depmod` also processes module files in order to extract and gather
    that information, and generates a `modules.alias` file, located in `/lib/modules/<kernel_release>/modules.alias`
    , which will map devices to their drivers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`depmod`实用程序不仅构建`modules.dep`和`modules.dep.bin`文件。它做的不仅仅是这些。当内核开发人员实际编写驱动程序时，他们确切地知道驱动程序将支持哪些硬件。然后他们负责为驱动程序提供所有受支持设备的产品和供应商ID。`depmod`还处理模块文件以提取和收集这些信息，并生成一个`modules.alias`文件，位于`/lib/modules/<kernel_release>/modules.alias`，它将设备映射到它们的驱动程序：'
- en: 'An excerpt of `modules.alias` is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules.alias`的摘录如下：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this step, you'll need a user-space hot-plug agent (or device manager), usually
    `udev` (or `mdev` ), that will register with the kernel in order to get notified
    when a new device appears.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，您将需要一个用户空间热插拔代理（或设备管理器），通常是`udev`（或`mdev`），它将向内核注册，以便在新设备出现时得到通知。
- en: The notification is done by the kernel, sending the device's description (pid,
    vid, class, device class, device subclass, interface, and all other information
    that may identify a device) to the hot-plug daemon, which in turn calls `modprobe`
    with this information. `modprobe` then parses the `modules.alias` file in order
    to match the driver associated with the device. Before loading the module, `modprobe`
    will look for its dependencies in `module.dep` . If it finds any, the dependencies
    will be loaded prior to the associated module loading; otherwise, the module is
    loaded directly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过发送设备的描述（pid、vid、class、device class、device subclass、interface以及可能标识设备的所有其他信息）来通知，这些信息发送到热插拔守护程序，它再调用`modprobe`来处理这些信息。`modprobe`然后解析`modules.alias`文件以匹配与设备关联的驱动程序。在加载模块之前，`modprobe`将在`module.dep`中查找它的依赖项。如果找到任何依赖项，那么在加载相关模块之前将加载依赖项；否则，模块将直接加载。
- en: Module unload
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块卸载
- en: 'The usual command to unload a module is `rmmod` . One should prefer using this
    to unload a module loaded with `insmod` command. The command should be given the
    module name to unload as a parameter. Module unloading is a kernel feature that
    one can enable or disable, according to the value of the `CONFIG_MODULE_UNLOAD`
    config option. Without this option, one will not be able to unload any module.
    Let us enable module unloading support:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载模块的常用命令是`rmmod`。应该优先使用此命令来卸载使用`insmod`命令加载的模块。应该将模块名称作为参数给出。模块卸载是一个内核功能，可以根据`CONFIG_MODULE_UNLOAD`配置选项的值来启用或禁用。如果没有此选项，将无法卸载任何模块。让我们启用模块卸载支持：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At runtime, the kernel will prevent from unloading modules that may break things,
    even if one asks it to do so. This is because the kernel keeps a reference count
    on module usage, so that it knows whether a module is actually in use or not.
    If the kernel believes it is unsafe to remove a module, it will not. Obviously,
    one can change this behavior:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，内核将阻止卸载可能破坏事物的模块，即使有人要求这样做。这是因为内核保持对模块使用的引用计数，以便它知道模块是否实际上正在使用。如果内核认为移除模块是不安全的，它就不会这样做。显然，人们可以改变这种行为：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding option should be set in the kernel config in order to force module
    unload:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制模块卸载，应该在内核配置中设置前述选项：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the other hand, a higher level command to unload a module in a smart manner
    is `modeprobe -r` , which automatically unloads unused dependencies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以智能方式卸载模块的更高级命令是`modeprobe -r`，它会自动卸载未使用的依赖项：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you may have guessed, it is a really helpful option for developers. Finally,
    one can check whether a module is loaded or not with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这对开发人员来说是一个非常有帮助的选项。最后，可以使用以下命令检查模块是否已加载：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Driver skeletons
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序骨架
- en: 'Let''s consider the following `helloworld` module. It will be the basis for
    our work during the rest of this chapter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下`helloworld`模块。它将成为本章其余部分工作的基础：
- en: helloworld.c
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: helloworld.c
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Module entry and exit point
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块入口和出口点
- en: 'Kernel drivers all have entry and exit points: the former corresponds to the
    function called when the module is loaded (`modprobe` , `insmod` ) and the latter
    is the function executed at module unloading (at `rmmod or modprobe -r` ).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 内核驱动程序都有入口和出口点：前者对应于模块加载时调用的函数（`modprobe`，`insmod`），后者是在模块卸载时执行的函数（在`rmmod`或`modprobe
    -r`中）。
- en: We all remember the `main()` function, which is the entry point for every user-space
    program written in C/C++ that exits when that same function returns. With kernel
    modules, things are different. The entry point can have any name you want, and
    unlike a user-space program that exits when `main()` returns, the exit point is
    defined in another function. All you need to do is to inform the kernel which
    functions should be executed as an entry or exit point. The actual functions `hellowolrd_init`
    and `hellowolrd_exit` could be given any name. The only thing that is actually
    mandatory is to identify them as the corresponding loading and removing functions,
    giving them as parameters to the `module_init()` and `module_exit()` macros.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都记得`main()`函数，它是每个以C/C++编写的用户空间程序的入口点，当该函数返回时程序退出。对于内核模块，情况有所不同。入口点可以有任何你想要的名称，而不像用户空间程序在`main()`返回时退出，出口点是在另一个函数中定义的。你需要做的就是告诉内核哪些函数应该作为入口或出口点执行。实际的函数`hellowolrd_init`和`hellowolrd_exit`可以被赋予任何名称。实际上，唯一强制的是将它们标识为相应的加载和卸载函数，并将它们作为参数传递给`module_init()`和`module_exit()`宏。
- en: To sum up, `module_init()` is used to declare the function that should be called
    when the module is loaded (with `insmod` or `modprobe` ). What is done in the
    initialization function will define the behavior of the module. `module_exit()`
    is used to declare the function that should be called when the module is unloaded
    (with `rmmod` ).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`module_init()`用于声明在加载模块（使用`insmod`或`modprobe`）时应调用的函数。初始化函数中所做的事情将定义模块的行为。`module_exit()`用于声明在卸载模块（使用`rmmod`）时应调用的函数。
- en: Either the `init` function or the `exit` function is run once, right after the
    module is loaded or unloaded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是`init`函数还是`exit`函数，在模块加载或卸载后都只运行一次。
- en: __init and __exit attributes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`__init`和`__exit`属性'
- en: '`__init` and `__exit` are actually kernel macros, defined in `include/linux/init.h`
    , shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init`和`__exit`实际上是内核宏，在`include/linux/init.h`中定义，如下所示：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `__init` keyword tells the linker to place the code in a dedicated section
    into the kernel object file. This section is known in advance to the kernel, and
    freed when the module is loaded and the `init` function finished. This applies
    only to built-in drivers, not to loadable modules. The kernel will run the init
    function of the driver for the first time during its boot sequence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init`关键字告诉链接器将代码放置在内核对象文件的一个专用部分中。这个部分对内核是预先知道的，并且在模块加载和`init`函数完成后被释放。这仅适用于内置驱动程序，而不适用于可加载模块。内核将在其引导序列期间首次运行驱动程序的初始化函数。'
- en: Since the driver cannot be unloaded, its init function will not be called again
    until the next reboot. There is no need to keep references on its init function
    anymore. The same for the `__exit` keyword, whose corresponding code is omitted
    when the module is compiled statically into the kernel, or when module unloading
    support is not enabled, because in both cases, the `exit` function is never called.
    `__exit` has no effect on loadable modules.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于驱动程序无法卸载，其初始化函数直到下次重启之前都不会再次被调用。不再需要保留对其初始化函数的引用。对于`__exit`关键字也是一样，当模块被静态编译到内核中时，或者未启用模块卸载支持时，其对应的代码将被省略，因为在这两种情况下，`exit`函数永远不会被调用。`__exit`对可加载模块没有影响。
- en: 'Let''s spend more time understanding how such attributes work. It is all about
    object files called **Executable and Linkable Format** (**ELF** ). An ELF object
    file is made of various named sections. Some of these are mandatory and form the
    basis of the ELF standard, but one can make up any section one wants and have
    it used by special programs. This is what the kernel does. One can run `objdump
    -h module.ko` in order to print out different sections that constitute the given
    `module.ko` kernel module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花更多时间了解这些属性是如何工作的。这一切都关于名为**可执行和可链接格式**（**ELF**）的对象文件。一个ELF对象文件由各种命名的部分组成。其中一些是强制性的，并且构成了ELF标准的基础，但人们可以创造任何想要的部分，并让特殊程序使用它。这就是内核的做法。可以运行`objdump
    -h module.ko`来打印出构成给定`module.ko`内核模块的不同部分：
- en: '![](img/Image00005.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00005.jpg)'
- en: List of sections of helloworld-params.ko module
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: helloworld-params.ko模块的部分列表
- en: 'Only a few of the sections in the caption are standerd ELF sections:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题中的部分中，只有少数是标准的ELF部分：
- en: '`.text` , also called code, which contains program code'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`，也称为代码，其中包含程序代码'
- en: '`.data` , which contains initialized data, and is also called data segment'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`，其中包含初始化数据，也称为数据段'
- en: '`.rodata` , for read-only data'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata`，用于只读数据'
- en: '`.comment`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.评论`'
- en: Uninitialized data segment, also called **block started by symbol** (**bss**
    )
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化数据段，也称为 **由符号开始的块**（**bss**）
- en: Other sections are added on demand for the kernel purpose.The most important
    for this chapter are **.modeinfo** sections, which store information about the
    modules, and **.init.text** sections, which store code prefixed with the `__init`
    macro.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其他部分是根据内核目的的需求添加的。对于本章来说，最重要的是 **.modeinfo** 部分，它存储有关模块的信息，以及 **.init.text**
    部分，它存储以 `__init` 宏为前缀的代码。
- en: The linker (`ld` on Linux systems), which is a part of binutils, is responsible
    for the placement of symbols (data, code, and so on) in the appropriate section
    in the generated binary in order to be processed by the loader when the program
    is executed. One may customize these sections, change their default location,
    or even add additional sections by providing a linker script, called a **linker
    definition file** (**LDF** ) or **linker definition script** (**LDS** ). Now all
    you have to do is to inform the linker of the symbol placement through compiler
    directives. The GNU C compiler provides attributes for that purpose. In the case
    of the Linux kernel, there is a custom LDS file provided, located in `arch/<arch>/kernel/vmlinux.lds.S`
    . `__init` and `__exit` are then used to mark symbols to be placed onto dedicated
    sections mapped in kernel's LDS files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器（Linux 系统上的 `ld` ）是 binutils 的一部分，负责将符号（数据、代码等）放置在生成的二进制文件的适当部分，以便在程序执行时由加载器处理。可以通过提供链接器脚本（称为
    **链接器定义文件**（**LDF**）或 **链接器定义脚本**（**LDS**））来自定义这些部分，更改它们的默认位置，甚至添加额外的部分。现在，您只需要通过编译器指令通知链接器符号的放置。GNU
    C 编译器提供了用于此目的的属性。在 Linux 内核的情况下，提供了一个自定义的 LDS 文件，位于 `arch/<arch>/kernel/vmlinux.lds.S`
    中。然后使用 `__init` 和 `__exit` 来标记要放置在内核的 LDS 文件中映射的专用部分中的符号。
- en: In conclusion, `__init` and `__exit` are Linux directives (actually macros),
    which wrap the C compiler attribute used for symbol placement. They instruct the
    compiler to put the code they prefix respectively in `.init.text` and `.exit.text`
    sections, even though the kernel can access different object sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`__init` 和 `__exit` 是 Linux 指令（实际上是宏），它们包装了用于符号放置的 C 编译器属性。它们指示编译器将它们分别放置在
    `.init.text` 和 `.exit.text` 部分，即使内核可以访问不同的对象部分。
- en: Module information
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块信息
- en: 'Even without having to read its code, one should be able to gather some information
    (for example, the author(s), parameter(s) description, the license) about a given
    module. A kernel module uses its `.modinfo` section to store informations about
    the module. Any `MODULE_*` macro will update the content of that section with
    the values passed as parameters. Some of these macros are `MODULE_DESCRIPTION()`
    , `MODULE_AUTHOR()` , and `MODULE_LICENSE()` . The real underlying macro provided
    by the kernel to add an entry in the module info section is `MODULE_INFO(tag,
    info)` , which adds generic info of form tag = info. This means a driver author
    could add any free form info they want, such as:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不必阅读其代码，人们也应该能够收集有关给定模块的一些信息（例如作者、参数描述、许可证）。内核模块使用其 `.modinfo` 部分来存储有关模块的信息。任何
    `MODULE_*` 宏都将使用传递的值更新该部分的内容。其中一些宏是 `MODULE_DESCRIPTION()`、`MODULE_AUTHOR()` 和
    `MODULE_LICENSE()`。内核提供的真正底层宏用于在模块信息部分中添加条目是 `MODULE_INFO(tag, info)`，它添加了形式为
    tag = info 的通用信息。这意味着驱动程序作者可以添加任何他们想要的自由形式信息，例如：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One can dump the content of the `.modeinfo` section of a kernel module using
    the `objdump -d -j .modinfo` command on the given module:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `objdump -d -j .modinfo` 命令在给定模块上转储 `.modeinfo` 部分的内容：
- en: '![](img/Image00006.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00006.jpg)'
- en: Content of .modeinfo section of helloworld-params.ko module
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: helloworld-params.ko 模块的 .modeinfo 部分的内容
- en: 'The modinfo section can be seen as the data sheet of the module. The user-space
    tool that actually prints information in a stylized manner is `modinfo` :'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: modinfo 部分可以被视为模块的数据表。实际上以格式化的方式打印信息的用户空间工具是 `modinfo`：
- en: '![](img/Image00007.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00007.jpg)'
- en: modinfo output
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: modinfo 输出
- en: Apart from the custom info one defines, there is standard info one should provide,
    and that the kernel provides macros for; these are license, module author, parameter
    description, module version, and module description.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自定义信息外，还应提供标准信息，内核为此提供了宏；这些是许可证、模块作者、参数描述、模块版本和模块描述。
- en: Licensing
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许可
- en: 'The license is defined in a given module by the `MODULE_LICENSE()` macro:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 许可在给定模块中由 `MODULE_LICENSE()` 宏定义：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The license will define how your source code should be shared (or not) with
    other developers. `MODULE_LICENSE()` tells the kernel what license our module
    is under. It has an effect on your module behavior, since a non GPL-compatible
    license will result in your module not being able to see/use services/functions
    exported by the kernel through the `EXPORT_SYMBOL_GPL()` macro, which shows the
    symbols to GPL-compatible modules only, which is the opposite of `EXPORT_SYMBOL()`
    , which exports functions for modules with any license. Loading a non GPL-compatible
    will also result in a tainted kernel; that means a non-open source or untrusted
    code has been loaded, and you will likely have no support from the community.
    Remember that the module without `MODULE_LICENSE()` is not considered open source
    and will taint the kernel too. The following is an excerpt of `include/linux/module.h`
    , describing the license supported by the kernel:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证将定义您的源代码应如何与其他开发人员共享（或不共享）。`MODULE_LICENSE()`告诉内核我们的模块使用的许可证。它会影响您的模块行为，因为不兼容GPL的许可证将导致您的模块无法看到/使用内核通过`EXPORT_SYMBOL_GPL()`宏导出的服务/函数，该宏仅向兼容GPL的模块显示符号，这与`EXPORT_SYMBOL()`相反，后者为任何许可证的模块导出函数。加载不兼容GPL的模块还将导致内核受到污染；这意味着已加载非开源或不受信任的代码，您可能不会得到社区的支持。请记住，没有`MODULE_LICENSE()`的模块也不被视为开源，并且也会污染内核。以下是`include/linux/module.h`的摘录，描述了内核支持的许可证：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is mandatory for your module to be at least GPL-compatible in order for you
    to enjoy full kernel services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您的模块至少必须与GPL兼容，才能享受完整的内核服务。
- en: Module author(s)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块作者
- en: '`MODULE_AUTHOR()` declares the module''s author(s):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODULE_AUTHOR()`声明模块的作者：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is possible to have more than one author. In this case, each author must
    be declared with `MODULE_AUTHOR()` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有多个作者。在这种情况下，每个作者都必须用`MODULE_AUTHOR()`声明：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Module description
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块描述
- en: '`MODULE_DESCRIPTION()` briefly describes what the module does:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODULE_DESCRIPTION()`简要描述模块的功能：'
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Errors and message printing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误和消息打印
- en: Error codes are interpreted either by the kernel or by the user-space application
    (through the `errno` variable). Error handling is very important in software development,
    more than it is in kernel development. Fortunately, the kernel provides a couple
    of errors that cover almost every error you'll encounter, and sometimes you will
    need to print them out in order to help you debug.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码要么由内核解释，要么由用户空间应用程序（通过`errno`变量）解释。错误处理在软件开发中非常重要，比在内核开发中更重要。幸运的是，内核提供了几个几乎涵盖了你可能遇到的每个错误的错误，并且有时你需要打印它们以帮助你调试。
- en: Error handling
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Return the wrong error code for a given error and it will result in either
    the kernel or user-space app producing unneeded behavior and making a wrong decision.
    To keep things clear, there are predefined errors in the kernel tree that cover
    almost every case you may face. Some of the errors (with their meaning) are defined
    in `include/uapi/asm-generic/errno-base.h` , and the rest of the list can be found
    in `include/uapi/asm-generic/errno.h.` The following is an excerpt of list of
    errors, from `include/uapi/asm-generic/errno-base.h` :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定错误的错误代码将导致内核或用户空间应用程序产生不必要的行为并做出错误的决定。为了保持清晰，内核树中有预定义的错误，几乎涵盖了您可能遇到的每种情况。一些错误（及其含义）在`include/uapi/asm-generic/errno-base.h`中定义，其余列表可以在`include/uapi/asm-generic/errno.h`中找到。以下是`include/uapi/asm-generic/errno-base.h`中错误列表的摘录：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Most of time, the classical way to return an error is to do so in the form
    `return -ERROR` , especially when it comes to answering to system calls. For example,
    for an I/O error, the error code is `EIO` and one should `return -EIO` :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，返回错误的经典方法是以`return -ERROR`的形式返回，特别是当涉及到回答系统调用时。例如，对于I/O错误，错误代码是`EIO`，应该`return
    -EIO`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Errors sometimes cross the kernel space and propagate themselves to the user
    space. If the returned error is an answer to a system call (`open` , `read` ,
    `ioctl` , `mmap` ), the value will be automatically assigned to the user-space
    `errno` global variable, on which one can use `strerror(errno)` to translate the
    error into a readable string:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误有时会跨越内核空间并传播到用户空间。如果返回的错误是对系统调用（`open`，`read`，`ioctl`，`mmap`）的回答，则该值将自动分配给用户空间的`errno`全局变量，可以使用`strerror(errno)`将错误转换为可读字符串：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you face an error, you must undo everything that has been set until the
    error occurs. The usual way to do this is to use the `goto` statement:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到错误时，必须撤消发生错误之前设置的所有操作。通常的做法是使用`goto`语句：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The reason why one uses the `goto` statement is simple. When it comes to handling
    error, let''s say at step 5, one has to clean previous operations (steps 4, 3,
    2, 1). Instead of doing lot of nested checking operation shown as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`goto`语句的原因很简单。当涉及到处理错误时，比如在第5步，必须清理之前的操作（步骤4、3、2、1）。而不是进行大量的嵌套检查操作，如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This may be confusing, and may lead to indentation issues. One prefers using
    the `goto` in order to have a straight control flow, shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，并可能导致缩进问题。人们更喜欢使用`goto`以便有一个直接的控制流，如下所示：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means, one should only use goto to move forward in a function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，应该只使用goto在函数中向前移动。
- en: Handling null pointer errors
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空指针错误
- en: 'When it comes to returning an error from functions that are supposed to return
    a pointer, functions often return the `NULL` pointer. It is a working but quite
    meaningless approach, since one does not exactly know why this null pointer is
    returned. For that purpose, the kernel provides three functions, `ERR_PTR` , `IS_ERR`
    , and `PTR_ERR` :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到从应该返回指针的函数返回错误时，函数经常返回`NULL`指针。这是一种有效但相当无意义的方法，因为人们并不确切知道为什么返回了这个空指针。为此，内核提供了三个函数，`ERR_PTR`，`IS_ERR`和`PTR_ERR`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first actually returns the error value as a pointer. Given a function that
    is likely to `return -ENOMEM` after a failed memory allocation, we have to do
    something like `return ERR_PTR(-ENOMEM);` . The second is used to check whether
    the returned value is a pointer error or not, `if (IS_ERR(foo))` . The last returns
    the actual error code `return PTR_ERR(foo);` . The following is an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实际上将错误值作为指针返回。假设一个函数在失败的内存分配后可能会`return -ENOMEM`，我们必须这样做`return ERR_PTR(-ENOMEM);`。第二个用于检查返回的值是否是指针错误，`if
    (IS_ERR(foo))`。最后返回实际的错误代码`return PTR_ERR(foo);`。以下是一个例子：
- en: 'How to use `ERR_PTR` , `IS_ERR` , and `PTR_ERR` :'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用`ERR_PTR`，`IS_ERR`和`PTR_ERR`：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a plus on error handling, which is also an excerpt of the kernel coding
    style that says: If the name of a function is an action or an imperative command,
    the function should return an error-code integer. If the name is a predicate,
    the function should return a `succeeded` Boolean. For example, `add work` is a
    command, and the `add_work()` function returns `0` for success or `-EBUSY` for
    failure. In the same way, `PCI device present` is a predicate, and the `pci_dev_present()`
    function returns `1` if it succeeds in finding a matching device or `0` if it
    doesn''t.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误处理的一个优点，也是内核编码风格的一部分，其中说：如果函数的名称是一个动作或一个命令，函数应该返回一个错误代码整数。如果名称是一个谓词，函数应该返回一个`succeeded`布尔值。例如，`add
    work`是一个命令，`add_work（）`函数成功返回`0`，失败返回`-EBUSY`。同样，`PCI device present`是一个谓词，`pci_dev_present（）`函数在成功找到匹配设备时返回`1`，如果没有找到则返回`0`。
- en: Message printing – printk()
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息打印 - printk（）
- en: 'The `printk()` is to the kernel what `printf()` is to the user-space. Lines
    written by `printk()` can be displayed through the `dmesg` command. Depending
    on how important the message you need to print is, you can choose between eight
    log-level messages, defined in `include/linux/kern_levels.h` , along with their
    meaning:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk（）`对内核来说就像`printf（）`对用户空间一样。由`printk（）`编写的行可以通过`dmesg`命令显示。根据您需要打印的消息的重要性，您可以在`include/linux/kern_levels.h`中定义的八个日志级别消息之间进行选择，以及它们的含义：'
- en: 'The following is the list of kernel log levels. Each of these levels correspond
    to a number in a string, whose priority is inverted proportional to the value
    of the number. For example, `0` is higher priority:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内核日志级别的列表。这些级别中的每一个都对应于字符串中的一个数字，其优先级与数字的值成反比。例如，`0`是更高的优先级：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code shows how one can print a kernel message along with a log
    level:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何打印内核消息以及日志级别：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you omit the debug level (`printk("This is an error\n")` ), the kernel will
    provide one to the function, depending on the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL`
    config option, which is the default kernel log level. One may actually use one
    of the following, much more meaningful macros, which are wrappers around those
    defined previously: `pr_emerg` , `pr_alert` , `pr_crit` , `pr_err` , `pr_warning`
    , `pr_notice` , `pr_info` , and `pr_debug` :'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略调试级别（`printk("This is an error\n")`），内核将根据`CONFIG_DEFAULT_MESSAGE_LOGLEVEL`配置选项为函数提供一个调试级别，这是默认的内核日志级别。实际上可以使用以下更有意义的宏之一，它们是对先前定义的宏的包装器：`pr_emerg`，`pr_alert`，`pr_crit`，`pr_err`，`pr_warning`，`pr_notice`，`pr_info`和`pr_debug`：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For new drivers, it is recommended to use these wrappers. The reality of `printk()`
    is that, whenever it is called, the kernel compares the message log level with
    the current console log level; if the former is higher (lower value) than the
    latter, the message will be immediately printed to the console. You can check
    your log level parameters with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新驾驶员，建议使用这些包装器。 `printk（）`的现实是，每当调用它时，内核都会将消息日志级别与当前控制台日志级别进行比较；如果前者较高（值较低）则消息将立即打印到控制台。您可以使用以下命令检查日志级别参数：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, the first value is the current log level (4), and the second is
    the default one, according to the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL` option. Other
    values are not relevant for the purpose of this chapter, so let us ignore these.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，第一个值是当前日志级别（4），第二个值是默认值，根据`CONFIG_DEFAULT_MESSAGE_LOGLEVEL`选项。其他值对于本章的目的并不重要，因此让我们忽略这些。
- en: 'A list of kernel log levels is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 内核日志级别列表如下：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The current log level can be changed with:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当前日志级别可以通过以下更改：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`printk()` never blocks and is safe enough to be called even from atomic contexts.
    It tries to lock the console and print the message. If locking fails, the output
    will be written into a buffer and the function will return, never blocking. The
    current console holder will then be notified about new messages and will print
    them before releasing the console.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk（）`永远不会阻塞，并且即使从原子上下文中调用也足够安全。它会尝试锁定控制台并打印消息。如果锁定失败，输出将被写入缓冲区，函数将返回，永远不会阻塞。然后当前控制台持有者将收到有关新消息的通知，并在释放控制台之前打印它们。'
- en: The kernel supports other debug methods too, either dynamically or by using
    `#define DEBUG` on top of the file. People interested in such debugging style
    can refer to kernel documentation in *Documentation/dynamic-debug-howto.txt* file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还支持其他调试方法，可以动态使用`#define DEBUG`或在文件顶部使用`#define DEBUG`。对此类调试风格感兴趣的人可以参考内核文档中的*Documentation/dynamic-debug-howto.txt*文件。
- en: Module parameters
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块参数
- en: 'As a user program does, a kernel module can accept arguments from the command
    line. This allows dynamically changing the behavior of the module according to
    given parameters, and can help the developer not having to indefinitely change/compile
    the module during a test/debug session. In order to set this up, one should first
    declare the variables that will hold the values of command line arguments, and
    use the `module_param()` macro on each of these. The macro is defined in `include/linux/moduleparam.h`
    (this should be included in the code too: `#include <linux/moduleparam.h>` ) shown
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户程序一样，内核模块可以从命令行接受参数。这允许根据给定的参数动态更改模块的行为，并且可以帮助开发人员在测试/调试会话期间不必无限制地更改/编译模块。为了设置这一点，首先应该声明将保存命令行参数值的变量，并对每个变量使用`module_param()`宏。该宏在`include/linux/moduleparam.h`中定义（代码中也应该包括：`#include
    <linux/moduleparam.h>`），如下所示：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This macro contains the following elements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏包含以下元素：
- en: '`name` : The name of the variable used as the parameter'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：用作参数的变量的名称'
- en: '`type` : The parameter''s type (bool, charp, byte, short, ushort, int, uint,
    long, ulong), where `charp` stands for char pointer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：参数的类型（bool、charp、byte、short、ushort、int、uint、long、ulong），其中`charp`代表char指针'
- en: '`perm` : This represents the `/sys/module/<module>/parameters/<param>` file
    permissions. Some of them are `S_IWUSR` , `S_IRUSR` , `S_IXUSR` , `S_IRGRP` ,
    `S_WGRP` , and `S_IRUGO` , where:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perm`：这表示`/sys/module/<module>/parameters/<param>`文件的权限。其中一些是`S_IWUSR`，`S_IRUSR`，`S_IXUSR`，`S_IRGRP`，`S_WGRP`和`S_IRUGO`，其中：'
- en: '`S_I` is just a prefix'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S_I`只是一个前缀'
- en: '`R` : read, `W` : write, `X` : execute'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：读取，`W`：写入，`X`：执行'
- en: '`USR` : user, `GRP` : group, `UGO` : user, group, others'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USR`：用户，`GRP`：组，`UGO`：用户，组，其他人'
- en: One can eventually use a `|` (OR operation) to set multiple permissions. If
    perm is `0` , the file parameter in `sysfs` will not be created. You should use
    only `S_IRUGO` read-only parameters, which I highly recommend; by making a `|`
    (OR) with other properties, you can obtain fine-grained properties.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终可以使用`|`（或操作）来设置多个权限。如果perm为`0`，则`sysfs`中的文件参数将不会被创建。您应该只使用`S_IRUGO`只读参数，我强烈建议；通过与其他属性进行`|`（或）运算，可以获得细粒度的属性。
- en: 'When using module parameters, one should use `MODULE_PARM_DESC` in order to
    describe each of them. This macro will populate the module info section with each
    parameter''s description. The following is a sample, from the `helloworld-params.c`
    source file provided with the code repository of the book:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块参数时，应该使用`MODULE_PARM_DESC`来描述每个参数。这个宏将在模块信息部分填充每个参数的描述。以下是一个示例，来自书籍的代码库中提供的`helloworld-params.c`源文件：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To load the module and feed our parameter, we do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载模块并传递我们的参数，我们需要执行以下操作：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One could have used `modinfo` prior to loading the module in order to display
    description of parameters supported by the module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载模块之前，可以使用`modinfo`来显示模块支持的参数的描述：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Building your first module
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个模块
- en: There are two places to build a module. It depends on whether you want people
    to enable the module by themselves or not using the kernel config interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个地方可以构建一个模块。这取决于您是否希望人们使用内核配置界面自行启用模块。
- en: The module's makefile
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的makefile
- en: A makefile is a special file used to execute a set of actions, among which the
    most important is the compilation of programs. There is a dedicated tool to parse
    makefiles, called `make` . Prior to jumping to the description of the whole make
    file, let us introduce the `obj-<X>` kbuild variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile是一个特殊的文件，用于执行一系列操作，其中最重要的是编译程序。有一个专门的工具来解析makefile，叫做`make`。在跳转到整个make文件的描述之前，让我们介绍`obj-<X>`
    kbuild变量。
- en: 'In almost every kernel makefile, one will see at least one instance of an `obj<-X>`
    variable. This actually corresponds to the `obj-<X>` pattern, where `<X>` should
    be either `y` , `m` , left blank, or `n` . This is used by the kernel makefile
    from the head of the kernel build system in a general manner. These lines define
    the files to be built, any special compilation options, and any subdirectories
    to be entered recursively. A simple example is:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个内核makefile中，都会看到至少一个`obj<-X>`变量的实例。这实际上对应于`obj-<X>`模式，其中`<X>`应该是`y`，`m`，留空，或`n`。这是由内核makefile从内核构建系统的头部以一般方式使用的。这些行定义要构建的文件、任何特殊的编译选项以及要递归进入的任何子目录。一个简单的例子是：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This tells kbuild that there is one object in the current directory named `mymodule.o`
    . `mymodule.o` will be built from `mymodule.c` or `mymodule.S` . How and if `mymodule.o`
    will be built or linked depends on the value of `<X>` :'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉kbuild当前目录中有一个名为`mymodule.o`的对象。`mymodule.o`将从`mymodule.c`或`mymodule.S`构建。`mymodule.o`将如何构建或链接取决于`<X>`的值：
- en: If `<X>` is set to `m` , the variable `obj-m` is used, and `mymodule.o` will
    be built as a module.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<X>`设置为`m`，则使用变量`obj-m`，`mymodule.o`将作为一个模块构建。
- en: If `<X>` is set to `y` , the variable `obj-y` is used, and `mymodule.o` will
    be built as part of the kernel. One then says foo is a built-in module.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<X>`设置为`y`，则使用变量`obj-y`，`mymodule.o`将作为内核的一部分构建。然后说foo是一个内置模块。
- en: If `<X>` is set to `n` , the variable `obj-m` is used, and `mymodule.o` will
    not be built at all.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<X>`设置为`n`，则使用变量`obj-m`，`mymodule.o`将根本不会被构建。
- en: 'Therefore, the pattern `obj-$(CONFIG_XXX)` is often used, where `CONFIG_XXX`
    is a kernel config option, set or not during the kernel configuration process.
    An example is:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常使用`obj-$(CONFIG_XXX)`模式，其中`CONFIG_XXX`是内核配置选项，在内核配置过程中设置或不设置。一个例子是：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`$(CONFIG_MYMODULE)` evaluates to either `y` or `m` according to its value
    during the kernel configuration (remember `make menuconfig` ). If `CONFIG_MYMODULE`
    is neither `y` nor `m` , then the file will not be compiled nor linked. `y` means
    built-in (it stands for yes in the kernel config process), and `m` stands for
    module. `$(CONFIG_MYMODULE)` pulls the right answer from the normal config process.
    This is explained in the next section.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(CONFIG_MYMODULE)`根据内核配置过程中的值评估为`y`或`m`。如果`CONFIG_MYMODULE`既不是`y`也不是`m`，则文件将不会被编译或链接。`y`表示内置（在内核配置过程中代表是），`m`代表模块。`$(CONFIG_MYMODULE)`从正常配置过程中获取正确的答案。这将在下一节中解释。'
- en: 'The last use case is:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个用例是：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This means that kbuild should go into the directory named `somedir` ; look for
    any makefile inside and process it in order to decide what objects should be built.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着kbuild应进入名为`somedir`的目录；查找其中的任何makefile并处理它，以决定应构建哪些对象。
- en: 'Back to the makefile, the following is the content makefile we will use to
    build each of the modules introduced in the book:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回到makefile，以下是我们将用于构建书中介绍的每个模块的内容makefile：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`obj-m := hellowolrd.o` : `obj-m` lists modules we want to build. For each
    `<filename>.o` , the build system will look for a `<filename>.c` to build. `obj-m`
    is used to build a module, whereas `obj-y` will result in a built-in object.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj-m := hellowolrd.o`：`obj-m`列出我们要构建的模块。对于每个`<filename>.o`，构建系统将寻找一个`<filename>.c`进行构建。`obj-m`用于构建模块，而`obj-y`将导致内置对象。'
- en: '`KERNELDIR := /lib/modules/$(shell uname -r)/build` : `KERNELDIR` is the location
    of the prebuilt kernel source. As we said earlier, we need a prebuilt kernel in
    order to build any module. If you have built your kernel from the source, one
    should set this variable with the absolute path of the built source directory.
    `-C` instructs to make utility to change into the specified directory prior to
    reading the makefiles or doing anything else.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERNELDIR := /lib/modules/$(shell uname -r)/build`：`KERNELDIR`是预构建内核源的位置。正如我们之前所说，我们需要预构建的内核才能构建任何模块。如果您已经从源代码构建了内核，则应将此变量设置为构建源目录的绝对路径。`-C`指示make实用程序在读取makefile或执行其他任何操作之前切换到指定的目录。'
- en: '`M=$(shell pwd)` : This is relevant to the kernel build system. The kernel
    Makefile uses this variable to locate the directory of the external module to
    build. Your .c files should be placed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M=$(shell pwd)`：这与内核构建系统有关。内核Makefile使用此变量来定位要构建的外部模块的目录。您的`.c`文件应放置在这里。'
- en: '`all default: modules` : This line instructs the `make` utility to execute
    the `modules` target, whether `all` or `default` targets, which are classical
    targets when it comes to building user apps. In other words, `make default` or
    `make all` or simply `make` commands will be translated into `make modules` .'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all default: modules`：此行指示`make`实用程序执行`modules`目标，无论是`all`还是`default`目标，这些都是在构建用户应用程序时的经典目标。换句话说，`make
    default`或`make all`或简单地`make`命令将被转换为`make modules`。'
- en: '`modules modules_install help clean:` : This line represents the list target
    valid in this Makefile .'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules modules_install help clean：`：此行表示此Makefile中有效的列表目标。'
- en: '`$(MAKE) -C $(KERNELDIR ) M=$(shell pwd) $@` : This is the rule to be executed
    for each target enumerated above. `$@` will be replaced with the name of the target
    that caused the rule to run. In other words, if one calls make modules, `$@` will
    be replaced with modules, and the rule will become: `$(MAKE) -C $(KERNELDIR )
    M=$(shell pwd) module` .'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(MAKE) -C $(KERNELDIR ) M=$(shell pwd) $@`：这是要为上述每个目标执行的规则。`$@`将被替换为导致规则运行的目标的名称。换句话说，如果调用make
    modules，`$@`将被替换为modules，规则将变为：`$(MAKE) -C $(KERNELDIR ) M=$(shell pwd) module`。'
- en: In the kernel tree
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核树中
- en: Before you can build your driver in the kernel tree, you should first identify
    which directory in drivers should host your `.c` file. Given your file name `mychardev.c`
    , which contains the source code of your special character driver, it should be
    placed to the `drivers/char` directory in the kernel source. Every subdirectory
    in drivers has both `Makefile` and `Kconfig` files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核树中构建驱动程序之前，您应首先确定驱动程序应放置在哪个驱动程序目录中的`.c`文件。给定您的文件名`mychardev.c`，其中包含您的特殊字符驱动程序的源代码，它应放置在内核源中的`drivers/char`目录中。驱动程序中的每个子目录都有`Makefile`和`Kconfig`文件。
- en: 'Add the following content to the `Kconfig` of that directory:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到该目录的`Kconfig`中：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the makefile of that same directory, add:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录的makefile中添加：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Be careful when updating the `Makefile` ; the `.o` file name must match the
    exact name of your `.c` file. If your source file is `foobar.c,` you must use
    `foobar.o` in the `Makefile` . In order to have your driver built as a module,
    add the following line in your board defconfig in the `arch/arm/configs` directory:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Makefile`时要小心；`.o`文件名必须与您的`.c`文件的确切名称匹配。如果您的源文件是`foobar.c`，则必须在`Makefile`中使用`foobar.o`。为了使您的驱动程序作为模块构建，将以下行添加到`arch/arm/configs`目录中的板defconfig中：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You may also run `make menuconfig` to select it from the UI, and run `make`
    , to build the kernel, then `make modules` to build modules (including yours).
    To make the driver be built in, just replace `m` with `y` :'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行`make menuconfig`从UI中选择它，并运行`make`构建内核，然后运行`make modules`构建模块（包括您自己的模块）。要使驱动程序内置构建，只需用`y`替换`m`：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Everything described here is what embedded board manufacturers do in order
    to provide a **Board Support Package** (**BSP** ) with their board, with a kernel
    that already contains their custom drivers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的一切都是嵌入式板制造商为了提供带有他们的板的**BSP**（**Board Support Package**）而做的，其中包含已经包含他们自定义驱动程序的内核：
- en: '![](img/Image00008.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00008.jpg)'
- en: packt_dev module in kernel tree
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 内核树中的packt_dev模块
- en: Once configured, you can build the kernel with `make` and build modules with
    `make modules` .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，您可以使用`make`构建内核，并使用`make modules`构建模块。
- en: 'Modules included in the kernel source tree are installed in `/lib/modules/$(KERNELRELEASE)/kernel/`
    . On your Linux system, it is `/lib/modules/$(uname -r)/kernel/` . Run the following
    command in order to install the modules:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在内核源树中的模块将安装在`/lib/modules/$(KERNELRELEASE)/kernel/`中。在您的Linux系统上，它是`/lib/modules/$(uname
    -r)/kernel/`。运行以下命令以安装模块：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Out of the tree
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树外
- en: 'Before you can build an external module, you need to have a complete and precompiled
    kernel source-tree. The kernel source-tree version must be the same as the kernel
    you''ll load and use your module with. There are two ways to obtain a prebuilt
    kernel version:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建外部模块之前，您需要拥有完整的预编译内核源代码树。内核源代码树的版本必须与您将加载和使用模块的内核相同。获取预构建内核版本有两种方法：
- en: Build it by yourself (discussed this earlier)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自行构建（之前讨论过）
- en: Install the `linux-headers-*` package from your distribution repository
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的发行版存储库安装`linux-headers-*`软件包
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will install only headers, not the whole source tree. Headers will then
    be installed in `/usr/src/linux-headers-$(uname -r)` . On my computer, it is `/usr/src/linux-headers-4.4.0-79-generic/`
    . There will be a symlink, `/lib/modules/$(uname -r)/build` , pointing to the
    previously installed headers. It is the path you should specify as your kernel
    directory in your `Makefile` . It is all you have to do for a prebuilt kernel.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只安装头文件，而不是整个源代码树。然后，头文件将安装在`/usr/src/linux-headers-$(uname -r)`中。在我的计算机上，它是`/usr/src/linux-headers-4.4.0-79-generic/`。将会有一个符号链接，`/lib/modules/$(uname
    -r)/build`，指向先前安装的头文件。这是您应该在`Makefile`中指定为内核目录的路径。这是您为预构建内核所需做的一切。
- en: Building the module
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块
- en: 'Now, when you are done with your makefile, just change to your source directory
    and run the `make` command, or `make modules` :'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您完成了您的makefile，只需切换到您的源目录并运行`make`命令，或者`make modules`：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding example only dealt with native builds, compiling on an x86 machine
    for an x86 machine. What about cross-compilation ? This is the process by which
    one compiles on machine A, called host, a code that is intended to run on machine
    B, called target; host and target having different architectures. The classical
    use case is to build on an x86 machine a code that should run on an ARM architecture,
    which is exactly our situation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子只涉及本地构建，在x86机器上为x86机器进行编译。那么交叉编译呢？这是指在A机器上（称为主机）编译旨在在B机器上（称为目标机）运行的代码的过程；主机和目标机具有不同的架构。经典用例是在x86机器上构建应在ARM架构上运行的代码，这恰好是我们的情况。
- en: 'When it comes to crosscompiling a kernel module, there are essentially two
    variables the kernel makefile needs to be aware of; these are: `ARCH` and `CROSS_COMPILE`
    , which respectively represent the target architecture and the compiler prefix
    name. So what change between native compilation and cross compilation of a kernel
    module is the `make` command. The following is the line to build for ARM:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及交叉编译内核模块时，内核makefile需要了解的基本上有两个变量；这些是：`ARCH`和`CROSS_COMPILE`，分别代表目标架构和编译器前缀名称。因此，本地编译和交叉编译内核模块之间的变化是`make`命令。以下是为ARM构建的命令行：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed you the basics of driver development and explained the concept
    of module/built-in devices, as well as their loading and unloading. Even if you
    are not able to interact with the user space, you are ready to write a complete
    driver, print a formatted message, and understand the concept of `init` /`exit`
    . The next chapter will deal with character devices, with which you will be able
    to target enhanced features, write code accessible from the user space, and have
    a significant impact on the system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了驱动程序开发的基础知识，并解释了模块/内置设备的概念，以及它们的加载和卸载。即使您无法与用户空间交互，您也可以准备编写完整的驱动程序，打印格式化消息，并理解`init`/`exit`的概念。下一章将涉及字符设备，您将能够针对增强功能编写代码，编写可从用户空间访问的代码，并对系统产生重大影响。
