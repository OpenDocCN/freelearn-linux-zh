["```\n...\n#define NFORKS 60000\nvoid do_nothing()\n{\n  unsigned long f = 0xb00da;\n}\nint main(void)\n{\n  int pid, j, status;\n\n  for (j = 0; j < NFORKS; j++) {\n        switch (pid = fork()) {\n        case -1:\n              FATAL(\"fork failed! [%d]\\n\", pid);\n        case 0: // Child process\n              do_nothing();\n              exit(EXIT_SUCCESS);\n        default: // Parent process\n              waitpid(pid, &status, 0);\n        }\n  }\n  exit(EXIT_SUCCESS);\n}\n```", "```\n$ time ./fork_test \n\nreal    0m10.993s\nuser    0m7.436s\nsys     0m2.969s\n$ \n```", "```\n$ time ./pthread_test \n\nreal    0m3.584s\nuser    0m0.379s\nsys     0m2.704s\n$ \n```", "```\n$ perf stat ./fork_test\n\n Performance counter stats for './fork_test':\n\n       9054.969497 task-clock (msec)      # 0.773 CPUs utilized \n            61,245 context-switches       # 0.007 M/sec \n               202 cpu-migrations         # 0.022 K/sec \n         15,00,063 page-faults            # 0.166 M/sec \n   <not supported> cycles \n   <not supported> instructions \n   <not supported> branches \n   <not supported> branch-misses \n\n      11.714134973 seconds time elapsed\n$ \n```", "```\n$ perf stat ./pthread_test\n\n Performance counter stats for './pthread_test':\n\n       2377.866371 task-clock (msec)        # 0.587 CPUs utilized \n            60,887 context-switches         # 0.026 M/sec \n               117 cpu-migrations           # 0.049 K/sec \n                69 page-faults              # 0.029 K/sec \n   <not supported> cycles \n   <not supported> instructions \n   <not supported> branches \n   <not supported> branch-misses \n\n       4.052964938 seconds time elapsed\n$ \n```", "```\n$ cd <linux-4.17-kernel-src-dir>\n$ perf stat make V=0 -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- allscripts/kconfig/conf --syncconfig Kconfig\n  CHK include/config/kernel.release\n  SYSHDR arch/arm/include/generated/uapi/asm/unistd-oabi.h\n  SYSHDR arch/arm/include/generated/uapi/asm/unistd-common.h\n  WRAP arch/arm/include/generated/uapi/asm/bitsperlong.h\n  WRAP arch/arm/include/generated/uapi/asm/bpf_perf_event.h\n  WRAP arch/arm/include/generated/uapi/asm/errno.h\n[...]                  *<< lots of output >>* \n  CC arch/arm/boot/compressed/string.o\n  AS arch/arm/boot/compressed/hyp-stub.o\n  AS arch/arm/boot/compressed/lib1funcs.o\n  AS arch/arm/boot/compressed/ashldi3.o\n  AS arch/arm/boot/compressed/bswapsdi2.o\n  AS arch/arm/boot/compressed/piggy.o\n  LD arch/arm/boot/compressed/vmlinux\n  OBJCOPY arch/arm/boot/zImage\n  Kernel: arch/arm/boot/zImage is ready\n\n Performance counter stats for 'make V=0 -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all':\n\n    1174027.949123 task-clock (msec) # 1.717 CPUs utilized \n          3,80,189 context-switches  # 0.324 K/sec \n             7,921 cpu-migrations    # 0.007 K/sec \n       2,13,51,434 page-faults       # 0.018 M/sec \n   <not supported> cycles \n   <not supported> instructions \n   <not supported> branches \n   <not supported> branch-misses \n\n 683.798578130 seconds time elapsed\n$ ls -lh <...>/linux-4.17/arch/arm/boot/zImage \n-rwxr-xr-x 1 seawolf seawolf 4.0M Aug 13 13:10  <...>/zImage*\n$ ls -lh <...>/linux-4.17/vmlinux\n-rwxr-xr-x 1 seawolf seawolf 103M Aug 13 13:10  <...>/vmlinux*\n$ \n```", "```\n$ ps -LA\n[...]\n11204 11204 pts/0 00:00:00 make\n11227 11227 pts/0 00:00:00 sh\n11228 11228 pts/0 00:00:00 arm-linux-gnuea\n11229 11229 pts/0 00:00:01 cc1\n11242 11242 pts/0 00:00:00 sh\n11243 11243 pts/0 00:00:00 arm-linux-gnuea\n11244 11244 pts/0 00:00:00 cc1\n11249 11249 pts/0 00:00:00 sh\n11250 11250 pts/0 00:00:00 arm-linux-gnuea\n11251 11251 pts/0 00:00:00 cc1\n11255 11255 pts/0 00:00:00 sh\n11256 11256 pts/0 00:00:00 arm-linux-gnuea\n11257 11257 pts/0 00:00:00 cc1\n[...]\n$ \n```", "```\n$ cd <linux-4.17-kernel-src-dir>\n$ perf stat make V=0 -j1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all\nscripts/kconfig/conf --syncconfig Kconfig\n  SYSHDR arch/arm/include/generated/uapi/asm/unistd-common.h\n  SYSHDR arch/arm/include/generated/uapi/asm/unistd-oabi.h\n  SYSHDR arch/arm/include/generated/uapi/asm/unistd-eabi.h\n  CHK include/config/kernel.release\n  UPD include/config/kernel.release\n  WRAP arch/arm/include/generated/uapi/asm/bitsperlong.h\n\n[...]                  *<< lots of output >>*\n\n  CC crypto/hmac.mod.o\n  LD [M] crypto/hmac.ko\n  CC crypto/jitterentropy_rng.mod.o\n  LD [M] crypto/jitterentropy_rng.ko\n  CC crypto/sha256_generic.mod.o\n  LD [M] crypto/sha256_generic.ko\n  CC drivers/video/backlight/lcd.mod.o\n  LD [M] drivers/video/backlight/lcd.ko\n\n Performance counter stats for 'make V=0 -j1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all':\n\n    1031535.713905 task-clock (msec) # 0.837 CPUs utilized \n          1,78,172 context-switches # 0.173 K/sec \n                 0 cpu-migrations # 0.000 K/sec \n       2,13,29,573 page-faults # 0.021 M/sec \n   <not supported> cycles \n   <not supported> instructions \n   <not supported> branches \n   <not supported> branch-misses \n\n    1232.146348757 seconds time elapsed\n$ \n```", "```\n$ vmstat 3\nprocs --------memory----------- --swap-- --io-- -system-- ------cpu-----\n r b  swpd   free   buff  cache  si so  bi  bo   in   cs  us sy id wa st\n 0 0 287332 664156 719032 6168428 1 2  231  141   73   22 23 16 60  1  0\n 0 0 287332 659440 719056 6170132 0 0    0  124 2878 2353  5  5 89  1  0\n 1 0 287332 660388 719064 6168484 0 0    0  104 2862 2224  4  5 90  0  0\n 0 0 287332 662116 719072 6170276 0 0    0  427 2922 2257  4  6 90  1  0\n 0 0 287332 662056 719080 6170220 0 0    0   12 2358 1984  4  5 91  0  0\n 0 0 287332 660876 719096 6170544 0 0    0   88 2971 2293  5  6 89  1  0\n 0 0 287332 660908 719104 6170520 0 0    0   24 2982 2530  5  6 89  0  0\n[...]\n```", "```\n$ getconf GNU_LIBPTHREAD_VERSION\nNPTL 2.27\n$ \n```", "```\n#include <pthread.h>\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                void *(*start_routine) (void *), void *arg);\n```", "```\n[...]\n#include <pthread.h>\n#include \"../common.h\"\n#define NTHREADS 3\n\nvoid * worker(void *data)\n{\n      long datum = (long)data;\n      printf(\"Worker thread #%ld says: hello, world.\\n\", datum);\n      printf(\" #%ld: work done, exiting now\\n\", datum);\n}\n\nint main(void)\n{\n      long i;\n      int ret;\n      pthread_t tid;\n\n      for (i = 0; i < NTHREADS; i++) {\n            ret = pthread_create(&tid, NULL, worker, (void *)i);\n            if (ret)\n                  FATAL(\"pthread_create() failed! [%d]\\n\", ret);\n      }\n      exit(EXIT_SUCCESS);\n}\n```", "```\nCC := gcc\nCFLAGS=-O2 -Wall -UDEBUG -pthread\nLINKIN := -pthread\n\n#--- Target :: pthreads1\npthreads1.o: pthreads1.c\n    ${CC} ${CFLAGS} -c pthreads1.c -o pthreads1.o\npthreads1: common.o pthreads1.o\n    ${CC} -o pthreads1 pthreads1.o common.o ${LINKIN}\n```", "```\n$ for i in $(seq 1 5); do echo \"trial run #$i:\" ; ./pthreads1; done trial run #1:\nWorker thread #0 says: hello, world.\nWorker thread #0 says: hello, world.\ntrial run #2:\nWorker thread #0 says: hello, world.\nWorker thread #0 says: hello, world.\n #0: work done, exiting now\ntrial run #3:\nWorker thread #1 says: hello, world.\nWorker thread #1 says: hello, world.\n #1: work done, exiting now\ntrial run #4:\ntrial run #5: $ \n```", "```\n#include <pthread.h>\n void pthread_exit(void *retval);\n```", "```\nvoid * worker(void *data)\n{\n      long datum = (long)data;\n      printf(\"Worker thread #%ld running ...\\n\", datum);\n      printf(\"#%ld: work done, exiting now\\n\", datum);\n      pthread_exit(NULL);\n}\n[...]\n  for (i = 0; i < NTHREADS; i++) {\n        ret = pthread_create(&tid, NULL, worker, (void *)i);\n        if (ret)\n              FATAL(\"pthread_create() failed! [%d]\\n\", ret);\n  }\n#if 1\n pthread_exit(NULL);\n#else\n      exit(EXIT_SUCCESS);\n#endif\n[...]\n```", "```\n$ ./pthreads2 \nWorker thread #0 running ...\n#0: work done, exiting now\nWorker thread #1 running ...\n#1: work done, exiting now\nWorker thread #2 running ...\n#2: work done, exiting now\n$ \n```", "```\n[...]\nvoid * worker(void *data)\n{\n      long datum = (long)data;\n      printf(\"Worker thread #%ld running ...\\n\", datum);\n      sleep(3);\n      printf(\"#%ld: work done, exiting now\\n\", datum);\n      pthread_exit(NULL);\n}\n[...]\n```", "```\n$ ./pthreads3 \nWorker thread #0 running ...\nWorker thread #1 running ...\nWorker thread #2 running ...\n *[... All three threads sleep for 3s ...]*\n\n#1: work done, exiting now\n#0: work done, exiting now\n#2: work done, exiting now\n$ \n```", "```\n$ ./pthreads2 \nWorker thread #0 running ...\n#0: work done, exiting now\nWorker thread #2 running ...\n#2: work done, exiting now\nWorker thread #1 running ...\n#1: work done, exiting now\n$ \n```", "```\n#include <pthread.h>\n#define NTHREADS 3\n[...]\n\nint main(void)\n{\n  [...]\n for (i = 0; i < NTHREADS; i++) {\n        ret = pthread_create(&tid, NULL, worker, (void *)i);\n        if (ret)\n              FATAL(\"pthread_create() failed! [%d]\\n\", ret);\n  }\n[...]\n```", "```\n$ ulimit -u\n63223\n$ \n```", "```\n$ prlimit --nproc\nRESOURCE DESCRIPTION          SOFT  HARD  UNITS\nNPROC max number of processes 63223 63223 processes\n$ \n```", "```\n$ cat /proc/sys/kernel/threads-max \n126446\n$ \n```", "```\n$ cat /proc/sys/kernel/threads-max \n7420\n$ prlimit --nproc\nRESOURCE DESCRIPTION          SOFT  HARD  UNITS\nNPROC max number of processes 3710  3710  processes\n$ \n```", "```\nint main(int argc, char **argv)\n{\n  long i;\n  int ret;\n  pthread_t tid;\n  long numthrds=0;\n\n  if (argc != 2) {\n      fprintf(stderr, \"Usage: %s number-of-threads-to-create\\n\", argv[0]);\n      exit(EXIT_FAILURE);\n  }\n  numthrds = atol(argv[1]);\n  if (numthrds <= 0) {\n      fprintf(stderr, \"Usage: %s number-of-threads-to-create\\n\", argv[0]);\n      exit(EXIT_FAILURE);\n  }\n\n  for (i = 0; i < numthrds; i++) {\n        ret = pthread_create(&tid, NULL, worker, (void *)i);\n        if (ret)\n              FATAL(\"pthread_create() failed! [%d]\\n\", ret);\n  }\n  pthread_exit(NULL);\n}\n```", "```\nvoid * worker(void *data)\n{\n      long datum = (long)data;\n      printf(\"Worker thread #%5ld: pausing now...\\n\", datum);\n      (void)pause();\n```", "```\n\n      printf(\" #%5ld: work done, exiting now\\n\", datum);\n      pthread_exit(NULL);\n}\n```", "```\n$ ./cr8_so_many_threads \nUsage: ./cr8_so_many_threads number-of-threads-to-create\n$ ./cr8_so_many_threads 300\nWorker thread #   0: pausing now...\nWorker thread #   1: pausing now...\nWorker thread #   2: pausing now...\nWorker thread #   3: pausing now...\nWorker thread #   5: pausing now...\nWorker thread #   6: pausing now...\nWorker thread #   4: pausing now...\nWorker thread #   7: pausing now...\nWorker thread #  10: pausing now...\nWorker thread #  11: pausing now...\nWorker thread #   9: pausing now...\nWorker thread #   8: pausing now...\n\n[...]\n\nWorker thread #  271: pausing now...\nWorker thread #  299: pausing now...\nWorker thread #  285: pausing now...\nWorker thread #  284: pausing now...\nWorker thread #  273: pausing now...\nWorker thread #  287: pausing now...\n[...]\n^C\n$ \n```", "```\n$ prlimit --nproc ; ulimit -u RESOURCE DESCRIPTION          SOFT HARD UNITS\nNPROC max number of processes 3710 3710 processes\n3710 $ ./cr8_so_many_threads 40000\nWorker thread # 0: pausing now...\nWorker thread # 1: pausing now...\nWorker thread # 2: pausing now...\nWorker thread # 4: pausing now...\n\n[...]\n\nWorker thread # 2139: pausing now...\nWorker thread # 2113: pausing now...\nWorker thread # 2112: pausing now...\nFATAL:cr8_so_many_threads.c:main:52: pthread_create() #2204 failed ! [11]\n kernel says: Resource temporarily unavailable\n$ \n```", "```\nmax number of threads = number of CPU cores * factor;\n where factor = 1.5 or 2.\n```", "```\n#define _GNU_SOURCE /* See feature_test_macros(7) */\n#include <pthread.h>\nint pthread_getattr_default_np(pthread_attr_t *attr);\n```", "```\n$ ./disp_defattr_pthread \nLinux Default Thread Attributes:\nDetach State : PTHREAD_CREATE_JOINABLE\nScheduling \n Scope       : PTHREAD_SCOPE_SYSTEM\n Inheritance : PTHREAD_INHERIT_SCHED\n Policy      : SCHED_OTHER\n Priority    : 0\nThread Stack \n  Guard Size :    4096 bytes\n  Stack Size : 8388608 bytes\n$ \n```", "```\nstatic void display_thrd_attr(pthread_attr_t *attr)\n{\n  int detachst=0;\n  int sched_scope=0, sched_inh=0, sched_policy=0;\n  struct sched_param sch_param;\n  size_t guardsz=0, stacksz=0;\n  void *stackaddr;\n\n  // Query and display the 'Detached State'\n  if (pthread_attr_getdetachstate(attr, &detachst))\n        WARN(\"pthread_attr_getdetachstate() failed.\\n\");\n  printf(\"Detach State : %s\\n\",\n    (detachst == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n    (detachst == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n     \"<unknown>\");\n```", "```\n//--- Scheduling Attributes\n  printf(\"Scheduling \\n\");\n  // Query and display the 'Scheduling Scope'\n  if (pthread_attr_getscope(attr, &sched_scope))\n        WARN(\"pthread_attr_getscope() failed.\\n\");\n  printf(\" Scope : %s\\n\",\n    (sched_scope == PTHREAD_SCOPE_SYSTEM) ? \"PTHREAD_SCOPE_SYSTEM\" :\n    (sched_scope == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n     \"<unknown>\");\n\n  // Query and display the 'Scheduling Inheritance'\n  if (pthread_attr_getinheritsched(attr, &sched_inh))\n        WARN(\"pthread_attr_getinheritsched() failed.\\n\");\n  printf(\" Inheritance : %s\\n\",\n    (sched_inh == PTHREAD_INHERIT_SCHED) ? \"PTHREAD_INHERIT_SCHED\" :\n    (sched_inh == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n     \"<unknown>\");\n\n  // Query and display the 'Scheduling Policy'\n  if (pthread_attr_getschedpolicy(attr, &sched_policy))\n        WARN(\"pthread_attr_getschedpolicy() failed.\\n\");\n  printf(\" Policy : %s\\n\",\n        (sched_policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n        (sched_policy == SCHED_RR)    ? \"SCHED_RR\" :\n        (sched_policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n         \"<unknown>\");\n\n  // Query and display the 'Scheduling Priority'\n  if (pthread_attr_getschedparam(attr, &sch_param))\n        WARN(\"pthread_attr_getschedparam() failed.\\n\");\n  printf(\" Priority : %d\\n\", sch_param.sched_priority);\n```", "```\n//--- Thread Stack Attributes\n  printf(\"Thread Stack \\n\");\n  // Query and display the 'Guard Size'\n  if (pthread_attr_getguardsize(attr, &guardsz))\n        WARN(\"pthread_attr_getguardsize() failed.\\n\");\n  printf(\" Guard Size : %9zu bytes\\n\", guardsz);\n\n  /* Query and display the 'Stack Size':\n   * 'stack location' will be meaningless now as there is no\n   * actual thread created yet!\n   */\n  if (pthread_attr_getstack(attr, &stackaddr, &stacksz))\n        WARN(\"pthread_attr_getstack() failed.\\n\");\n  printf(\" Stack Size : %9zu bytes\\n\", stacksz);\n}\n```", "```\n#include <pthread.h>\nint pthread_join(pthread_t thread, void **retval);\n```", "```\nint main(void)\n{\n  long i;\n  int ret, stat=0;\n  pthread_t tid[NTHREADS];\n pthread_attr_t attr;\n\n  /* Init the thread attribute structure to defaults */\n  pthread_attr_init(&attr);\n  /* Create all threads as joinable */\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n  // Thread creation loop\n  for (i = 0; i < NTHREADS; i++) {\n      printf(\"main: creating thread #%ld ...\\n\", i);\n      ret = pthread_create(&tid[i], &attr, worker, (void *)i);\n      if (ret)\n          FATAL(\"pthread_create() failed! [%d]\\n\", ret);\n  }\n  pthread_attr_destroy(&attr);\n```", "```\nvoid * worker(void *data)\n{\n      long datum = (long)data;\n      int slptm=8;\n\n      printf(\" worker #%ld: will sleep for %ds now ...\\n\", datum, slptm);\n      sleep(slptm);\n      printf(\" worker #%ld: work (eyeroll) done, exiting now\\n\", datum);\n\n      /* Terminate with success: status value 0.\n * The join will pick this up. */\n pthread_exit((void *)0);\n}\n```", "```\n  // Thread join loop\n  for (i = 0; i < NTHREADS; i++) {\n      printf(\"main: joining (waiting) upon thread #%ld ...\\n\", i);\n      ret = pthread_join(tid[i], (void **)&stat);\n      if (ret)\n          WARN(\"pthread_join() failed! [%d]\\n\", ret);\n      else\n          printf(\"Thread #%ld successfully joined; it terminated with\"\n                 \"status=%d\\n\", i, stat);\n  }\n  printf(\"\\nmain: now dying... <Dramatic!> Farewell!\\n\");\n  pthread_exit(NULL);\n}\n```", "```\n$ make pthreads_joiner1 \ngcc -O2 -Wall -UDEBUG -c ../common.c -o common.o\ngcc -O2 -Wall -UDEBUG -c pthreads_joiner1.c -o pthreads_joiner1.o\ngcc -o pthreads_joiner1 pthreads_joiner1.o common.o -lpthread\n$ ./pthreads_joiner1 \nmain: creating thread #0 ...\nmain: creating thread #1 ...\n worker #0: will sleep for 8s now ...\nmain: creating thread #2 ...\n worker #1: will sleep for 8s now ...\nmain: joining (waiting) upon thread #0 ...\n worker #2: will sleep for 8s now ...\n\n*<< ... worker threads sleep for 8s ... >>*\n\n worker #0: work (eyeroll) done, exiting now\n worker #1: work (eyeroll) done, exiting now\n worker #2: work (eyeroll) done, exiting now\nThread #0 successfully joined; it terminated with status=0\nmain: joining (waiting) upon thread #1 ...\nThread #1 successfully joined; it terminated with status=0\nmain: joining (waiting) upon thread #2 ...\nThread #2 successfully joined; it terminated with status=0\n\nmain: now dying... <Dramatic!> Farewell!\n$ \n```", "```\n$ ./pthreads_joiner2 \nmain: creating thread #0 ...\nmain: creating thread #1 ...\nmain: creating thread #2 ...\nmain: joining (waiting) upon thread #0 ...\n worker #0: will sleep for 8s now ...\n worker #1: will sleep for 7s now ...\n worker #2: will sleep for 6s now ... *<< ... worker threads sleep for 8s, 7s and 6s resp ... >>*\n worker #2: work (eyeroll) done, exiting now\n worker #1: work (eyeroll) done, exiting now\n worker #0: work (eyeroll) done, exiting now\nThread #0 successfully joined; it terminated with status=0\nmain: joining (waiting) upon thread #1 ...\nThread #1 successfully joined; it terminated with status=0\nmain: joining (waiting) upon thread #2 ...\nThread #2 successfully joined; it terminated with status=0\n\nmain: now dying... <Dramatic!> Farewell!\n$ \n```", "```\n#define _GNU_SOURCE /* See feature_test_macros(7) */\n#include <pthread.h>\n\nint pthread_tryjoin_np(pthread_t thread, void **retval);\nint pthread_timedjoin_np(pthread_t thread, void **retval,\n                         const struct timespec *abstime);\n```", "```\n struct timespec {\n     time_t tv_sec; /* seconds */\n     long tv_nsec;  /* nanoseconds */\n };\n```", "```\nlong i;\nint ret;\npthread_t tid;\n\nfor (i = 0; i < NTHREADS; i++) {\n     ret = pthread_create(&tid, NULL, worker, (void *)i);\n    ...\n}\n```", "```\nvoid * worker(void *data)\n{\n long datum = (long)data;\n...\n```", "```\n/* Our data structure that we intend to pass as a parameter to the threads. City Airport information. */\ntypedef struct {\n    char IATA_code[IATA_MAXSZ];\n              /* http://www.nationsonline.org/oneworld/IATA_Codes/ */\n    char city[CITY_MAXSZ];     /* city name */\n    float latitude, longitude; /* coordinates of the city airport */\n    unsigned int altitude;     /* metres */\n  /* todo: add # runways, runway direction, radio beacons freq, etc etc */\n    unsigned long reserved;    /* for future use */\n} Airport; /* yes! the {lat,long,alt} tuple is accurate :-) */\nstatic const Airport city_airports[3] = {\n  { \"BLR\", \"Bangalore International\", 13.1986, 77.7066, 904, 0 },\n  { \"BNE\", \"Brisbane International\", 27.3942, 153.1218, 4, 0 },\n  { \"BRU\", \"Brussels National\", 50.9010, 4.4856, 58, 0 },\n};\n```", "```\n  Airport * plocdata[NTHREADS];\n...\n  // Thread creation loop\n  for (i = 0; i < NTHREADS; i++) {\n      printf(\"main: creating thread #%ld ...\\n\", i);\n\n      /* Allocate and initialize data structure to be passed to the\n       * thread as a parameter */\n       plocdata[i] = calloc(1, sizeof(Airport));\n       if (!plocdata[i])\n          FATAL(\"calloc [%d] failed\\n\", i);\n       memcpy(plocdata[i], &city_airports[i], sizeof(Airport));\n\n       ret = pthread_create(&tid[i], &attr, worker, (void *)plocdata[i]);\n       if (ret)\n          FATAL(\"pthread_create() index %d failed! [%d]\\n\", i, ret);\n  }\n```", "```\nvoid * worker(void *data)\n{\n Airport * arg = (Airport *)data;\n  int slptm=8;\n\n  printf( \"\\n----------- Airports Details ---------------\\n\"\n    \" IATA code : %.*s %32s\\n\"\n    \" Latitude, Longitude, Altitude : %9.4f %9.4f %9um\\n\"\n    , IATA_MAXSZ, arg->IATA_code,\n    arg->city,\n    arg->latitude, arg->longitude, arg->altitude);\n...\n```", "```\n printf(\"main: &i=%p\\n\", &i);\n for (i = 0; i < NTHREADS; i++) {\n     printf(\"Creating thread #%ld now ...\\n\", i);\n     ret = pthread_create(&tid, NULL, worker, (void *)&i);\n     ...\n}\n```", "```\nvoid * worker(void *data)\n{\n    long data_addr = (long)data;\n    long index = *(long *)data_addr;\n    printf(\"Worker thread: data_addr=%p value=%ld\\n\", \n            (void *)data_addr, index);\n    pthread_exit((void *)0);\n}\n```", "```\n$ ./pthreads1_wrong\nmain: &i=0x7ffebe160f00\nCreating thread #0 now ...\nCreating thread #1 now ...\nWorker thread: data_addr=0x7ffebe160f00 value=1\nCreating thread #2 now ...\nWorker thread: data_addr=0x7ffebe160f00 value=2\nWorker thread: data_addr=0x7ffebe160f00 value=3 $ \n```", "```\n$ ./pthreads1_wrong\nmain: &i=0x7fff4475e0d0\nCreating thread #0 now ...\nCreating thread #1 now ...\nCreating thread #2 now ...\nWorker thread: data_addr=0x7fff4475e0d0 value=2\nWorker thread: data_addr=0x7fff4475e0d0 value=2\nWorker thread: data_addr=0x7fff4475e0d0 value=3\n$ \n```", "```\nfor (i = 0; i < NTHREADS; i++) {\n     printf(\"Creating thread #%ld now ...\\n\", i);\n     ret = pthread_create(&tid, NULL, worker, (void *)i);\n    ...\n}\n```", "```\n#include <pthread.h>\nint pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);\nint pthread_attr_getstacksize(const pthread_attr_t *attr, \n                              size_t *stacksize);\n```", "```\n#include <pthread.h>\nint pthread_attr_setstack(pthread_attr_t *attr,\n                           void *stackaddr, size_t stacksize);\nint pthread_attr_getstack(const pthread_attr_t *attr,\n                           void **stackaddr, size_t *stacksize);\n```", "```\n#include <pthread.h>\nint pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);\nint pthread_attr_getguardsize(const pthread_attr_t *attr, \n                               size_t *guardsize);\n```", "```\n$ ./stack_test \nUsage: ./stack_test size-of-thread-stack-in-KB\n$ ./stack_test 2560\nDefault thread stack size       : 8388608 bytes\nThread stack size now set to    : 2621440 bytes\nDefault thread stack guard size :    4096 bytes\n\nmain: creating thread #0 ...\nmain: creating thread #1 ...\nmain: creating thread #2 ...\n worker #0:\nmain: joining (waiting) upon thread #0 ...\n worker #1:\n\n *** In danger(): here, sizeof long is 8\n worker #2:\nThread #0 successfully joined; it terminated with status=1\nmain: joining (waiting) upon thread #1 ...\ndummy(): parameter val = 115709118\nThread #1 successfully joined; it terminated with status=0\nmain: joining (waiting) upon thread #2 ...\nThread #2 successfully joined; it terminated with status=1\nmain: now dying... <Dramatic!> Farewell!\n$ \n```", "```\n$ ./stack_test 256\nDefault thread stack size       : 8388608 bytes\nThread stack size now set to    :  262144 bytes\nDefault thread stack guard size :    4096 bytes\n\nmain: creating thread #0 ...\nmain: creating thread #1 ...\n worker #0:\nmain: creating thread #2 ...\n worker #1:\nmain: joining (waiting) upon thread #0 ...\nSegmentation fault (core dumped)\n$ \n```", "```\n$ dmesg [...]\nkern :info : [*<timestamp>*] stack_test_dbg[27414]: segfault at 7f5ad1733000 ip 0000000000400e68 sp 00007f5ad164aa20 error 6 in stack_test_dbg[400000+2000]\n$ \n```", "```\nint main(int argc, char **argv)\n{\n[...]\n  stack_set = atoi(argv[1]) * 1024;\n[...]\n  /* Init the thread attribute structure to defaults */\n  pthread_attr_init(&attr);\n[...]\n  /* Set thread stack size */\n  ret = pthread_attr_setstacksize(&attr, stack_set);\n  if (ret)\n      FATAL(\"pthread_attr_setstack(%u) failed! [%d]\\n\", TSTACK, ret);\n  printf(\"Thread stack size now set to : %10u bytes\\n\", stack_set);\n[...]\n```", "```\nvoid * worker(void *data)\n{\n  long datum = (long)data;\n\n  printf(\" worker #%ld:\\n\", datum);\n  if (datum != 1)\n      pthread_exit((void *)1);\n\n danger(); ...\n```", "```\nstatic void danger(void)\n{\n#define NEL    500\n  long heavylocal[NEL][NEL], alpha=0;\n  int i, j;\n  long int k=0;\n\n  srandom(time(0));\n\n  printf(\"\\n *** In %s(): here, sizeof long is %ld\\n\",\n          __func__, sizeof(long));\n  /* Turns out to be 8 on an x86_64; so the 2d-array takes up\n   * 500 * 500 * 8 = 2,000,000 ~= 2 MB.\n   * So thread stack space of less than 2 MB should result in a segfault.\n   * (On a test box, any value < 1960 KB = 2,007,040 bytes,\n   * resulted in segfault).\n   */\n\n  /* The compiler is quite intelligent; it will optimize away the\n   * heavylocal 2d array unless we actually use it! So lets do some\n   * thing with it...\n   */\n  for (i=0; i<NEL; i++) {\n      k = random() % 1000;\n      for (j=0; j<NEL-1; j++)\n heavylocal[i][j] = k;\n      /*printf(\"hl[%d][%d]=%ld\\n\", i, j, (long)heavylocal[i][j]);*/\n  }\n\n  for (i=0; i<NEL; i++)\n      for (j=0; j<NEL; j++)\n          alpha += heavylocal[i][j];\n  dummy(alpha);\n}\n```"]