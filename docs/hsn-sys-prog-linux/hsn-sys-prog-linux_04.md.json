["```\nchar buf[256];\n```", "```\n#include <stdlib.h>\nvoid *malloc(size_t size);\n```", "```\nvoid *ptr;\nptr = malloc(256);\n```", "```\n    struct sbar {\n        int a[10], b[10];\n        char buf[512];\n    } *psbar;\n\n psbar = malloc(sizeof(struct sbar));\n    // initialize and work with it\n    [...]\n    free(psbar);\n```", "```\nstruct [...] *psbar;\nsbar = malloc(sizeof(struct sbar));\nif (!sbar) {\n *<... handle the error ...>*\n}\n```", "```\n$ ltrace ./tst \nmalloc(592)           = 0xd60260\nfree(0xd60260)        = <void>\nexit(0 <no return ...>\n+++ exited (status 0) +++\n$ \n```", "```\n    int szt = sizeof(size_t);\n    float max=0;\n    max = pow(2, szt*8);\n    printf(\"sizeof size_t = %u; \" \n            \"max value of the param to malloc = %.0f\\n\", \n            szt, max);\n```", "```\n$ gcc -m32 mallocmax.c -o mallocmax32 -Wall -lm\n$ ./mallocmax32\n*** max_malloc() ***\nsizeof size_t = 4; max value of the param to malloc = 4294967296\n[...]\n$ \n```", "```\n*** negative_malloc() ***\nsize_t max    = 18446744073709551616\nld_num2alloc  = -288225969623711744\nszt_num2alloc = 18158518104085839872\n1\\. long int used:  malloc(-288225969623711744) returns (nil)\n2\\. size_t used:    malloc(18158518104085839872) returns (nil)\n3\\. short int used: malloc(6144) returns 0x136b670\n4\\. short int used: malloc(-4096) returns (nil)\n5\\. size_t used:    malloc(18446744073709547520) returns (nil)\n```", "```\nconst size_t onePB    = 1125899907000000; /* 1 petabyte */\nint qa = 28*1000000;\nlong int ld_num2alloc = qa * onePB;\nsize_t szt_num2alloc  = qa * onePB;\nshort int sd_num2alloc;\n```", "```\n$ ./mallocmax32 \n*** max_malloc() ***\nsizeof size_t = 4; max param to malloc = 4294967296\n*** negative_malloc() ***\nsize_t max    = 4294967296\nld_num2alloc  = 0\nszt_num2alloc = 1106247680\n1\\. long int used:  malloc(-108445696) returns (nil)\n2\\. size_t used:    malloc(4186521600) returns (nil)\n3\\. short int used: malloc(6144) returns 0x85d1570\n4\\. short int used: malloc(-4096) returns (nil)\n5\\. size_t used:    malloc(4294963200) returns (nil)\n$ \n```", "```\ngcc -Wall   -c -o mallocmax.o mallocmax.c\nmallocmax.c: In function \u2018negative_malloc\u2019:\nmallocmax.c:87:6: warning: argument 1 value \u201818446744073709551615\u2019 exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]\n  ptr = malloc(-1UL);\n  ~~~~^~~~~~~~~~~~~~\nIn file included from mallocmax.c:18:0:\n/usr/include/stdlib.h:424:14: note: in a call to allocation function \u2018malloc\u2019 declared here\n extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;\n              ^~~~~~ \n[...]\n```", "```\n[...] warning: argument 1 value \u201818446744073709551615\u2019 *exceeds maximum object size* *9223372036854775807* [-Walloc-size-larger-than=] [...]\n```", "```\n    void *ptr;\n    ptr = malloc(0);\n    free(ptr);\n```", "```\n$ ltrace ./a.out \nmalloc(0)                                  = 0xf50260\nfree(0xf50260)                                = <void>\nexit(0 <no return ...>\n+++ exited (status 0) +++\n$ \n```", "```\nvoid *ptr = NULL;\n[...] \nwhile(*<some-condition-is-true>*) {\n    if (!ptr)\n        ptr = malloc(n);\n\n    [...\n   * <use 'ptr' here>*\n    ...]\n\n    free(ptr);\n}\n```", "```\n    int *ptr;\n    ptr = calloc(1000, sizeof(int));\n```", "```\nvoid *ptr, *newptr;\nptr = calloc(100, sizeof(char)); // error checking code not shown here\nnewptr = realloc(ptr, 150);\nif (!newptr) {\n    fprintf(stderr, \"realloc failed!\");\n free(ptr);\n    exit(EXIT_FAILURE);\n}\n*< do your stuff >*\nfree(newptr);\n```", "```\nvoid *ptr, *newptr;\nptr = calloc(100, sizeof(char)); // error checking code not shown here\nnewptr = realloc(NULL, 150);\n```", "```\nvoid *ptr, *newptr;\nptr = calloc(100, sizeof(char)); // error checking code not shown here\nnewptr = realloc(ptr, 0);\n```", "```\nstruct sbar *ptr, *newptr;\nptr = calloc(1000, sizeof(struct sbar)); // array of 1000 struct sbar's\n[...]\n// now we want 500 more!\nnewptr = realloc(ptr, 500*sizeof(struct sbar));\n```", "```\n[...]\n// now we want 500 more!\nnewptr = reallocarray(ptr, 500, sizeof(struct sbar));\n```", "```\n... However, unlike that realloc() call, reallocarray() fails safely in the case where the  multiplication  would  overflow.   If  such  an  overflow occurs, reallocarray() returns NULL, sets errno to ENOMEM, and leaves the original block of memory unchanged.\n```", "```\n#include <unistd.h>\n[...]\n    printf(\"Current program break: %p\\n\", sbrk(0));\n```", "```\n$ ./show_curbrk \nCurrent program break: 0x1bb4000\n$ ./show_curbrk \nCurrent program break: 0x1e93000\n$ ./show_curbrk \nCurrent program break: 0x1677000\n$ \n```", "```\nint main(int argc, char **argv)\n{\n    char *heap_ptr;\n    size_t num = 2048;\n\n    /* No params, just print the current break and exit */\n    if (argc == 1) {\n        printf(\"Current program break: %p\\n\", sbrk(0));\n        exit(EXIT_SUCCESS);\n    }\n\n    /* If passed a param - the number of bytes of memory to\n     * dynamically allocate - perform a dynamic alloc, then\n     * print the heap address, the current break and exit.\n     */\n    num = strtoul(argv[1], 0, 10);\n    if ((errno == ERANGE && num == ULONG_MAX)\n         || (errno != 0 && num == 0))\n         handle_err(EXIT_FAILURE, \"strtoul(%s) failed!\\n\", argv[1]);\n    if (num >= 128 * 1024)\n         handle_err(EXIT_FAILURE, \"%s: pl pass a value < 128 KB\\n\",\n         argv[0]);\n\n    printf(\"Original program break: %p ; \", sbrk(0));\n    heap_ptr = malloc(num);\n    if (!heap_ptr)\n        handle_err(EXIT_FAILURE, \"malloc failed!\");\n    printf(\"malloc(%lu) = %16p ; curr break = %16p\\n\",\n            num, heap_ptr, sbrk(0));\n    free(heap_ptr);\n\n    exit(EXIT_SUCCESS);\n}\n```", "```\n$ make show_curbrk && ./show_curbrk [...]\nCurrent program break: 0x1247000\n$ ./show_curbrk 1024\nOriginal program break: 0x1488000 ; malloc(1024) =        0x1488670 ; \ncurr break =        0x14a9000\n$ \n```", "```\nOriginal program break = 0x1488000\nheap_ptr               = 0x1488670\nNew program break      = 0x14a9000\n```", "```\n$ ./malloc_brk_test -h\nUsage: ./malloc_brk_test [option | --help]\n option = 0 : show only mem pointers [default]\n option = 1 : opt 0 + show malloc stats as well\n option = 2 : opt 1 + perform larger alloc's (over MMAP_THRESHOLD)\n option = 3 : test segfault 1\n option = 4 : test segfault 2\n-h | --help : show this help screen\n$ \n```", "```\n$ ./malloc_brk_test\n                              init_brk =        0x1c97000\n #: malloc(       n) =        heap_ptr           cur_brk   delta  \n                                                      [cur_brk-init_brk]\n 0: malloc(       8) =        0x1c97670         0x1cb8000 [135168]\n 1: malloc(    4083) =        0x1c97690         0x1cb8000 [135168]\n 2: malloc(       3) =        0x1c98690         0x1cb8000 [135168]\n$ \n```", "```\n$ ./malloc_brk_test 1\n                              init_brk =   0x184e000\n #: malloc(       n) =        heap_ptr     cur_brk   delta   \n                                            [cur_brk-init_brk]\n 0: malloc(       8) =        0x184e670    0x186f000 [135168]\nArena 0:\nsystem bytes     =     135168\nin use bytes     =       1664\nTotal (incl. mmap):\nsystem bytes     =     135168\nin use bytes     =       1664\nmax mmap regions =          0\nmax mmap bytes   =          0\n\n 1: malloc(    4083) =        0x184e690    0x186f000 [135168]\nArena 0:\nsystem bytes     =     135168\nin use bytes     =       5760\nTotal (incl. mmap):\nsystem bytes     =     135168\nin use bytes     =       5760\nmax mmap regions =          0\nmax mmap bytes   =          0\n\n 2: malloc(       3) =        0x184f690    0x186f000 [135168]\nArena 0:\nsystem bytes     =     135168\nin use bytes     =       5792\nTotal (incl. mmap):\nsystem bytes     =     135168\nin use bytes     =       5792\nmax mmap regions =          0\nmax mmap bytes   =          0              \n```", "```\n$ ./malloc_brk_test 2\n                              init_brk =        0x2209000\n #: malloc(       n) =        heap_ptr           cur_brk   delta \n                                                      [cur_brk-init_brk]\n[...]\n\n 3: malloc(  136168) =   0x7f57288cd010         0x222a000 [135168]\nArena 0:\nsystem bytes     =     135168\nin use bytes     =       5792\nTotal (incl. mmap):\nsystem bytes     =     274432\nin use bytes     =     145056\nmax mmap regions =          1\nmax mmap bytes   =     139264\n\n 4: malloc( 1048576) =   0x7f57287c7010         0x222a000 [135168]\nArena 0:\nsystem bytes     =     135168\nin use bytes     =       5792\nTotal (incl. mmap):\nsystem bytes     =    1327104\nin use bytes     =    1197728\nmax mmap regions =          2\nmax mmap bytes   =    1191936\n\n$                     \n```", "```\nBy  default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available.  In case it turns out that the system is out of memory, one or more processes will be killed by the OOM  killer.\n[...]\n```", "```\n#include <unistd.h>\n#include <sys/mman.h>\n\nint mincore(void *addr, size_t length, unsigned char *vec);\n```", "```\nlong pgsz = sysconf(_SC_PAGESIZE);\nsize_t len = 3*pgsz;\n\nvoid *ptr = malloc(len);\n\n[...]       // initialize the memory, etc\n\n// Lock it!\nif (mlock(ptr, len) != 0) {\n     // mlock failed, handle it\n     return ...;\n}\n\n[...]   /* use the memory, confident it is resident in RAM & will stay  \n           there until unlocked */\n\nmunlock(ptr, len);   // it's now unlocked, can be swapped\n```", "```\n$ prlimit | grep MEMLOCK\nMEMLOCK   max locked-in-memory address space   65536   65536 bytes\n$ \n```", "```\n[...]\n#define CMD_MAX  256\nstatic void disp_locked_mem(void)\n{\n    char *cmd = malloc(CMD_MAX);\n    if (!cmd)\n        FATAL(\"malloc(%zu) failed\\n\", CMD_MAX);\n    snprintf(cmd, CMD_MAX-1, \"grep Lck /proc/%d/status\", getpid());\n    system(cmd);\n    free(cmd);\n}\n\nstatic void try_mlock(const char *cpgs)\n{\n    size_t num_pg = atol(cpgs);\n    const long pgsz = sysconf(_SC_PAGESIZE);\n    void *ptr= NULL;\n    size_t len;\n\n    len = num_pg * pgsz;\n    if (len >= LONG_MAX)\n        FATAL(\"too many bytes to alloc (%zu), aborting now\\n\", len);\n\n/* ptr = malloc(len); */\n/* Don't use the malloc; POSIX wants page-aligned memory for mlock */\n    posix_memalign(&ptr, pgsz, len);\n    if (!ptr)\n        FATAL(\"posix_memalign(for %zu bytes) failed\\n\", len);\n\n    /* Lock the memory region! */\n    if (mlock(ptr, len)) {\n        free(ptr);\n        FATAL(\"mlock failed\\n\");\n    }\n    printf(\"Locked %zu bytes from address %p\\n\", len, ptr);\n    memset(ptr, 'L', len);\n    disp_locked_mem();\n    sleep(1);\n\n    /* Now unlock it.. */\n    if (munlock(ptr, len)) {\n        free(ptr);\n        FATAL(\"munlock failed\\n\");\n    }\n    printf(\"unlocked..\\n\");\n    free(ptr);\n}\n\nint main(int argc, char **argv)\n{\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s pages-to-alloc\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    disp_locked_mem();\n    try_mlock(argv[1]);\n    exit (EXIT_SUCCESS);\n}\n```", "```\n$ ./mlock_try Usage: ./mlock_try pages-to-alloc $ ./mlock_try 1 VmLck:           0 kB\nLocked 4096 bytes from address 0x1a6e000\nVmLck:           4 kB\nunlocked.. $ ./mlock_try 32 VmLck:           0 kB mlock_try.c:try_mlock:79: mlock failed\nperror says: Cannot allocate memory\n$ \n$ ./mlock_try 15 VmLck:           0 kB\nLocked 61440 bytes from address 0x842000\nVmLck:          60 kB\nunlocked.. $ sudo ./mlock_try 32 [sudo] password for <user>: xxx \nVmLck:           0 kB\nLocked 131072 bytes from address 0x7f6b478db000\nVmLck:         128 kB\nunlocked..\n$ prlimit | grep MEMLOCK MEMLOCK    max locked-in-memory address space     65536     65536 bytes\n$ \n```", "```\n#include <sys/mman.h>\nint mprotect(void *addr, size_t len, int prot);\n```", "```\n[...]\n    /* Don't use the malloc; POSIX wants page-aligned memory for mprotect(2) */\n    posix_memalign(&ptr, gPgsz, 4*gPgsz);\n    if (!ptr)\n        FATAL(\"posix_memalign(for %zu bytes) failed\\n\", 4*gPgsz);\n    protect_mem(ptr);\n    test_mem(ptr, atoi(argv[1]));\n[...]\n```", "```\nint okornot[4];\nstatic void protect_mem(void *ptr)\n{\n    int i;\n    u64 start_off=0;\n    char str_prots[][128] = {\"PROT_READ|PROT_WRITE\", \"PROT_READ\",\n                             \"PROT_WRITE|PROT_EXEC\", \"PROT_NONE\"};\n    int prots[4] = {PROT_READ|PROT_WRITE, PROT_READ,\n PROT_WRITE|PROT_EXEC, PROT_NONE};\n\n    printf(\"%s():\\n\", __FUNCTION__);\n    memset(okornot, 0, sizeof(okornot));\n\n    /* Loop over each page, setting protections as required */\n    for (i=0; i<4; i++) {\n        start_off = (u64)ptr+(i*gPgsz);\n        printf(\"page %d: protections: %30s: \"\n               \"range [0x%llx:0x%llx]\\n\",\n               i, str_prots[i], start_off, start_off+gPgsz-1);\n\n        if (mprotect((void *)start_off, gPgsz, prots[i]) == -1)\n            WARN(\"mprotect(%s) failed\\n\", str_prots[i]);\n        else\n            okornot[i] = 1;\n    }\n}\n```", "```\nstatic void test_mem(void *ptr, int write_on_ro_mem)\n{\n    int byte = random() % gPgsz;\n    char *start_off;\n\n    printf(\"\\n----- %s() -----\\n\", __FUNCTION__);\n\n    /* Page 0 : rw [default] mem protection */\n    if (okornot[0] == 1) {\n        start_off = (char *)ptr + 0*gPgsz + byte;\n        TEST_WRITE(0, start_off, 'a');\n        TEST_READ(0, start_off);\n    } else\n        printf(\"*** Page 0 : skipping tests as memprot failed...\\n\");\n\n    /* Page 1 : ro mem protection */\n    if (okornot[1] == 1) {\n        start_off = (char *)ptr + 1*gPgsz + byte;\n        TEST_READ(1, start_off);\n        if (write_on_ro_mem == 1) {\n            TEST_WRITE(1, start_off, 'b');\n        }\n    } else\n        printf(\"*** Page 1 : skipping tests as memprot failed...\\n\");\n\n    /* Page 2 : RWX mem protection */\n    if (okornot[2] == 1) {\n        start_off = (char *)ptr + 2*gPgsz + byte;\n        TEST_READ(2, start_off);\n        TEST_WRITE(2, start_off, 'c');\n    } else\n        printf(\"*** Page 2 : skipping tests as memprot failed...\\n\");\n\n    /* Page 3 : 'NONE' mem protection */\n    if (okornot[3] == 1) {\n        start_off = (char *)ptr + 3*gPgsz + byte;\n        TEST_READ(3, start_off);\n        TEST_WRITE(3, start_off, 'd');\n    } else\n        printf(\"*** Page 3 : skipping tests as memprot failed...\\n\");\n}\n```", "```\n#define TEST_READ(pgnum, addr) do { \\\n    printf(\"page %d: reading: byte @ 0x%llx is \", \\\n    pgnum, (u64)addr); \\\n    fflush(stdout); \\\n    printf(\" %x\", *addr); \\\n    printf(\" [OK]\\n\"); \\\n} while (0)\n\n#define TEST_WRITE(pgnum, addr, byte) do { \\\n    printf(\"page %d: writing: byte '%c' to address 0x%llx now ...\", \\\n            pgnum, byte, (u64)addr); \\\n    fflush(stdout); \\\n    *addr = byte; \\\n    printf(\" [OK]\\n\"); \\\n} while (0)\n```", "```\n$ cat /etc/issue Ubuntu 18.04 LTS \\n \\l $ uname -r 4.15.0-23-generic $ \n\n$ ./memprot\nUsage: ./memprot test-write-to-ro-mem [0|1]\n$ ./memprot 0\n----- protect_mem() -----\npage 0: protections: PROT_READ|PROT_WRITE: range [0x55796ccd5000:0x55796ccd5fff]\npage 1: protections: PROT_READ: range [0x55796ccd6000:0x55796ccd6fff]\npage 2: protections: PROT_READ|PROT_WRITE|PROT_EXEC: range [0x55796ccd7000:0x55796ccd7fff]\npage 3: protections: PROT_NONE: range [0x55796ccd8000:0x55796ccd8fff]\n\n----- test_mem() -----\npage 0: writing: byte 'a' to address 0x55796ccd5567 now ... [OK]\npage 0: reading: byte @ 0x55796ccd5567 is 61 [OK]\npage 1: reading: byte @ 0x55796ccd6567 is 0 [OK]\npage 2: reading: byte @ 0x55796ccd7567 is 0 [OK]\npage 2: writing: byte 'c' to address 0x55796ccd7567 now ... [OK]\npage 3: reading: byte @ 0x55796ccd8567 is Segmentation fault\n$ \n```", "```\n$ ./memprot 1 ----- protect_mem() -----\npage 0: protections: PROT_READ|PROT_WRITE: range [0x564d74f2d000:0x564d74f2dfff]\npage 1: protections: PROT_READ: range [0x564d74f2e000:0x564d74f2efff]\npage 2: protections: PROT_READ|PROT_WRITE|PROT_EXEC: range [0x564d74f2f000:0x564d74f2ffff]\npage 3: protections: PROT_NONE: range [0x564d74f30000:0x564d74f30fff]\n\n----- test_mem() -----\npage 0: writing: byte 'a' to address 0x564d74f2d567 now ... [OK]\npage 0: reading: byte @ 0x564d74f2d567 is 61 [OK]\npage 1: reading: byte @ 0x564d74f2e567 is 0 [OK]\npage 1: writing: byte 'b' to address 0x564d74f2e567 now ...Segmentation fault\n$ \n```", "```\n$ lsb_release -a\nLSB Version: :core-4.1-amd64:core-4.1-noarch\nDistributor ID: Fedora\nDescription: Fedora release 28 (Twenty Eight)\nRelease: 28\nCodename: TwentyEight\n$ uname -r\n4.16.13-300.fc28.x86_64\n$ \n```", "```\n$ ./memprot 0\n----- protect_mem() -----\npage 0: protections: PROT_READ|PROT_WRITE: range [0x15d8000:0x15d8fff]\npage 1: protections: PROT_READ: range [0x15d9000:0x15d9fff]\npage 2: protections: PROT_READ|PROT_WRITE|PROT_EXEC: range [0x15da000:0x15dafff]\n!WARNING! memprot.c:protect_mem:112:  \n            mprotect(PROT_READ|PROT_WRITE|PROT_EXEC) failed\nperror says: Permission denied\npage 3: protections: PROT_NONE: range [0x15db000:0x15dbfff]\n\n----- test_mem() -----\npage 0: writing: byte 'a' to address 0x15d8567 now ... [OK]\npage 0: reading: byte @ 0x15d8567 is 61 [OK]\npage 1: reading: byte @ 0x15d9567 is 0 [OK]\n*** Page 2 : skipping tests as memprot failed...\npage 3: reading: byte @ 0x15db567 is Segmentation fault (core dumped)\n$ \n```", "```\n        $ getenforce \n        Enforcing\n        $ setenforce \n        usage: setenforce [ Enforcing | Permissive | 1 | 0 ]\n        $ sudo setenforce 0\n        [sudo] password for <username>: xxx\n        $ getenforce \n        Permissive\n        $ \n        ```", "```\n$ ./memprot 0\n----- protect_mem() -----\npage 0: protections: PROT_READ|PROT_WRITE: range [0x118e000:0x118efff]\npage 1: protections: PROT_READ: range [0x118f000:0x118ffff]\npage 2: protections: PROT_READ|PROT_WRITE|PROT_EXEC: range [0x1190000:0x1190fff]\npage 3: protections: PROT_NONE: range [0x1191000:0x1191fff]\n\n----- test_mem() -----\npage 0: writing: byte 'a' to address 0x118e567 now ... [OK]\npage 0: reading: byte @ 0x118e567 is 61 [OK]\npage 1: reading: byte @ 0x118f567 is 0 [OK]\npage 2: reading: byte @ 0x1190567 is 0 [OK]\npage 2: writing: byte 'c' to address 0x1190567 now ... [OK]\npage 3: reading: byte @ 0x1191567 is Segmentation fault (core dumped)\n$ \n```", "```\n$ sudo setenforce 1\n$ getenforce \nEnforcing\n$ \n```", "```\n$ journalctl --boot | grep memprot\n[...]\n<timestamp> <host> python3[31861]: SELinux is preventing memprot from using the execheap access on a process.\n If you do not think memprot should need to map heap memory that is both writable and executable.\n If you believe that memprot should be allowed execheap access on processes labeled unconfined_t by default.\n # ausearch -c 'memprot' --raw | audit2allow -M my-memprot\n # semodule -X 300 -i my-memprot.pp\n```", "```\n$ cat Makefile\n[...]\nCROSS_COMPILE=arm-linux-gnueabihf-\nCC=gcc\nCCARM=${CROSS_COMPILE}gcc\n[...]\ncommon_arm.o: ../common.c ../common.h\n    ${CCARM} ${CFLAGS} -c ../common.c -o common_arm.o\nmemprot_arm: common_arm.o memprot_arm.o\n    ${CCARM} ${CFLAGS} -o memprot_arm memprot_arm.c common_arm.o\n[...]\n```", "```\n$ make clean [...] $ make memprot_arm\narm-linux-gnueabihf-gcc -Wall -c ../common.c -o common_arm.o gcc -Wall -c -o memprot_arm.o memprot_arm.c arm-linux-gnueabihf-gcc -Wall -o memprot_arm memprot_arm.c common_arm.o $ file ./memprot_arm ./memprot_arm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=3c720<...>, with debug_info, not stripped $ \n```", "```\n$ qemu-system-arm -m 512 -M vexpress-a9 \\\n   -kernel <...>/images/zImage \\\n   -drive file=<...>/images/rfs.img,if=sd,format=raw \\\n   -append \\\n    \"console=ttyAMA0 rootfstype=ext4 root=/dev/mmcblk0 init=/sbin/init \" \\\n   -nographic -dtb <...>/images/vexpress-v2p-ca9.dtb\n\n[...]\nBooting Linux on physical CPU 0x0\nLinux version 4.9.1-crk (xxx@yyy) (gcc version 4.8.3 20140320 (prerelease) (Sourcery CodeBench Lite 2014.05-29) ) #16 SMP Wed Jan 24 10:09:17 IST 2018\nCPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c5387d\nCPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\n\n[...]\n\nsmsc911x 4e000000.ethernet eth0: SMSC911x/921x identified at 0xa1290000, IRQ: 31\n/bin/sh: can't access tty; job control turned off\nARM / $ \n```", "```\nARM # ./memprot_arm Usage: ./memprot_arm test-write-to-ro-mem [0|1] ARM # ./memprot_arm 0 ----- protect_mem() -----\npage 0: protections: PROT_READ|PROT_WRITE: range [0x24000, 0x24fff]\npage 1: protections: PROT_READ: range [0x25000, 0x25fff]\npage 2: protections: PROT_READ|PROT_WRITE|PROT_EXEC: range [0x26000, 0x26fff]\npage 3: protections: PROT_NONE: range [0x27000, 0x27fff]\n\n----- test_mem() -----\npage 0: writing: byte 'a' to address 0x24567 now ... [OK]\npage 0: reading: byte @ 0x24567 is 61 [OK]\npage 1: reading: byte @ 0x25567 is 0 [OK]\npage 2: reading: byte @ 0x26567 is 0 [OK]\npage 2: writing: byte 'c' to address 0x26567 now ... [OK]\npage 3: reading: byte @ 0x27567 is Segmentation fault (core dumped)\nARM # \n```", "```\n[...]\nstatic void try_alloca(const char *csz, int do_the_memset)\n{\n    size_t sz = atol(csz);\n    void *aptr;\n\n    aptr = alloca(sz);\n    if (!aptr)\n        FATAL(\"alloca(%zu) failed\\n\", sz);\n    if (1 == do_the_memset)\n        memset(aptr, 'a', sz);\n\n    /* Must _not_ call free(), just return;\n     * the memory is auto-deallocated!\n     */\n}\n\nint main(int argc, char **argv)\n{\n  [...]\n    if (atoi(argv[2]) == 1)\n        try_alloca(argv[1], 1);\n    else if (atoi(argv[2]) == 0)\n        try_alloca(argv[1], 0);\n    else {\n        fprintf(stderr, \"Usage: %s size-to-alloca do_the_memset[1|0]\\n\", \n                     argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    exit (EXIT_SUCCESS);\n}\n```", "```\n$ ./alloca_try\nUsage: ./alloca_try size-to-alloca do_the_memset[1|0]\n$ ./alloca_try 50000 1\n$ ./alloca_try 50000 0\n$ \n```", "```\n$ ./alloca_try -1 0\n$ echo $?\n0\n$ ./alloca_try -1 1\nSegmentation fault (core dumped)\n$\n```", "```\n$ ltrace ./alloca_try -1 1\natoi(0x7ffcd6c3e0c9, 0x7ffcd6c3d868, 0x7ffcd6c3d888, 0)         =  1\natol(0x7ffcd6c3e0c6, 1, 0, 0x1999999999999999)                  = -1\nmemset(0x7ffcd6c3d730, 'a', -1 <no return ...>\n--- SIGSEGV (Segmentation fault) ---\n+++ killed by SIGSEGV +++\n$ \n```", "```\n$ ltrace ./alloca_try -1 0\natoi(0x7fff9495b0c9, 0x7fff94959728, 0x7fff94959748, 0)     =  0\natoi(0x7fff9495b0c9, 0x7fff9495b0c9, 0, 0x1999999999999999) =  0\natol(0x7fff9495b0c6, 0, 0, 0x1999999999999999)              = -1\nexit(0 <no return ...>\n+++ exited (status 0) +++\n$ \n```", "```\n$ ./alloca_try 8000000 1\n$ ./alloca_try 8400000 1\nSegmentation fault (core dumped)\n$ ulimit -s\n8192\n$ \n```"]