- en: '*Chapter 3*: Using Linux and Linux Tools for Network Diagnostics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用Linux和Linux工具进行网络诊断'
- en: In this chapter, we'll cover some "how it works" networking basics, as well
    as how to use our Linux workstation in network troubleshooting. When you're done
    with this chapter, you should have tools to troubleshoot local and remote network
    services, as well as to "inventory" your network and its services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些“工作原理”网络基础知识，以及如何在我们的Linux工作站中进行网络故障排除。完成本章后，您应该具备故障排除本地和远程网络服务以及“清点”网络及其服务的工具。
- en: 'In particular, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Networking basics – the OSI model.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络基础知识-OSI模型。
- en: Layer 2 – relating IP and MAC addresses using ARP, with some more detail on
    MAC addresses.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2层-使用ARP关联IP和MAC地址，并对MAC地址进行更详细的介绍。
- en: Layer 4 – how TCP and UDP ports work, including the TCP "three-way handshake"
    and how this appears in Linux commands.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4层- TCP和UDP端口的工作原理，包括TCP的“三次握手”，以及这在Linux命令中的表现。
- en: Local TCP and UDP port enumeration, and how these relate to running services.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地TCP和UDP端口枚举，以及这些与运行服务的关系。
- en: Remote port enumeration using both native tools.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本机工具进行远程端口枚举。
- en: Remote port enumeration using installed scanners (netcat and nmap in particular).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已安装的扫描程序（尤其是netcat和nmap）进行远程端口枚举。
- en: Finally, we'll cover some of the basics of wireless operations and troubleshooting.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将介绍一些无线操作和故障排除的基础知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples in this section, we'll use our existing Ubuntu host or
    **Virtual Machine** (**VM**). We'll be touching on some wireless topics in this
    chapter, so if you don't have a wireless card in your host or VM, you'll want
    a Wi-Fi adapter to work through those examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本节中的示例，我们将使用我们现有的Ubuntu主机或**虚拟机**（**VM**）。在本章中，我们将涉及一些无线主题，因此如果您的主机或VM中没有无线网卡，您将需要一个Wi-Fi适配器来完成这些示例。
- en: 'As we work through the various troubleshooting methods, we''ll use a variety
    of tools, starting with some native Linux commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过各种故障排除方法时，我们将使用各种工具，首先是一些本地Linux命令：
- en: '![](img/B16336_Table_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_01.jpg)'
- en: 'We''ll also use some installed applications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一些已安装的应用程序：
- en: '![](img/B16336_Table_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_02.jpg)'
- en: For the packages that aren't included in Ubuntu, be sure that you have a working
    internet connection so you can use the `apt` commands for installation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu中未包含的软件包，请确保您有可用的互联网连接，以便您可以使用`apt`命令进行安装。
- en: Network basics – the OSI model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络基础知识-OSI模型
- en: 'It''s convenient to discuss network and application concepts in terms of layers,
    with each layer being roughly responsible for higher and more abstract functions
    at upper levels, and more *nuts and bolts* primitives as you travel *down the
    stack*. The following diagram describes the OSI model in broad terms:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以层的术语讨论网络和应用概念很方便，每一层大致负责更高级别和更抽象功能的功能，并且随着您向*下移动*，在更低层有更多的*基本*原语。以下图表以广义的方式描述了OSI模型：
- en: '![Figure 3.1 – The OSI model for network communication, with some descriptions
    and examples'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1-网络通信的OSI模型，带有一些描述和示例'
- en: '](img/B16336_03_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_001.jpg)'
- en: Figure 3.1 – The OSI model for network communication, with some descriptions
    and examples
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1-网络通信的OSI模型，带有一些描述和示例
- en: In regular usage, the layers are often referenced by number, counting from the
    bottom. So, a Layer 2 problem will usually involve MAC addresses and switches,
    and will be confined to the VLAN that the station is in (which usually means the
    local subnet). Layer 3 issues will involve IP addressing, routing, or packets
    (and so will involve routers and adjacent subnets of more distant networks).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规用法中，层通常按数字引用，从底部开始计数。因此，第2层问题通常涉及MAC地址和交换机，并且将局限于站点所在的VLAN（通常意味着本地子网）。第3层问题将涉及IP地址分配，路由或数据包（因此将涉及路由器和更远网络的相邻子网）。
- en: As with any model, there's always room for confusion. For instance, there's
    some longstanding *fuzziness* between Layers 6 and 7\. Between layers 5 and 6,
    while IPSEC is definitely encryption and so belongs in layer 6, it can also be
    considered a tunneling protocol (depending on your point of view and implementation).
    Even at layer 4, TCP has the concept of a session, so would seem to perhaps have
    one foot in the layer 5 side – though the concept of *ports* keeps it firmly in
    layer 4.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何模型一样，总会有混淆的余地。例如，在第6层和第7层之间存在一些长期以来的*模糊性*。在第5层和第6层之间，虽然IPSEC绝对是加密，因此属于第6层，但它也可以被视为一种隧道协议（取决于您的观点和实现）。即使在第4层，TCP也有会话的概念，因此似乎可能在第5层一侧有所涉及-尽管*端口*的概念将其牢牢地放在第4层。
- en: And of course, there's always room for humor – the common wisdom/joke is that
    *people* form Layer 8 in this model. So, a Layer 8 problem might involve a helpdesk
    call, budget discussions, or a meeting with your organization's management to
    resolve it!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，总会有幽默的余地-常见的智慧/笑话是在这个模型中，*人*形成第8层。因此，第8层问题可能涉及求助台电话，预算讨论，或与您组织的管理层开会解决！
- en: What we see in this next diagram illustrates the most important concept to keep
    in mind with this model. As data is received, it travels up the stack, from the
    most primitive constructs it encapsulates to more and more abstract/high-level
    constructs (from bits to frames to packets to APIs to applications, for instance).
    Sending data moves it from the application layer toward the binary representation
    on the wire (from the upper layers to the lower ones).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图表中，我们看到的是要牢记的这个模型中最重要的概念。随着数据的接收，它沿着堆栈向上移动，从最原始的构造到更抽象/高级的构造（例如从位到帧到数据包到API到应用程序）。发送数据将其从应用层移动到线上的二进制表示（从上层到下层）。
- en: 'Layers 1-3 are often referred to as the **media** or **network** layers, whereas
    layers 4-7 are generally called the **host or application** layers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第1-3层通常被称为**媒体**或**网络**层，而第4-7层通常被称为**主机或应用程序**层：
- en: '![Figure 3.2 – Traveling up and down the OSI stack, encapsulating and decapsulating
    as we go'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2-上下移动OSI堆栈，封装和解封装'
- en: '](img/B16336_03_002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_002.jpg)'
- en: Figure 3.2 – Traveling up and down the OSI stack, encapsulating and decapsulating
    as we go
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2-上下移动OSI堆栈，封装和解封装
- en: This concept is what makes it possible for a vendor to manufacture a switch
    that will interact with a network card from another vendor for instance, or for
    switches to work with routers. This is also what powers our application ecosystem
    – for the most part application developers do not have to worry about IP addresses,
    routing, or the differences between wireless and wired networks, all that is just
    taken care of – the network can be treated as a black box, where you send data
    in one end, and you can be certain that it will come out at the other end in the
    right place and format.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念使得供应商能够制造一个开关，它可以与另一个供应商的网络卡进行交互，或者让交换机与路由器一起工作。这也是我们应用生态系统的动力-在大多数情况下，应用程序开发人员不必担心IP地址、路由或无线和有线网络之间的差异，所有这些都已经被处理好了-网络可以被视为一个黑盒子，你在一端发送数据，你可以确信它会在另一端以正确的位置和格式出现。
- en: Now that we have established the basics of the OSI model, let's learn in detail
    about the data link layer by exploring the `arp` command and the local ARP table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了OSI模型的基础，让我们通过探索`arp`命令和本地ARP表来详细了解数据链路层。
- en: Layer 2 – relating IP and MAC addresses using ARP
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2层-使用ARP关联IP和MAC地址
- en: With the OSI model firmly in place, we can see that our discussion so far around
    IP addresses has been clustered around Layer 3\. This is where regular people,
    and even many IT and networking people, tend to consider the network path to *stop*
    in their understanding – they can follow the path down that far and consider the
    rest to be a black box. But as a networking professional, Layers 1 and 2 are extremely
    important – let's start with Layer 2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了OSI模型的坚实基础，我们可以看到到目前为止我们围绕IP地址的讨论都集中在第3层。这是普通人，甚至许多IT和网络人员在他们的理解中通常认为网络路径*停止*的地方-他们可以一直跟踪到那里，然后认为剩下的部分是一个黑盒子。但作为一个网络专业人员，第1层和第2层非常重要-让我们从第2层开始。
- en: Theoretically, MAC addresses are the addresses that are *burned into* each network
    interface. While this is normally true, it's also an easy thing to change. What
    is the MAC address though? It's a 12-digit (6-byte/48-bit) address, normally shown
    in hexadecimal. When displayed, each byte or double-byte is usually separated
    by `.` or `-`. So typical MAC addresses might be `00-0c-29-3b-73-cb` or `9a93.5d84.5a69`
    (showing both common representations).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，MAC地址是*烧入*到每个网络接口的地址。虽然这通常是正确的，但这也是一个容易改变的事情。MAC地址是什么呢？它是一个12位（6字节/48位）地址，通常以十六进制显示。在显示时，每个字节或双字节通常用`.`或`-`分隔。因此，典型的MAC地址可能是`00-0c-29-3b-73-cb`或`9a93.5d84.5a69`（显示两种常见表示）。
- en: In practice, these addresses are used to communicate between hosts in the same
    VLAN or subnet. If you look at a packet capture (we'll get on to this later in
    the book, in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet
    Capture and Analysis in Linux*), at the start of a TCP conversation you'll see
    the sending station send a broadcast (a request sent to all stations in the subnet)
    `who has IP address x.x.x.x`. The `That's me, and my MAC address is aaaa.bbbb.cccc`.
    If the target IP address is on a different subnet, the sender will "ARP for" the
    gateway for that subnet (which will usually be the default gateway, unless there
    are local routes defined).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些地址用于在同一VLAN或子网中的主机之间进行通信。如果你查看数据包捕获（我们将在本书的后面部分进行，*第11章*，*Linux中的数据包捕获和分析*），在TCP会话开始时，你会看到发送站发送一个广播（发送到子网中的所有站点的请求）`谁有IP地址x.x.x.x`。`那是我，我的MAC地址是aaaa.bbbb.cccc`。如果目标IP地址在不同的子网上，发送方将为该子网的网关进行“ARP请求”（通常是默认网关，除非定义了本地路由）。
- en: Going forward, the sender and receiver then communicate using MAC addresses.
    The switch infrastructure that the two hosts are connected to uses MAC addresses
    only within each VLAN, which is one reason why switches are so much faster than
    routers. When we look at the actual packets (in the chapter on *Packet Capture*),
    you'll see both the sending and receiving MAC address as well as the IP addresses
    in each packet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前进时，发送方和接收方使用MAC地址进行通信。这两个主机连接的交换机基础设施仅在每个VLAN中使用MAC地址，这也是交换机比路由器快得多的原因之一。当我们查看实际的数据包（在*数据包捕获*章节中），你会看到每个数据包中的发送和接收MAC地址以及IP地址。
- en: 'The ARP request is cached on each host in an `arp` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ARP请求在每个主机上都被缓存到一个`arp`命令中：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see this is pretty simple. It just relates the Layer 3 IP address to
    the Layer 2 MAC address to the Layer 1 `/proc` directory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这很简单。它只是将第3层IP地址与第2层MAC地址关联到第1层`/proc`目录：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that there is both a default value (in seconds), and a value for each network
    adapter (these usually match). This may seem short to you – the matching MAC address
    table on switches (commonly called the CAM table) is normally at 5 minutes, and
    the ARP table on routers is normally 14,400 seconds (4 hours). These values are
    all about resources. In aggregate, workstations have the resources to frequently
    send ARP packets. The switches *learn* MAC addresses from traffic (including ARP
    requests and replies), so having that timer be slightly longer than the workstation
    timer makes sense. Similarly, having a lengthy ARP cache timer on routers conserves
    its CPU and NIC resources. That timer is so long on routers because in years past,
    routers were constrained by bandwidth and CPU, compared to just about everything
    else on the network. While that has changed in modern times, the lengthy default
    value for ARP cache timeout on routers remains. This is an easy thing to forget
    during router or firewall migrations – I've been involved in many maintenance
    windows of that type where a `clear arp` command on the right router magically
    "fixed everything" after the migration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个网络适配器都有一个默认值（以秒为单位），这些值通常是匹配的。这对您来说可能看起来很短-交换机上的匹配MAC地址表（通常称为CAM表）通常为5分钟，路由器上的ARP表通常为14,400秒（4小时）。这些值都与资源有关。总的来说，工作站有资源频繁发送ARP数据包。交换机从流量中（包括ARP请求和响应）学习MAC地址，因此使得该计时器略长于工作站计时器是有意义的。同样，路由器上的长时间ARP缓存计时器可以节省其CPU和NIC资源。路由器上的计时器之所以如此之长，是因为在过去的几年里，与网络上的其他所有设备相比，路由器受到带宽和CPU的限制。尽管在现代时代已经发生了变化，但路由器上ARP缓存超时的长默认值仍然存在。在路由器或防火墙迁移期间很容易忘记这一点-我参与了许多此类维护窗口，在迁移后，对正确路由器的`clear
    arp`命令神奇地“修复了一切”。
- en: 'We haven''t talked about the `/proc` directory in Linux yet – this is a "virtual"
    directory of files that contain the current settings and statuses of various things
    on your Linux host. These are not "real" files, but they are represented as files
    so we can use the same commands that we use for files: `cat`, `grep`, `cut`, `sort`,
    `awk`, and so on. You can look at network interface errors and values, such as
    in /`proc/net/dev`, for instance (note how things don''t quite line up correctly
    in this listing):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论Linux中的`/proc`目录-这是一个包含Linux主机上各种设置和状态的当前文件的“虚拟”目录。这些不是“真实”的文件，但它们被表示为文件，因此我们可以使用与文件相同的命令：`cat`、`grep`、`cut`、`sort`、`awk`等。例如，您可以查看网络接口错误和值，例如在`/proc/net/dev`中（请注意此列表中的事物并不完全正确对齐）。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can even look in the memory stats (note that `meminfo` contains **lots**
    more info):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以查看内存统计信息（请注意`meminfo`包含**更多**信息）：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Back to ARP and MAC addresses. You can add a static MAC address – one that won't
    expire and might be different from the real MAC of the host you want to connect
    to. This is often done for troubleshooting purposes. Or you can clear an ARP entry,
    which you might often want to do if a router has been swapped out (for instance
    if your default gateway router has the same IP but now has a different MAC). Note
    that you don't need special rights to view the ARP table, but you sure do to modify
    it!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回到ARP和MAC地址。您可以添加静态MAC地址-一个不会过期且可能与您要连接的主机的真实MAC不同的地址。这通常是为了故障排除目的。或者您可以清除ARP条目，如果路由器已被替换（例如，如果您的默认网关路由器具有相同的IP但现在具有不同的MAC），则您可能经常需要执行此操作。请注意，您无需特殊权限即可查看ARP表，但您确实需要修改它！
- en: 'To add a static entry, do the following (note the `PERM` status when we display
    it):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加静态条目，请执行以下操作（请注意在显示时的`PERM`状态）。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To delete an ARP entry, do the following (note that the `-i interfacename`
    parameter is routinely skipped for this command):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除ARP条目，请执行以下操作（请注意，对于此命令，通常会跳过`-i interfacename`参数）。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To masquerade as a given IP address – for instance, to answer ARP requests
    for IP `10.0.0.1` – do the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要伪装成给定的IP地址-例如，回答IP`10.0.0.1`的ARP请求-请执行以下操作：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, you can also easily change an interface's MAC address. You might think
    that this would be done to deal with duplicated addresses, but that situation
    is exceedingly rare.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以轻松更改接口的MAC地址。您可能会认为这是为了处理重复的地址，但这种情况非常罕见。
- en: 'Legitimate reasons to change a MAC address might include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更改MAC地址的合法原因可能包括以下内容：
- en: You have migrated a firewall and the ISP has your MAC hardcoded.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已迁移防火墙，而ISP已经将您的MAC硬编码。
- en: You have migrated a host or host NIC, and the upstream router isn't accessible
    to you, but you can't wait 4 hours for the ARP cache to expire on that router.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已迁移主机或主机NIC，并且上游路由器对您不可访问，但您不能等待该路由器上的ARP缓存过期4小时。
- en: You have migrated a host, and there is a DHCP reservation for the old MAC address
    that you need to use, but you don't have access to "fix" that DHCP entry.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已迁移主机，并且旧MAC地址有DHCP保留，但您无法访问“修复”该DHCP条目。
- en: Apple devices will change their wireless MAC addresses for privacy reasons.
    Given how many other (and easier) methods there are to track a person's identity,
    this protection isn't usually that effective.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出于隐私原因，苹果设备会更改其无线MAC地址。鉴于追踪个人身份的许多其他（更容易的）方法，这种保护通常并不那么有效。
- en: 'Malicious reasons to change a MAC address include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更改MAC地址的恶意原因包括以下内容：
- en: You are attacking a wireless network, and have figured out that once authenticated,
    the only checks that the access point does are against the client MAC addresses.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在攻击无线网络，并且已经发现一旦经过身份验证，接入点所做的唯一检查就是对客户端MAC地址。
- en: The same as the previous point, but against an Ethernet network that's secured
    with `802.1x` authentication, but with an insecure or incomplete configuration
    (we'll get into this in more detail in a later chapter).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前一点相同，但针对使用`802.1x`认证的以太网网络，但配置不安全或不完整（我们将在后面的章节中详细介绍）。
- en: You are attacking a wireless network that has MAC address permissions on it.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在攻击具有MAC地址权限的无线网络。
- en: Hopefully this illustrates that using MAC addresses for security purposes isn't
    usually a wise decision.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这说明了出于安全目的使用MAC地址通常不是明智的决定。
- en: 'To find your MAC addresses, we have four different methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找您的MAC地址，我们有四种不同的方法：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To change a Linux host''s MAC address, we have several options:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改Linux主机的MAC地址，我们有几个选项：
- en: 'In the Linux GUI, you could start by clicking the network icon on the top panel,
    then select **Settings** for your interface. For instance, for a host with one
    Ethernet card, choose "**Wired Connection**", then **Wired Settings**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux GUI中，您可以通过单击顶部面板上的网络图标，然后选择**设置**来开始。例如，对于具有一个以太网卡的主机，选择“**有线连接**”，然后选择**有线设置**：
- en: '![Figure 3.3 – Changing the MAC address from the GUI, step 1'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 从GUI更改MAC地址，第1步'
- en: '](img/B16336_03_003.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_003.jpg)'
- en: Figure 3.3 – Changing the MAC address from the GUI, step 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 从GUI更改MAC地址，第1步
- en: 'From the interface that pops up, open the **New Profile** dialog box by clicking
    the **+** icon, then simply add the MAC in the **Cloned Address** field:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从弹出的界面中，通过单击**+**图标打开**新配置文件**对话框，然后在**克隆地址**字段中简单地添加MAC：
- en: '![Figure 3.4 – Changing the MAC address from the GUI, step 2'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 从GUI更改MAC地址，第2步'
- en: '](img/B16336_03_004.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_004.jpg)'
- en: Figure 3.4 – Changing the MAC address from the GUI, step 2
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 从GUI更改MAC地址，第2步
- en: 'Or, from the command line or using a script, you can do the following (use
    your own interface names and target MAC address, of course):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过命令行或使用脚本执行以下操作（当然，使用您自己的接口名称和目标MAC地址）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is also the `macchanger` package with which you can change your interface's
    MAC address to a target value or to a pseudo-random value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`macchanger`软件包，您可以使用它将接口的MAC地址更改为目标值或伪随机值。
- en: 'To make a permanent MAC address change, you can use `netplan` and its associated
    configuration files. First, make a backup of the configuration file, `/etc/netplan./01-network-manager-all.yaml`,
    then edit it. Note that to change the MAC, you need a `match` statement for the
    hardware **Burned-In Address** (**BIA**) MAC address value, then the line after
    sets the new MAC:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行永久的MAC地址更改，您可以使用`netplan`及其相关的配置文件。首先，备份配置文件`/etc/netplan./01-network-manager-all.yaml`，然后进行编辑。请注意，要更改MAC地址，您需要一个硬件**烧入地址**（**BIA**）MAC地址值的`match`语句，然后在设置新MAC的下一行：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can test your new configuration with `sudo netplan try`, and apply it with
    `sudo netplan apply`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`sudo netplan try`测试新配置，并使用`sudo netplan apply`应用它。
- en: 'Alternatively, you can create or edit the `/etc/udev/rules.d/75-mac-spoof.rules`
    file, which will execute on every startup. Add the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以创建或编辑`/etc/udev/rules.d/75-mac-spoof.rules`文件，该文件将在每次启动时执行。添加以下内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the basics of MAC address usage in ARP mastered, let's dig a bit deeper
    into MAC addresses and their relationship to the manufacturers of the various
    network adapters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了ARP中MAC地址使用的基础知识后，让我们深入了解MAC地址及其与各种网络适配器制造商的关系。
- en: MAC address OUI values
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAC地址OUI值
- en: So now that we've covered timeouts and ARP, do we know everything we need to
    about Layer 2 and MAC addresses? Not quite yet – let's talk about **Organizationally
    Unique Identifier** (**OUI**) values. If you remember our discussion about how
    IP addresses are split into network and host sections using the subnet mask, you'll
    be surprised to know that there's a similar dividing line in MAC addresses!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们已经讨论了超时和ARP，我们是否已经了解了关于第2层和MAC地址的所有内容？还不完全 - 让我们谈谈**组织唯一标识符**（**OUI**）值。如果您还记得我们关于如何使用子网掩码将IP地址分成网络和主机部分的讨论，您会惊讶地知道MAC地址中也有类似的分界线！
- en: The leading bits of each MAC address are supposed to identify the manufacturer
    – this value is called the OUI. OUIs are registered with the formal registry maintained
    by the IEEE and posted at [http://standards-oui.ieee.org/oui.txt](http://standards-oui.ieee.org/oui.txt).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MAC地址的前导位应该标识制造商 - 这个值称为OUI。OUI已在IEEE维护的正式注册表中注册，并发布在[http://standards-oui.ieee.org/oui.txt](http://standards-oui.ieee.org/oui.txt)上。
- en: However, the Wireshark project maintains a more complete listing, located at
    [https://gitlab.com/wireshark/wireshark/-/raw/master/manuf](https://gitlab.com/wireshark/wireshark/-/raw/master/manuf).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，Wireshark项目维护了一个更完整的列表，位于[https://gitlab.com/wireshark/wireshark/-/raw/master/manuf](https://gitlab.com/wireshark/wireshark/-/raw/master/manuf)。 '
- en: Wireshark also offer a lookup web application for this listing at [https://www.wireshark.org/tools/oui-lookup.html](https://www.wireshark.org/tools/oui-lookup.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark还提供了一个查找Web应用程序，用于此列表，网址为[https://www.wireshark.org/tools/oui-lookup.html](https://www.wireshark.org/tools/oui-lookup.html)。
- en: Normally a MAC address is split equally, with the first 3 bytes (6 characters)
    being allocated to the OUI, and the last 3 bytes being allocated to uniquely identify
    the device. However, organizations are able to purchase longer OUIs (for a lower
    fee), which give them fewer device addresses to allocate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，MAC地址被平均分割，前3个字节（6个字符）分配给OUI，后3个字节分配给唯一标识设备。但是，组织可以购买更长的OUI（费用更低），这使它们可以分配更少的设备地址。
- en: OUIs are valuable tools in network troubleshooting – when problems arise or
    unknown stations appear on the network, the OUI values can help in identifying
    these culprits. We'll see OUIs crop up later in this chapter, when we discuss
    network scanners (Nmap in particular).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OUI在网络故障排除中是有价值的工具 - 当问题出现或未知站点出现在网络上时，OUI值可以帮助识别这些罪犯。我们将在本章后面讨论网络扫描仪（特别是Nmap）时，看到OUI稍后会出现。
- en: If you need a command-line OUI parser for Linux or Windows, I have one posted
    at [https://github.com/robvandenbrink/ouilookup](https://github.com/robvandenbrink/ouilookup).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要Linux或Windows的命令行OUI解析器，我在[https://github.com/robvandenbrink/ouilookup](https://github.com/robvandenbrink/ouilookup)上发布了一个。
- en: This concludes our first adventures in Layer 2 of the OSI model and our examination
    of its relationship to Layer 3, so let's venture higher into the stack into layer
    4, by looking at the TCP and UDP protocols and their associated services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在OSI模型的第2层中的第一次冒险，以及我们对其与第3层的关系的考察，所以让我们进入更高的层次，进入第4层，看看TCP和UDP协议及其相关服务。
- en: Layer 4 – how TCP and UDP ports work
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4层 - TCP和UDP端口的工作原理
- en: '**Transmission Control Protocol** (**TCP**) and **User Datagram Protocol**
    (**UDP**) are normally what is meant when we discuss Layer 4 communications, in
    particular how they use the concept of *ports*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）和用户数据报协议（UDP）通常是我们讨论第4层通信时所指的内容，特别是它们如何使用*端口*的概念。
- en: When a station wants to *talk* to another station in the same subnet using its
    IP address (the IP usually gets determined in the application or presentation
    layers), it will check its ARP cache to see whether there's a MAC address that
    matches that IP. If there's no entry for that IP address, it will send an ARP
    request to the local broadcast address (as we discussed in the last section).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个站点想要使用其IP地址与同一子网中的另一个站点进行*通信*（IP通常在应用程序或表示层中确定），它将检查其ARP缓存，以查看是否有与该IP匹配的MAC地址。如果没有该IP地址的条目，它将向本地广播地址发送ARP请求（正如我们在上一节中讨论的那样）。
- en: The next step is for the protocol (TCP or UDP) to establish port-to-port communications.
    The station picks an available port, above `1024` and below `65535` (the maximum
    port value), called the **ephemeral port**. It then uses that port to connect
    to the fixed server port on the server. The combination of these ports, combined
    with the IP addresses at each end and the protocol in use (either TCP or UDP),
    will always be unique (because of the way the source port is chosen), and is called
    a **tuple**. This tuple concept is expandable, notably in NetFlow configurations,
    where other values can be "bolted on," such as **Quality of Service** (**QOS**),
    **Differentiated Services Code Point** (**DSCP**) or **Type of Service** (**TOS**)
    values, application names, interface names, and routing information such as **Autonomous
    System Numbers** (**ASNs**), MPLS, or VLAN information and bytes of traffic sent
    and received. Because of this flexibility, the basic 5-value tuple that all others
    are built on is often referred to as the **5-tuple**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是协议（TCP或UDP）建立端口到端口的通信。站点选择一个可用的端口，高于`1024`且低于`65535`（最大端口值），称为**临时端口**。然后使用该端口连接到服务器上的固定服务器端口。这些端口的组合，加上每端的IP地址和使用的协议（TCP或UDP），将始终是唯一的（因为源端口的选择方式），称为**元组**。这个元组概念是可扩展的，特别是在NetFlow配置中，其他值可以被“附加”，例如**服务质量**（QOS）、**区分服务代码点**（DSCP）或**服务类型**（TOS）值、应用程序名称、接口名称和路由信息，如**自治系统号**（ASNs）、MPLS或VLAN信息以及发送和接收的流量字节。由于这种灵活性，所有其他值都是基于的基本5值元组通常被称为**5元组**。
- en: 'The first 1,024 ports (numbered `0-1023`) are almost never used as source ports
    – these are designated specifically as server ports, and need root privileges
    to work with. Ports in the range of `1024`-`49151` are designated "user ports"
    and `49152`-`65535` are dynamic or private ports. Servers are not however forced
    to use ports numbered below `1024` though (almost every database server for instance
    uses port numbers above `1024`), and this is just a historical convention that
    dates back to when TCP and UDP were being developed and all server ports were
    below `1024`. If you look at many of the servers that date back that far, you''ll
    see the following pattern, for instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前1024个端口（编号为`0-1023`）几乎从不用作源端口 - 这些专门被指定为服务器端口，并且需要root权限才能使用。`1024`-`49151`范围内的端口被指定为“用户端口”，`49152`-`65535`被称为动态或私有端口。但是，服务器并不被强制使用低于`1024`的端口号（例如，几乎每个数据库服务器都使用高于`1024`的端口号），这只是一个历史惯例，可以追溯到TCP和UDP正在开发时，所有服务器端口都在`1024`以下。如果你看看那些追溯到那个时期的服务器，你会看到以下模式，例如：
- en: '![](img/B16336_Table_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_03.jpg)'
- en: A full listing of the ports that are formally assigned is maintained by the
    IANA, and is posted at [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: IANA维护了正式分配的端口的完整列表，并发布在[https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)上。
- en: Documentation for this is in *RFC6335*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的文档在RFC6335中。
- en: In practice though, *assignment* is a strong word for this list. While it would
    be foolish to put a web server on TCP port `53`, or a DNS server on UDP port `80`,
    many applications are not on this list at all, so simply choose a port that is
    normally free and use that. It's not unusual to see vendors select a port that
    is actually assigned to someone else on this list, but assigned to a more obscure
    or less used service. So for the most part, this list is a set of strong suggestions,
    with the unspoken implication that we'll consider any vendor who selects a well-known
    port for their own use to be... let's say, "foolish."
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，“分配”对于这个列表来说是一个强有力的词。虽然将Web服务器放在TCP端口`53`上或将DNS服务器放在UDP端口`80`上是愚蠢的，但许多应用程序根本不在这个列表上，因此只需选择一个通常空闲的端口并使用即可。看到供应商选择实际上已分配给其他人的端口，但分配给了一个更隐蔽或不太常用的服务，这并不罕见。因此，在很大程度上，这个列表是一系列强烈的建议，暗示着我们将考虑任何选择一个知名端口用于自己用途的供应商是……可以说是“愚蠢”的。
- en: Layer 4 – TCP and the three-way handshake
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4层 - TCP和三次握手
- en: UDP simply picks up from working out the 5-tuple and starts sending data. It's
    up to the receiving application to take care of receiving that data, or to check
    the application's packets to verify that things arrive in order and to do any
    error checking. In fact, it's because of this lack of overhead that UDP is used
    so often for time-critical applications such as **VoIP** (**Voice over IP**) and
    video streaming. If a packet is missed in those types of applications, normally
    backtracking to retry it will interrupt the stream of data and be noticed by the
    end user, so errors are to some extent simply ignored.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: UDP只需从解析5元组开始发送数据。接收应用程序负责接收数据，或者检查应用程序的数据包以验证数据是否按顺序到达并进行任何错误检查。事实上，正是因为UDP没有这种额外开销，所以它经常用于诸如VoIP（IP电话）和视频流等对时间要求严格的应用程序。在这些类型的应用程序中，如果丢失了一个数据包，通常回溯重试会中断数据流并被最终用户注意到，因此错误在某种程度上被简单地忽略。
- en: 'TCP however negotiates a sequence number, and maintains a sequence count as
    the conversation progresses. This allows TCP-based applications to keep track
    of dropped or corrupted packets, and retry those in parallel with more data from
    the application being sent and received. The initial negotiation of this is usually
    called the **three-way-handshake** – graphically it looks something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TCP协商了一个序列号，并在对话进行中保持一个序列计数。这使得基于TCP的应用程序能够跟踪丢失或损坏的数据包，并在应用程序发送和接收更多数据的同时重试这些数据包。这个初始的协商通常被称为“三次握手”，在图形上看起来像这样：
- en: '![Figure 3.5 – The TCP three-way handshake, with a TCP session established'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – TCP三次握手，建立TCP会话'
- en: '](img/B16336_03_005.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_005.jpg)'
- en: Figure 3.5 – The TCP three-way handshake, with a TCP session established
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – TCP三次握手，建立TCP会话
- en: 'This works as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: The first packet comes from the client from an ephemeral port, to the server's
    (usually) fixed port. It is has the **SYN** (synchronize) bit set, and has a randomly
    assigned **SEQ** (initial sequence) number, in this case **5432**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个数据包来自客户端的临时端口，发送到服务器的（通常是）固定端口。它设置了SYN（同步）位，并具有随机分配的SEQ（初始序列）号，本例中为5432。
- en: The reply packet from the server has the **ACK** (acknowledge) bit set, with
    a number of **5433**, and also has the **SYN** bit set with its own random **SYN**
    value, in this case **6543**. This packet may already contain data in addition
    to the handshake information (all subsequent packets may contain data).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器的回复数据包设置了ACK（确认）位，编号为5433，并且还设置了SYN位，具有自己的随机SYN值，本例中为6543。此数据包可能已经包含了握手信息以外的数据（所有后续数据包可能都包含数据）。
- en: The third packet is the **ACK** to the server's first **SYN**, with the number
    **6544**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个数据包是对服务器的第一个SYN的ACK，编号为6544。
- en: Going forward, all packets are **ACK** packets sent to the other party so that
    every packet has a unique sequence number and a direction.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，所有的数据包都是发送给对方的ACK数据包，以便每个数据包都有一个唯一的序列号和一个方向。
- en: Technically packet number **2** could be two separate packets, but normally
    they're combined into a single packet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，数据包2可以是两个单独的数据包，但通常它们被合并成一个数据包。
- en: The graceful end of a conversation works exactly the same way. The party that's
    ending the conversation sends a **FIN**, the other replies with a **FIN-ACK**,
    which gets an **ACK** from the first party, and they're done.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对话的优雅结束方式与此完全相同。结束对话的一方发送一个FIN，另一方回复一个FIN-ACK，得到第一方的ACK，然后结束。
- en: An ungraceful end to the conversation is often initiated with a **RST** (reset)
    packet – once a **RST** is sent, things are over, and the other party shouldn't
    send a reply to that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对话的不优雅结束通常是由一个RST（重置）数据包发起的——一旦发送了RST，一切就结束了，另一方不应该对此发送回复。
- en: We'll use these topics later in this chapter, and also throughout the book.
    So if you're still fuzzy on this, have another read, especially of the preceding
    diagram, until this looks right to you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面以及整本书中都会使用这些主题。所以如果你对此还有疑惑，再读一遍，特别是前面的图表，直到你觉得没问题为止。
- en: Now that we have some idea of how TCP and UDP ports connect to each other and
    why your application might use one over the other, let's look at how your host's
    applications "listen" on various ports.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对TCP和UDP端口如何连接以及为什么应用程序可能使用其中之一有了一些了解，让我们来看看您主机上的应用程序如何在各种端口上“监听”。
- en: Local port enumeration – what am I connected to? What am I listening for?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地端口枚举——我连接到什么？我在监听什么？
- en: Many fundamental troubleshooting steps in networking are at one end or the other
    of a communication link – namely on the client or server host. For instance, if
    a web server isn't reachable, it's of course useful to see whether the web server
    process is running and is "listening" on the appropriate ports for client requests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，许多基本的故障排除步骤都在通信链的一端或另一端——即在客户端或服务器主机上。例如，如果无法访问网页服务器，当然有必要查看网页服务器进程是否正在运行，并且是否在适当的端口上“监听”客户端请求。
- en: 'The `netstat` command is the traditional method to assess the state of network
    conversations and services on the local host. To list all listening ports and
    connections, use the following options:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`命令是评估本地主机上网络对话和服务状态的传统方法。要列出所有监听端口和连接，请使用以下选项：'
- en: '![](img/B16336_Table_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_04.jpg)'
- en: 'All five parameters are illustrated as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有五个参数如下所示：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note the varying states (you can review all of these in the `man` page for
    `netstat`, using the `man netstat` command). The most common states that you will
    see are listed in the following table. If the descriptions for either seem confusing,
    you can skip forward to the next couple of pages to work this through using the
    diagrams (*Figures 3.6* and *3.7*):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的状态（您可以在`netstat`的`man`页面中查看所有这些状态，使用`man netstat`命令）。您将看到的最常见的状态列在下表中。如果对任何一种状态的描述感到困惑，您可以跳到接下来的几页，使用图表（图3.6和3.7）来解决这个问题：
- en: '![](img/B16336_Table_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_05.jpg)'
- en: 'The less commonly seen states (mostly because these usually only last for a
    short time) are shown in the following table. If you consistently see any of these
    states you may have a problem to troubleshoot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了较少见的状态（主要是因为这些状态通常只持续很短的时间）。如果您一直看到这些状态中的任何一个，您可能需要解决问题：
- en: '![](img/B16336_Table_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_06.jpg)'
- en: 'How do these states relate to the handshake we just discussed? Let''s put them
    in a diagram – note again that in most cases the intermediate steps should only
    exist for a very short time. If you see a `SYN_SENT` or `SYN_RECVD` state for
    more than a few milliseconds you likely have some troubleshooting to do:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态与我们刚讨论的握手有什么关系？让我们把它们放在一个图表中 - 再次注意，大多数情况下，中间步骤应该只存在很短的时间。如果您看到`SYN_SENT`或`SYN_RECVD`状态持续时间超过几毫秒，您可能需要进行一些故障排除：
- en: '![Figure 3.6 – TCP session status at various points as the session is established'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - TCP会话在建立过程中的各个状态'
- en: '](img/B16336_03_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_006.jpg)'
- en: Figure 3.6 – TCP session status at various points as the session is established
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - TCP会话在建立过程中的各个状态
- en: 'You''ll see similar states as a TCP session is torn down. Note again that many
    of the intermediate states should only last a short time. Poorly written applications
    often don''t do session teardown correctly, so you may see states such as `CLOSE
    WAIT` in those situations. Another case where session teardown isn''t done well
    is when an in-path firewall has a maximum TCP session length defined. This setting
    is usually in place to handle poorly written applications that don''t close out
    correctly, or perhaps never close out at all. A maximum session timer however
    can also interfere with long-running sessions such as older-style backup jobs.
    If you have such a situation and the long-running session doesn''t recover well
    (for instance a backup job that errors out instead of resuming the session), you
    may need to work with the firewall administrator to increase this timer, or work
    with the backup administrator to look at more modern backup software (with multiple
    parallel TCP sessions and better error recovery for instance):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当拆除TCP会话时，您会看到类似的状态。再次注意，许多中间状态应该只持续很短的时间。编写不良的应用程序通常无法正确拆除会话，因此在这种情况下，您可能会看到`CLOSE
    WAIT`等状态。另一种拆除会话不良的情况是当路径中的防火墙定义了最大TCP会话长度。通常情况下，此设置用于处理无法正确关闭或甚至根本不关闭的编写不良的应用程序。然而，最大会话计时器也可能干扰长时间运行的会话，例如旧式备份作业。如果您遇到这种情况，长时间运行的会话无法恢复良好（例如备份作业出错而不是恢复会话），则可能需要与防火墙管理员合作，以增加此计时器，或者与备份管理员合作，考虑使用更现代的备份软件（例如具有多个并行TCP会话和更好的错误恢复）：
- en: '![Figure 3.7 – TCP session status at various points as the session is "torn
    down"'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 - TCP会话在各个点被"拆除"时的状态'
- en: '](img/B16336_03_007.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_007.jpg)'
- en: Figure 3.7 – TCP session status at various points as the session is "torn down"
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - TCP会话在各个点被"拆除"时的状态
- en: Notice that on the session initiation, we don't have two states that separate
    the `SYN` and `ACK` back from the server – there are a lot more states involved
    in shutting down a session than in standing one up. Also note that packets turn
    around in fractions of a second, so if you see any TCP sessions in a `netstat`
    display that are anything other than `ESTABLISHED`, `LISTENING`, `TIME-WAIT`,
    or (less frequently) `CLOSED`, then something is unusual.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在会话初始化时，我们没有两个状态来区分从服务器返回的`SYN`和`ACK` - 关闭会话涉及的状态比建立会话时涉及的状态要多得多。还要注意的是，数据包在几分之一秒内就会传输，所以如果您在`netstat`显示中看到任何TCP会话不是`ESTABLISHED`、`LISTENING`、`TIME-WAIT`或（较少见的）`CLOSED`，那么就有些异常。
- en: 'To relate the listening ports back to the services that are behind them, we''ll
    use `l` (for listening) instead of `a`, and add the `p` option for program:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将监听端口与其背后的服务联系起来，我们将使用`l`（用于监听）而不是`a`，并添加`p`选项以获取程序：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Are there alternatives to `netstat`? Definitely, there are many.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有`netstat`的替代方案？当然，有很多。
- en: '`ss` for instance has almost the same functions. In the following table, you
    can see what we''ve asked for:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ss`几乎具有相同的功能。在下表中，您可以看到我们要求的内容：
- en: '![](img/B16336_Table_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_07.jpg)'
- en: 'Let''s add the process information by adding the `p` option:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加`p`选项来添加进程信息：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how that last column was wrapped onto the next line? Let's use the `cut`
    command to only select some fields in this text display. Let's ask for columns
    1, 2, 4, 5, and 6 (we'll remove the `Recv-Q` and `Send-Q` fields). We'll do this
    using the concept of *piping* the output of one command to the next command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一列是如何换行到下一行的？让我们使用`cut`命令仅选择文本显示中的一些字段。让我们要求列1、2、4、5和6（我们将删除`Recv-Q`和`Send-Q`字段）。我们将使用*管道*的概念将一个命令的输出传递给下一个命令。
- en: The `cut` command has only a few options, and normally you'll use either `d`
    (delimiter) or `f` (field number).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`命令只有几个选项，通常您会使用`d`（分隔符）或`f`（字段编号）。'
- en: In our case, our delimiter is a *space* character, and we want fields 1, 2,
    5, and 6\. Unfortunately, we have multiple spaces between our fields. How can
    we fix that? Let's use the `tr` (translate) command. Normally `tr` will translate
    one single character to a single different character, for instance `tr 'a' 'b'`
    will replace all occurrences of `a` with `b`. In our case though, we'll use the
    `s` option of `tr`, which will reduce multiple occurrences of the target character
    down to one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的分隔符是*空格*字符，我们想要字段1、2、5和6。不幸的是，我们的字段之间有多个空格。我们该如何解决？让我们使用`tr`（translate）命令。通常情况下，`tr`会将一个单个字符转换为一个不同的字符，例如`tr
    'a' 'b'`将用`b`替换所有出现的`a`。但在我们的情况下，我们将使用`tr`的`s`选项，它将把目标字符的多个出现减少到一个。
- en: 'What will our final set of commands look like? Look at the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终命令集会是什么样子？看看以下内容：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first command is the same `ss` command we used last time. We send that
    on to `tr`, which replaces all repeated space characters with a single space.
    `cut` gets the output of this and executes the following: "Using the space character
    delimiter, give me only fields 1, 2, 5, and 6, using a *T**ab* character between
    my resulting columns."'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令与上次使用的`ss`命令相同。我们将其发送到`tr`，它将所有重复的空格字符替换为单个空格。`cut`获取此输出并执行以下操作：“使用空格字符分隔符，只给我字段1、2、5和6，使用*制表符*字符在我的结果列之间。”
- en: 'Our final result? Let''s see:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终结果呢？让我们看看：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the tab for a delimiter gives us a better chance of the resulting columns
    lining up. If this were a larger listing, we might send the whole output to a
    `.tsv` (short for **tab-separated variables**) file, which can be read directly
    by most spreadsheet applications. This would be done using a variant of piping,
    called **redirection**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用制表符作为分隔符给我们更好的机会让结果列对齐。如果这是一个更大的列表，我们可能会将整个输出发送到一个`.tsv`（缩写为**制表符分隔变量**）文件中，这可以直接被大多数电子表格应用程序读取。这将使用一种称为**重定向**的管道变体来完成。
- en: 'In this example, we''ll send the whole output to a file called `ports.csv`
    using the `>` operator, then type the file using the `cat` (concatenate) command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`>`运算符将整个输出发送到一个名为`ports.csv`的文件中，然后使用`cat`（连接）命令来查看文件内容：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, there''s a special command called `tee` that will send the output
    to two different locations. In this case, we''ll send it to the `ports.out` file,
    and the special `STDOUT` (standard output) file, which essentially means "type
    it back into my terminal session." For fun, let''s use the `grep` command to select
    only established sessions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个特殊的命令叫做`tee`，它可以将输出发送到两个不同的位置。在这种情况下，我们将其发送到`ports.out`文件和特殊的`STDOUT`（标准输出）文件，这基本上意味着“将其输入回我的终端会话中”。为了好玩，让我们使用`grep`命令只选择已建立的会话：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Want to see some more detailed statistics on the TCP conversations? Use `t`
    for TCP, and `o` for options:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想要查看一些关于TCP对话的更详细的统计信息吗？使用`t`代表TCP，`o`代表选项：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This TCP options display can be useful in troubleshooting long-lived TCP sessions
    that might run through a firewall. Because of memory constraints, firewalls will
    periodically clear TCP sessions that have not terminated correctly. Since they
    haven't terminated, in most cases the firewall will look for sessions that have
    run longer than *x* minutes (where *x* is some number that has a default value
    and can be configured). A classic way that this can go sideways is if a client
    is running a backup or transferring a large file through the firewall, perhaps
    backing up to a cloud service or transferring a large file in or out of the network.
    If these sessions exceed that timeout value, they'll of course just get closed
    at the firewall.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种TCP选项显示对于排除可能通过防火墙运行的长期TCP会话非常有用。由于内存限制，防火墙会定期清除未正确终止的TCP会话。由于它们没有终止，在大多数情况下，防火墙将寻找运行时间超过*x*分钟的会话（其中*x*是一个具有默认值并且可以配置的数字）。这种情况经典的错误可能出现在客户端通过防火墙运行备份或传输大文件，可能是备份到云服务或在网络内外传输大文件。如果这些会话超过了超时值，它们当然会在防火墙上被关闭。
- en: In cases like this, it's important to see how long individual TCP sessions might
    last in a long transfer. A backup or a file transfer might be composed using several
    shorter sessions, running in parallel and in sequence to maximize performance.
    Or they might be a single transfer that runs as long as the process. This set
    of `ss` options can help you gauge how your process behaves under the hood, without
    having to resort to a packet capture (never fear, we will get to packet captures
    later in this book).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重要的是要看到长时间的TCP会话可能持续多久。备份或文件传输可能由几个较短的会话组成，同时并按顺序运行以最大化性能。或者它们可能是一个持续时间与进程一样长的单个传输。这组`ss`选项可以帮助您了解您的进程在幕后的行为，而无需求助于数据包捕获（不要担心，我们将在本书的后面部分介绍数据包捕获）。
- en: 'Let''s take one more crack at this, looking at the listening ports and relating
    the display back to the listening service on the host:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，查看监听端口并将显示与主机上的监听服务相关联：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another classic way to collect this information is to use the `lsof` (list
    of open files) command. Wait a minute though, we want to get network information,
    not a list of who has what file open! The missing information behind this question
    is that in Linux, `lsof` to enumerate connections on TCP ports `80` and `22`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 收集这些信息的另一个经典方法是使用`lsof`（打开文件列表）命令。等一下，我们想要获取网络信息，而不是谁打开了什么文件的列表！这个问题背后缺少的信息是，在Linux中，`lsof`用于枚举TCP端口`80`和`22`上的连接：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see the same information, represented in slightly different ways. This
    is also handy in that the `lsof` command explicitly shows the direction of each
    conversation, which it gets from the initial `SYN` packet in the conversation
    (whoever sent the first `SYN` packet is the client in any TCP conversation).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到相同的信息，以稍微不同的方式表示。这也很方便，因为`lsof`命令明确显示了每个对话的方向，它是从对话中的初始`SYN`数据包中获取的（发送第一个`SYN`数据包的人在任何TCP对话中都是客户端）。
- en: Why are we so focused on listening ports and processes? One answer was actually
    touched on earlier in this chapter – you can only have one service listening on
    a particular port. The classic example of this is trying to start a new website
    on TCP port `80`, not being aware that there's already a service listening on
    that port. In that case, the second service or process will simply fail to start.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们如此专注于监听端口和进程？一个答案实际上在本章的早些时候已经提到 - 你只能在特定端口上有一个服务监听。这个经典的例子是尝试在TCP端口`80`上启动一个新网站，却不知道已经有一个服务在该端口上监听。在这种情况下，第二个服务或进程将简单地无法启动。
- en: Now that we've explored local listening ports, along with their associated processes,
    let's turn our attention to remote listening ports – services listening on other
    hosts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了本地监听端口以及它们关联的进程，让我们把注意力转向远程监听端口 - 在其他主机上监听的服务。
- en: Remote port enumeration using native tools
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本机工具进行远程端口枚举
- en: So now we know how to work out our local services and some traffic diagnostics,
    how can we enumerate listening ports and services on remote hosts?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在我们知道如何处理本地服务和一些流量诊断，我们如何枚举远程主机上的监听端口和服务呢？
- en: 'The easy way is to use native tools – for instance `scp` for SFTP servers,
    or `ftp` for FTP servers. But what if it''s some different service that we don''t
    have an installed client for. Simple enough, the `telnet` command can be used
    in a pinch for this – for instance, we can telnet to a printer''s admin port,
    running `http` (`tcp/80`), and make a `GET` request for the header of the first
    page. Notice the garbage characters at the bottom of the listing – that''s how
    graphics are represented on this page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的方法是使用本机工具-例如`scp`用于SFTP服务器，或`ftp`用于FTP服务器。但如果是一些我们没有安装客户端的不同服务怎么办。很简单，`telnet`命令可以在这种情况下使用-例如，我们可以telnet到打印机的管理端口，运行`http`（`tcp/80`），并对第一页的标题发出`GET`请求。注意列表底部的垃圾字符-这是该页面上图形的表示方式：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even if you don't know what to type, usually if you can connect at all with
    telnet, that means that the port you are trying is open.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道要输入什么，通常如果你能用telnet连接，那就意味着你尝试的端口是打开的。
- en: There are a few problems with this method though – if you don't know what to
    type, this isn't a foolproof way of determining whether that port is open or not.
    Also, quite often, exiting out of that session can be a problem – often `BYE`,
    `QUIT`, or `EXIT` will work, sometimes pressing *^c* (*Ctrl* + *C*) or *^z* will
    work, but neither of those methods is 100% guaranteed. Finally, it's likely you
    are either looking at multiple hosts or multiple ports, or this might be just
    the first step in your troubleshooting. All of these factors combined make this
    method both clumsy and time consuming.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也存在一些问题-如果你不知道要输入什么，这并不是一种确定端口是否打开的万无一失的方法。而且，经常退出会成为一个问题-通常`BYE`，`QUIT`或`EXIT`会起作用，有时按下*^c*（*Ctrl*
    + *C*）或*^z*会起作用，但这两种方法都不是100%保证。最后，你可能正在查看多个主机或多个端口，或者这可能只是你故障排除的第一步。所有这些因素综合起来，使得这种方法既笨拙又耗时。
- en: In answer to this, we have dedicated *port scanner* tools that are purpose-built
    for this – `nmap` (which we'll cover in the next section) is the most popular
    of these. However, if you don't happen to have one of those installed, the `nc`
    (netcat) command is your friend!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此的回答，我们有专门为此目的而构建的*端口扫描器*工具-`nmap`（我们将在下一节中介绍）是其中最受欢迎的。但是，如果你没有安装其中一个，`nc`（netcat）命令就是你的朋友！
- en: 'Let''s scan our example HP printer with netcat:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用netcat扫描我们的示例HP打印机：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or how about we test the first `1024` ports? Say we use the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们测试前`1024`个端口怎么样？假设我们使用以下命令：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We get pages and pages of errors such as the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了许多错误页面，比如以下内容：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'OK, let''s try to filter those down with our friend `grep`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试用我们的朋友`grep`来过滤这些：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That still doesn't work – why not? The key is the word "error," Netcat sends
    errors to the special `STDERR` (standard error) file, which is normal in Linux
    (we'll see why successful connections count as errors for this tool later in this
    section). That file echoes to the console, but it's not `STDOUT`, so our `grep`
    filter misses it entirely. How do we fix this?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不起作用-为什么呢？关键在于“错误”这个词，Netcat将错误发送到特殊的`STDERR`（标准错误）文件，这在Linux中是正常的（我们稍后将看到为什么对于这个工具来说，成功的连接算作错误）。该文件会回显到控制台，但它不是`STDOUT`，所以我们的`grep`过滤器完全错过了。我们该如何解决这个问题呢？
- en: 'A bit of background on the three `STD` files or *streams* – they each have
    a file number associated with them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这三个`STD`文件或*流*的一些背景知识-它们各自都有一个与之关联的文件编号：
- en: '![](img/B16336_Table_08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_08.jpg)'
- en: 'By playing some games with these file numbers, we can redirect `STDERR` to
    `STDOUT` (so `grep` will now work for us):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对这些文件编号进行一些游戏，我们可以将`STDERR`重定向到`STDOUT`（这样`grep`现在将为我们工作）：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That''s `0` (which is seen on real networks), but netcat fails on that:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`0`（在真实网络中可见），但netcat在这方面失败了：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can duplicate this for UDP as well:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为UDP复制这个过程：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, if we scan a UDP range this can take a `port unreachable` error, which
    isn''t always supported if you have any firewalls in the path. Let''s see how
    long that "first `1024`" scan takes when targeting a UDP port (note how we''re
    stringing commands together using the semicolon):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们扫描UDP范围，这可能会出现`端口不可达`错误，如果路径中有任何防火墙，这并不总是受支持。让我们看看当针对UDP端口时，“前`1024`”扫描需要多长时间（注意我们如何使用分号串联命令）：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Yes, a solid 18 minutes – this method is not a speed demon!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，整整18分钟-这种方法并不是一个速度恶魔！
- en: 'Using netcat, you can also interact directly with a service, the same as in
    our telnet example, but without the "terminal/cursor control" type overhead that
    telnet brings. For instance, to connect to a web server, the syntax would be as
    follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用netcat，你也可以直接与服务交互，就像我们的telnet示例一样，但没有telnet带来的“终端/光标控制”类型的开销。例如，连接到web服务器的语法如下：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of more interest though, we can stand up a fake service, telling netcat to listen
    on a given port. This can be extremely handy if you need to test connectivity,
    in particular if you want to test a firewall rule, but don't have the destination
    host or service built yet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但更有趣的是，我们可以建立一个虚假的服务，告诉netcat监听指定的端口。如果你需要测试连接，特别是如果你想测试防火墙规则，但还没有构建目标主机或服务，这将非常方便。
- en: This syntax tells the host to listen on port `80`. Using the `l` parameter tells
    netcat to listen, but when your remote tester or scanner connects and disconnects,
    the netcat listener exits. Using the `l` parameter is the "listen harder" option,
    which properly handles TCP connections and disconnections, leaving the listener
    in place. Unfortunately, the `l` parameter and the `–e` (execute) parameter are
    both missing in the Ubuntu implementation of netcat. We can fake this out though
    – read on!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法告诉主机监听端口`80`。使用`l`参数告诉netcat监听，但当你的远程测试程序或扫描程序连接并断开连接时，netcat监听器会退出。使用`l`参数是“更努力地监听”的选项，它可以正确处理TCP连接和断开连接，使监听器保持在原地。不幸的是，Ubuntu实现的netcat中缺少`l`参数和`-e`（执行）参数。不过我们可以通过其他方法实现这一点-继续阅读！
- en: 'Expanding on this, let''s stand up a simple website using netcat! First, create
    a simple text file. We''ll make our `index.html` something like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们使用netcat搭建一个简单的网站！首先，创建一个简单的文本文件。我们将把我们的`index.html`做成以下的样子：
- en: '![](img/B16336_Table_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_09.jpg)'
- en: 'Now, to stand up the website, let''s add a timeout of 1 second to our netcat
    statement, and put the whole thing into a loop so that when we exit a connection,
    netcat gets restarted:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了搭建网站，让我们在netcat语句中添加一个1秒的超时，并将整个内容放入一个循环中，这样当我们退出连接时，netcat会重新启动：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note how listening on port `80` fails – we had to hit *Ctrl* + *C* to exit
    from the loop. Why is that? (Hint: go back to how ports are defined in Linux,
    earlier in this chapter.) Let''s try again with port `1500`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意监听端口`80`失败了 - 我们不得不按下*Ctrl* + *C*来退出循环。为什么会这样？（提示：回到本章前面关于Linux中端口定义的部分。）让我们再试一次，使用端口`1500`：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Browsing to our new website (note that it''s HTTP, and note the `:1500` used
    to set the destination port), we now see the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到我们的新网站（注意它是HTTP，并注意使用`:1500`来设置目标端口），我们现在看到以下内容：
- en: '![Figure 3.8 – A Netcat simple website'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - 一个Netcat简单网站'
- en: '](img/B16336_03_008.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_008.jpg)'
- en: Figure 3.8 – A Netcat simple website
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 一个Netcat简单网站
- en: 'Back on the Linux console, you''ll see that netcat echoes the client `GET`
    request and the browser''s `User-Agent` string. You''ll see the entire HTTP exchange
    (from the server''s perspective):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Linux控制台，您会看到netcat回显客户端的`GET`请求和浏览器的`User-Agent`字符串。您将看到整个HTTP交换（从服务器的角度）：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Making this a bit more active, let''s make this a website that tells us the
    date and time:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更加积极一点，让这个网站告诉我们日期和时间：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Browsing to that site now gives us the current date and time:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览该网站，我们可以看到当前的日期和时间：
- en: '![Figure 3.9 – A more complex Netcat website – adding time and date'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 一个更复杂的Netcat网站 - 添加时间和日期'
- en: '](img/B16336_03_009.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_009.jpg)'
- en: Figure 3.9 – A more complex Netcat website – adding time and date
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 一个更复杂的Netcat网站 - 添加时间和日期
- en: 'Or, using `apt-get` to install the `fortune` package, we can now add a proverb
    to give us some *timely* wisdom:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`apt-get`安装`fortune`软件包，我们现在可以添加一句谚语来给我们一些及时的智慧：
- en: '![Figure 3.10 – Adding a fortune to the Netcat website'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 - 向Netcat网站添加一句谚语'
- en: '](img/B16336_03_010.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_010.jpg)'
- en: Figure 3.10 – Adding a fortune to the Netcat website
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 向Netcat网站添加一句谚语
- en: 'We can also transfer a file using netcat. At the receiving end, we''ll listen
    on port `1234`, and send our output to `out.file`, again using redirection:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用netcat传输文件。在接收端，我们将监听端口`1234`，并将输出发送到`out.file`，同样使用重定向：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At the sending end, we''ll connect to that service for 3 seconds, and send
    it `sent-file.txt`. We''ll get our input by using redirection in the opposite
    direction, using the `<` operator:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送端，我们将连接到该服务3秒钟，并发送`sent-file.txt`。我们将通过在相反方向使用重定向来获取我们的输入，使用`<`运算符：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, back at the receiver, we can `cat` the resulting file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到接收端，我们可以使用`cat`命令查看生成的文件：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This illustrates that netcat can be a valuable troubleshooting tool, but it
    can be complex to use depending on what you are trying to accomplish. We can use
    netcat to be a simple proxy, as a simple chat application, or to present a complete
    Linux shell – all kinds of things that are handy to a network administrator (or
    a penetration tester for that matter).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明netcat可以是一个有价值的故障排除工具，但根据您要完成的任务，使用起来可能会比较复杂。我们可以使用netcat作为一个简单的代理，作为一个简单的聊天应用程序，或者呈现一个完整的Linux
    shell - 所有这些对于网络管理员（或者渗透测试者）来说都是很方便的东西。
- en: That wraps up the basics of netcat. We've used netcat to enumerate local ports,
    connect to and interact with remote ports, stand up some fairly complex local
    services, and even transfer files. Now let's look at Nmap, a much faster and more
    elegant method of enumerating remote ports and services.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是netcat的基础知识。我们已经使用netcat来枚举本地端口，连接和与远程端口交互，搭建了一些相当复杂的本地服务，甚至传输文件。现在让我们来看看Nmap，这是一种更快速、更优雅的枚举远程端口和服务的方法。
- en: Remote port and service enumeration – nmap
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程端口和服务枚举 - nmap
- en: The tool that is most widely used to scan network resources is **NMAP** (short
    for **Network Mapper**). NMAP started as a simple port scanner tool, but is well
    past that set of simple functions now, with a long list of functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用于扫描网络资源的最广泛使用的工具是NMAP（简称网络映射器）。NMAP起初是一个简单的端口扫描工具，但现在已经远远超出了简单的功能范围，具有长长的功能列表。
- en: First of all, nmap is not installed by default on a basic Ubuntu workstation
    (though it is included by default in many other distros). To install it, run `sudo
    apt-get install nmap`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，nmap在基本的Ubuntu工作站上默认情况下是没有安装的（尽管它在许多其他发行版中默认情况下是包含的）。要安装它，请运行`sudo apt-get
    install nmap`。
- en: As we go forward working with nmap, please try the various commands we're using
    in our examples. You'll likely see similar results, and will learn about this
    valuable tool along the way. You may learn lots about your network along the way
    too!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用nmap进行工作时，请尝试我们在示例中使用的各种命令。您可能会看到类似的结果，并且会在学习的过程中了解这个有价值的工具。在这个过程中，您可能也会对您的网络有很多了解！
- en: Important note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: One very important caveat on the advice of "try this out yourself." NMAP is
    a pretty innocuous tool, it almost never causes network problems. However, if
    you are running this against a production network, you will want to get a feel
    for that network first. There are several classes of gear that have particularly
    "rickety" network stacks – older medical devices for instance, as well as older
    **Industrial Control Systems** (**ICS**) or **Supervisory Control and Data Acquisition**
    (**SCADA**) gear.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“自己尝试一下”建议的一个非常重要的警告。NMAP是一个相当无害的工具，它几乎不会引起网络问题。但是，如果您在生产网络上运行它，您将首先要了解该网络的情况。有几类设备的网络堆栈特别“不稳定”
    - 例如较旧的医疗设备，以及较旧的工业控制系统（ICS）或监控和数据采集（SCADA）设备。
- en: In other words, if you in are a hospital, a factory, or a utility, take care!
    Running any network mapping against your production networks can cause issues.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果您在医院、工厂或公用事业部门，要小心！对生产网络运行任何网络映射都可能引起问题。
- en: You likely do still want to do this, but test against known "idle" gear first
    so you know that when you scan the "real" network, you have some assurance that
    you aren't going to cause a problem. And please (**please**), if you are on a
    healthcare network, **don't ever** scan anything that's attached to a person!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能确实还想这样做，但首先要针对已知的"空闲"设备进行测试，这样当你扫描"真实"网络时，你可以确保不会造成问题。而且，请（**请**），如果你在医疗保健网络上，请**永远**不要扫描任何与人相关的东西！
- en: A second (legal) caveat – don't scan things without permission. If you are on
    your home or lab network, that's a great place to play with assessment tools such
    as nmap or more aggressive security assessment tools. However, if you are at work,
    even if you're sure that you're not going to cause problems, you'll want to get
    permission in writing first.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（合法的）警告-不要未经许可扫描东西。如果你在家里或实验室网络上，那是一个很好的地方来使用nmap或更具侵略性的安全评估工具。但是，如果你在工作中，即使你确信不会造成问题，你也需要先书面获得许可。
- en: Scanning internet hosts that you don't own or don't have written permission
    to scan is very much illegal. Many would consider it pretty innocuous, and in
    most cases scanning is simply considered "internet white noise" by most companies
    (most organizations are scanned dozens or hundreds of times per hour). Always
    keep in mind that the proverb "the difference between a criminal and an information
    security professional is a signed contract" is repeated so often because it is
    100% true.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描你不拥有或没有书面许可扫描的互联网主机是非常非法的。许多人认为这是相当无害的，在大多数情况下，扫描只是大多数公司认为的"互联网白噪音"（大多数组织每小时被扫描几十次甚至几百次）。请记住，谚语"罪犯和信息安全专业人员之间的区别在于签署的合同"之所以经常被重复，是因为它是100%正确的。
- en: 'With all that behind us, let''s get more familiar with this great tool! Try
    running `man nmap` (remember the `manual` command?) – there''s lots of good information
    in the man pages for nmap, including full documentation. Once we get more familiar
    with the tool though, you may find the help text quicker to use. Normally you
    know (more or less) what you are looking for, so you can search for it using the
    `grep` command, for instance: `nmap - -help | grep <my_search_string>`. In the
    case of nmap, you can dispense with the standard `- - help` option, as the default
    output of nmap with no arguments is the help page.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，让我们更加熟悉这个伟大的工具！尝试运行`man nmap`（还记得`manual`命令吗？）- nmap的man页面中有很多有用的信息，包括完整的文档。不过一旦我们更熟悉这个工具，你可能会发现帮助文本更快。通常你知道（多多少少）你在寻找什么，所以你可以使用`grep`命令搜索，例如：`nmap
    - -help | grep <my_search_string>`。在nmap的情况下，你可以放弃标准的`- - help`选项，因为nmap没有参数的默认输出是帮助页面。
- en: 'So, to find out how to do a ping scan – that is, to ping everything in the
    range (which I always forget the syntax for) – you would search as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要找出如何进行ping扫描-也就是说，对范围内的所有内容进行ping（我总是忘记语法），你可以搜索如下：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'How do we proceed? NMAP wants to know what you want mapped – in this case I''ll
    map the `192.168.122.0/24` subnet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该怎么做？NMAP想知道你想要映射什么-在这种情况下，我将映射`192.168.122.0/24`子网：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So that's a quick scan that tells us every IP that is currently active on our
    subnet.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速扫描，告诉我们子网上当前活动的每个IP。
- en: Now let's look for services. Let's start by looking for anything running `tcp/443`
    (which you may recognize as HTTPS). We'll use the `nmap –p 443 –open 192.168.122.0/24`
    command. There are two things to note in this command. First of all, we specified
    the port with the `-p` option.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们寻找服务。让我们首先寻找任何运行`tcp/443`（你可能会认识为HTTPS）的东西。我们将使用`nmap –p 443 –open 192.168.122.0/24`命令。在这个命令中有两件事要注意。首先，我们用`-p`选项指定了端口。
- en: By default NMAP scans for TCP ports using a `SYN` scan. nmap sends a `SYN` packet,
    and waits to get back a `SYN-ACK` packet. If it sees that, the port is open. If
    it gets a `port unreachable` response, then the port is considered closed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，NMAP使用`SYN`扫描来扫描TCP端口。nmap发送一个`SYN`数据包，并等待收到一个`SYN-ACK`数据包。如果它看到了，端口就是打开的。如果它收到一个`端口不可达`的响应，那么端口被认为是关闭的。
- en: If we wanted a full `connect` scan (where the entire three-way handshake completes),
    we could have specified `-sT`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进行完整的`connect`扫描（整个三次握手完成），我们可以指定`-sT`。
- en: Next, we see a `--open` option. This indicates "only show me open ports." Without
    this we would see closed ports as well as "filtered" ports (which typically means
    nothing came back from the initial packet).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了一个`--open`选项。这表示"只显示给我打开的端口"。如果没有这个选项，我们将看到关闭的端口以及"过滤"的端口（通常意味着初始数据包没有返回任何东西）。
- en: 'If we wanted more detail on why a port might be considered open, closed, or
    filtered, we would remove the `--open` option, and add `--reason`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更详细地了解为什么端口可能被认为是打开、关闭或被过滤，我们会移除`--open`选项，然后添加`--reason`。
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To scan UDP ports, we would use the same syntax, but add the `sU` option. Notice
    at this point that we''re starting to see MAC addresses of the hosts that are
    up. This is because the scanned hosts are in the same subnet as the scanner, so
    that information is available. NMAP uses the MAC addresses'' OUI section to identify
    the vendor of each network card:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描UDP端口，我们会使用相同的语法，但添加`sU`选项。注意到这一点，我们开始看到活动主机的MAC地址。这是因为扫描的主机与扫描器在同一个子网中，所以这些信息是可用的。NMAP使用MAC地址的OUI部分来识别每个网络卡的供应商：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Oops – because we''re scanning for UDP ports, Nmap needs to run with root privileges
    (using `sudo`). This is because it needs to put the sending interface into *promiscuous
    mode* so that it can capture any packets that might be returned. This is because
    there is no Layer 5 concept of a *session* in UDP like we have in TCP, so there
    is no layer 5 connection between the sent and received packets. Depending on what
    command-line arguments are used (not just for UDP scans), Nmap may need elevated
    rights. In most cases if you are using Nmap or a similar tool, you''ll find yourself
    using `sudo` a fair bit:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕-因为我们正在扫描UDP端口，Nmap需要以root权限运行（使用`sudo`）。这是因为它需要将发送接口置于*混杂模式*，以便捕获可能返回的任何数据包。这是因为UDP中没有类似TCP中的*会话*的第5层概念，因此发送和接收的数据包之间没有第5层连接。根据使用的命令行参数（不仅仅是用于UDP扫描），Nmap可能需要提升的权限。在大多数情况下，如果您使用Nmap或类似工具，您会发现自己经常使用`sudo`：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A few more things to note about this scan:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此扫描还有一些需要注意的事项：
- en: The initial scan attempt failed – note that you need root rights to do most
    scans within NMAP. To get the results it does, in many cases the tool crafts packets
    itself rather than using the standard OS services to do that, and it also usually
    needs rights to capture packets that are returned by your target hosts – so nmap
    needs elevated privileges for both of those operations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 初始扫描尝试失败了-请注意，您需要root权限才能在NMAP中进行大多数扫描。为了获得它所做的结果，在许多情况下，该工具会自己制作数据包，而不是使用标准的操作系统服务来执行，它通常也需要权限来捕获目标主机返回的数据包-因此nmap需要提升的权限来执行这两个操作。
- en: We see lots more statuses indicating `open|filtered` ports. UDP is particularly
    prone to this – since there's no `SYN`/`SYN-ACK` type of handshake, you send a
    `UDP` packet, and you may not get anything back – this doesn't necessarily mean
    the port is down, it might mean that your packet was processed by the remote service,
    and no acknowledgment was sent (some protocols are like that). Or in many cases
    it might mean that the port is not up, and the host does not properly return an
    ICMP `Port Unreachable` error message (ICMP Type 1, Code 3).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到很多状态指示`open|filtered`端口。UDP特别容易出现这种情况-因为没有`SYN`/`SYN-ACK`类型的握手，你发送一个`UDP`数据包，可能不会收到任何回应-这并不一定意味着端口关闭，可能意味着你的数据包被远程服务处理了，但没有发送确认（有些协议就是这样）。或者在很多情况下，这可能意味着端口没有开启，主机没有正确返回ICMP
    `Port Unreachable`错误消息（ICMP Type 1, Code 3）。
- en: 'To get more detail, let''s use the `sV` option, which will probe the ports
    in question and get more information on the service itself. In this case, we''ll
    see that `192.168.122.1` is identified positively as open, running the `domain`
    service, with a service version listed as `generic dns response: NOTIMP` (this
    indicates that the server does not support the DNS `UPDATE` function, described
    in *RFC 2136*). The *service fingerprint* signature following the service information
    can be helpful in further identifying the service if the NMAP identification isn''t
    conclusive.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '为了获得更多细节，让我们使用`sV`选项，这将探测相关端口并获取有关服务本身的更多信息。在这种情况下，我们将看到`192.168.122.1`被明确识别为开放的，运行`domain`服务，并列出服务版本为`generic
    dns response: NOTIMP`（这表示服务器不支持*RFC 2136*中描述的DNS `UPDATE`功能）。服务信息后面的*服务指纹*签名可以帮助进一步识别服务，如果NMAP的识别不是最终确定的。'
- en: Notice also that for other hosts, the reason is listed as `no-response`. If
    you know the protocol, you can usually make good inferences in those situations.
    In the case of scanning for DNS, `no-response` means that there's no DNS server
    there or the port is closed. (or possibly it's open with some oddball service
    other than DNS running on it, which is highly unlikely). (This is to the one DNS
    server at `192`.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，对于其他主机，原因被列为`no-response`。如果您了解协议，通常可以在这些情况下做出良好的推断。在扫描DNS时，`no-response`表示那里没有DNS服务器或端口关闭。（或者可能是打开了一些与DNS不同的古怪服务，这是非常不太可能的）。（这是在`192`的一个DNS服务器上。）
- en: 'Also note that this scan took a solid 100 seconds, roughly 50 times our original
    scan:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这次扫描花了整整100秒，大约是我们最初扫描的50倍：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s try an `sV` verbose service scan of just `192.168.122.1`, port `tcp/443`
    – we''ll see that NMAP does a pretty good job of identifying the web server running
    on that host:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试对`192.168.122.1`的`tcp/443`端口进行`sV`详细服务扫描-我们将看到NMAP对运行在该主机上的Web服务器进行了相当不错的识别：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Trying the same against `192.168.122.51`, we see that the service is properly
    identified as the VMware ESXi 7.0 management interface:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对`192.168.122.51`进行相同的操作，我们发现该服务被正确识别为VMware ESXi 7.0管理界面：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that we're experts at scanning ports with various options, let's expand
    on this. NMAP allows us to run scripts against any open ports it finds – this
    can be a great time saver!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成为使用各种选项扫描端口的专家，让我们来扩展一下。NMAP允许我们对它发现的任何开放端口运行脚本-这可以节省大量时间！
- en: NMAP scripts
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NMAP脚本
- en: So far we've just looked at port scanning – NMAP is much more than that though.
    A fully featured scripting engine is available to process the packets or the output
    of NMAP, based on Lua (a text-based interpreted language). We won't dig into LUA
    in this book to any great extent, but NMAP does come with several pre-written
    scripts, some of which are invaluable to a network administrator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是看了端口扫描-NMAP不仅仅是这样。它提供了一个完整的脚本引擎，可以处理NMAP的数据包或输出，基于Lua（一种基于文本的解释语言）。我们不会在本书中深入研究LUA，但NMAP附带了几个预先编写的脚本，其中一些对网络管理员非常有价值。
- en: 'For instance, consider the SMB version information. Microsoft has been strongly
    recommending that SMBv1 be retired for years now, peaking just before the EternalBlue
    and EternalRomance vulnerabilities in SMBv1 were used by the WannaCry/Petya/NotPetya
    families of malware in 2017\. While SMBv1 has been effectively retired by making
    it hard to even enable in newer Windows versions, we still see SMBv1 in corporate
    networks – whether on older server platforms or on older Linux-based appliances
    that implement SMBv1 in their SAMBA service. Scanning for this couldn''t be easier
    using the `smb-protocols` script. Before you use any script, it''s handy to open
    the script to see exactly what it does, and how it needs to be called by NMAP
    (what ports or arguments it might need). In this case, the `smb-protocols` text
    gives us the usage, as well as what to expect in the output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑SMB版本信息。微软多年来一直强烈建议退役SMBv1，尤其是在2017年WannaCry/Petya/NotPetya恶意软件系列中使用EternalBlue和EternalRomance漏洞之前。尽管通过在较新的Windows版本中甚至难以启用SMBv1来有效地退役了SMBv1，但我们仍然在企业网络中看到SMBv1-无论是在较旧的服务器平台上还是在实现Samba服务中的较旧的基于Linux的设备上。使用`smb-protocols`脚本扫描这一点非常容易。在使用任何脚本之前，打开脚本查看它的确切功能以及NMAP如何调用它（可能需要哪些端口或参数）。在这种情况下，`smb-protocols`文本给出了我们的用法，以及输出中可以期望的内容。
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s scan some specific hosts in a target network to see more. We''ll just
    show the output from one example host that has the SMBv1 protocol running. Note
    that from the hostname it seems to be a **Network-Attached Storage** (**NAS**)
    device, so is likely Linux- or BSD-based under the hood. From the OUI we can see
    the brand name of the host, which gives us even more specific information:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扫描目标网络中的一些特定主机，以获取更多信息。我们只展示一个运行SMBv1协议的示例主机的输出。从主机名来看，它似乎是一个**网络附加存储**（**NAS**）设备，因此很可能在内部是基于Linux或BSD的。从OUI中我们可以看到主机的品牌名称，这给了我们更具体的信息：
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Or you can scan for the `Eternal*` vulnerabilities directly using the `smb-vuln-ms17-010.nse`
    script (showing just one host as an example). Scanning that same host, we see
    that even though SMBv1 is enabled, that specific vulnerability is not in play.
    It's still strongly recommended that SMBv1 be disabled though, as there's a whole
    list of vulnerabilities that SMBv1 is susceptible to, not just `ms17-010`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以直接使用`smb-vuln-ms17-010.nse`脚本扫描`Eternal*`漏洞（仅显示一个主机作为示例）。扫描同一主机时，我们发现即使启用了SMBv1，该特定漏洞也没有发挥作用。但仍强烈建议禁用SMBv1，因为SMBv1容易受到一系列漏洞的影响，而不仅仅是`ms17-010`。
- en: 'Scrolling down a bit further in the list, our second example host does have
    that vulnerability. From the hostname, we see that this is likely a business-critical
    host (running BAAN), so we''d much rather have this server fixed than ransomware.
    Looking at the production application on that host, there''s really no reason
    for SMB to be exposed at all to most users – really only system or application
    administrators should be mapping a drive to this host, and users would connect
    to it through its application port. The recommendation for this is clearly to
    patch the vulnerability (this likely hasn''t been done in several years), but
    also to firewall that service away from most users (or disable that service if
    it isn''t used by the administrators):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中再往下滚动一点，我们的第二个示例主机确实存在该漏洞。从主机名来看，我们可以看到这很可能是一个业务关键的主机（运行BAAN），因此我们更希望修复这台服务器而不是勒索软件。查看该主机上的生产应用程序，实际上没有理由让大多数用户暴露SMB-实际上只有系统或应用程序管理员应该映射到该主机，用户应该通过其应用程序端口连接到它。对此的建议显然是修补漏洞（这可能已经有好几年没有做了），但也要将该服务防火墙隔离开大多数用户（或者如果管理员不使用该服务，则禁用该服务）。
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Nmap installs with hundreds of scripts. If you are looking for something specific,
    especially if you can't determine it from just a port scan, then using one or
    more nmap scripts is often the easiest way to go. Just keep in mind that if you
    are looking for a "rogue" host, say a DHCP server, you'll find your production
    host as well as any unwanted instances.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap安装了数百个脚本。如果您正在寻找特定内容，特别是如果仅通过端口扫描无法确定，那么使用一个或多个nmap脚本通常是最简单的方法。只需记住，如果您正在寻找"流氓"主机，比如DHCP服务器，您将找到您的生产主机以及任何不需要的实例。
- en: Note that many of these rely on you to include the right port numbers in the
    scan. The "broadcast" style scripts will usually only scan the subnet that your
    scanner is on, so scanning a remote subnet likely means "borrowing" or placing
    a host on that subnet. Many of the core network services discussed in this list
    are covered in later chapters in this book, including DNS, DHCP, and the like.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多脚本依赖您在扫描中包含正确的端口号。"广播"风格的脚本通常只会扫描您的扫描器所在的子网，因此扫描远程子网可能意味着"借用"或放置主机在该子网上。本列表中讨论的许多核心网络服务在本书的后续章节中都有涉及，包括DNS、DHCP等。
- en: Keep in mind (again) that scanning without authorization is never in your best
    interest – get written permission first!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住（再次强调），未经授权的扫描从来不符合您的最佳利益-首先获得书面许可！
- en: 'There are definitely hundreds of scripts that come with nmap, and hundreds
    more available with a quick internet search. Some of the pre-packaged nmap scripts
    I find handiest on a production network include the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: nmap附带了数百个脚本，还有数百个可以通过快速的互联网搜索获得。我在生产网络上发现的一些预打包的nmap脚本包括以下内容：
- en: '![](img/B16336_Table_10.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_10.jpg)'
- en: '**Unexpected, malicious, or misconfigured network infrastructure**:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**意外的、恶意的或配置错误的网络基础设施**：'
- en: '![](img/B16336_Table_11.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_11.jpg)'
- en: '**Server problems and malicious services**:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器问题和恶意服务**：'
- en: '![](img/B16336_Table_12.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_12.jpg)'
- en: '**Pirated, "shadow IT," malicious, or otherwise unexpected servers**:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版、"影子IT"、恶意或其他意外服务器**：'
- en: '![](img/B16336_Table_13a.jpg)![](img/B16336_Table_13b.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_13a.jpg)![](img/B16336_Table_13b.jpg)'
- en: '**Workstation issues**:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作站问题**：'
- en: '![](img/B16336_Table_14.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_14.jpg)'
- en: '**Network perimeter problems**:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络外围问题**：'
- en: '![](img/B16336_Table_15.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_15.jpg)'
- en: '**Miscellaneous server or workstation issues**:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他服务器或工作站问题**：'
- en: '![](img/B16336_Table_16.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_Table_16.jpg)'
- en: This summarizes the various uses of Nmap. Where Nmap doesn't do so well is in
    larger networks – for instance, in `/8` or `/16` networks, or some of the really
    large IPv6 networks. For these networks, a faster tool is needed. Let's explore
    the MASSCAN tool for these uses.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了Nmap的各种用途。Nmap在较大的网络中表现不佳 - 例如，在`/8`或`/16`网络中，或一些非常大的IPv6网络中。对于这些网络，需要更快的工具。让我们探索MASSCAN工具的这些用途。
- en: Are there limits to Nmap?
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nmap有限制吗？
- en: The primary limit to Nmap is performance. As the network size grows, Nmap will
    (of course) take longer and longer to complete any scan you are running. This
    is often not an issue, but in a production network, if your scan starts at 8 A.M.
    and ends sometime the next day, there's likely a sizable amount of time where
    devices are mostly powered off or are disconnected, so the scan's usefulness will
    suffer. This gets especially pronounced when you are on very large networks –
    for instance, as your subnet mask shrinks or your network count grows, scan times
    for Nmap can grow to hours, days, or weeks. Equally, on IPv6 networks it's common
    to see thousands, hundreds of thousands, or even millions of addresses, which
    can translate to Nmap scan times of years or decades.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap的主要限制是性能。随着网络规模的增长，Nmap（当然）完成任何扫描所需的时间会越来越长。这通常不是问题，但在生产网络中，如果您的扫描从早上8点开始，直到第二天结束，那么很可能有相当长的时间设备大多处于关闭状态或断开连接状态，因此扫描的实用性会受到影响。当您在非常大的网络上时，这一点尤为明显
    - 例如，当您的子网掩码缩小或网络数量增加时，Nmap的扫描时间可能会增加到几个小时、几天或几周。同样，在IPv6网络中，通常会看到成千上万甚至数百万的地址，这可能会导致Nmap扫描时间长达数年甚至数十年。
- en: There are two ways to help resolve this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以帮助解决这个问题。
- en: 'First, if you read the NMAP `man` page, there are some parameters to speed
    things up – you can adjust parallelism (how many operations can run at once),
    host timeouts, round trip timeouts, and the delay wait between operations. These
    are fully explained on the `man` page, and are discussed in more depth here: [https://nmap.org/book/man-performance.html](https://nmap.org/book/man-performance.html).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您阅读NMAP的`man`页面，有一些参数可以加快速度 - 您可以调整并行性（可以同时运行多少个操作）、主机超时、往返超时和操作之间的延迟等。这些在`man`页面上有详细说明，并且在这里有更深入的讨论：[https://nmap.org/book/man-performance.html](https://nmap.org/book/man-performance.html)。
- en: 'Or, you can look at a different tool. Rob Graham maintains the MASSCAN tool,
    which is specifically built for high-performance scanning. With enough bandwidth
    and horsepower, it can scan the entire IPv4 internet in under 10 minutes. Version
    1.3 of this tool adds IPv6 support. The MASSCAN syntax is similar to Nmap''s,
    but there are some things to watch out for when using this faster tool. The tool,
    as well as its documentation and "gotchas," is posted here: [https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以查看不同的工具。Rob Graham维护了MASSCAN工具，该工具专门用于高性能扫描。有足够的带宽和马力，它可以在不到10分钟的时间内扫描整个IPv4互联网。该工具的1.3版本增加了IPv6支持。MASSCAN的语法类似于Nmap，但在使用这个更快的工具时有一些需要注意的地方。该工具以及其文档和“陷阱”发布在这里：[https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan)。
- en: For very large networks, a common approach would be to use MASSCAN (or Nmap
    tuned for faster scans) for an initial set of scans. The output from that cursory
    scan can then be used to "feed" the next tool, whether that is Nmap or possibly
    some other tool, perhaps a security scanner such as Nessus or OpenVAS. "Chaining"
    tools together like this maximizes the strengths of each to deliver the best outcomes
    in the shortest time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常大的网络，一个常见的方法是使用MASSCAN（或调整为更快扫描的Nmap）进行初始扫描。然后可以使用来自初步扫描的输出来“馈送”下一个工具，无论是Nmap还是可能是其他工具，也许是诸如Nessus或OpenVAS之类的安全扫描工具。像这样将工具“链接”在一起，最大程度地发挥各自的优势，以在最短的时间内实现最佳结果。
- en: All tools have their limits though, and IPv6 networks remain a challenge for
    scanning tools. Unless you can limit the scope somehow, IPv6 will quickly reach
    the limits of network bandwidth, time, and memory on the scanning host. Tools
    such as DNS harvesting can help here – if you can identify which hosts are actually
    active before scanning for services, that can reduce the target addresses significantly
    back down to manageable volumes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工具都有其局限性，IPv6网络对于扫描工具仍然是一个挑战。除非您可以以某种方式限制范围，否则IPv6将很快达到扫描主机的网络带宽、时间和内存的极限。DNS收集等工具可以在这方面提供帮助
    - 如果您可以在扫描服务之前确定哪些主机实际上是活动的，那么可以将目标地址数量显着减少到可管理的范围内。
- en: With port scanning behind us, let's leave the wired world and explore troubleshooting
    with Linux on wireless networks.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描已经完成，让我们离开有线世界，探索在无线网络上使用Linux进行故障排除。
- en: Wireless diagnostic operations
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线诊断操作
- en: Diagnostic tools in wireless networks are generally concerned with finding areas
    of low signal strength and interference – things that cause problems for the folks
    using your wireless network.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 无线网络中的诊断工具通常关注于发现信号强度低和干扰的区域 - 这些问题会给使用您的无线网络的人造成问题。
- en: There are a few excellent wireless tools that are Linux-based, but we'll discuss
    Kismet, Wavemon, and LinSSID. All three tools are free, and all can be installed
    with the standard `apt-get install <package name>` command. If you expand your
    tool search to include attack-type tools or commercial products, that list obviously
    grows much bigger.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基于Linux的优秀无线工具，但我们将讨论Kismet、Wavemon和LinSSID。这三个工具都是免费的，并且都可以使用标准的`apt-get
    install <package name>`命令进行安装。如果将工具搜索范围扩大到包括攻击类型工具或商业产品，那么列表显然会变得更大。
- en: Kismet is one of the older wireless tools available for Linux. My first exposure
    to it was as an information security tool, highlighting that "hidden" wireless
    SSIDs were in fact not hidden at all!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Kismet是Linux上可用的较旧的无线工具之一。我第一次接触它是作为信息安全工具，强调“隐藏”的无线SSID实际上根本不是隐藏的！
- en: 'To run the tool, use the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该工具，请使用以下命令：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or, if you have a fully working configuration and don''t need the actual server
    window, run the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您有一个完全工作的配置，不需要实际的服务器窗口，运行以下命令：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, in another window (or in the same place if you ran Kismet in the background),
    run the Kismet client:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个窗口中（或者如果您在后台运行Kismet，则在同一个位置），运行Kismet客户端：
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the display that appears, you'll see the various SSIDs, and the BSSIDs of
    the access points that are transmitting them. As you scroll through this list,
    you'll see the channel and encryption types used for each SSID, the speed that
    your laptop understands that it can negotiate on that SSID, and also all of the
    client stations on that SSID. Each client will have its MAC address, frequency,
    and packet count shown. This information is all sent in cleartext as part of each
    client's association process and continued connection "handshaking."
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示中，您将看到各种SSID以及传输它们的接入点的BSSID。当您浏览此列表时，您将看到用于每个SSID的信道和加密类型，您的笔记本电脑理解它可以在该SSID上协商的速度，以及该SSID上的所有客户端站点。每个客户端都将显示其MAC地址、频率和数据包计数。这些信息都作为每个客户端的关联过程和持续连接的“握手”部分以明文发送。
- en: Since your wireless adapter can only be on one SSID/BSSID combination at once,
    the information presented is collected by hopping between channels.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的无线适配器一次只能在一个SSID/BSSID组合上，所以所呈现的信息是通过在信道之间跳转收集的。
- en: 'In the following screenshot, we show a hidden SSID, with the BSSID of the access
    point shown, as well as the eight clients associated with that SSID on that access
    point:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们展示了一个隐藏的SSID，显示了接入点的BSSID，以及与该接入点上的该SSID关联的八个客户端：
- en: '![Figure 3.11 – Typical Kismet output on the main screen'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - 主屏幕上的典型Kismet输出'
- en: '](img/B16336_03_011.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_011.jpg)'
- en: Figure 3.11 – Typical Kismet output on the main screen
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - 主屏幕上的典型Kismet输出
- en: 'Pressing *Enter* on a network gives you more information on the SSID being
    broadcast from that access point. Note we''re seeing a **hidden SSID** in this
    display:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上按*Enter*键会给您更多关于从该接入点广播的SSID的信息。请注意，我们在这个显示中看到了一个**隐藏的SSID**：
- en: '![Figure 3.12 – Kismet output, access point/SSID detail'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - Kismet输出，接入点/SSID详细信息'
- en: '](img/B16336_03_012.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_012.jpg)'
- en: Figure 3.12 – Kismet output, access point/SSID detail
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - Kismet输出，接入点/SSID详细信息
- en: 'Drilling down further, you can get details on client activity:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入，您可以获取有关客户端活动的详细信息：
- en: '![Figure 3.13 – Kismet output, client detail'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - Kismet输出，客户端详细信息'
- en: '](img/B16336_03_013.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_013.jpg)'
- en: Figure 3.13 – Kismet output, client detail
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - Kismet输出，客户端详细信息
- en: While Kismet is a great tool for reconnaissance and demonstrations, the menu
    is fairly easy to get lost in, and it isn't easy to focus on tracking the things
    we really care about when troubleshooting signal strength.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Kismet是一款用于侦察和演示的好工具，但菜单相当容易迷失在其中，当排除信号强度故障时，很难专注于追踪我们真正关心的事物。
- en: 'Wavemon is a very different tool. It monitors your connection only, so you
    have to associate it with an SSID. It''ll give you your current access point,
    speed, channel, and so on, as shown in the following screenshot. This can be useful,
    but it''s a narrow view of the information that''s normally required for troubleshooting
    – note in the following screenshot that the values reported are mostly about data
    throughput and signal as seen from the network that the adapter is associated
    to. For this reason, the Wavemon tool is mostly useful for troubleshooting uplink
    issues, and isn''t used so much in troubleshooting, assessing, or viewing information
    on an overall wireless infrastructure:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Wavemon是一个非常不同的工具。它只监视您的连接，因此您必须将其与一个SSID关联起来。它会给出您当前的接入点、速度、信道等信息，如下面的屏幕截图所示。这可能是有用的，但它只是对通常用于故障排除所需的信息的狭窄视图
    - 请注意在下面的屏幕截图中，报告的值主要是关于数据吞吐量和信号，从适配器关联到的网络中看到的。因此，Wavemon工具主要用于故障排除上行问题，并且在故障排除、评估或查看整体无线基础设施方面并不经常使用：
- en: '![Figure 3.14 – Wavemon display'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 - Wavemon显示'
- en: '](img/B16336_03_014.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_014.jpg)'
- en: Figure 3.14 – Wavemon display
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - Wavemon显示
- en: Of more use is **LinSSID**, a fairly close port of inSSIDer, the Windows application
    from MetaGeek. On running the application, the screen is fairly empty. Select
    the wireless adapter that you want to use to "sniff" the local wireless networks,
    and press the **Run** button.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是**LinSSID**，这是对MetaGeek的Windows应用inSSIDer的一个相当接近的移植。运行应用程序后，屏幕相当空白。选择要用于“嗅探”本地无线网络的无线适配器，然后按**Run**按钮。
- en: 'The display shows the channels available on both spectrums (2.4 and 5 GHz),
    with each SSID represented in the top window. Each SSID/BSSID combination that
    is checked in the list is shown in the bottom window. This makes it very easy
    to see the signal strength of each AP in the list, along with the relative strengths
    in the graphical display. SSIDs that interfere with each other are obvious in
    their overlapping graphical displays. The following screenshot of the display
    shows the 5 GHz spectrum situation – notice how the APs seem to all be clustered
    around two channels. Any one of them could improve their performance by changing
    channels, and in our display there''s plenty of channels to spare – in fact, this
    is what''s pushing the migration to 5 GHz. Yes, that band is faster, but more
    importantly it''s much easier to solve any interference problems from neighboring
    access points. Note also that each channel is shown on the graph as taking roughly
    20 GHz (more on this later):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了两个频谱上可用的信道（2.4和5 GHz），每个SSID在顶部窗口中表示。在列表中选中的每个SSID/BSSID组合都显示在底部窗口中。这样很容易看到列表中每个AP的信号强度，以及图形显示中的相对强度。在它们重叠的图形显示中，相互干扰的SSID是显而易见的。下面的屏幕截图显示了5
    GHz频谱情况 - 请注意AP似乎都聚集在两个信道周围。其中任何一个都可以通过更改信道来提高性能，在我们的显示中有很多信道可以使用 - 实际上，这正是推动迁移到5
    GHz的原因。是的，这个频段更快，但更重要的是，它更容易解决来自邻近接入点的任何干扰问题。还要注意，图表上显示的每个信道大约占用20 GHz（稍后会详细介绍）：
- en: '![Figure 3.15 – LinSSID output – the main screen showing channel allocation
    and strength, both in text and graphically'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 - LinSSID输出 - 主屏显示信道分配和强度，文本和图形两种方式'
- en: '](img/B16336_03_015.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_015.jpg)'
- en: Figure 3.15 – LinSSID output – the main screen showing channel allocation and
    strength, both in text and graphically
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 - LinSSID输出 - 主屏显示信道分配和强度，文本和图形两种方式
- en: 'The 2.4 GHz channel is no better. Since there are only 11 channels available
    in North America, you normally see people select channels 1, 6, or 11 - the 3
    channels that do not interfere with each other. In almost any environment that
    isn''t rural, you''ll see several neighbors using those same 3 channels that you
    thought were free! In the following screenshot, we see that everyone picked channel
    11 for some reason:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4 GHz信道也不好。由于在北美只有11个信道可用，通常会看到人们选择信道1、6或11 - 这3个信道不会相互干扰。在几乎任何不是农村的环境中，您会看到几个邻居使用您认为是空闲的那3个信道！在下面的屏幕截图中，我们看到每个人都选择了信道11，原因不明：
- en: '![Figure 3.16 – Interference from wireless neighbors – multiple wireless BSSIDs
    using the same channel'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 - 来自无线邻居的干扰 - 多个无线BSSID使用相同的信道'
- en: '](img/B16336_03_016.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_016.jpg)'
- en: Figure 3.16 – Interference from wireless neighbors – multiple wireless BSSIDs
    using the same channel
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 - 来自无线邻居的干扰 - 多个无线BSSID使用相同的信道
- en: In this second example (also from the 2.4 GHz spectrum), we see the result of
    people choosing a wider "footprint" for their signal. In `802.11` wireless, you
    have the option of expanding your default 20 GHz channel to 40 of 80 GHz. The
    benefit to this is that – in the absence of any neighbors – this will certainly
    improve throughput, especially for a lightly utilized channel (one or two clients
    for instance). However, in an environment where adjacent access points have overlapping
    signals, you can see that increasing channel width (on the 2.4 GHz band) leaves
    everyone with more interference – neighboring access points can find themselves
    with no good channel choices. This situation will typically impact the signal
    quality (and throughput) for everyone, including the one "bad neighbor" that chose
    to increase their channel width.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中（也来自2.4 GHz频谱），我们看到人们选择了更宽的信号“足迹”的结果。在802.11无线中，您可以将默认的20 GHz信道扩展到40或80
    GHz。这样做的好处是 - 在没有任何邻居的情况下 - 这肯定会提高吞吐量，特别是对于轻度使用的信道（例如一个或两个客户端）。然而，在相邻接入点有重叠信号的环境中，您会发现增加信道宽度（在2.4
    GHz频段上）会给每个人带来更多的干扰 - 相邻接入点可能发现自己没有好的信道选择。这种情况通常会影响每个人的信号质量（和吞吐量），包括选择增加信道宽度的那个“坏邻居”。
- en: 'In the 5 GHz band, there are significantly more channels, so increasing your
    channel width can usually be done more safely. It''s always wise to see what''s
    happening in your spectrum first though, before either selecting or widening the
    channels on your access points:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在5 GHz频段，有更多的信道，因此通常可以更安全地增加信道宽度。不过，在选择或扩大接入点上的信道之前，最好先看看您的频谱发生了什么：
- en: '![Figure 3.17 – Using wider channel widths in the 2.4 GHz spectrum, with resulting
    interference'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 - 在2.4 GHz频谱中使用更宽的信道宽度，导致干扰'
- en: '](img/B16336_03_017.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_03_017.jpg)'
- en: Figure 3.17 – Using wider channel widths in the 2.4 GHz spectrum, with resulting
    interference
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 - 在2.4 GHz频谱中使用更宽的信道宽度，导致干扰
- en: Of the tools we've discussed, LinSSID in particular is very useful in doing
    wireless site surveys where you need to see which channels are available, and
    more importantly, track signal strength and find "dead spots" to maximize wireless
    coverage throughout a building or area. LinSSID is also the most helpful of the
    tools we've discussed in finding situations of channel interference, or troubleshooting
    situations where a poor choice was made in channel width.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论过的工具中，LinSSID特别适用于进行无线站点调查，您需要查看可用的信道，更重要的是，跟踪信号强度并找到“死角”，以最大限度地覆盖建筑物或区域的无线覆盖范围。
    LinSSID也是我们讨论过的工具中最有帮助的，可以找到信道干扰的情况，或者解决信道宽度选择不当的情况。
- en: With what we've discussed and the tools we've explored, you should now be well
    equipped to troubleshoot issues around wireless signal strength and interference
    on both the 2.4 GHz and 5 GHz bands. You should be able to use tools such as Kismet
    to find hidden SSIDs, tools such as Wavemon to troubleshoot networks you are associated
    with, and tools including LinSSID to view the wireless spectrum holistically,
    looking for interference and signal strength, as well as issues with channel width
    and channel overlap.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '通过我们讨论和探讨过的工具，您现在应该能够很好地解决2.4 GHz和5 GHz频段的无线信号强度和干扰问题。您应该能够使用诸如Kismet之类的工具来查找隐藏的SSID，使用诸如Wavemon之类的工具来解决您所关联的网络的问题，并使用诸如LinSSID之类的工具来全面查看无线频谱，寻找干扰和信号强度问题，以及信道宽度和信道重叠问题。 '
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter behind us, you should have a good understanding of the hierarchal
    organization of the various networking and application protocols, as described
    in the OSI model. You should have a solid understanding of TCP and UDP, in particular
    how both protocols use ports, and how TCP sessions are set up and torn down. Using
    `netstat` or `ss` to see how your host is connecting to various remote services,
    or what services your host is listening for, is a skill you can use going forward.
    Expanding on this, using port scanners to see what hosts and network services
    are running in your organization should be a skill that you should find useful.
    Finally, our discussion of Linux wireless tools should help in troubleshooting,
    configuration, and wireless site surveys. All of these skills will be things we
    build on as we move forward in our journey in this book, but more importantly,
    they'll be useful in troubleshooting application and networking problems in your
    organization.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您应该对OSI模型中各种网络和应用协议的分层组织有很好的理解。您应该对TCP和UDP有扎实的了解，特别是这两种协议如何使用端口，以及TCP会话如何建立和终止。使用`netstat`或`ss`查看您的主机如何连接到各种远程服务，或者您的主机正在监听哪些服务，这是您可以继续使用的技能。在此基础上，使用端口扫描程序查看您的组织中运行着哪些主机和网络服务应该是您会发现有用的技能。最后，我们讨论的Linux无线工具应该有助于故障排除、配置和无线站点调查。所有这些技能将是我们在本书中继续前进时建立的东西，但更重要的是，它们将有助于您在组织中解决应用程序和网络问题。
- en: This wraps up our discussion of network troubleshooting using Linux. We'll revisit
    troubleshooting in most chapters though – as we move forward and build each part
    of our infrastructure, we'll find new potential problems and troubleshooting approaches.
    In this section, we discussed in detail how communications occur from a network
    and host point of view. In the next chapter, we'll discuss Linux firewalls, a
    good way to limit and control those communications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对使用Linux进行网络故障排除的讨论。尽管在大多数章节中我们会重新讨论故障排除-随着我们前进并构建基础设施的每个部分，我们会发现新的潜在问题和故障排除方法。在本节中，我们详细讨论了通信从网络和主机的角度发生的情况。在下一章中，我们将讨论Linux防火墙，这是限制和控制通信的好方法。
- en: Questions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的结束，这里有一系列问题供您测试对本章材料的了解。您将在*附录*的*评估*部分找到答案：
- en: When you assess your local ports using `netstat`, `ss`, or another command,
    will you ever see a UDP session in the `ESTABLISHED` state?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您使用`netstat`、`ss`或其他命令评估本地端口时，您是否会看到处于`ESTABLISHED`状态的UDP会话？
- en: Why is it important to be able to determine which processes listen on which
    ports?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪些进程监听哪些端口是重要的吗？
- en: Why is it important to determine which remote ports you connect to from any
    particular application?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定从任何特定应用程序连接到哪些远程端口是重要的吗？
- en: Why would you scan for expired or soon-to-expire certificates on ports other
    than `tcp/443`?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要扫描除`tcp/443`以外的端口上即将过期或即将过期的证书？
- en: Why would netcat need `sudo` rights in order to start a listener on port `80`?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么netcat需要`sudo`权限才能在端口`80`上启动监听器？
- en: In the 2.4 GHz band, which three channels make the best selection to reduce
    interference?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在2.4 GHz频段中，哪三个信道是最佳选择以减少干扰？
- en: When would you use a Wi-Fi channel width other than 20 GHz?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了20 GHz之外，您何时会使用其他Wi-Fi信道宽度？
- en: Further reading
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The OSI model (*ISO/IED 7498-1*): [https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip](https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI模型（*ISO/IED 7498-1*）：[https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip](https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip)
- en: 'Nmap: [https://nmap.org/](https://nmap.org/)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap：[https://nmap.org/](https://nmap.org/)
- en: 'The Nmap reference guide: [https://nmap.org/book/man.html](https://nmap.org/book/man.html)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap参考指南：[https://nmap.org/book/man.html](https://nmap.org/book/man.html)
- en: '[https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717](https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717](https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717)'
- en: 'MASSCAN: [https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MASSCAN：[https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan)
