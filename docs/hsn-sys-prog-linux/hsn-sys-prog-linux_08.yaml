- en: Process Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程功能
- en: 'In two chapter, you will learn concepts and practices regarding process credentials
    and capabilities. Besides being of practical importance to application development
    in Linux, this chapter, by its very nature, delves deeper into an often overlooked
    but extremely important aspect: security.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在两章中，您将学习有关进程凭据和功能的概念和实践。除了在Linux应用程序开发中具有实际重要性之外，本章本质上深入探讨了一个经常被忽视但极为重要的方面：安全性。
- en: 'We have divided the coverage of this key area into two major parts, each of
    which is a chapter in this book:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这一关键领域的覆盖分为两个主要部分，每个部分都是本书的一个章节：
- en: In [Chapter 7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process Credentials,*
    the traditional-style Unix permissions model is discussed in some detail, and
    techniques to run programs with root privileges but without requiring the root
    password were shown.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml)中，*进程凭据*，传统风格的Unix权限模型被详细讨论，并展示了以root权限运行程序但不需要root密码的技术。
- en: In this [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities,*
    the *modern* approach, the POSIX capabilities model, is discussed in some detail.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)中，*进程功能*，*现代*方法，POSIX功能模型，被详细讨论。
- en: We will attempt to clearly show the reader that, while it is important to learn
    about the traditional mechanisms and how they operate, this becomes a classic
    weak link as far as *security* is concerned. However you look at it, security
    is of paramount importance, especially these days; the advent of Linux running
    on all sorts of devices—tiny IoT and embedded devices to mobile devices, desktops,
    servers, and super-computing platforms—makes security a key concern for all stakeholders.
    Hence, the modern capabilities approach should be used when developing software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试清楚地向读者展示，虽然了解传统机制及其运作方式很重要，但就*安全*而言，这成为了一个经典的弱点。无论如何看待它，安全性都是至关重要的，尤其是在当今这个时代；Linux运行在各种设备上——从微型物联网和嵌入式设备到移动设备、台式机、服务器和超级计算平台——使安全成为所有利益相关者的关键关注点。因此，在开发软件时应该使用现代功能方法。
- en: 'In this chapter, we will cover the *modern approach—*the POSIX capabilities
    model—in some detail. We will discuss what exactly it is, and how it provides
    security and robustness. The reader will learn about the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍*现代方法*——POSIX功能模型。我们将讨论它究竟是什么，以及它如何提供安全性和健壮性。读者将了解以下内容：
- en: What exactly the modern POSIX Capabilities model is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代POSIX功能模型究竟是什么
- en: Why it is superior to the older (traditional) Unix permissions model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么它优于旧的（传统的）Unix权限模型
- en: How to work with capabilities on Linux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux上使用功能
- en: Embedding capabilities into a process or binary executable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能嵌入到进程或二进制可执行文件中
- en: Security tips
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全提示
- en: Along the way, we will use code examples, which will allow you to try out some
    of these facilities so that you can gain a better understanding of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将使用代码示例，让您尝试其中一些功能，以便更好地理解它们。
- en: The modern POSIX capabilities model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代POSIX功能模型
- en: 'Consider this (fictional) scenario: Vidya is on a project developing a Linux
    application for Alan and his team. She is working on a component that captures
    network packets and saves them to a file (for later analysis). The program is
    called **packcap**. However, to successfully capture the network packets, packcap
    must run with *root* privileges. Now, Vidya understands that running applications
    as  *root* is not a good security practice; not only that, she knows the customer
    will not accept the statement: Oh, it didn''t work? You must run it logged in
    as a root or via sudo. Running it via sudo(8) might sound reasonable, but, when
    you stop to think about it, that implies that every member of Alan''s team must
    be given the *root* password, and this is simply not acceptable.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个（虚构的）情景：Vidya正在为Alan和他的团队开发Linux应用程序的项目。她正在开发一个捕获网络数据包并将其保存到文件中的组件（以供以后分析）。该程序名为**packcap**。然而，为了成功捕获网络数据包，packcap必须以*root*权限运行。现在，Vidya明白以*root*身份运行应用程序不是一个好的安全实践；不仅如此，她知道客户不会接受这样的说法：哦，它没用？你必须以root登录或通过sudo运行它。通过sudo(8)运行它可能听起来合理，但是，当你停下来想一想，这意味着Alan的每个团队成员都必须被给予*root*密码，这是完全不可接受的。
- en: 'So, how does she solve the problem? The answer suddenly jumps out at her: Make
    the *packcap* binary executable a *setuid-*root file; this way, when it''s launched,
    the process will be running with *root* privileges, so there will be no need for
    a root login/password or sudo. Sounds fantastic.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，她如何解决这个问题呢？答案突然出现在她脑海中：将*packcap*二进制文件设置为*setuid-*root文件可执行；这样，当它被启动时，进程将以*root*权限运行，因此不需要root登录/密码或sudo。听起来很棒。
- en: Motivation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: 'This—the setuid—root approach—is *exactly* the traditional manner in which
    problems like the one briefly described above were solved. So, what''s changed
    today (well, over several years now)? In a nutshell: *security concerns over hacking*.
    The reality is this: All real-world non-trivial programs do have defects (bugs)—hidden,
    lurking, undiscovered, perhaps, but very much there. The vast scope and complexity
    of modern real-world software projects make this an unfortunate reality. Certain
    bugs result in *vulnerabilities* "leaking" into the software product; this is
    precisely what hackers look to *exploit*. The well-known, yet dreaded, **Buffer
    Overflow** *(***BoF***)* attacks are based on software vulnerabilities within
    several heavily used library APIs! (We highly recommend reading David Wheeler''s
    book *Secure Programming* *HOWTO - Creating Secure Software—*see the *Further
    reading* section on the GitHub repository.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种setuid-root方法——正是传统的解决上面简要描述的问题的方式。那么，今天有什么变化（好吧，现在已经有好几年了）？简而言之：*对黑客攻击的安全关注*。现实情况是：所有真实世界的非平凡程序都有缺陷（错误）——隐藏的、潜伏的、未发现的，也许，但确实存在。现代真实世界软件项目的广泛范围和复杂性使这成为一个不幸的现实。某些错误导致*漏洞*“泄漏”到软件产品中；这正是黑客寻求*利用*的内容。众所周知，但令人畏惧的**缓冲区溢出**（***BoF***）攻击是基于几个广泛使用的库API中的软件漏洞！（我们强烈建议阅读David
    Wheeler的书*安全编程* *HOWTO - 创建安全软件*——请参阅GitHub存储库的*进一步阅读*部分。）
- en: '**At the code level, security issues are bugs; once fixed, the issue disappears.**
    (See a link to Linux''s comments on this in the *Further reading* section on the
    GitHub repository.)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**在代码级别上，安全问题就是错误；一旦修复，问题就消失了。**（在GitHub存储库的*进一步阅读*部分中查看Linux对此的评论链接。）'
- en: 'So what''s the point? Simply put the point is this: It''s entirely possible
    that the setuid-root program you deliver to your customer (packcap) has unfortunate
    and unknown-as-of-now software vulnerabilities embedded within it, which hackers
    could discover and exploit (yes, there''s a whole job description for this—**white-hat
    hacking** or **pentesting.**)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么重点是什么？简而言之，重点就是：您交付给客户的setuid-root程序（packcap）可能包含不幸的、目前未知的软件漏洞，黑客可能会发现并利用它们（是的，这有一个专门的工作描述——**白帽黑客**或**渗透测试**）。
- en: If the process *hacked into* runs with normal privileges—non-root—at least then
    the damage is limited to that user account, and it goes no further. But if the
    process is running with root privilege and the attack succeeds, the hacker might
    well end up with a *root shell on the system*. The system is now compromised—anything
    can happen (secrets can be stolen, backdoors and rootkits installed, DoS attacks
    become trivial.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程*被黑客入侵*以普通特权—非root—运行，那么损害至少被限制在该用户帐户中，不会进一步扩散。但是，如果进程以root特权运行并且攻击成功，黑客可能最终会在系统上获得*root
    shell*。系统现在已经受到损害——任何事情都可能发生（秘密可能被窃取，后门和rootkit被安装，DoS攻击变得微不足道）。
- en: 'It''s not only about security, though: by limiting privileges, you gain damage-control
    benefits as well; bugs and crashes are going to cause limited damage—the situation
    is far better *contained* than earlier.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是关于安全，通过限制特权，您还会获得损坏控制的好处；错误和崩溃将会造成有限的损害——情况比以前要好得多。
- en: POSIX capabilities
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX功能
- en: So, going back to our fictional packcap example application, how do we run the
    process—which requires root, it seems—without root privileges (no root login,
    setuid-root*,* or sudo(8) allowed) and yet have it perform its tasks correctly?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，回到我们虚构的packcap示例应用程序，我们如何运行该进程——似乎需要root——而不具备root特权（不允许root登录，setuid-root*或sudo(8)）并且使其正确执行任务？
- en: 'Enter the POSIX Capabilities model: In this model, instead of giving a process
    *blanket access* as a root (or other) user, there is a way to *embed particular
    capabilities into both the process and/or binary file.* The Linux kernel supports
    the POSIX capabilities model from very early on—the 2.2 Linux kernels (at the
    time of writing, we are now in the 4.x kernel series). From a practical viewpoint,
    the features we describe as follows are available from Linux kernel version 2.6.24
    (released January 2008) onward.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进入POSIX功能模型：在这个模型中，与其像root（或其他）用户一样给予进程*全面访问*，不如将特定功能*嵌入到进程和/或二进制文件中*。 Linux内核从很早开始就支持POSIX功能模型——2.2
    Linux内核（在撰写本文时，我们现在处于4.x内核系列）。从实际的角度来看，我们将描述的功能从Linux内核版本2.6.24（2008年1月发布）开始可用。
- en: 'This is how it works in a nutshell: Every process—in fact, every *thread—*as
    part of its OS metadata, contains a bitmask. These are called the *capability
    bits* or the *capability set*, because *each* *bit represents a capability***.**
    By carefully setting and clearing bits, the kernel (as well as the user space,
    if it has the capability) can therefore set *fine granularity permissions* on
    a per-thread basis (we will cover multithreading in detail in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials*, for now, treat the term *thread*
    as interchangeable with *process*).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：每个进程——实际上，每个*线程*——作为其操作系统元数据的一部分，包含一个位掩码。这些被称为*功能位*或*功能集*，因为*每个* *位代表一个功能***。**通过仔细设置和清除位，内核（以及用户空间，如果具有该功能）因此可以在每个线程基础上设置*细粒度权限*（我们将在以后的[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)中详细介绍多线程，现在，将术语*线程*视为可互换使用*进程*）。
- en: More realistically, and as we shall see next, the kernel maintains *several
    capability sets (capsets) per thread alive*; each capset consists of an array
    of two 32-bit unsigned values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更现实的是，正如我们将在接下来看到的，内核保持*每个线程活动的多个功能集（capsets）*；每个capset由两个32位无符号值的数组组成。
- en: 'For example, there is a capability bit called `CAP_DAC_OVERRIDE`**;** it would
    normally be cleared (0). If set, then the process will bypass all the kernel''s
    file permission checks—for anything: reading, writing, and executing! (This is
    known as **DAC**: **Discretionary Access Control.**)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个称为`CAP_DAC_OVERRIDE`的功能位**；**它通常会被清除（0）。如果设置，那么进程将绕过内核的所有文件权限检查——无论是读取、写入还是执行！（这被称为**DAC**：**自主访问控制**。）
- en: 'Looking at a few more examples of capability bits would be useful at this point
    (the full list is available at the *man page* on *capabilities(7)* here: [https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)).
    Some snippets follow:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，查看一些功能位的更多示例将是有用的（完整列表可在这里的*功能（7）*功能页面上找到：[https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)）。以下是一些片段：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*In effect, the capabilities model provides fine-grained permissions; a way
    to slice up the (overly) enormous power of the root user into distinct manageable
    pieces.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，功能模型提供了细粒度的权限；一种将root用户的（过度）巨大的权限切割成可管理的独立部分的方法。*'
- en: 'So, to understand the significant benefit in the context of our fictional packcap
    example, consider this: With the traditional Unix permissions model, at best,
    the release binary would be a setuid-root binary executable file; the process
    would run with root privileges. In the best case, there''s no bug, no security
    issues (or, if there are, they aren''t discovered), and all goes well—luckily.
    But, we don''t believe in luck, right?"(In the words of Jack Reacher, Lee Child''s
    protagonist, "Hope for the best, prepare for the worst")." In the worst case,
    there are exploitable vulnerabilities lurking in the code and there are hackers
    who will work tirelessly until they find and exploit them. The entire system could
    be compromised.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们虚构的packcap示例的背景下理解重要的好处，考虑这一点：使用传统的Unix权限模型，最好的情况下，发布的二进制文件将是一个setuid-root二进制可执行文件；进程将以root权限运行。在最好的情况下，没有错误，没有安全问题（或者如果有，它们没有被发现），一切都会顺利进行-幸运的是。但是，我们不相信运气，对吧？（用李·查德的主角杰克·里彻的话来说，“希望最好，为最坏做准备”）。在最坏的情况下，代码中潜在的漏洞可以被利用，有黑客会不知疲倦地工作，直到他们找到并利用它们。整个系统可能会受到威胁。
- en: On the other hand, with the modern POSIX capabilities model, the packcap binary
    executable file will *not* require to be setuid at all, never mind setuid-root;
    the process would run with normal privileges. The work still gets done because
    we embed the *capability* for precisely that work (in this example, network packet
    capture) and absolutely nothing else. Even if there are exploitable vulnerabilities
    lurking in the code, hackers would probably not be as motivated to find and exploit
    them; the simple reason for this is this is that even if they do manage to gain
    access (say, an arbitrary code execution bounty), all that can be exploited is
    the account of the non-privileged users running the process. It's demotivating
    to the hacker (well, that's a joke, but with truth ingrained within).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用现代POSIX功能模型，packcap二进制可执行文件将*不需要*设置setuid，更不用说setuid-root；进程将以普通权限运行。工作仍然可以完成，因为我们嵌入了*能力*来精确完成这项工作（在这个例子中，是网络数据包捕获），绝对没有其他东西。即使代码中存在可利用的漏洞，黑客可能也不会有动力去找到并利用它们；这个简单的原因是，即使他们设法获得访问权限（比如，任意代码执行赏金），他们可以利用的只是运行进程的非特权用户的帐户。这对黑客来说是没有动力的（好吧，这是一个玩笑，但其中蕴含着真理）。
- en: 'Think about it: the Linux capabilities model is one way to implement a well-accepted
    security practice: *the* ***Principle of Least Privilege (PoLP):*** Each module
    in a product (or project) must have access only to the information and resources
    necessary for its legitimate work, and nothing more.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：Linux功能模型是实现一个被广泛接受的安全实践的一种方式：*最小特权原则（PoLP）*：产品（或项目）中的每个模块只能访问其合法工作所需的信息和资源，而不多。
- en: Capabilities – some gory details
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能-一些血腥的细节
- en: 'Linux capabilities are a fairly complex topic. For the purposes of this book,
    we delve into the subject to the depth necessary for the systems application developer
    to profit from the discussion. To get the complete details, please check out the
    man page on capabilities (7) here: [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    as well as the kernel documentation on credentials here: [https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst](https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Linux功能是一个相当复杂的主题。对于本书的目的，我们深入讨论了系统应用开发人员从讨论中获益所需的深度。要获取完整的详细信息，请查看这里的功能手册（7）：[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)，以及这里的内核文档：[https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst](https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst)
- en: OS support
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统支持
- en: '**Capability bitmask**(**s**) are often referred to as **capability sets**—we
    abbreviate this term to **capset**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能位掩码**（**s**）通常被称为**功能集**-我们将这个术语缩写为**capset**。'
- en: 'To work with the power of the POSIX capabilities model, in the first place,
    the OS itself must provide "life support" for it; full support implies the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用POSIX功能模型的功能，首先，操作系统本身必须为其提供“生命支持”；完全支持意味着以下内容：
- en: Whenever a process or thread attempts to perform some operation, the kernel
    is able to check whether the thread is allowed to do so (by checking for the appropriate
    bit being set in the thread's effective capset—see the next section).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当进程或线程尝试执行某些操作时，内核能够检查线程是否被允许这样做（通过检查线程有效capset中设置适当位）-请参见下一节。
- en: System calls (and usually wrapper library APIs) must be provided such that a
    thread can query and set its capsets.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须提供系统调用（通常是包装器库API），以便线程可以查询和设置其capsets。
- en: Linux kernel filesystem code must have a facility such that capabilities can
    be embedded (or attached) into a binary-executable file (so that when the file
    "runs", the process acquires those capabilities).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核文件系统代码必须具有一种设施，以便可以将功能嵌入（或附加）到二进制可执行文件中（以便当文件“运行”时，进程会获得这些功能）。
- en: Modern Linux (particularly Kernel Version 2.6.24 onward) supports all three,
    and thus fully supports the capabilities model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux（特别是2.6.24版本及以后的内核）支持所有三种，因此完全支持功能模型。
- en: Viewing process capabilities via procfs
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过procfs查看进程功能
- en: To understand more details, we need a quick way to "look into" the kernel and
    retrieve information; the Linux kernel's **proc filesystem** (often abbreviated
    to **procfs**) provides just this feature (along with more).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解，我们需要一种快速的方法来“查看”内核并检索信息；Linux内核的**proc文件系统**（通常缩写为**procfs**）就提供了这个功能（以及更多）。
- en: Procfs is a pseudo-filesystem typically mounted on */proc*. Exploring procfs
    to learn more about Linux is a great idea; do check out some links in the *Further
    reading* section on the GitHub repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Procfs是一个伪文件系统，通常挂载在/proc上。探索procfs以了解更多关于Linux的信息是一个好主意；在GitHub存储库的*进一步阅读*部分中查看一些链接。
- en: 'Here, we shall just focus on the task at hand: to get to the details, procfs
    exposes a directory called `/proc/self` (which refers to the current process''s
    context, somewhat analogous to the *this* pointer in OOP); under it, a pseudo
    file named *status* reveals interesting details about the process (or thread)
    in question. The process''s capsets are seen as "Cap*" so we just grep for this
    pattern. In the next code, we perform this on a regular non-privileged process
    (*grep* itself via the *self* directory), as well as with a privileged (root)
    process (*systemd/init PID 1*), to see the differences:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只关注手头的任务：要了解详细信息，procfs公开了一个名为`/proc/self`的目录（它指的是当前进程的上下文，有点类似于OOP中的*this*指针）；在它下面，一个名为*status*的伪文件揭示了有关所讨论的进程（或线程）的有趣细节。进程的capsets被视为“Cap*”，所以我们只需按照这个模式进行grep。在下一段代码中，我们对一个常规的非特权进程（*grep*本身通过*self*目录）以及一个特权（root）进程（*systemd/init
    PID 1*）执行此操作，以查看差异：
- en: 'Process/thread capsets: regular process (such as grep):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 进程/线程capsets：常规进程（如grep）：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Process/thread capsets: privileged (root) process (such as systemd/init PID
    1):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 进程/线程capsets：特权（root）进程（如systemd/init PID 1）：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Enumerated in a table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个表中列举：
- en: '| **Thread Capability Set (capset)** | **Typical Value for Non-Privileged Task**
    | **Typical Value for Privileged Task** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **线程能力集（capset）** | **非特权任务的典型值** | **特权任务的典型值** |'
- en: '| CapInh (Inherited) | `0x0000000000000000` | `0x0000000000000000` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| CapInh（继承） | `0x0000000000000000` | `0x0000000000000000` |'
- en: '| CapPrm (Permitted) | `0x0000000000000000` | `0x0000003fffffffff` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| CapPrm（允许） | `0x0000000000000000` | `0x0000003fffffffff` |'
- en: '| CapEff (Effective) | `0x0000000000000000` | `0x0000003fffffffff` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| CapEff（有效） | `0x0000000000000000` | `0x0000003fffffffff` |'
- en: '| CapBnd (Bounded) | `0x0000003fffffffff` | `0x0000003fffffffff` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| CapBnd（有界） | `0x0000003fffffffff` | `0x0000003fffffffff` |'
- en: '| CapAmb (Ambient) | `0x0000000000000000` | `0x0000000000000000` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| CapAmb（环境） | `0x0000000000000000` | `0x0000000000000000` |'
- en: (This table describes the output from a Fedora 27/Ubuntu 17.10 Linux on x86_64).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: （此表描述了Fedora 27/Ubuntu 17.10 Linux在x86_64上的输出）。
- en: 'Broadly, there are two types of *capability sets*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，有两种类型的*能力集*：
- en: Thread capability sets
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程能力集
- en: File capability sets
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件能力集
- en: Thread capability sets
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程能力集
- en: Within thread capsets, there are actually several types per thread.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程capsets中，实际上有几种类型。
- en: 'Linux per-**thread** capability sets:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Linux每个**线程**的能力集：
- en: '**Permitted (Prm):** The overall limiting *superset* of effective capabilities
    for the thread. If a capability is dropped, it can never be reacquired.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许（Prm）：**线程的有效能力的整体限制*超集*。如果一个能力被丢弃，它就永远无法重新获得。'
- en: '**Inheritable (Inh):** Inheritance here refers to the absorption of capset
    attributes across an *exec*. What happens to the capsets when a process executes
    another process? (Details on the exec are dealt with in a later chapter. For now,
    suffice it to say that if bash execs vi, then we call bash the predecessor and
    vi the successor).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可继承（Inh）：**这里的继承是指在*exec*操作中吸收capset属性。当一个进程执行另一个进程时，capsets会发生什么？（关于exec的详细信息将在后面的章节中处理。现在，可以说如果bash执行vi，那么我们称bash为前任，vi为继任）。'
- en: Will the successor process inherit the capsets of the predecessor? Well, yes
    the *inheritable capset*, that is. From the previous table, we can see that for
    a non-privileged process, the inherited capset is all zeros, implying that no
    capabilities are inherited across the exec operation. So, if a process wants to
    execute another process and that (successor) process must run with elevated privileges,
    it should use ambient capabilities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继任进程是否会继承前任的capsets？是的，继承的是*可继承的capset*。从前面的表中，我们可以看到对于非特权进程，继承的capset都是零，这意味着在执行操作中没有能力被继承。因此，如果一个进程想要执行另一个进程，并且（继任）进程必须以提升的特权运行，它应该使用环境能力。
- en: '**Effective (Eff):** These are the capabilities that the kernel actually uses
    when checking permissions for the given thread.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效（Eff）：**这些是内核在检查给定线程的权限时实际使用的能力。'
- en: '**Ambient (Amb):** (From Linux 4.3 onward). These are the capabilities that
    are inherited across an exec operation. The bits *must* be present (set to 1)
    in both the permitted and inheritable capsets—only then can it be "ambient". In
    other words, if a capability is cleared from either a Prm or an Inh, it is also
    cleared in an Amb.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境（Amb）：**（从Linux 4.3开始）。这些是在执行操作中继承的能力。位必须同时存在（设置为1）在允许和可继承的capsets中，只有这样它才能是“环境”。换句话说，如果一个能力从Prm或Inh中清除，它也会在Amb中清除。'
- en: If a *set[u|g]id* program or a program with *file capabilities* (as we will
    see) is executed, the ambient set is cleared. Normally, upon exec, the ambient
    capset is added to Prm and assigned to Eff (of the successor process).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行了一个*set[u|g]id*程序或者一个带有*文件能力*（我们将会看到）的程序，环境集会被清除。通常，在执行期间，环境capset会被添加到Prm并分配给继任进程的Eff。
- en: '**Bounding (Bnd):** This capset is a way *to limit* the capabilities bestowed
    upon a process during an exec. Its effect:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界（Bnd）：**这个capset是在执行期间赋予进程的能力的一种*限制*方式。它的效果是：'
- en: 'When the process executes another process, the permitted set is the ANDing
    of the original permitted and bounded capsets: *Prm = Prm* AND *Bnd.* This way,
    you can limit the successor process''s permitted capset.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程执行另一个进程时，允许的集合是原始允许和有界capset的AND运算：*Prm = Prm* AND *Bnd.* 这样，你可以限制继任进程的允许capset。
- en: Only if a capability is in the bounding set, can it be added to the inheritable
    capset.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在边界集中的能力才能被添加到可继承的capset中。
- en: Also, from Linux 2.6.25 onward, the capability bounding set is a per-thread
    attribute.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，从Linux 2.6.25开始，能力边界集是一个每个线程的属性。
- en: 'Executing a program will have no impact on the capsets unless either of the
    following is true:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序不会对capsets产生影响，除非以下情况之一成立：
- en: The successor is a setuid-root or a setgid program
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承者是一个setuid-root或setgid程序
- en: File capabilities are set on the binary executable that is execed
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件能力设置在被执行的二进制可执行文件上
- en: How can these thread capsets be programmatically queried and changed? Indeed,
    that's what the *capget(2)* and *capset(2)* system calls are for. However, we
    would suggest one uses  the library-level wrapper APIs *cap_get_proc(3)* and *cap_set_proc(3)*
    instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线程capsets如何以编程方式查询和更改？这正是*capget(2)*和*capset(2)*系统调用的用途。然而，我们建议使用库级别的包装API
    *cap_get_proc(3)*和*cap_set_proc(3)*。
- en: File capability sets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件能力集
- en: At times, we require the ability to "embed" capabilities into a binary-executable
    file (the discussion regarding the reasons for this is covered in the following
    section). This will obviously require kernel filesystem support. In early Linux,
    this system was a kernel-configurable option; from Linux kernel 2.6.33, file capabilities
    are always compiled into the kernel, and are therefore always present.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要能力将能力“嵌入”到二进制可执行文件中（关于这一点的讨论在下一节中）。这显然需要内核文件系统支持。在早期的Linux中，这个系统是一个内核可配置选项；从Linux内核2.6.33开始，文件能力总是编译到内核中，因此总是存在。
- en: 'File capsets are a powerful security feature—you could say they are the modern
    equivalent of the older *set[u|g]id* features. To use them in the first place,
    the OS must support them, and the process (or thread) requires the `CAP_FSETCAP`
    capability. Here is the key point: The (previous) thread capsets along with the
    (coming) file capsets ultimately determine thread capabilities following an *exec*
    operation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件capsets是一个强大的安全功能——你可以说它们是旧的*set[u|g]id*功能的现代等价物。首先，要使用它们，操作系统必须支持它们，并且进程（或线程）需要`CAP_FSETCAP`能力。这是关键：（之前的）线程capsets和（即将到来的）文件capsets最终确定了*exec*操作后线程的能力。
- en: 'Here are the Linux file capability sets:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Linux文件能力集：
- en: 'Permitted (Prm): auto-permitted capabilities'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许（Prm）：自动允许的能力
- en: Inheritable (Inh)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可继承（Inh）
- en: 'Effective (Eff): This is a single bit: if set, the new Prm capset gets raised
    in the Eff set; otherwise, it does not.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效（Eff）：这是一个单一的位：如果设置，新的Prm capset会在Eff集中提升；否则，不会。
- en: 'Once again, understand the caveat under which the above information has been
    provided: it''s not the complete details. To get them, please check out the man
    page on capabilities(7) here: [https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)*.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次理解上述信息提供的警告：这不是完整的细节。要获取它们，请在这里查看关于capabilities(7)的man页面：[https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)。
- en: 'Here is a screenshot snippet from this man page, showing the algorithm used
    to determine capabilities during the *exec* operation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自该man页面的截图片段，显示了*exec*操作期间确定能力的算法：
- en: '![](img/f94536e7-3ae1-470b-82bb-4a039d23102c.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f94536e7-3ae1-470b-82bb-4a039d23102c.png)'
- en: Embedding capabilities into a program binary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将能力嵌入程序二进制文件
- en: 'We have understood that the fine granularity of the capabilities model is a
    major security advantage over the old-style root only or setuid-root approach.
    So, back to our fictional packcap program: We would like to use *c*apabilities,
    and not the setuid-root. So, lets say that, upon careful study of the available
    capabilities, we conclude that we would like the following capabilities to be
    endowed into our program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，能力模型的细粒度是与旧式的仅限root或setuid-root方法相比的一个主要安全优势。因此，回到我们的虚构的packcap程序：我们想要使用*能力*，而不是setuid-root。因此，经过仔细研究可用的能力，我们得出结论，我们希望将以下能力赋予我们的程序：
- en: '`CAP_NET_ADMIN`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_NET_ADMIN`'
- en: '`CAP_NET_RAW`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_NET_RAW`'
- en: Looking up the man page on credentials(7) reveals that the first of them gives
    a process the ability to perform all required network administrative asks; the
    second, the ability to use "raw" sockets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看credentials(7)的man页面会发现，第一个给予进程执行所有必需的网络管理请求的能力；第二个给予使用“原始”套接字的能力。
- en: But how exactly does the developer embed these required capabilities into the
    compiled binary executable file? Ah, that's easily achieved with the `getcap(8)`
    and `setcap(8)` utilities. Obviously, you use `getcap(8)` to query a given file's
    capabilities and `setcap (8)` *to set them upon a given file.*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是开发人员如何将这些所需的能力嵌入到编译后的二进制可执行文件中呢？啊，这很容易通过`getcap(8)`和`setcap(8)`实用程序实现。显然，你使用`getcap(8)`来查询给定文件的能力，使用`setcap(8)`*在给定文件上设置它们*。
- en: '"If not already installed, please do install the getcap(8) and setcap(8) utilities
    on your system (the book''s GitHub repo provides a list of madatory and optional
    software packages)"'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “如果尚未安装，请在系统上安装getcap(8)和setcap(8)实用程序（本书的GitHub存储库提供了必需和可选软件包的列表）”
- en: 'The alert reader will notice something fishy here: If you are able to arbitrarily
    set capabilities upon a binary executable file, then where is the security? (We
    could just set `CAP_SYS_ADMIN` on the file /bin/bash, and it would now run as 
    the root.) So, the reality is that you can only set capabilities on a file if
    you already have the `CAP_FSETCAP` capability; from the manual:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕的读者会注意到这里有些可疑：如果你能够任意设置二进制可执行文件的能力，那么安全在哪里？（我们可以在文件/bin/bash上设置`CAP_SYS_ADMIN`，它现在将以root身份运行。）因此，事实是，只有在文件上已经具有`CAP_FSETCAP`能力时，才能在文件上设置能力；从手册中得知：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In effect, practically speaking, you would thus perform the setcap(8) as root
    via sudo(8); this is because we only get the CAP_SETFCAP capability when running
    with root privilege.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，实际上，你会以root身份通过sudo(8)执行setcap(8)；这是因为只有在以root权限运行时才能获得CAP_SETFCAP能力。
- en: 'So, let''s do an experiment: We build a simple `hello world` program (`ch8/hello_pause.c`);
    the only difference is this: We call the `pause(2)` system call after the `printf`;
    the `pause` has process sleep (forever):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们做一个实验：我们构建一个简单的`hello world`程序（`ch8/hello_pause.c`）；唯一的区别是这样：我们在`printf`之后调用`pause(2)`系统调用；`pause`会使进程休眠（永远）：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then write another C program to *query* the capabilities on any given process;
    the code of `ch8/query_pcap.c`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写另一个C程序来*查询*任何给定进程上的功能；`ch8/query_pcap.c`的代码：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s simple: the `cap_get_pid(3)` API returns the capability state, essentially
    the `capsets` of the target process. The only hassle is it''s represented via
    an internal data type called `cap_t`; to read it, we''d have to convert it to
    human-readable ASCII text; you guessed it, the `cap_to_text (3)`*.* API has precisely
    that function. We use it and print the result. (Hey, notice how we must `cap_free(3)` the
    variable after use; the manual informs us about this.)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单：`cap_get_pid(3)` API返回功能状态，基本上是目标进程的`capsets`。唯一的麻烦是它是通过一个叫做`cap_t`的内部数据类型表示的；要读取它，我们必须将其转换为人类可读的ASCII文本；你猜对了，`cap_to_text
    (3)`*.* API正好有这个功能。我们使用它并打印结果。（嘿，注意我们必须在使用后`cap_free(3)`释放变量；手册告诉我们这一点。）
- en: Several of these APIs to do with capabilities (broadly the `cap_*` ones), require
    the `libcap` library to be installed on the system. If not already installed,
    use your package manager to do so (the correct package is usually called `libcap-dev[el*]`).
    Obviously, you must link with the `libcap` library (we use the `-lcap` to do so
    in the Makefile).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与功能有关的API中的一些（广义上的`cap_*`）需要在系统上安装`libcap`库。如果尚未安装，请使用您的软件包管理器进行安装（正确的软件包通常称为`libcap-dev[el*]`）。显然，您必须链接`libcap`库（我们在Makefile中使用`-lcap`来这样做）。
- en: 'Let''s try it out:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Process PID 1, traditionally (Sys V) *init,* but nowadays `systemd`, runs with
    *root* privileges; thus, when we use our program to query its capsets (in reality,
    we get the effective capset returned), we get quite a long capability list! (as
    expected.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进程PID 1，传统上（Sys V）是*init*，但现在是`systemd`，以*root*权限运行；因此，当我们使用我们的程序查询其capsets（实际上，我们得到的是有效的capset返回），我们得到了一个相当长的功能列表！（如预期的那样。）
- en: 'Next, we build and run the `hello_pause` process in the background; then we
    query its capabilities:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在后台构建和运行`hello_pause`进程；然后我们查询它的功能：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `hello_pause` process is of course unprivileged, nor does it have any capabilities
    embedded within it; thus, as expected, we see it has *no* capabilities.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`hello_pause`进程当然是没有特权的，也没有任何功能嵌入其中；因此，如预期的那样，我们看到它*没有*功能。
- en: 'Now for the interesting part: Firstly, we embed capabilities into our `hello_pause`
    binary executable file using the `setcap(8)` utility:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分：首先，我们使用`setcap(8)`实用程序将功能嵌入到我们的`hello_pause`二进制可执行文件中：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This makes sense: as  `root` (technically, now we understand, with `CAP_SYS_ADMIN`
    capability), we of course have the `CAP_SETFCAP` capability, and thus succeed
    in using `setcap(8)`. Syntactically, we need to specify to `setcap(8)` a capability
    list followed by an action list; previously, we''ve specified the `cap_net_admin,cap_net_raw`
    capabilities, and the *add to effective and permitted* as the action list (with
    the `+ep` syntax).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的：作为`root`（从技术上讲，现在我们明白了，具有`CAP_SYS_ADMIN`功能），我们当然具有`CAP_SETFCAP`功能，因此成功使用`setcap(8)`。从语法上讲，我们需要指定给`setcap(8)`一个功能列表，后面跟着一个操作列表；以前，我们已经指定了`cap_net_admin,cap_net_raw`功能，以及*添加到有效和允许*作为操作列表（使用`+ep`语法）。
- en: 'Now, we retry our little experiment:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重新尝试我们的小实验：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Yes! The *new* `hello_pause` process indeed has the capabilities we wanted it
    to have.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！*新的*`hello_pause`进程确实具有我们希望它具有的功能。
- en: What happens if both the traditional setuid-root *and* the modern (file) capabilities
    are embedded in a binary executable? Well, in that case, when run, *only the capabilities
    embedded into the file* take effect; the process would have an EUID of 0, but
    would *not* have full *root* capabilities.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传统的setuid-root和现代（文件）功能都嵌入到一个二进制可执行文件中会发生什么？嗯，在这种情况下，运行时*只有文件中嵌入的功能*会生效；进程的EUID为0，但*不会*具有完整的*root*功能。
- en: Capability-dumb binaries
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能愚蠢的二进制
- en: 'Notice something, though: the `hello_pause` program above *really has no* idea
    that it actually has these capabilities; in other words, it programmatically has
    done nothing to query or set POSIX capabilities on itself. Yet, via the file capabilities
    model (and the setcap(8) utility) we have "injected" capabilities into it. *This
    type of binary is therefore called a* **capability-dumb binary***.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，注意一下：上面的`hello_pause`程序*实际上并不知道*它实际上具有这些功能；换句话说，它在程序上并没有做任何事情来查询或设置自己的POSIX功能。然而，通过文件功能模型（和setcap(8)实用程序），我们已经“注入”了功能。*这种类型的二进制因此被称为*
    **功能愚蠢的二进制***。*
- en: It's still vastly superior to doing a clumsy setuid-root security-wise, but
    it could get even "smarter" if the application itself—programmatically—used APIs
    to query and set capabilities upon itself at runtime. We can think of this kind
    of app as a **capability-smart binary*****.***
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全性的角度来看，这仍然远远优于使用笨拙的setuid-root，但如果应用程序本身在运行时使用API来查询和设置功能，它可能会变得更加“智能”。我们可以将这种类型的应用程序视为**功能智能二进制*****。
- en: Often, when porting a legacy setuid-root (or worse, just a *root*) type of application,
    developers will strip it of the setuid-root bit, knock off *root* ownership from
    the binary and then convert it into a *capability-dumb* binary by running setcap(8) on
    it. This is a good first step towards better security (or "hardening").
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在移植传统的setuid-root（或更糟糕的，只是*root*）类型的应用程序时，开发人员会剥离它的setuid-root位，从二进制文件中删除*root*所有权，然后通过运行setcap(8)将其转换为*功能愚蠢*二进制。这是迈向更好安全性（或“加固”）的第一步。
- en: Getcap and similar utilities
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Getcap和类似的实用程序
- en: 'The `getcap(8)` utility can be used to look up the capabilities embedded in
    a (binary) *file.* As a quick example lets run `getcap` on the shell program and
    the ping utility:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`getcap(8)`实用程序可用于查找嵌入在（二进制）*文件*中的功能。作为一个快速的例子，让我们在shell程序和ping实用程序上运行`getcap`：'
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's clear that bash does not have any file capsets—that's exactly what we expect.
    Ping, on the other hand, does, so that it can carry out its duties without requiring
    root privilege.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，bash没有任何文件capsets——这正是我们所期望的。另一方面，Ping有，因此它可以在不需要root特权的情况下执行其职责。
- en: 'The `getcap` utility usage is amply demonstrated via a bash script (similar
    to the one we saw in the previous chapter): `ch8/show_caps.sh`*.* Run it to see
    various file capability embedded programs installed on the system (left as a simple
    exercise for the reader to try out).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个bash脚本（类似于我们在上一章中看到的）充分演示了`getcap`实用程序的用法：`ch8/show_caps.sh`。运行它以查看系统上安装的各种嵌入文件能力的程序（留作读者的一个简单练习）。
- en: Similar in some respects to `getcap(8)`, though a superset of it, is the `capsh(1)` utility—a
    **capability shell wrapper**; check out its man pages for details.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与`getcap(8)`类似的是`capsh(1)`实用程序——一个**capability shell wrapper**；查看其手册页以获取详细信息。
- en: Also similar to the `query_pcap` program we wrote, is the `getpcaps(1)` utility.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们编写的`query_pcap`程序类似的是`getpcaps(1)`实用程序。
- en: Wireshark – a case in point
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wireshark——一个典型案例
- en: 'So: the story we cooked up at the beginning of this topic is not entirely fictitious—well,
    it is, but it has a remarkable real-world parallel: the well known *Wireshark*
    (previously called Ethereal) network packet sniffer and protocol analyzer application.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：我们在本主题开头编写的故事并非完全虚构——好吧，它确实是，但它有一个引人注目的现实世界平行：著名的*Wireshark*（以前称为Ethereal）网络数据包嗅探器和协议分析器应用程序。
- en: On older versions, Wireshark used to run as a `setuid-root` process, to perform
    packet capture.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本中，Wireshark曾作为`setuid-root`进程运行，以执行数据包捕获。
- en: Modern versions of Wireshark separate out the packet capture into a program
    called **dumpcap1.** It does not run as a setuid-root process, it runs with required
    capability bits embedded into it, giving it just the privileges it requires to
    do its job—packet capture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的Wireshark将数据包捕获分离到一个名为**dumpcap1**的程序中。它不作为setuid-root进程运行，而是嵌入了所需的能力位，使其具有执行其工作所需的特权——数据包捕获。
- en: 'The potential payoff to a hacker now performing a successful attack on it is
    thus dramatically reduced— instead of gaining *root*, the hacker at best gains
    the privileges (EUID, EGID) of the user who is running Wireshark and the wireshark
    group; he does not get root! We use *ls(1)* and *getcap(1)* to see this as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在黑客成功攻击它的潜在回报大大降低了——黑客最多只能获得运行Wireshark的用户和wireshark组的特权（EUID，EGID）而不是*root*！我们使用*ls(1)*和*getcap(1)*来查看这一点，如下所示：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice, in the long listing above, the others (O) access category has no permissions;
    only a root user and members of Wireshark can execute dumpcap(1). (Do *not* execute
    it as a root; you will then defeat the whole point: security).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的长列表中，其他（O）访问类别没有权限；只有root用户和Wireshark成员可以执行dumpcap(1)。（不要以root身份执行它；那样你将打败整个安全性的目的）。
- en: 'FYI, the actual packet-capture code is in a library called `pcap—packet` capture:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: FYI，实际的数据包捕获代码在一个名为`pcap—packet` capture的库中：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For your information: A security advisory from Red Hat detailing security issues
    with wireshark: [https://access.redhat.com/errata/RHSA-2012:0509](https://access.redhat.com/errata/RHSA-2012:0509).
    A snippet from the following proves an important point:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考：Red Hat发布的安全公告详细介绍了wireshark的安全问题：[https://access.redhat.com/errata/RHSA-2012:0509](https://access.redhat.com/errata/RHSA-2012:0509)。以下摘录证明了一个重要观点：
- en: '... Several flaws were found in Wireshark. If Wireshark read a malformed packet
    off a network or opened a malicious dump file, it could crash or, possibly, **execute
    arbitrary code as the user running Wireshark**. (CVE-2011-1590, CVE-2011-4102,
    CVE-2012-1595) ...'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '...在Wireshark中发现了几个缺陷。如果Wireshark从网络上读取了格式不正确的数据包或打开了恶意的转储文件，它可能会崩溃，甚至可能**以运行Wireshark的用户的身份执行任意代码**。（CVE-2011-1590，CVE-2011-4102，CVE-2012-1595）...'
- en: 'The highlighted text is key: Even if a hacker manages the feat of arbitrary
    code execution, it will execute with the privileges of the user running Wireshark—not
    root!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的文本很关键：即使黑客成功执行任意代码，它也将以运行Wireshark的用户的特权而不是root特权执行！
- en: 'The details on how exactly to set up W*ireshark* with POSIX capabilities is
    covered here (under the section entitled *GNU/Linux distributions*: [https://wiki.wireshark.org/CaptureSetup/CapturePrivileges](https://wiki.wireshark.org/CaptureSetup/CapturePrivileges)
    *.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用POSIX功能设置W*ireshark*的详细信息在这里（在名为*GNU/Linux distributions*的部分下）：[https://wiki.wireshark.org/CaptureSetup/CapturePrivileges](https://wiki.wireshark.org/CaptureSetup/CapturePrivileges)。
- en: 'It should now be amply clear: **dumpcap** is a *capability-dumb* binary; the
    Wireshark process (or file) itself is not privileged in any manner. Security wins,
    both ways.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚了：**dumpcap**是一个*capability-dumb*二进制文件；Wireshark进程（或文件）本身没有任何特权。安全性胜出，两全其美。
- en: Setting capabilities programmatically
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式设置能力
- en: We've seen how to build a *capability-dumb* binary; now let's figure out how
    to add or drop process (thread) capabilities at runtime within the program itself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何构建一个*capability-dumb*二进制文件；现在让我们弄清楚如何在程序内部在运行时添加或删除进程（线程）能力。
- en: The other side of the coin from getcap is the setcap of course—we have already
    worked with the utility on the command line. Now lets work with the relevant APIs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: getcap的另一面当然是setcap——我们已经在命令行上使用过这个实用程序。现在让我们使用相关的API。
- en: 'The thing to understand is this: To work with the process capsets, we require
    what is called a "capability state" in memory. To get this capability state, we
    use the `cap_get_proc(3)` API (of course, as mentioned earlier, all these APIs
    are from the `libcap` library, which we will link into). Once we have a working
    context, the capability state, we will use the `cap_set_flag(3)` API to set up
    the transaction:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解的是：要使用进程capsets，我们需要在内存中拥有所谓的“能力状态”。为了获得这个能力状态，我们使用`cap_get_proc(3)`API（当然，正如前面提到的，所有这些API都来自`libcap`库，我们将将其链接到其中）。一旦我们有了一个工作上下文，即能力状态，我们将使用`cap_set_flag(3)`API来设置事务：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first parameter is the capability state we received from the `cap_get_proc()`*;*
    the second parameter is the capability set we wish to affect—one of effective,
    permitted or inherited. The third parameter is the number of capabilities we are
    manipulating with this one API call. The fourth parameter—this is where we identify
    the capabilities that we wish to add or drop, but how? We pass a pointer to an
    *array* of `cap_value_t` . Of course, we must initialize the array; each element
    holds a capability. The final, fifth parameter `value` can be one of two values:
    `CAP_SET` to *set* the capability, `CAP_CLEAR` to *drop* it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们从`cap_get_proc()`*得到的功能状态；*第二个参数是我们希望影响的功能集之一：有效的、允许的或继承的。第三个参数是我们用这个API调用操作的功能数量。第四个参数——这是我们如何识别我们希望添加或删除的功能的地方，但是如何？我们传递一个`cap_value_t`数组的指针。当然，我们必须初始化数组；每个元素都持有一个功能。最后，第五个参数`value`可以是两个值之一：`CAP_SET`用于*设置*功能，`CAP_CLEAR`用于*删除*它。
- en: 'Until now, all the work has been within a memory context—the capability state
    variable; it''s not really taken effect upon the process (or thread) capsets.
    To actually set the capsets upon the process, we use the *cap_set_proc(3)* API:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的工作都是在内存上下文中进行的——功能状态变量；它实际上并没有影响到进程（或线程）的功能集。为了实际设置进程的功能集，我们使用*cap_set_proc(3)*
    API：
- en: '`int cap_set_proc(cap_t cap_p);`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`int cap_set_proc(cap_t cap_p);`'
- en: The parameter to it is the capability state variable that we carefully set up.
    *Now* the capabilities will be set.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它的参数是我们仔细设置的功能状态变量。*现在*功能将被设置。
- en: Also realize, unless we run it as *root* (which of course we don't—that's really
    the whole point), we cannot just raise our capabilities. Hence, within the `Makefile`
    itself, once the program binary file is built, we perform a `sudo setcap` upon
    the binary executable file itself (`set_pcap`) enhancing its capabilities; we
    bestow the `CAP_SETUID` and the `CAP_SYS_ADMIN` capability bits into its permitted
    and effective capsets.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，除非我们以*root*身份运行它（当然我们不会这样做——这确实是整个重点），我们不能只提高我们的功能。因此，在`Makefile`内部，一旦程序二进制文件构建完成，我们就对二进制可执行文件本身（`set_pcap`）执行`sudo
    setcap`，增强它的功能；我们赋予它的允许和有效功能集中的`CAP_SETUID`和`CAP_SYS_ADMIN`功能位。
- en: 'The next program briefly demonstrates how a process can add or drop capabilities
    (that are of course *within* it''s permitted capset). When run with option 1,
    it adds the `CAP_SETUID` capability and "proves" it via a simple test function
    (`test_setuid()`). Here is an interesting bit: Since the binary *file* already
    has two capabilities embedded within it (we do a `setcap(8)`  in the `Makefile),`
    we actually *need to drop* the `CAP_SYS_ADMIN` capability (from its effective
    set).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序简要演示了一个进程如何添加或删除功能（当然是*在*它的允许功能集内）。当选项1运行时，它添加了`CAP_SETUID`功能，并通过一个简单的测试函数（`test_setuid()`）“证明”了它。这里有一个有趣的地方：由于二进制*文件*已经在其中嵌入了两个功能（我们在`Makefile`中进行了`setcap(8)`），我们实际上*需要删除*`CAP_SYS_ADMIN`功能（从它的有效集中）。
- en: When run with option 2, we want two capabilities—`CAP_SETUID` and `CAP_SYS_ADMIN`;
    it will work, as these are embedded into the effective and permitted capsets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当选项2运行时，我们希望有两个功能——`CAP_SETUID`和`CAP_SYS_ADMIN`；它会工作，因为这些功能已经嵌入到有效和允许的功能集中。
- en: Here is the relevant code of `ch8/set_pcap.c`***:***
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ch8/set_pcap.c`的相关代码***:***
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s build it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建它：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `setcap(8)` has embedded file capabilities into the binary executable
    `set_pcap` (which `getcap(8)` verifies).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`setcap(8)`已经将文件功能嵌入到二进制可执行文件`set_pcap`中（由`getcap(8)`验证）。
- en: 'Try it out; we''ll first run it with option `2`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 试一下；我们首先用选项`2`运行它：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `pause(2)` system call has put the process to sleep; this is deliberately
    done so that we can try things out (see the next code). As an aside, to work with
    this, the program has set up some minimal signal handling; however, this topic
    will be discussed in detail in subsequent chapters. For now, just understand that
    the pause (and associated signal handling) allows us to literally "pause" the
    process, inspect stuff, and once done, send it a signal to continue it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause(2)`系统调用使进程进入睡眠状态；这是故意这样做的，以便我们可以尝试一些东西（见下一个代码）。顺便说一句，为了使用这个，程序已经设置了一些最小的信号处理；然而，这个主题将在后续章节中详细讨论。现在，只要理解暂停（和相关的信号处理）允许我们真正“暂停”进程，检查东西，一旦完成，发送一个信号继续它：'
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Above, we inspect the process via both our own `query_pcap` program and the
    proc filesystem. Both the `CAP_SETUID` and `CAP_SYS_ADMIN` capabilities are present
    in both the *Permitted* and *Effective* capsets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们通过我们自己的`query_pcap`程序和proc文件系统检查了进程。`CAP_SETUID`和`CAP_SYS_ADMIN`功能都存在于*允许*和*有效*功能集中。
- en: 'To continue the process, we send it a signal; a simple way—via the `kill(1)`
    command (details in a later [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*). There''s quite a bit to see now:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续这个过程，我们发送一个信号；一个简单的方法是通过`kill(1)`命令（详细内容见后面的[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)，*信号-第一部分*）。现在有很多东西要看：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The funny **(boing!)** is just the process informing us that signal handling
    has occurred. (Ignore it.) We invoke the `test_setuid()` function, the function
    code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的**(boing!)**只是过程通知我们发生了信号处理。(忽略它。)我们调用`test_setuid()`函数，函数代码：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We attempt to become *root* (effectively) with the `seteuid(0)` line of code.
    The output shows us that we have succeeded in doing so as the EUID becomes `0`.
    After this, we call the `drop_caps_be_normal()` function, which "drops" all capabilities
    *and* reverts us to "our original self", using the earlier-seen `setuid(getuid())`
    semantic; the function code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试用`seteuid(0)`代码行成为*root*（有效）。输出显示我们已经成功做到了，因为EUID变成了`0`。之后，我们调用`drop_caps_be_normal()`函数，它“删除”了所有功能*并*使用之前看到的`setuid(getuid())`语义将我们恢复为“我们的原始自己”；函数代码：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The program output indeed shows us that the EUID now reverts to non-zero (the
    RUID of `1000`) and the `seteuid(0)` fails, as expected (now that we've dropped
    capabilities and root privileges.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出确实显示我们的EUID现在恢复为非零（`1000`的RUID），并且`seteuid(0)`失败，正如预期的那样（现在我们已经删除了功能和root权限）。
- en: 'The process then invokes `pause(2)` once more (the `"Pausing #2 ..."` statement
    in the output), so that the process remains alive; now we can see this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进程再次调用`pause(2)`（输出中的“暂停#2…”语句），以使进程保持活动状态；现在我们可以看到这个：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Indeed, all capabilities have been dropped. (We leave the test case of running
    the program with option `1` to the reader.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，所有的能力都已经被放弃了。（我们把用选项`1`运行程序的测试案例留给读者。）
- en: 'Here is an interesting point: You might come across the statement `CAP_SYS_ADMIN`
    is the new root. Really? Let''s test it: What if we embed only the `CAP_SYS_ADMIN`
    capability into the binary file and modify the code to not drop it when running
    under option `1`? At first glance, it would seem that it should not matter—we
    should still be able to successfully perform the `seteuid(0)` as we''re effectively
    running as root with this capability. But guess what? It doesn''t work! Here''s
    the bottom line: This teaches us that while the statement sounds good, it''s really
    not completely true! We still require the `CAP_SETUID` capability to carry out
    arbitrary usage of the `set*id()` system calls.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的观点：你可能会遇到这样的说法`CAP_SYS_ADMIN`是新的root。真的吗？让我们来测试一下：如果我们只将`CAP_SYS_ADMIN`能力嵌入到二进制文件中，并修改代码在选项`1`下运行时不丢弃它会发生什么？乍一看，似乎这并不重要
    - 我们仍然能够成功执行`seteuid(0)`，因为我们实际上是以这种能力作为根用户运行的。但是猜猜看？它不起作用！底线是：这教会我们，虽然这个说法听起来不错，但它并不完全正确！我们仍然需要`CAP_SETUID`能力来执行`set*id()`系统调用的任意使用。
- en: We leave it to the reader to write the code for this case and test it as an
    exercise.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这个案例的代码编写和测试留给读者作为练习。
- en: Miscellaneous
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: 'A few remaining miscellaneous, but nevertheless useful, points and tips follow:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他杂项，但仍然有用的观察和提示：
- en: How ls displays different binaries
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ls显示不同的二进制文件
- en: 'A screenshot of Fedora 27 (x86_64) showing the pretty colors `*ls* -l` displays
    when displaying different binary executable types:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 27（x86_64）的屏幕截图显示了`*ls* -l`在显示不同的二进制可执行文件类型时显示的漂亮颜色：
- en: '![](img/40ef71dc-ca7b-45cc-841e-95a96ec8fdf1.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ef71dc-ca7b-45cc-841e-95a96ec8fdf1.png)'
- en: 'What exactly are these binaries? Let''s list just that, in the order they''re
    displayed above:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二进制文件到底是什么？让我们按照上面显示的顺序列出：
- en: '`dumpcap`: a file capabilities binary executable'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpcap`：一个文件功能二进制可执行文件'
- en: '`passwd`: a `setuid-root` binary executable'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passwd`：一个`setuid-root`二进制可执行文件'
- en: '`ping`: a file capabilities binary executable'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`：一个文件功能二进制可执行文件'
- en: '`write`: a `setgid-tty` binary executable'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`：一个`setgid-tty`二进制可执行文件'
- en: 'Note: The precise meaning and coloring can certainly vary across Linux distributions;
    the output shown is from a Fedora 27 x86_64 system.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：精确的含义和着色在Linux发行版之间肯定会有所不同；所显示的输出来自Fedora 27 x86_64系统。
- en: Permission models layering
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限模型分层
- en: 'Now that we have seen details on both models—the traditional UNIX permissions
    in the previous chapter and the modern POSIX capabilities one in this one, we
    take a bird''s-eye view of the same. The reality of a modern Linux kernel is that
    the legacy model is actually layered on top of the newer capabilities model; the
    following table  shows this "layering":'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在上一章中看到了传统的UNIX权限和本章中的现代POSIX能力模型的细节，我们对其进行了概述。现代Linux内核的现实情况是，传统模型实际上是建立在更新的能力模型之上的；以下表格显示了这种“分层”：
- en: '| **Pros and Cons** | **Model/Attributes** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **优缺点** | **模型/属性** |'
- en: '| Simpler, less secure | UNIX Permissions Process and File with UID, GID values
    embedded |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 更简单，更不安全 | UNIX权限进程和带有UID、GID值的文件 |'
- en: '|  | Process credentials: {RUID, RGID, EUID, EGID} |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  | 进程凭证：{RUID, RGID, EUID, EGID} |'
- en: '| More complex, more secure | POSIX Capabilities |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 更复杂，更安全 | POSIX能力 |'
- en: '|  | Thread Capsets, File Capsets |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  | 线程Capsets，文件Capsets |'
- en: '|  | Per Thread: {Inherited, Permitted, Effective, Bounded, Ambient} capsets
    Binary File: {Inherited, Permitted, Effective} capsets |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  | 每个线程：{继承的，允许的，有效的，有界的，环境的} capsets 二进制文件：{继承的，允许的，有效的} capsets |'
- en: 'A few observations to note due to this layering, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种分层，有一些观察结果需要注意：
- en: 'At the upper layer: What appears as a single integer, the process UID and GID,
    is actually two integers under the hood—the real and effective user | group IDs.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上层：看起来像一个单一的整数，进程UID和GID，实际上在底层是两个整数 - 真实和有效的用户|组ID。
- en: 'Mid layer: Giving rise to the four process credentials: {RUID, EUID, RGID,
    EGID}.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间层：产生四个进程凭证：{RUID, EUID, RGID, EGID}。
- en: 'Bottom layer: Which in turn is integrated on modern Linux kernels into the
    POSIX capabilities model:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层：这又集成到现代Linux内核中POSIX能力模型中：
- en: All kernel subsystems and code now use the capabilities model to control and
    determine access to an object.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有内核子系统和代码现在都使用能力模型来控制和确定对对象的访问。
- en: Now *root* - the "new" root, really—is predicated on the (overloaded) capability
    bit `CAP_SYS_ADMIN` being set.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在*root* - 实际上是“新”root - 取决于（过载的）能力位`CAP_SYS_ADMIN`的设置。
- en: 'the set*id() system calls can be arbitrarily used to set real/effective IDs
    once the `CAP_SETUID` capability is present:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦存在`CAP_SETUID`能力，set*id()系统调用可以任意用于设置真实/有效ID：
- en: thus, you can make EUID = 0, and so on.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，您可以使EUID = 0，依此类推。
- en: Security tips
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全提示
- en: 'A quick summation of key points regarding security as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性的关键点的快速总结如下：
- en: 'Obviously, with all our discussion, as far as is possible, do not use the now-outdated
    root mode any longer; this includes the (non) usage of setuid-root programs. Rather,
    you should use capabilities and assign only the required capabilities to the process:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，尽可能不再使用过时的root模式；这包括（不）使用setuid-root程序。相反，您应该使用能力，并且只为进程分配所需的能力：
- en: directly or programmatically via the `libcap(3)` APIs ("capability-smart" binaries),
    or
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接或通过`libcap(3)`API（“能力智能”二进制文件）进行编程。
- en: indirectly via the `setcap(8)` file capabilities on the binary ("capability-dumb"
    binaries).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过二进制文件的`setcap(8)`文件功能间接设置。
- en: If the above has been done via the API route, you should consider dropping capabilities
    immediately once the need for that capability is done (and raising it only as
    and when required).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述是通过API路线完成的，那么一旦需要该能力，您应立即考虑放弃该能力（并且只在需要时提高它）。
- en: 'Containers: a "hot" fairly recent technology (essentially, containers are lightweight
    virtual machines in a sense), they are quoted as "safe" as they help isolate running
    code. However, the reality is not so rosy: Container deployment is often done
    with little or no thought toward security, resulting in highly insecure environments.
    You can greatly benefit security-wise from the wise use of the POSIX capabilities
    model. An interesting RHEL blog on how you can ask Docker (a popular container
    technology product) to drop capabilities and thus greatly increase security is
    detailed here: [https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/](https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器：一种“热门”的相当新的技术（本质上，容器在某种意义上是轻量级虚拟机），它们被认为是“安全”的，因为它们有助于隔离运行的代码。然而，现实并不那么乐观：容器部署通常缺乏对安全性的考虑，导致高度不安全的环境。您可以通过明智地使用POSIX能力模型在安全方面获得很大的好处。有关如何要求Docker（一种流行的容器技术产品）放弃能力并从而大大提高安全性的有趣的RHEL博客在这里详细介绍：[https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/](https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/)。
- en: FYI – under the hood, at the level of the Kernel
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FYI - 在内核层面
- en: (The paragraph that follows is just FYI and optional; if interested in deeper
    details then take a look, or feel free to skip it.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: （以下段落仅供参考，如果对更深入的细节感兴趣，请查看，或者随意跳过。）
- en: 'Within the Linux kernel, all task (process and thread) metadata is kept within
    a data structure called the *task_struct* (also known as the *process descriptor*).
    The information on what Linux calls *the security context of a task* is kept within
    this task structure, embedded inside another data structure called **cred** (short
    for **credentials**). This structure, *cred*, contains everything we''ve discussed:
    The modern POSIX capabilities bitmasks (or capability sets) as well as the traditional-style
    process privileges: the RUID, EUID, RGID, EGID (as well as the set[u|g]id and
    fs[u|g]id bits).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，所有任务（进程和线程）元数据都保存在一个称为*task_struct*（也称为*进程描述符*）的数据结构中。关于Linux所谓的*任务的安全上下文*的信息保存在这个任务结构中，嵌入在另一个称为**cred**（缩写为**凭证**）的数据结构中。这个结构*cred*包含了我们讨论过的一切：现代POSIX能力位掩码（或能力集）以及传统风格的进程特权：RUID、EUID、RGID、EGID（以及set[u|g]id和fs[u|g]id位）。
- en: 'The `procfs` method we saw earlier actually looks up the credential information
    from here. Hackers are obviously interested in accessing the cred structure and
    being able to modify it on the fly: filling it with zeros in the appropriate places
    gets them root! Does this sound far-fetched? Check out the *(Some) Linux Kernel
    Exploits* in the *Further reading* section on the GitHub repository. Unfortunately,
    it happens more often than anyone would like.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的`procfs`方法实际上是从这里查找凭据信息。黑客显然对访问凭据结构并能够在运行时修改它感兴趣：在适当的位置填充零可以让他们获得root权限！这听起来离谱吗？在GitHub存储库的*进一步阅读*部分中查看*(一些)
    Linux内核利用*。不幸的是，这种情况经常发生。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the reader has been taken through important ideas on the design
    and implementation of the modern POSIX capabilities model (on the Linux OS). Among
    other things, we have covered what POSIX capabilities are, and, crucially, why
    they are important, especially from the viewpoint of security. The embedding of
    capabilities into a runtime process or binary executable was also covered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者已经了解了关于现代POSIX能力模型（在Linux操作系统上）的设计和实现的重要思想。除其他事项外，我们已经介绍了什么是POSIX能力，以及为什么它们很重要，特别是从安全的角度来看。还介绍了将能力嵌入运行时进程或二进制可执行文件。
- en: The whole intent of the discussion, which started in the previous chapter, is
    to open the application developer's eyes to key security issues that arise when
    developing code. We hope we have left you, the reader, with a feeling of urgency,
    and of course the knowledge and tools to deal with security in a modern manner.
    Today's applications have to not just work; they have to be written with security
    in mind! or else...
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的整个目的，始于上一章，是让应用程序开发人员认识到在开发代码时出现的关键安全问题。我们希望我们已经让您，读者，感到紧迫，当然还有处理现代安全性的知识和工具。今天的应用程序不仅仅是要工作；它们必须以安全性为考量来编写！否则……
