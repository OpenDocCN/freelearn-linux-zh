- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: '**What are some of the reasons running a virtual machine would be preferable
    to a bare-metal installation?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行虚拟机相对于裸金属安装有哪些优点？
- en: The virtual machine can run inside the current preferred operating system, instead
    of replacing it or setting up a complicated dual-boot solution.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机可以在当前首选操作系统内运行，而不是替换它或设置复杂的双引导解决方案。
- en: A virtual machine can be snapshotted, which means the entire state of the machine
    is preserved and can be restored.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机可以进行快照，这意味着整个机器的状态被保留并可以恢复。
- en: Many different operation systems can run on a single machine, concurrently.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多不同的操作系统可以同时在一台机器上运行。
- en: '**What are some of the downsides of running a virtual machine as opposed to
    a bare-metal installation?**'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行虚拟机与裸金属安装相比有哪些缺点？
- en: There is a little overhead from the virtualization.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化会带来一些开销。
- en: More resources (CPU/RAM/disk) will always be used compared to running a bare-metal
    installation.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行裸金属安装相比，将始终使用更多资源（CPU/RAM/磁盘）。
- en: '**What is the difference between a type-1 and type-2 hypervisor?**'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Type-1和Type-2 hypervisor之间有什么区别？
- en: Type-1 hypervisors are installed directly on the physical machine (e.g. VMWare
    vSphere, KVM, Xen), while type-2 hypervisors are installed in an already running
    operating system (for example, VirtualBox, VMWare Workstation Player).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Type-1 hypervisors直接安装在物理机器上（例如VMWare vSphere，KVM，Xen），而Type-2 hypervisors安装在已运行的操作系统中（例如VirtualBox，VMWare
    Workstation Player）。
- en: '**In which two ways can we start a virtual machine on VirtualBox?**'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用哪两种方式在VirtualBox上启动虚拟机？
- en: Normally, which opens a new window with the terminal console (or GUI, if a desktop
    environment is installed).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，它会打开一个新窗口，其中包含终端控制台（或GUI，如果安装了桌面环境）。
- en: Headless, which runs the virtual machine as a server, without a GUI.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头模式，将虚拟机作为服务器运行，没有GUI。
- en: '**What makes an Ubuntu LTS version special?**'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ubuntu LTS版本有什么特别之处？
- en: LTS stands for Long Term Support. Ubuntu LTS versions are guaranteed updates
    for five years, instead of the nine months for regular Ubuntu releases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LTS代表长期支持。Ubuntu LTS版本保证更新五年，而常规Ubuntu版本只有九个月。
- en: '**What should we do if, after the Ubuntu installation, the virtual machine
    boots to the Ubuntu installation screens again?**'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在Ubuntu安装后，虚拟机再次引导到Ubuntu安装屏幕，我们应该怎么办？
- en: We should check if either the virtual hard disk in higher in the boot order
    than the optical drive, or we unmount the ISO from the optical drive so only the
    virtual hard disk is a valid boot target.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查虚拟硬盘是否比光驱在引导顺序中更高，或者卸载光盘驱动器上的ISO，以便只有虚拟硬盘是有效的引导目标。
- en: '**What should we do if we accidentally reboot during installation, and we never
    end up at the Ubuntu installation (but instead see an error)?** We should ensure
    the optical disk is higher in the boot order than the virtual hard disk AND we
    need to make sure the ISO is mounted on the optical disk.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在安装过程中意外重启，并且最终没有进入Ubuntu安装界面（而是看到错误），我们应该怎么办？我们应该确保光盘驱动器在引导顺序中高于虚拟硬盘，并且需要确保ISO已挂载到光盘驱动器上。
- en: '**Why did we setup NAT forwarding for the virtual machine?**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么要为虚拟机设置NAT转发？
- en: So we're not limited to using the terminal console, but instead we can use richer
    SSH tooling such as PuTTY or MobaXterm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不仅限于使用终端控制台，而是可以使用更丰富的SSH工具，如PuTTY或MobaXterm。
- en: Chapter 3
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**Why is syntax highlighting an important feature for text editors?** It makes
    it easy to spot syntax error, by using colors.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么语法高亮是文本编辑器的重要特性？它通过使用颜色来轻松发现语法错误。
- en: '**How can we extend the functionality already provided by Atom?** We can install
    extra Packages, or even write our own.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何扩展Atom已提供的功能？我们可以安装额外的包，甚至编写自己的包。
- en: '**What are the benefits of autocomplete when writing shell scripts?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写shell脚本时，自动完成的好处是什么？
- en: It reduces typing, especially for multi-line constructs.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了输入，特别是对于多行结构。
- en: It makes it easier to find commands.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样更容易找到命令。
- en: '**How could we describe the difference between Vim and GNU nano?** Nano is
    simple, Vim is powerful.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何描述Vim和GNU nano之间的区别？Nano简单，Vim强大。
- en: '**Which are the two most interesting modes in Vim?** Normal mode and Insert
    mode.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vim中最有趣的两种模式是哪两种？普通模式和插入模式。
- en: '**What is the .vimrc file?** It is used to configure persistent options for
    Vim, such as the color scheme and how to handle tabs.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .vimrc文件是什么？它用于配置Vim的持久选项，如颜色方案和如何处理制表符。
- en: '**What do we mean when we call nano a WYSIWYG editor?**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们称nano为WYSIWYG编辑器时，我们是什么意思？
- en: WYSIWYG stands for What You See Is What You Get, which means you can start typing
    at your cursor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: WYSIWYG代表What You See Is What You Get，这意味着你可以从光标处开始输入。
- en: '**Why would we want to combine GUI editors with command-line editors?** Because
    it''s easier to write in GUI editors, but easier to troubleshoot with command-line
    editors.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们希望将GUI编辑器与命令行编辑器结合使用？因为在GUI编辑器中编写更容易，但在命令行编辑器中进行故障排除更容易。
- en: Chapter 4
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: '**What is a file system?**'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统是什么？
- en: A software implementation of the way data is stored on and retrieved from a
    physical medium.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在物理介质上的存储和检索方式的软件实现。
- en: '**Which Linux specific file systems are most common?**'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些Linux特定的文件系统最常见？
- en: ext4
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ext4
- en: XFS
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XFS
- en: Btrfs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Btrfs
- en: '**True of false: multiple file system implementations can be used concurrently
    on Linux?**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux上可以同时使用多个文件系统实现，是真是假？
- en: True; the root file system is always a single type, but different parts of the
    file system tree can be used to mount other file system types on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正确；根文件系统始终是单一类型，但文件系统树的不同部分可以用于挂载其他文件系统类型。
- en: '**What is the journaling feature present on most Linux file system implementations?**'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数Linux文件系统实现中存在的日志记录功能是什么？
- en: Journaling is the mechanism which ensures writes to disks cannot fail halfway.
    It greatly improves reliability of the file system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一种机制，可以确保对磁盘的写入不会在中途失败。它极大地提高了文件系统的可靠性。
- en: '**On which point in the tree is the root file system mounted?**'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**根文件系统挂载在树的哪个位置？**'
- en: At the highest point, on `/.`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高点，在`/.`上。
- en: '**What is the PATH variable used for?**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PATH变量用于什么？**'
- en: It is used to determine from which directory binaries can be used. You can check
    the contents of the PATH variable with the command 'echo $PATH'.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于确定可以使用哪个目录中的二进制文件。您可以使用命令'echo $PATH'检查PATH变量的内容。
- en: '**In which top-level directory are configuration files stored according to
    the Filesystem Hierarchy Standard?**'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**根据文件系统层次结构标准，配置文件存储在哪个顶级目录中？**'
- en: In `/etc/`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/`中。
- en: '**Where are process logs commonly saved?**'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进程日志通常保存在哪里？**'
- en: In `/var/log/`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/var/log/`中。
- en: '**How many file types does Linux have?**'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux有多少种文件类型？
- en: '7'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '**How does the Bash autocomplete function work?**'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bash自动完成功能是如何工作的？
- en: For commands that support the autocomplete function, you can use TAB once to
    get the correct argument (if there is a single possibility), or TAB twice for
    a list of possible arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持自动完成功能的命令，您可以使用TAB一次来获取正确的参数（如果只有一个可能性），或者使用TAB两次来获取可能参数的列表。
- en: Chapter 5
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**Which three permissions are used for Linux files?**'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux文件使用哪三种权限？**'
- en: Read
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读
- en: Write
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写
- en: Execute
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行
- en: '**Which three types of ownership are defined for Linux files?**'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux文件定义了哪三种所有权类型？**'
- en: User
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Group
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组
- en: Others
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他
- en: '**Which command is used to change the permissions on a file?**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用于更改文件权限的命令是什么？**'
- en: '`chmod`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod`'
- en: '**What mechanism controls the default permissions for newly created files?**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制新创建文件的默认权限的机制是什么？**'
- en: '`umask`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`umask`'
- en: '**How is the following symbolic permission described in octal:** rwxrw-r--'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下符号权限如何用八进制描述：** rwxrw-r--'
- en: 0764\. 7 from rwx on the first three places (user), 6 from `rw-` on the second
    three places (group), and 4 from `r--` on the last three places (others).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 0764\. 前三位（用户）为rwx的7，第二组三位（组）为`rw-`的6，最后三位（其他）为`r--`的4。
- en: '**How is the following octal permission described symbolically:** 0644'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下八进制权限如何用符号描述：** 0644'
- en: rw-r--r--. First 6 is ReadWrite, then two 4s which are just Reads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: rw-r--r--。第一个6是读写，然后是两个4，只是读取。
- en: '**Which command allows us to gain superuser privileges?**'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个命令允许我们获得超级用户权限？**'
- en: '`sudo`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`'
- en: '**Which commands can we use to change ownerships for a file?**'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以使用哪些命令来更改文件的所有权？**'
- en: '`chown`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown`'
- en: '`chgrp`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chgrp`'
- en: '**How can we arrange for multiple users to share access to files?** We make
    sure they share group membership, and create a directory in which only members
    of those groups are allowed.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何安排多个用户共享对文件的访问？** 确保他们共享组成员资格，并创建一个只允许这些组成员的目录。'
- en: '**Which types of Advanced Permissions does Linux have?**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux有哪些高级权限类型？**'
- en: File Attributes
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件属性
- en: Special File Permissions
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊文件权限
- en: Access Control Lists
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制列表
- en: Chapter 6
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**Which command do we use to copy files in Linux?**'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们在Linux中用哪个命令复制文件？**'
- en: '`cp`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`。'
- en: '**What is the difference between moving and renaming files?**'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移动和重命名文件之间有什么区别？**'
- en: Technically, there is no difference. Functionally, moving changes the directory
    a file is in, while renaming keeps the file in the same directory. Both are handled
    in Linux by the `mv` command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，没有区别。从功能上讲，移动更改了文件所在的目录，而重命名保持了文件在同一目录中。在Linux中，这两者都由`mv`命令处理。
- en: '**Why is the** `rm` **command, used to remove files under Linux, potentially
    dangerous?**'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么** `rm` **命令，用于在Linux下删除文件，可能很危险？**'
- en: It can be used to recursively delete directories and anything in them
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于递归删除目录和其中的所有内容
- en: It does not (by default) present an 'Are you sure?' prompt
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会（默认情况下）出现“您确定吗？”提示
- en: It allows you to delete files using wildcards
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您使用通配符删除文件
- en: '**What is the difference between a hard link and a symbolic (soft) link?**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**硬链接和符号（软）链接之间有什么区别？**'
- en: Hard links refer to the data on the filesystem, while symbolic links refer to
    the file (which, in turn, refers to the data on the filesystem).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接指的是文件系统上的数据，而符号链接指的是文件（反过来又指向文件系统上的数据）。
- en: '**What are the three most important operating modes of `tar`?**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`tar`的三种最重要的操作模式是什么？**'
- en: Archiving mode
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档模式
- en: Extracting mode
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取模式
- en: Printing mode
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印模式
- en: '**Which option is used by `tar` to select the output directory?**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`tar`用于选择输出目录的选项是什么？**'
- en: '`-C`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`-C`'
- en: '**What is the biggest difference between `locate` and `find` when searching
    on filename?**'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在搜索文件名时，`locate`和`find`之间最大的区别是什么？**'
- en: Locate allows partly named matches by default, while find requires specifying
    wildcards if that partial matches are desired.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Locate默认允许部分命名匹配，而find需要指定通配符，如果需要部分匹配。
- en: '**How many options of `find` can be combined?**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`find`的多少个选项可以组合？**'
- en: As many as the search requires! This is exactly what makes `find` so incredibly
    powerful.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索需要的数量！这正是使`find`如此强大的原因。
- en: Chapter 7
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**What do we, by convention, do as the first thing when we learn a new programming
    or scriping language?**'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当我们学习新的编程或脚本语言时，按照惯例，我们首先做什么？**'
- en: We print the string "Hello World".
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印字符串“Hello World”。
- en: '**What is the shebang for Bash?**'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bash的shebang是什么？**'
- en: '#!/bin/bash'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/bin/bash'
- en: '**Why is the shebang needed?**'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么需要shebang？**'
- en: If we're running the script without specifying which program we should use,
    the shebang will allow Linux to use the correct one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不指定应该使用哪个程序的情况下运行脚本，shebang将允许Linux使用正确的程序。
- en: '**In what three ways can we run a script?**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以以哪三种方式运行脚本？**'
- en: 'By using the program which we want to run it with: `bash script.sh`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用我们想要运行的程序：`bash script.sh`
- en: 'By setting the executable permission and prefixing the scriptname with ./:
    ``./script.sh``'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置可执行权限并在脚本名之前加上./：``./script.sh``
- en: 'By setting the executable permission and using the fully qualified path to
    the file: `/tmp/script.sh`'
  id: totrans-114
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置可执行权限并使用完全限定的文件路径：`/tmp/script.sh`
- en: '**Why do we place such emphasis on readability when creating shell scripts?**'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建shell脚本时为什么要如此强调可读性？**'
- en: Scripts are much easier to use if the person using them can easily understand
    what the script does
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用脚本的人能够轻松理解脚本的功能，那么使用脚本会更容易
- en: If anyone other than yourself needs to edit the script (and you can consider
    yourself 'someone else' too after a few months!) it helps tremendously if it's
    simple to understand
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果除了您自己之外的其他人需要编辑脚本（经过几个月后，您自己也可以考虑自己是“其他人”！），如果脚本简单易懂，将会极大地帮助
- en: '**Why do we use comments?**'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们要使用注释？**'
- en: So we can explain things in the script which might not be obvious by just looking
    at the commands. Furthermore, it also allows us to give some design rationale
    if that helps clarify the script.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在脚本中解释可能仅通过查看命令不明显的事情。此外，它还允许我们提供一些设计原理，如果有助于澄清脚本。
- en: '**Why do we recommend including a script header for all shell scripts you write?**'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们建议为您编写的所有shell脚本包括脚本头？**'
- en: If gives a bit of information on the author, age and description to the script.
    It helps give context to the script, which can be very helpful when the script
    is not working as expected, or needs to be modified.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为脚本提供了一些关于作者、年龄和描述的信息。当脚本不能按预期工作或需要修改时，这有助于为脚本提供上下文。
- en: '**Which three types of verbosity have we discussed?**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们讨论了哪三种冗长？**'
- en: Verbosity in comments
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释的冗长
- en: Verbosity in commands
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的冗长
- en: Verbosity in command output
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令输出的冗长
- en: '**What is the KISS principle?**'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KISS原则是什么？**'
- en: KISS, which stands for *Keep It Simple, Stupid*, is a design recommendation
    which helps us to remember that we should keep things simple, as that often increases
    usability and readability, while even being the best solution most of the times
    as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: KISS，即“保持简单，愚蠢”，是一种设计建议，它帮助我们记住我们应该保持简单，因为这通常会增加可用性和可读性，而且大多数时候也是最好的解决方案。
- en: Chapter 8
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**What is a variable?**'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是变量？**'
- en: A variable is a basic building block for programming languages, which is used
    to store run-time values that can be referenced multiple times in the application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是编程语言的基本构建块，用于存储可以在应用程序中多次引用的运行时值。
- en: '**Why do we need variables?**'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们为什么需要变量？**'
- en: Variables are great for storing information you need multiple times. In this
    case, if you need to change the information, it's a single operation (in the case
    of a constant). In the case of a real variable, it allows us to reference run-time
    information in the program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常适合存储您需要多次使用的信息。在这种情况下，如果需要更改信息，这是一个单独的操作（对于常量而言）。对于真实变量，它允许我们在程序中引用运行时信息。
- en: Lastly, proper variable naming allow us to grant extra context to our script,
    increasing readability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，适当的变量命名使我们能够为我们的脚本提供额外的上下文，增加可读性。
- en: '**What is a constant?**'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是常量？**'
- en: A constant is a special type of variable, since its value is determined is fixed
    and used throughout the script. Normal variables are often mutated multiple times
    during execution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是一种特殊类型的变量，因为它的值是固定的，并且在整个脚本中使用。正常变量在执行过程中经常发生多次变化。
- en: '**Why are naming conventions especially important for variables?**'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么对变量来说命名约定尤为重要？**'
- en: 'Bash allows us to name our variables almost anything. Because this can become
    confusing (which is never a good thing!) it is important to pick one naming convention
    and stick to it: this increases consistency and coherence for our scripts.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Bash允许我们几乎可以给变量取任何名字。因为这可能会变得混乱（这绝不是一件好事！），所以选择一个命名约定并坚持下去很重要：这增加了脚本的一致性和连贯性。
- en: '**What are positional arguments?**'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是位置参数？**'
- en: 'When you call a Bash script, any other text passed after the `bash scriptname.sh`
    command can be accessed in the script, as this text is considered the *arguments*
    to the script. Each word not enclosed in quotes is handled as a single argument:
    a multi-word argument should be enclosed in quotes!'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用Bash脚本时，在`bash scriptname.sh`命令之后传递的任何其他文本都可以在脚本中访问，因为这些文本被视为脚本的*参数*。没有用引号括起来的每个单词都被视为单个参数：多个单词的参数应该用引号括起来！
- en: '**What is the difference between a parameter and an argument?**'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**参数和参数之间有什么区别？**'
- en: Arguments are used to fill the parameters of a script. Parameters are the *static
    variable names* which are used in the script logic, whereas the arguments are
    the *run-time values* used as the parameters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 参数用于填充脚本的参数。参数是脚本逻辑中使用的*静态变量名称*，而参数是用作参数的*运行时值*。
- en: '**How can we make a script interactive?**'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何使脚本交互？**'
- en: By using the `read` command. We can store the values that the users gives in
    a variable of our choice, otherwise we can use the default $REPLY variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`read`命令。我们可以将用户提供的值存储在我们选择的变量中，否则我们可以使用默认的$REPLY变量。
- en: '**How can we create a script that we can use both non-interactive and interactively?**'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何创建一个既可以非交互式又可以交互式使用的脚本？**'
- en: By combining (optional) positional arguments with the `read` command. To verify
    that we have all the information we need before starting the logic of the script,
    we use the `if-then` construct coupled with the `test` command to see if all our
    variables are populated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合（可选）位置参数和`read`命令。为了验证在开始脚本逻辑之前我们是否拥有所有需要的信息，我们使用`if-then`结构与`test`命令来查看我们的所有变量是否都被填充。
- en: Chapter 9
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**Why do we need an exit status?**'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们需要退出状态？**'
- en: So commands can signal to their callers if they succeeded or failed in a simple
    manner.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，命令可以以简单的方式向其调用者发出成功或失败的信号。
- en: '**What is the difference between exit status, exit code and return code?**'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**退出状态、退出码和返回码之间有什么区别？**'
- en: An exit code and return code refer to the same thing. An exit status is a *concept*,
    which is brought to life by the exit/return code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 退出码和返回码指的是同一件事。退出状态是一个*概念*，由退出/返回码实现。
- en: '**Which flag do we use with test to test for:**'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们使用哪个标志来测试test命令以测试：**'
- en: '*An existing directory*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现有目录*'
- en: -d
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: -d
- en: '*A writable file*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可写文件*'
- en: -w
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: -w
- en: '*An existing symbolic link*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现有符号链接*'
- en: -h (or -L)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: -h（或-L）
- en: '**What is the preferred shorthand syntax for `test -d /tmp/`?**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`test -d /tmp/`的首选简写语法是什么？**'
- en: '[[ -d /tmp/ ]]. Note that a space after [[ and before ]] is mandatory, or the
    command will fail!'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ -d /tmp/ ]]。请注意，[[之后和]]之前的空格是强制性的，否则命令将失败！'
- en: '**How can we print debug information in a Bash session?**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何在Bash会话中打印调试信息？**'
- en: Set the -x flag, either in the shell with `set -x` or when calling a script
    with `bash -x`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设置-x标志，可以在shell中使用`set -x`，也可以在调用脚本时使用`bash -x`。
- en: '**How can we check if a variable has content?**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何检查变量是否有内容？**'
- en: if [[ -n ${variable} ]] to check if the variable is non-zero
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[ -n ${variable} ]] 检查变量是否非零
- en: if [[ ! -z ${variable} ]] to check if the variable is not zero
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[ ! -z ${variable} ]] 检查变量是否不为零
- en: '**What is the Bash format for grabbing a return code?**'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抓取返回代码的Bash格式是什么？**'
- en: $?.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: $?。
- en: '**Of || and &&, which is the logical AND and which the OR?**'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '||和&&中，哪个是逻辑AND，哪个是OR？'
- en: '|| is OR, && is AND.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '||是OR，&&是AND。'
- en: '**What is the Bash format for grabbing the number of arguments?**'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抓取参数数量的Bash格式是什么？**'
- en: $#.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: $#。
- en: '**How can we make sure it does not matter from which working directory the
    user calls the script?**'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确保用户从任何工作目录调用脚本都无关紧要？**'
- en: By providing a `cd $(dirname $0)` at the beginning of the script.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本开头提供`cd $(dirname $0)`。
- en: '**How do Bash parameter expansions help us when dealing with user input?**'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bash参数扩展在处理用户输入时如何帮助我们？**'
- en: It allows us to remove capital letters so we can more easily compare to expected
    values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们删除大写字母，这样我们就可以更容易地与预期值进行比较。
- en: Chapter 10
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**What is a search pattern?**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是搜索模式？**'
- en: A regular expression syntax which allows us to find pieces of text with specified
    characteristics, such as length, content and location on a line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一种正则表达式语法，允许我们找到具有指定特征的文本片段，例如长度，内容和位置。
- en: '**Why are regular expressions considered greedy?**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么正则表达式被认为是贪婪的？**'
- en: Most regular expression try to find as much data as they can that match the
    search pattern. This includes whitespace and other punctuation, which is a logical
    separation for humans but not necessarily for a machine.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数正则表达式试图找到尽可能多的与搜索模式匹配的数据。这包括空格和其他标点符号，这对人类来说是逻辑分隔，但对机器来说不一定是。
- en: '**Which character in search patterns is considered a wildcard for any one character,
    except newlines?**'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索模式中，哪个字符被认为是除换行符外的任意一个字符的通配符？
- en: The dot (.).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 点（.）
- en: '**How is the asterisk used in Linux regular expression search patterns?**'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Linux正则表达式搜索模式中，星号如何使用？**'
- en: 'The * is used in combination with another character to allow it to form a repeating
    character. Example search pattern: spe*d will match spd, sped, speed, speeeeeeeeed,
    and so on.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*与另一个字符结合使用，以形成重复字符。示例搜索模式：spe*d将匹配spd，sped，speed，speeeeeeeeed等。'
- en: '**What are line anchors?**'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是行锚？**'
- en: The special characters used to denote line beginnings and endings. ^ for the
    beginning of the line, $ for the line end.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示行开头和行结尾的特殊字符。^表示行开头，$表示行结尾。
- en: '**Name three character types.**'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列举三种字符类型。**'
- en: 'Any of these are correct:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是正确的：
- en: alphanumeric
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母数字
- en: alphabet
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母表
- en: lowercase
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写
- en: uppercase
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写
- en: digits
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: blanks
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格
- en: '**What is globbing?**'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是Globbing？**'
- en: Globbing is accomplished when you use a * or ? on the command-line when interacting
    with files or file paths. Globbing allows us to easily manipulate (move, copy,
    delete, and so on) files that are matched on the globbing pattern.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在与文件或文件路径交互时，在命令行上使用*或?来完成Globbing。Globbing允许我们轻松操作（移动，复制，删除等）与Globbing模式匹配的文件。
- en: '**What is possible in the extended regular expression syntax, that is not possible
    with normal regular expressions under Bash?**'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展正则表达式语法中可能的，而在Bash下的普通正则表达式中不可能的是什么？**'
- en: One or more repeating characters
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个重复字符
- en: Exact number of repeating characters
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确数量的重复字符
- en: Range of repeating characters
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复字符范围
- en: Alternation with more than a single character
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个字符的交替
- en: '**What would be a good rule of thumb between deciding to use `grep` or `sed`?**'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`grep`或`sed`时，有什么好的经验法则？
- en: If your goal can be achieved with a single `grep` statement, choose simplicity.
    If it cannot be achieved in that manner, choose `sed` for more powerful syntax.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标可以通过单个`grep`语句实现，选择简单。如果不能以这种方式实现，选择更强大的语法`sed`。
- en: '**Why are regular expressions on Linux/Bash so hard?**'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么Linux/Bash上的正则表达式如此困难？**'
- en: There are many different implementations that are similar. With regular expressions
    and their difficulty as-is, this confusion does not help. Only practice and experience
    will remedy this!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多相似的不同实现。正则表达式及其困难本身，这种混乱并没有帮助。只有实践和经验才能解决这个问题！
- en: Chapter 11
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**How does an if-then(-else) statement end?**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if-then(-else)语句如何结束？
- en: 'With the reverse of the word if: `fi`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用if的反向：`fi`
- en: '**How can we use regular expression search patterns in a conditional evaluation?**'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何在条件评估中使用正则表达式搜索模式？**'
- en: 'By employing the =~ comparison symbol. For example: `[[ ${var} =~ [[:digit:]]
    ]]`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用=~比较符号。例如：`[[ ${var} =~ [[:digit:]] ]]`
- en: '**Why do we need the `elif` keyword?**'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们为什么需要`elif`关键字？**'
- en: If we want to sequentially test for more than one condition, we can use else
    if (`elif`).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要顺序测试多个条件，我们可以使用else if (`elif`)。
- en: '**What is *nesting*?**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是*嵌套*？**'
- en: Using an `if-then-else` statement or loop within another if-then-else statement
    or loop.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个if-then-else语句或循环中使用if-then-else语句或循环。
- en: '**How can we get information about how to use shell builtins and keywords?**'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何获取有关如何使用shell内置和关键字的信息？**'
- en: 'By using the command `help`, followed by the builtin or keyword we want information
    about. For example: `help [[`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命令`help`，然后是我们想要了解信息的内置或关键字。例如：`help [[`
- en: '**What is the opposite keyword of `while`?**'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`while`的相反关键字是什么？**'
- en: '`until`. A while loop runs until the condition is no longer *true,* an until
    loop runs until the condition is no longer *false*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`until`。while循环运行直到条件不再*true*，until循环运行直到条件不再*false*。'
- en: '**Why would we choose the for loop over the while loop?**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们会选择for循环而不是while循环？**'
- en: '`for` is more powerful and has many convenient shorthand syntaxes which would
    be hard or unreadable with `while`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`更强大，并且具有许多方便的简写语法，使用`while`可能会很难或难以阅读。'
- en: '**What is brace expansion and on which characters can we use it?**'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大括号扩展是什么，我们可以在哪些字符上使用它？**'
- en: 'Brace expansion allows us to write very short code, which generates a whitespace
    delimited list based on ASCII characters. For example: `{1..10}` prints the numbers
    1 through 10, with spaces in between. We can also use this for uppercase or lowercase
    letters, or any range in the ASCII character set.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展允许我们编写非常简短的代码，根据ASCII字符生成基于空格分隔的列表。例如：`{1..10}`打印1到10之间的数字，中间有空格。我们还可以用它来表示大写或小写字母，或ASCII字符集中的任何范围。
- en: '**Which two keywords allows us to have more granular control over loops?**'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪两个关键字允许我们对循环有更精细的控制？**'
- en: '`break` and `continue`. `break` stops the current loop, while `continue` jumps
    to the next iteration in the loop.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`。`break`停止当前循环，而`continue`跳到循环中的下一个迭代。'
- en: '**If we are nesting loops, how can we employ loop control to influence outer
    loops from an inner loop?**'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果我们嵌套循环，如何使用循环控制来影响内部循环中的外部循环？**'
- en: 'By adding a number higher than 1 to the `break` or `continue` keyword. Example:
    `break 2` exits from both the inner and one outer loop.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`break`或`continue`关键字后添加大于1的数字。例如：`break 2`退出内部和一个外部循环。
- en: Chapter 12
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**What are file descriptors?**'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文件描述符是什么？**'
- en: A handle to files or devices used by Linux as an interface for input/output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用作输入/输出接口的文件或设备的句柄。
- en: '**What do the terms stdin, stdout and stderr mean?**'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**术语stdin、stdout和stderr的含义是什么？**'
- en: stdin, standard input. Used for input to commands.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stdin，标准输入。用于命令的输入。
- en: stdout, standard output. Used for normal output of commands.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stdout，标准输出。用于命令的正常输出。
- en: stderr, standard error. Used for error output of commands.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stderr，标准错误。用于命令的错误输出。
- en: '**How to stdin, stdout and stderr map to the default file descriptors?**'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**stdin、stdout和stderr如何映射到默认文件描述符？**'
- en: stdin is bound to fd0, stdout to fd1, and stderr to fd2.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: stdin绑定到fd0，stdout绑定到fd1，stderr绑定到fd2。
- en: '**What is the difference between the output redirections `>`, `1>` and `2>`?**'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`>`、`1>`和`2>`之间的输出重定向有什么区别？**'
- en: '`>` and `1>` are equal, and refer to redirecting stdout. `2>` is used to redirect
    stderr.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`和`1>`是相等的，用于重定向stdout。`2>`用于重定向stderr。'
- en: '**What is the difference between `>` and `>>`?**'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`>`和`>>`之间有什么区别？**'
- en: '`>` will overwrite the file if it already has content, while `>>` will append
    to the file.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`将覆盖文件，如果文件已经有内容，而`>>`将追加到文件。'
- en: '**How can both stdout and stderr be redirected at the same time?**'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何同时重定向stdout和stderr？**'
- en: By using `&>` (and `&>>`)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`&>`（和`&>>`）
- en: By binding stderr to stdout, using `2>&1`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将stderr绑定到stdout，使用`2>&1`
- en: By piping with `|&`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`|&`进行管道传输
- en: '**Which special devices can be used to act as a black hole for output?**'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些特殊设备可以用作输出的黑洞？**'
- en: /dev/null and /dev/zero.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/null和/dev/zero。
- en: '**What does a pipe do, with regards to redirections?**'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**管道在重定向方面有什么作用？**'
- en: It binds the stdout/stderr of a command to the stdin of another command.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它将命令的stdout/stderr绑定到另一个命令的stdin。
- en: '**How can we send output to both the terminal and a log file?**'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何将输出发送到终端和日志文件？**'
- en: By piping through the `tee` command, preferably with `|&` so both stdout and
    stderr is forwarded.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`tee`命令进行管道传输，最好使用`|&`，这样stdout和stderr都会被转发。
- en: '**What is a typical use-case for a *here string*?**'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**here string的典型用例是什么？**'
- en: We can use a here string if we want to supply input directly to stdin of a command.
    `bc` is a good example of this.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接向命令的stdin提供输入，我们可以使用here string。`bc`就是一个很好的例子。
- en: Chapter 13
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: '**In which two ways can we define a function?**'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以以哪两种方式定义函数？**'
- en: name() {
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称（）{
- en: '}'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: function name {
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称{
- en: '}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**What are some advantages of functions?**'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**函数的一些优点是什么？**'
- en: Easy to reuse code
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于重用的代码
- en: Facilitates code sharing
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进代码共享
- en: Abstracting complex code
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象复杂的代码
- en: '**What is the difference between a globally scoped variable and a locally scoped
    one?**'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全局作用域变量和局部作用域变量之间有什么区别？**'
- en: Locally scoped variables are only valid within a function, globally scoped variables
    can be used throughout the entire script (even in functions).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部作用域的变量只在函数内部有效，全局作用域的变量可以在整个脚本中使用（甚至在函数中）。
- en: '**How can we set values and attributes on variables?**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何在变量上设置值和属性？**'
- en: By using the `declare` command.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`declare`命令。
- en: '**How can a function use arguments passed to it?**'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**函数如何使用传递给它的参数？**'
- en: 'In the same way as a script can: by using $1, $#, $@, and so on.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以使用$1、$#、$@等方式来执行命令。
- en: '**How can we return a value from a function?**'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何从函数中返回一个值？**'
- en: By outputting it to stdout. The command that calls the function should know
    to capture the output, using command substitution.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其输出到stdout。调用函数的命令应该知道如何捕获输出，使用命令替换。
- en: '**What does the `source` command do?**'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`source`命令是做什么的？**'
- en: It executes commands from a file in the current shell. If the sourced file contains
    only function definitions, these are loaded to be used later (but still only in
    the current shell).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它在当前shell中执行文件中的命令。如果被引用的文件只包含函数定义，那么这些函数将被加载以供以后使用（但仍然只能在当前shell中使用）。
- en: '**Why would we want to create a function library?**'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们想要创建一个函数库？**'
- en: A lot of utility functions, such as argument checking, error handling and color
    setting, never change and can sometimes be complex to figure out. If we do this
    once properly, we can then use the predefined functions from our library without
    needing to duplicate code from older scripts.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实用函数，如参数检查、错误处理和颜色设置，从不改变，有时可能很难弄清楚。如果我们正确地做一次，我们就可以使用库中预定义的函数，而不需要从旧脚本中复制代码。
- en: Chapter 14
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: '**What is scheduling?**'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是调度？**'
- en: Scheduling allows us to define when and how a script should run, without the
    need for the user to be interactive at that time.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 调度允许我们定义脚本应该在何时以及如何运行，而无需用户在那时进行交互。
- en: '**What do we mean with ad-hoc scheduling?**'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所说的临时调度是什么意思？
- en: Ad-hoc scheduling, which we normally do with `at` on Linux, is scheduling that
    is not periodically repeated, but often a one-time job at a fixed time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 临时调度，通常我们在Linux上使用`at`进行的调度，是指不定期重复的调度，而是通常在固定时间进行一次性作业。
- en: '**Where does the output of commands run with `at` normally go?**'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`at`运行的命令的输出通常会去哪里？
- en: By default, `at` tries to use `sendmail` to send a local mail to the user who
    owns the queue/job. If sendmail is not installed, the output is gone.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`at`尝试使用`sendmail`向拥有队列/作业的用户发送本地邮件。如果未安装sendmail，则输出将消失。
- en: '**How is scheduling for the `cron` daemon most often implemented?**'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cron`守护程序的调度最常见的实现方式是什么？'
- en: As a user-bound crontab.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户绑定的crontab。
- en: '**Which commands allows you to edit your personal crontab?**'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些命令允许您编辑您的个人crontab？
- en: The command `crontab -e`. Furthermore, you can list the current crontab with
    `crontab -l` and remove the current crontab with `crontab -r`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`crontab -e`。此外，您可以使用`crontab -l`列出当前的crontab，并使用`crontab -r`删除当前的crontab。
- en: '**Which five fields are present in the crontab timestamp syntax?**'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: crontab时间戳语法中存在哪五个字段？
- en: minute
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分钟
- en: hour
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小时
- en: day-of-month
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 月份中的日期
- en: month-of-year
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 年份中的月份
- en: day-of-week
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星期中的日期
- en: '**Which are the three most important environment variables for the crontab?**'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪三个环境变量对于crontab最重要？
- en: PATH
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路径
- en: SHELL
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外壳
- en: MAILTO
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAILTO
- en: '**How can we inspect the output for scripts or commands we have scheduled with
    `cron`?**'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何检查我们使用`cron`计划的脚本或命令的输出？
- en: We can either use redirection in the crontab to write the output to a file,
    or we can use the Linux local mail functionality to send us the output. Most of
    the times, redirecting output to a log file is the way to go.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在crontab中使用重定向将输出写入文件，或者我们可以使用Linux本地邮件功能将输出发送给我们。大多数情况下，将输出重定向到日志文件是最佳选择。
- en: '**If our scheduled scripts do not have enough output for us to effectively
    work with log files, how should we remedy this?**'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们计划的脚本没有足够的输出让我们有效地使用日志文件，我们应该如何解决这个问题？
- en: 'Use the echo command in multiple places in your script, to signal a message
    to the reader that execution is doing what is expected. Example of this are: ''Step
    1 completed successfully, continuing.'' and ''Script execution was a success,
    exiting.''.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中的多个位置使用echo命令，向读者发出执行正在按预期进行的消息。例如：'第1步成功完成，继续进行。'和'脚本执行成功，退出。'。
- en: Chapter 15
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: '**Why are flags often used as *modifiers* whereas positional parameters are
    used as *targets*?**'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么标志通常被用作*修饰符*，而位置参数被用作*目标*？
- en: 'Flags often modify the behavior: it can make a script more or less verbose,
    or perhaps write the output somewhere. Often, a command manipulates a file, which
    is then considered the primary *target* for what the command actually tries to
    achieve.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 标志通常修改行为：它可以使脚本更加详细或更加简洁，或者将输出写入其他位置。通常，命令会操作一个文件，然后该文件被视为命令实际尝试实现的主要*目标*。
- en: '**Why do we run `getopts` in a `while` loop?**'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在`while`循环中运行`getopts`？
- en: All flags are parsed sequentially, and when `getopts` can no longer find new
    flags it will return an exit code different from 0, which will exit the `while`
    loop at exactly the right moment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标志都按顺序解析，当`getopts`无法再找到新标志时，它将返回一个不同于0的退出代码，这将在恰当的时刻退出`while`循环。
- en: '**Why do we need a ?) in the case statement?** We cannot trust the user to
    correctly use all flags all the time. ?) matches any flag we have not specified,
    which we can then use to inform the user of incorrect usage.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在case语句中需要一个?)？我们不能指望用户始终正确使用所有标志。?)匹配我们未指定的任何标志，然后我们可以用它来通知用户使用不正确。
- en: '**Why do we (sometimes) need a :) in the case statement?** The :) is used when
    the optstring specifies an argument for an option, but the user has not given
    it. It allows you to inform the user of the missing information (and you will
    most probably abort the script at this point).'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们（有时）需要在case语句中使用:)？当optstring指定一个选项的参数，但用户没有给出时，可以使用:)。这允许您通知用户缺少的信息（在这一点上，您很可能会中止脚本）。
- en: '**Why do we need a separate optstring is we''re resolving all options anyway?**'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们最终解析所有选项，为什么我们需要一个单独的optstring？
- en: Because the optstring will tell `getopts` which options have arguments and which
    do not.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因为optstring将告诉`getopts`哪些选项有参数，哪些没有。
- en: '**Why do we need to substract 1 from the OPTIND variable when we use it in
    `shift`?** The OPTIND variable always refers to the *next possible index*, which
    means it is always 1 ahead of the final flag that was found. Because we only need
    to shift away the flags (which are seen as positional arguments!), we need to
    make sure we reduce the OPTIND by 1 before we shift.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在使用`shift`时需要从OPTIND变量中减去1？OPTIND变量始终指向*下一个可能的索引*，这意味着它始终比找到的最终标志提前1。因为我们只需要移除标志（它们被视为位置参数！），我们需要确保在移除之前将OPTIND减1。
- en: '**Is it a good idea to mix options with positional arguments?**'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项与位置参数混合使用是个好主意吗？
- en: Because of the added complexity of dealing with both options and positional
    arguments, it is often better to specify the *target* of your operation as a flag
    argument for the `-f` flag; -f is almost universally excepted as a file reference,
    which will always be considered as a logical target for most operations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理选项和位置参数的复杂性增加，通常最好将操作的*目标*指定为`-f`标志的标志参数；-f几乎被普遍接受为文件引用，这将始终被视为大多数操作的逻辑目标。
- en: Chapter 16
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: '**What is *parameter substitution*?** Nothing more than the run-time substitution
    of the variable name with its value at that moment.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*参数替换*是什么？不过是变量名称在运行时与其值的实时替换。'
- en: '**How can we include default values for our defined variables?**'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为定义的变量包含默认值？
- en: With the ${variable:-value} syntax, where *variable* is the name and *value*
    the default value. This will only be used if the value is null or empty ('').
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用${variable:-value}语法，其中*variable*是名称，*value*是默认值。只有在值为空或空（''）时才会使用此值。
- en: '**How can we use parameter expansion to handle missing parameter values?**
    While you would normally use an `if [[ -z ${variable} ]]; then`, parameter expansion
    allows you to use the following syntax to generate an error message and `exit
    1`: ${1:?Name not supplied!}'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用参数扩展来处理缺少的参数值？虽然通常会使用`if [[ -z ${variable} ]]; then`，但参数扩展允许您使用以下语法生成错误消息并`exit
    1`：${1:?未提供名称！}
- en: '**What does ${#*} do?** It is the same as $#, which we use to determine the
    number of arguments passed to our shell script. The general ${#name} syntax allows
    us to get the length of the value of the *name* variable.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ${#*}是什么意思？它与$#相同，我们用它来确定传递给我们的shell脚本的参数数量。一般的${#name}语法允许我们获取*name*变量的值的长度。
- en: '**How does *pattern substitution* work when talking about parameter expansions?**
    *Pattern substitution* allows us to take the value of a variable and modify it
    slightly, by doing a search/replace for a *pattern*.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在谈论参数扩展时，*模式替换*是如何工作的？*模式替换*允许我们获取变量的值并稍微修改它，通过搜索/替换*模式*。
- en: '**How is *pattern removal* related to *pattern substitution*****?**'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*模式去除*与*模式替换*有什么关系？'
- en: Removing a pattern is the same as replacing a pattern with nothing. With pattern
    removal, we get the added flexibility of search both from the beginning of the
    text (prefix) and from the end (suffix). Pattern removal is great when working
    with file paths.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 删除模式就相当于用空白替换模式。使用模式删除时，我们可以从文本的开头（前缀）和末尾（后缀）进行搜索，这样更加灵活。在处理文件路径时，模式删除非常有用。
- en: '**What types of case modifications can we perform?**'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以执行哪些类型的大小写修改？
- en: Lowercasing
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写
- en: Upercasing
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写
- en: Reversing the casing
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转大小写
- en: '**Which two things can we use to get a substring from a variables'' value?**
    We need an *offset*, or a *lenght*, or  the combination of both (most common).'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用哪两种方法从变量值中获取子字符串？我们需要一个*偏移量*，或一个*长度*，或者两者的组合（最常见）。
