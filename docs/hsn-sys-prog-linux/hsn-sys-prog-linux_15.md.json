["```\nint g=41;\nint main(void)\n{\n    g ++;\n}\n```", "```\nstatic long g1=10, g2=12, g3=14;    /* our globals */\npthread_mutex_t mylock;   /* lock to protect our globals */ \n```", "```\n if ((ret = pthread_mutex_init(&mylock, NULL)))\n     FATAL(\"pthread_mutex_init() failed! [%d]\\n\", ret);\n```", "```\npthread_mutex_t mylock = PTHREAD_MUTEX_INITIALIZER;\n```", "```\n if ((ret = pthread_mutex_destroy(&mylock)))\n     FATAL(\"pthread_mutex_destroy() failed! [%d]\\n\", ret);\n```", "```\nvoid * worker(void *data)\n{\n     long datum = (long)data + 1;\n     if (locking)\n         pthread_mutex_lock(&mylock);\n\n     /*--- Critical Section begins */\n g1 ++; g2 ++; g3 ++;\n     printf(\"[Thread #%ld] %2ld %2ld %2ld\\n\", datum, g1, g2, g3);\n     /*--- Critical Section ends */\n\n     if (locking)\n         pthread_mutex_unlock(&mylock);\n\n     /* Terminate with success: status value 0.\n      * The join will pick this up. */\n     pthread_exit((void *)0);\n}\n```", "```\n$ ./mutex1 \nUsage: ./mutex1 lock-or-not\n 0 : do Not lock (buggy!)\n 1 : do lock (correct)\n$ ./mutex1 1\nAt start:   g1 g2 g3\n            10 12 14\n[Thread #1] 11 13 15\n[Thread #2] 12 14 16\n[Thread #3] 13 15 17\n$ \n```", "```\n$ ./mutex1 0\nAt start:   g1 g2 g3\n            10 12 14\n[Thread #1] 11 13 15\n[Thread #2] 12 14 16\n[Thread #3] 13 15 17\n$ \n```", "```\nprintf( \"Locking mode : %s\\n\" \n        \"Verbose mode : %s\\n\",\n          (gLocking == 1?\"ON\":\"OFF\"),\n          (gVerbose == 1?\"ON\":\"OFF\"));\n\nif (gLocking) {\n     if ((ret = pthread_mutex_init(&mylock, NULL)))\n         FATAL(\"pthread_mutex_init() failed! [%d]\\n\", ret);\n }\n...\n```", "```\nvoid * worker(void *data)\n{\n    long datum = (long)data + 1;\n    int N=0;\n...\n    if (gLocking)\n        pthread_mutex_lock(&mylock);\n\n    /*--- Critical Section begins! */\n factorize(N);\n    printf(\"[Thread #%ld] (factorial) %d ! = %20lld\\n\",\n      datum, N, gFactorial);\n    /*--- Critical Section ends */\n\n    if (gLocking)\n        pthread_mutex_unlock(&mylock);\n...\n```", "```\n/*\n * This is the function that calculates the factorial of the given   parameter. \nStress it, making it susceptible to the data race, by turning verbose mode On; then, it will take more time to execute, and likely end up \"racing\" on the value of the global gFactorial. */\nstatic void factorize(int num)\n{\n     int i;\n     gFactorial = 1;\n     if (num <= 0)\n         return;\n    for (i=1; i<=num; i++) {\n         gFactorial *= i;\n         VPRINT(\" i=%2d fact=%20lld\\n\", i, gFactorial);\n    }\n}\n```", "```\n$ ./facto \nUsage: ./facto lock-or-not [verbose=[0]|1]\nLocking mode:\n 0 : do Not lock (buggy!)\n 1 : do lock (correct)\n(TIP: turn locking OFF and verbose mode ON to see the issue!)\n$ ./facto 1\nLocking mode : ON\nVerbose mode : OFF\n[Thread #2] (factorial) 12 ! =     479001600\n[Thread #1] (factorial) 10 ! =       3628800\n$ \n```", "```\n$ ./facto 0 1\nLocking mode : OFF\nVerbose mode : ON\nfacto.c:factorize:50: i= 1 fact=                 1\nfacto.c:factorize:50: i= 2 fact=                 2\nfacto.c:factorize:50: i= 3 fact=                 6\nfacto.c:factorize:50: i= 4 fact=                24\nfacto.c:factorize:50: i= 5 fact=               120\nfacto.c:factorize:50: i= 6 fact=               720\nfacto.c:factorize:50: i= 7 fact=              5040\nfacto.c:factorize:50: i= 8 fact=             40320\nfacto.c:factorize:50: i= 9 fact=            362880\nfacto.c:factorize:50: i=10 fact=            3628800\n[Thread #1] (factorial) 10 ! =           3628800\nfacto.c:factorize:50: i= 1 fact=                        1\nfacto.c:factorize:50: i= 2 fact=         7257600  *<-- Dirty Read!*\nfacto.c:factorize:50: i= 3 fact=                 21772800\nfacto.c:factorize:50: i= 4 fact=                 87091200\nfacto.c:factorize:50: i= 5 fact=                435456000\nfacto.c:factorize:50: i= 6 fact=               2612736000\nfacto.c:factorize:50: i= 7 fact=              18289152000\nfacto.c:factorize:50: i= 8 fact=             146313216000\nfacto.c:factorize:50: i= 9 fact=            1316818944000\nfacto.c:factorize:50: i=10 fact=           13168189440000\nfacto.c:factorize:50: i=11 fact=          144850083840000\nfacto.c:factorize:50: i=12 fact=         1738201006080000\n[Thread #2] (factorial) 12 ! =        1738201006080000\n$ \n```", "```\ninclude <pthread.h>\nint pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,     int *restrict type);\nint pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);\n```", "```\n#include <pthread.h>\nint pthread_mutexattr_getrobust(const pthread_mutexattr_t *attr,\n    int *robustness);\nint pthread_mutexattr_setrobust(const pthread_mutexattr_t *attr,\n    int robustness);\n```", "```\nint pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr,\n    int *pshared);\nint pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,\n    int pshared);\n```", "```\n$ ./pshared_mutex_demo \n./pshared_mutex_demo:15317: shmem segment successfully created / accessed. ID=38928405\n./pshared_mutex_demo:15317: Attached successfully to shmem segment at 0x7f45e9d50000\n./pshared_mutex_demo:15317: shmem segment successfully created / accessed. ID=38961174\n./pshared_mutex_demo:15317: Attached successfully to shmem segment at 0x7f45e9d4f000\n\n[pthread_once(): calls init_mutex(): from PID 15317]\n\nWorker thread #0 [15317] running ...\n [thrd 0]: attempting to take the shared mutex lock...\n [thrd 0]: got the (shared) lock!\n#0: work done, exiting now\n\n Child[15319]: attempting to taking the shared mutex lock...\n Child[15319]: got the (shared) lock!\n\nmain: joining (waiting) upon thread #0 ...\nThread #0 successfully joined; it terminated with status=0\n\nShared Memory 'comm' buffer:\n00000000 63 63 63 63 63 00 63 68 69 6c 64 20 31 35 33 31 ccccc.child 1531\n00000016 39 20 68 65 72 65 21 0a 00 74 74 74 74 74 00 74 9 here!..ttttt.t\n00000032 68 72 65 61 64 20 31 35 33 31 37 20 68 65 72 65 hread 15317 here\n00000048 21 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 !...............\n00000064 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000080 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000096 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000112 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n```", "```\n...\n\n  /* Setup a shared memory region for the process-shared mutex lock.\n   * A bit of complexity due to the fact that we use the space within for:\n   * a) memory for 1 process-shared mutex\n   * b) 32 bytes of padding (not strictly required)\n   * c) memory for 1 pthread_once_t variable.\n   * We need the last one for performing guaranteed once-only\n   * initialization of the mutex object.\n   */\n  shmaddr = shmem_setup(&gshm_id, argv[0], 0, \n              (NUM_PSMUTEX*sizeof(pthread_mutex_t) + 32 +  \n                sizeof(pthread_once_t)));\n  if (!shmaddr)\n      FATAL(\"shmem setup 1 failed\\n\");\n\n  /* Associate the shared memory segment with the mutex and \n   * the pthread_once_t variable. */\n  shmtx = (pthread_mutex_t *)shmaddr;\n  mutex_init_once = (pthread_once_t *)shmaddr +     \n                      (NUM_PSMUTEX*sizeof(pthread_mutex_t)) + 32;\n  *mutex_init_once = PTHREAD_ONCE_INIT; /* see below comment on pthread_once */\n\n  /* Setup a second shared memory region to be used as a comm buffer */\n  gshmbuf = shmem_setup(&gshmbuf_id, argv[0], 0, GBUFSIZE);\n  if (!gshmbuf)\n      FATAL(\"shmem setup 2 failed\\n\");\n  memset(gshmbuf, 0, GBUFSIZE);\n\n  /* Initialize the mutex; here, we come across a relevant issue: this\n   * mutex object is already instantiated in a shared memory region that\n   * other processes might well have access to. So who will initialize\n   * the mutex? (it must be done only once).\n   * Enter the pthread_once(3) API: it guarantees that, given a\n   * 'once_control' variable (1st param), the 2nd param - a function\n   * pointer, that function will be called exactly once.\n   * However: the reality is that the pthread_once is meant to be used\n   * between the threads of a process. Also, POSIX requires that the\n   * initialization of the 'once_control' is done statically; here, we\n   * have performed it at runtime...\n   */\n  pthread_once(mutex_init_once, init_mutex);\n...\n```", "```\nstatic void init_mutex(void)\n{\n  int ret=0;\n\n  printf(\"[pthread_once(): calls %s(): from PID %d]\\n\",\n      __func__, getpid());\n  ret = pthread_mutexattr_init(&mtx_attr);\n  if (ret)\n      FATAL(\"pthread_mutexattr_init failed [%d]\\n\", ret);\n\n  ret = pthread_mutexattr_setpshared(&mtx_attr, PTHREAD_PROCESS_SHARED);\n  if (ret)\n      FATAL(\"pthread_mutexattr_setpshared failed [%d]\\n\", ret);\n\n  ret = pthread_mutex_init(shmtx, &mtx_attr);\n  if (ret)\n      FATAL(\"pthread_mutex_init failed [%d]\\n\", ret);\n}\n```", "```\nvoid * worker(void *data)\n{\n  long datum = (long)data;\n  printf(\"Worker thread #%ld [%d] running ...\\n\", datum, getpid());\n  sleep(1);\n  printf(\" [thrd %ld]: attempting to take the shared mutex lock...\\n\", datum);\n\n  LOCK_MTX(shmtx);\n  /*--- critical section begins */\n  printf(\" [thrd %ld]: got the (shared) lock!\\n\", datum);\n  /* Lets write into the shmem buffer; first, a 5-byte 'signature',\n     followed by a message. */\n  memset(&gshmbuf[0]+25, 't', 5);\n  snprintf(&gshmbuf[0]+31, 32, \"thread %d here!\\n\", getpid());\n  /*--- critical section ends */\n  UNLOCK_MTX(shmtx);\n\n  printf(\"#%ld: work done, exiting now\\n\", datum);\n  pthread_exit(NULL);\n}\n```", "```\n#define LOCK_MTX(mtx) do {                           \\\n  int ret=0;                                         \\\n  if ((ret = pthread_mutex_lock(mtx)))               \\\n    FATAL(\"pthread_mutex_lock failed! [%d]\\n\", ret); \\\n} while(0)\n\n#define UNLOCK_MTX(mtx) do {                           \\\n  int ret=0;                                           \\\n  if ((ret = pthread_mutex_unlock(mtx)))               \\\n    FATAL(\"pthread_mutex_unlock failed! [%d]\\n\", ret); \\\n} while(0)\n```", "```\nint pthread_mutexattr_getprotocol(const pthread_mutexattr_t\n     *restrict attr, int *restrict protocol);\nint pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr,\n     int protocol);\n```", "```\n#include <pthread.h>\n#include <time.h>\nint pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,\n        const struct timespec *restrict abstime);\n```", "```\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n```", "```\nif (pthread_mutex_trylock(&mylock) != EBUSY)) {    <-- time t1\n    // it's unlocked                               <-- time t2\n}\n// it's locked\n```", "```\nint pthread_cond_wait(pthread_cond_t *restrict cond,\n                      pthread_mutex_t *restrict mutex);\nint pthread_cond_signal(pthread_cond_t *cond);\n```", "```\nint pthread_cond_init(pthread_cond_t *restrict cond,\n                          const pthread_condattr_t *restrict attr);\n```", "```\nint pthread_condattr_destroy(pthread_condattr_t *attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n```", "```\n...\n#define LOCK_MTX(mtx) do { \\\n  int ret=0; \\\n  if ((ret = pthread_mutex_lock(mtx))) \\\n    FATAL(\"pthread_mutex_lock failed! [%d]\\n\", ret); \\\n} while(0)\n\n#define UNLOCK_MTX(mtx) do { \\\n  int ret=0; \\\n  if ((ret = pthread_mutex_unlock(mtx))) \\\n    FATAL(\"pthread_mutex_unlock failed! [%d]\\n\", ret); \\\n} while(0)\n\nstatic int gWorkDone=0;\n/* The {cv,mutex} pair */\nstatic pthread_cond_t mycv;\nstatic pthread_mutex_t mycv_mutex = PTHREAD_MUTEX_INITIALIZER;\n```", "```\n// Init a condition variable attribute object\n  if ((ret = pthread_condattr_init(&cvattr)))\n      FATAL(\"pthread_condattr_init failed [%d].\\n\", ret);\n  // Init a {cv,mutex} pair: condition variable & it's associated mutex\n  if ((ret = pthread_cond_init(&mycv, &cvattr)))\n      FATAL(\"pthread_cond_init failed [%d].\\n\", ret);\n  // the mutex lock has been statically initialized above.\n```", "```\nstatic void * workerA(void *msg)\n{\n  int ret=0;\n\n  LOCK_MTX(&mycv_mutex);\n  while (1) {\n      printf(\" [thread A] : now waiting on the CV for thread B to finish...\\n\");\n      ret = pthread_cond_wait(&mycv, &mycv_mutex);\n      // Blocking: associated mutex auto-released ...\n      if (ret)\n          FATAL(\"pthread_cond_wait() in thread A failed! [%d]\\n\", ret);\n      // Unblocked: associated mutex auto-acquired upon release from the condition wait...\n\n      printf(\" [thread A] : recheck the predicate (is the work really \"\n \"done or is it a spurious wakeup?)\\n\");\n if (gWorkDone)\n break;\n      printf(\" [thread A] : SPURIOUS WAKEUP detected !!! \"\n             \"(going back to CV waiting)\\n\");\n  }\n UNLOCK_MTX(&mycv_mutex);\n  printf(\" [thread A] : (cv wait done) thread B has completed it's work...\\n\");\n  pthread_exit((void *)0);\n}\n```", "```\nstatic void * workerB(void *msg)\n{\n  int ret=0;\n\n  printf(\" [thread B] : perform the 'work' now (first sleep(1) :-)) ...\\n\");\n  sleep(1);\n  DELAY_LOOP('b', 72);\n  gWorkDone = 1;\n\n  printf(\"\\n [thread B] : work done, signal thread A to continue ...\\n\");\n  /* It's not strictly required to lock/unlock the associated mutex\n   * while signalling; we do it here to be pedantically correct (and\n   * to shut helgrind up).\n   */\n  LOCK_MTX(&mycv_mutex);\n  ret = pthread_cond_signal(&mycv);\n  if (ret)\n      FATAL(\"pthread_cond_signal() in thread B failed! [%d]\\n\", ret);\n  UNLOCK_MTX(&mycv_mutex);\n  pthread_exit((void *)0);\n}\n```", "```\n$ ./cv_simple_dbg \n [thread A] : now waiting on the CV for thread B to finish...\n [thread B] : perform the 'work' now (first sleep(1) :-)) ...\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n [thread B] : work done, signal thread A to continue ...\n [thread A] : recheck the predicate (is the work really done or is it a spurious wakeup?)\n [thread A] : (cv wait done) thread B has completed it's work...\n$ \n```", "```\nint pthread_cond_timedwait(pthread_cond_t *restrict cond,\n    pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);\n```"]