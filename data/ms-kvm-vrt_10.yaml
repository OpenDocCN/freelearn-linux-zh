- en: '*Chapter 8*: Creating and Modifying VM Disks, Templates, and Snapshots'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：创建和修改VM磁盘、模板和快照'
- en: This chapter represents the end of second part of the book, in which we focused
    on various `libvirt` features—installing `libvirt` networking and storage, virtual
    devices and display protocols, installing **virtual machines** (**VMs**) and configuring
    them… and all of that as a preparation for things that are coming in the next
    part of the book, which is about automation, customization, and orchestration.
    In order for us to be able to learn about those concepts, we must now switch our
    focus to VMs and their advanced operations—modifying, templating, using snapshots,
    and so on. Some of these topics will often be referenced later in the book, and
    some of these topics will be even more valuable for various business reasons in
    a production environment. Let's dive in and cover them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章代表了本书第二部分的结束，我们在这一部分专注于各种`libvirt`功能——安装`libvirt`网络和存储，虚拟设备和显示协议，安装**虚拟机**（**VMs**）并配置它们……所有这些都是为了为本书的下一部分做准备，下一部分将涉及自动化、定制和编排。为了让我们能够学习这些概念，我们现在必须把焦点转移到VM及其高级操作上——修改、模板化、使用快照等。本书的后面经常会提到这些主题中的一些，这些主题在生产环境中出于各种业务原因可能会更有价值。让我们深入研究并涵盖它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Modifying VM images using `libguestfs` tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`libguestfs`工具修改VM映像
- en: VM templating
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VM模板化
- en: '`virt-builder` and `virt-builder` repos'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-builder`和`virt-builder`存储库'
- en: Snapshots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照
- en: Use cases and best practices while using snapshots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用快照时的用例和最佳实践
- en: Modifying VM images using libguestfs tools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`libguestfs`工具修改VM映像
- en: As our focus in this book shifts more toward scaling things out, we have to
    end this part of the book by introducing a stack of commands that will come in
    handy as we start to build bigger environments. For bigger environments, we really
    need various automation, customization, and orchestration tools that we will start
    discussing in our next chapter. But first, we have to focus on various customization
    utilities that we already have at our disposal. These command-line utilities will
    be really helpful for many different types of operations, varying from `guestfish`
    (for accessing and modifying VM files) to `virt-p2v` (`virt-sysprep` (to *sysprep*
    a VM before templating and cloning). So, let's approach the subject of these utilities
    in an engineering fashion—step by step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书重点转向扩展，我们不得不在本书的这一部分结束时介绍一系列命令，这些命令将在我们开始构建更大的环境时非常有用。对于更大的环境，我们确实需要各种自动化、定制和编排工具，我们将在下一章开始讨论这些工具。但首先，我们必须专注于我们已经掌握的各种定制工具。这些命令行实用程序对于许多不同类型的操作都非常有帮助，从`guestfish`（用于访问和修改VM文件）到`virt-p2v`（`virt-sysprep`（在模板化和克隆之前*sysprep*
    VM）。因此，让我们以工程方式逐步接触这些实用程序的主题。
- en: '`libguestfs` is a command-line library of utilities for working with VM disks.
    This library consists of roughly 30 different commands, some of which are included
    in the following list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`libguestfs`是一个用于处理VM磁盘的命令行实用程序库。该库包括大约30个不同的命令，其中一些包括在以下列表中：'
- en: '`guestfish`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guestfish`'
- en: '`virt-builder`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-builder`'
- en: '`virt-builder-repository`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-builder-repository`'
- en: '`virt-copy-in`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-copy-in`'
- en: '`virt-copy-out`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-copy-out`'
- en: '`virt-customize`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-customize`'
- en: '`virt-df`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-df`'
- en: '`virt-edit`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-edit`'
- en: '`virt-filesystems`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-filesystems`'
- en: '`virt-rescue`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-rescue`'
- en: '`virt-sparsify`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-sparsify`'
- en: '`virt-sysprep`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-sysprep`'
- en: '`virt-v2v`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-v2v`'
- en: '`virt-p2v`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-p2v`'
- en: We'll start with five of the most important commands—`virt-v2v`, `virt-p2v`,
    `virt-copy-in`, `virt-customize`, and `guestfish`. We will cover `virt-sysprep`
    when we cover VM templating, and we have a separate part of this chapter dedicated
    to `virt-builder`, so we'll skip these commands for the time being.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从五个最重要的命令开始——`virt-v2v`、`virt-p2v`、`virt-copy-in`、`virt-customize`和`guestfish`。在我们讨论VM模板化时，我们将涵盖`virt-sysprep`，并且本章的一个单独部分专门介绍了`virt-builder`，因此我们暂时跳过这些命令。
- en: virt-v2v
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: virt-v2v
- en: 'Let''s say that you have a Hyper-V-, Xen-, or VMware-based VM and you want
    to convert them to KVM, oVirt, Red Hat Enterprise Virtualization, or OpenStack.
    We''ll just use a VMware-based VM as an example here and convert it to a KVM VM
    that is going to be managed by `libvirt` utilities. Because of some changes that
    were introduced in 6.0+ revisions of VMware platforms (both on the **ESX integrated**
    (**ESXi**) hypervisor side and on the vCenter server side and plugin side), it
    is going to be rather time-consuming to export a VM and convert it to a KVM machine—either
    by using a vCenter server or a ESXi host as a source. So, the simplest way to
    convert a VMware VM to a KVM VM would be the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个基于Hyper-V、Xen或VMware的VM，并且希望将其转换为KVM、oVirt、Red Hat Enterprise Virtualization或OpenStack。我们将以VMware为例，将其转换为由`libvirt`实用程序管理的KVM
    VM。由于VMware平台的6.0+版本（无论是在**ESX集成**（**ESXi**）hypervisor方面还是在vCenter服务器和插件方面）引入了一些更改，将VM导出并转换为KVM机器将非常耗时——无论是使用vCenter服务器还是ESXi主机作为源。因此，将VMware
    VM转换为KVM VM的最简单方法如下：
- en: Shut down the VM in the vCenter or ESXi host.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在vCenter或ESXi主机中关闭VM。
- en: Export the VM as an `Downloads` directory).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VM导出为`Downloads`目录。
- en: Install the VMware `OVFtool` utility from [https://code.vmware.com/web/tool/4.3.0/ovf](https://code.vmware.com/web/tool/4.3.0/ovf).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://code.vmware.com/web/tool/4.3.0/ovf](https://code.vmware.com/web/tool/4.3.0/ovf)安装VMware
    `OVFtool`实用程序。
- en: Move the exported VM files to the `OVFtool` installation folder.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导出的VM文件移动到`OVFtool`安装文件夹。
- en: Convert the VM in OVF format to **Open Virtualization Appliance** (**OVA**)
    format.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VM以OVF格式转换为**Open Virtualization Appliance**（**OVA**）格式。
- en: 'The reason why we need `OVFtool` for this is rather disappointing—it seems
    that VMware removed the option to export the OVA file directly. Luckily, `OVFtool`
    exists for Windows-, Linux-, and OS X-based platforms, so you''ll have no trouble
    using it. Here''s the last step of the process:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`OVFtool`的原因相当令人失望——似乎VMware删除了直接导出OVA文件的选项。幸运的是，`OVFtool`适用于基于Windows、Linux和OS
    X的平台，因此您不会在使用它时遇到麻烦。以下是该过程的最后一步：
- en: '![Figure 8.1 – Using OVFtool to convert OVF to OVA template format'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 使用OVFtool将OVF转换为OVA模板格式'
- en: '](img/B14834_08_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_01.jpg)'
- en: Figure 8.1 – Using OVFtool to convert OVF to OVA template format
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 使用OVFtool将OVF转换为OVA模板格式
- en: 'After doing this, we can easily upload the `v2v.ova` file to our KVM host and
    type the following command into the `ova` file directory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以轻松地将`v2v.ova`文件上传到我们的KVM主机，并在`ova`文件目录中键入以下命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-of` and `-o` options specify the output format (`qcow2` libvirt image),
    and `-n` makes sure that the VM gets connected to the default virtual network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`-of`和`-o`选项指定输出格式（`qcow2` libvirt映像），`-n`确保VM连接到默认虚拟网络。'
- en: 'If you need to convert a Hyper-V VM to KVM, you can do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将Hyper-V VM转换为KVM，可以这样做：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure that you specify the VM disk location correctly. The `-o local` and
    `-os /var/lib/libvirt/images` options make sure that the converted disk image
    gets saved locally, in the specified directory (the KVM default image directory).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您正确指定了VM磁盘位置。 `-o local` 和 `-os /var/lib/libvirt/images` 选项确保转换后的磁盘映像被保存在指定目录中（KVM默认映像目录）。
- en: There are other types of VM conversion processes, such as converting a physical
    machine to a virtual one. Let's cover that now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的VM转换过程，例如将物理机器转换为虚拟机。让我们现在来介绍一下。
- en: virt-p2v
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: virt-p2v
- en: Now that we've covered `virt-v2v`, let's switch to `virt-p2v`. Basically, `virt-v2v`
    and `virt-p2v` perform a job that seems similar, but the aim of `virt-p2v` is
    to convert a *physical* machine to *VM*. Technically speaking, this is quite a
    bit different, as with `virt-v2v` we can either access a management server and
    hypervisor directly and convert the VM on the fly (or via an OVA template). With
    a physical machine, there's no management machine that can provide some kind of
    support or **application programming interface** (**API**) to do the conversion
    process. We have to *attack* the physical machine directly. In the real world
    of IT, this is usually done via some kind of agent or additional application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`virt-v2v`，让我们转而介绍`virt-p2v`。基本上，`virt-v2v`和`virt-p2v`执行的工作似乎相似，但`virt-p2v`的目的是将*物理*机器转换为*VM*。从技术上讲，这是有很大不同的，因为使用`virt-v2v`，我们可以直接访问管理服务器和hypervisor，并在转换VM时（或通过OVA模板）进行转换。对于物理机器，没有管理机器可以提供某种支持或**应用程序编程接口**（**API**）来执行转换过程。我们必须直接*攻击*物理机器。在IT的实际世界中，通常通过某种代理或附加应用程序来完成这一点。
- en: Just as an example, if you want to convert a physical Windows machine to a VMware-based
    VM, you'll have to do it by installing a VMware vCenter Converter Standalone on
    a system that needs to be converted. Then, you'll have to select a correct mode
    of operation and *stream* the complete conversion process to vCenter/ESXi. It
    does work rather well, but—for example—RedHat's approach is a bit different. It
    uses a boot media to convert a physical server. So, before using this conversion
    process, you have to log in to the Customer Portal (located at [https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.0/x86_64/product-software](https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.0/x86_64/product-software)
    for `virt-p2v` and `virt-p2v-make-disk` utilities to create an image. But—lo and
    behold—the `virt-p2v-make-disk` utility uses `virt-builder`, which we will cover
    just a bit later in a separate part of this chapter. So, let's table this discussion
    for just a short while, as we will come back to it soon with full force.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，如果您想将物理Windows机器转换为基于VMware的VM，您需要在需要转换的系统上安装VMware vCenter Converter Standalone。然后，您需要选择正确的操作模式，并将完整的转换过程*流式传输*到vCenter/ESXi。这确实效果很好，但是举个例子，RedHat的方法有点不同。它使用引导介质来转换物理服务器。因此，在使用此转换过程之前，您必须登录到客户门户（位于[https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.0/x86_64/product-software](https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.0/x86_64/product-software)）以使用`virt-p2v`和`virt-p2v-make-disk`实用程序创建映像。但是，`virt-p2v-make-disk`实用程序使用`virt-builder`，我们稍后将在本章的另一部分中详细介绍。因此，让我们暂时搁置这个讨论，因为我们很快将全力回来。
- en: As a side note, on the list of supported destinations of this command, we can
    use Red Hat Enterprise Virtualization, OpenStack, or KVM/`libvirt`. In terms of
    supported architectures, `virt-p2v` is only supported for x86_64-based platforms,
    and only if it is used on RHEL/CentOS 7 and 8\. Keep that in mind when planning
    to do your P2V conversions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个旁注，在此命令的支持目的地列表中，我们可以使用Red Hat企业虚拟化、OpenStack或KVM/`libvirt`。在支持的架构方面，`virt-p2v`仅支持基于x86_64的平台，并且仅在RHEL/CentOS
    7和8上使用。在计划进行P2V转换时，请记住这一点。
- en: guestfish
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: guestfish
- en: The last utility that we want to discuss in this intro part of the chapter is
    called `guestfish`. This is a very, very important utility that enables you to
    do all sorts of advanced things with actual VM filesystems. We can also use it
    to do different types of conversion—for example, convert an `tar.gz`; convert
    a virtual disk image from an `ext4` filesystem to a `ext4` filesystem; and much
    more. We will show you a couple of examples of how to use it to open a VM image
    file and root around a bit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最后一个实用程序是`guestfish`。这是一个非常重要的实用程序，它使您能够对实际的VM文件系统进行各种高级操作。我们还可以使用它进行不同类型的转换，例如，将`tar.gz`转换为虚拟磁盘映像；将虚拟磁盘映像从`ext4`文件系统转换为`ext4`文件系统；等等。我们将向您展示如何使用它来打开VM映像文件并进行一些操作。
- en: The first example is a really common one—you have prepared a `qcow2` image with
    a complete VM; the guest operating system is installed; everything is configured;
    you're ready to copy that VM file somewhere to be reused; and... you remember
    that you didn't configure a root password according to some specification. Let's
    say that this was something that you had to do for a client, and that client has
    specific root password requirements for the initial root password. This makes
    it easier for the client—they don't need to have a password sent by you in an
    email; they have only one password to remember; and, after receiving the image,
    it will be used to create the VM. After the VM has been created and run, the root
    password will be changed to something—according to security practices—used by
    a client.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是一个非常常见的例子——您已经准备好了一个带有完整VM的`qcow2`镜像；客户操作系统已安装；一切都已配置好；您准备将该VM文件复制到其他地方以便重复使用；然后……您记得您没有根据某些规范配置根密码。假设这是您为客户做的事情，该客户对初始根密码有特定的要求。这对客户来说更容易——他们不需要通过电子邮件收到您发送的密码；他们只需要记住一个密码；并且，在收到镜像后，它将用于创建VM。在创建并运行VM之后，根密码将被更改为根据安全实践使用的客户密码。
- en: So, basically, the first example is an example of what it means to be *human*—forgetting
    to do something, and then wanting to repair that, but (in this case) without actually
    running the VM as that can change quite a few settings, especially if your `qcow2`
    image was created with VM templating in mind, in which case you *definitely* don't
    want to start that VM to repair something. More about that in the next part of
    this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，第一个例子是一个*人类*的例子——忘记做某事，然后想要修复，但（在这种情况下）不实际运行VM，因为这可能会改变很多设置，特别是如果您的`qcow2`镜像是为VM模板化而创建的，那么您*绝对*不希望启动该VM来修复某些东西。关于这一点，我们将在本章的下一部分详细介绍。
- en: 'This is an ideal use case for `guestfish`. Let''s say that our `qcow2` image
    is called `template.qcow2`. Let''s change the root password to something else—for
    example, `packt123`. First, we need a hash for that password. The easiest way
    to do that would be to use `openssl` with the `-6` option (which equals SHA512
    encryption), as illustrated in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`guestfish`的一个理想用例。假设我们的`qcow2`镜像名为`template.qcow2`。让我们将根密码更改为其他内容——例如，`packt123`。首先，我们需要该密码的哈希。最简单的方法是使用带有`-6`选项的`openssl`（相当于SHA512加密），如下面的截图所示：
- en: '![Figure 8.2 – Using openssl to create an SHA512-based password hash'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 使用openssl创建基于SHA512的密码哈希'
- en: '](img/B14834_08_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_02.jpg)'
- en: Figure 8.2 – Using openssl to create an SHA512-based password hash
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 使用openssl创建基于SHA512的密码哈希
- en: 'Now that we have our hash, we can mount and edit our image, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了哈希，我们可以挂载和编辑我们的镜像，如下所示：
- en: '![Figure 8.3 – Using guestfish to edit the root password inside our qcow2 VM
    image'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 使用guestfish编辑我们的qcow2 VM镜像中的根密码'
- en: '](img/B14834_08_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_03.jpg)'
- en: Figure 8.3 – Using guestfish to edit the root password inside our qcow2 VM image
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用guestfish编辑我们的qcow2 VM镜像中的根密码
- en: Shell commands that we typed in were used to get direct access to the image
    (without `libvirt` involvement) and to mount our image in read-write mode. Then,
    we started our session (`guestfish run` command), checked which filesystems are
    present in the image (`list-filesystems`), and mounted the filesystem on the root
    folder. In the second-to-last step, we changed the root's password hash to the
    hash created by `openssl`. The `exit` command closes our `guestfish` session and
    saves changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的Shell命令用于直接访问图像（无需涉及`libvirt`）并以读写模式挂载我们的图像。然后，我们启动了我们的会话（`guestfish run`命令），检查图像中存在哪些文件系统（`list-filesystems`），并将文件系统挂载到根文件夹上。在倒数第二步中，我们将根密码的哈希更改为由`openssl`创建的哈希。`exit`命令关闭我们的`guestfish`会话并保存更改。
- en: 'You could use a similar principle to—for example—remove forgotten `sshd` keys
    from the `/etc/ssh` directory, remove user `ssh` directories, and so on. The process
    can be seen in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的原理——例如——从`/etc/ssh`目录中删除遗忘的`sshd`密钥，删除用户`ssh`目录等。该过程如下截图所示：
- en: '![Figure 8.4 – Using virt-customize to execute command inside a qcow2 image'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 使用virt-customize在qcow2镜像内执行命令'
- en: '](img/B14834_08_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_04.jpg)'
- en: Figure 8.4 – Using virt-customize to execute command inside a qcow2 image
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 使用virt-customize在qcow2镜像内执行命令
- en: 'The second example is also rather useful, as it involves a topic covered in
    the next chapter (`cloud-init`), which is often used to configure cloud VMs by
    manipulating the early initialization of the VM instance. Also, taking a broader
    view of the subject, you can use this `guestfish` example to manipulate the service
    configuration *inside* VM images. So, let''s say that our VM image was configured
    so that the `cloud-init` service is started automatically. We want that service
    to be disabled for whatever reason—for example, to debug an error in the `cloud-init`
    configuration. If we didn''t have the capability to manipulate `qcow` image content,
    we''d have to start that VM, use `systemctl` to *disable* the service, and—perhaps—do
    the whole procedure to reseal that VM if this was a VM template. So, let''s use
    `guestfish` for the same purpose, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子也非常有用，因为它涉及到下一章中涵盖的一个主题（`cloud-init`），通常用于通过操纵VM实例的早期初始化来配置云VM。此外，从更广泛的角度来看，您可以使用这个`guestfish`示例来操纵VM镜像*内部*的服务配置。因此，假设我们的VM镜像被配置为自动启动`cloud-init`服务。出于某种原因，我们希望禁用该服务——例如，为了调试`cloud-init`配置中的错误。如果我们没有能力操纵`qcow`镜像内容，我们将不得不启动该VM，使用`systemctl`来*禁用*该服务，然后——也许——执行整个过程来重新封装该VM，如果这是一个VM模板的话。因此，让我们使用`guestfish`来达到相同的目的，如下所示：
- en: '![Figure 8.5 – Using guestfish to disable the cloud-init service on VM startup'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 使用guestfish在VM启动时禁用cloud-init服务'
- en: '](img/B14834_08_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_05.jpg)'
- en: Figure 8.5 – Using guestfish to disable the cloud-init service on VM startup
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 使用guestfish在VM启动时禁用cloud-init服务
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be careful in this example, as normally we'd use `ln -sf` with a space character
    between the command and options. Not so in our `guestfish` example—it needs to
    be used *without* a space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中要小心，因为通常我们会在`ln -sf`之间使用空格字符。但在我们的`guestfish`示例中不是这样—它需要*不*使用空格。
- en: 'And lastly, let''s say that we need to copy a file to our image. For example,
    we need to copy our local `/etc/resolv.conf` file to the image as we forgot to
    configure our`virt-copy-in` command for that purpose, as illustrated in the following
    screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们需要将文件复制到我们的镜像。例如，我们需要将本地的`/etc/resolv.conf`文件复制到镜像中，因为我们忘记为此目的配置我们的`virt-copy-in`命令，如下截图所示：
- en: '![Figure 8.6 – Using virt-copy-in to copy a file to our image'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 使用virt-copy-in将文件复制到我们的镜像'
- en: '](img/B14834_08_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_06.jpg)'
- en: Figure 8.6 – Using virt-copy-in to copy a file to our image
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 使用virt-copy-in将文件复制到我们的镜像
- en: Topics that we covered in this part of our chapter are very important for what
    follows next, which is a discussion about creating VM templates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的这一部分涵盖的主题对接下来的内容非常重要，即讨论创建虚拟机模板。
- en: VM templating
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VM模板化
- en: One of the most common use cases for VMs is creating VM *templates*. So, let's
    say that we need to create a VM that is going to be used as a template. We use
    the term *template* here literally, in the same manner in which we can use templates
    for Word, Excel, PowerPoint, and so on, as VM templates exist for the very same
    reason—to have a *familiar* working environment preconfigured for us so that we
    don't need to start from scratch. In the case of VM templates, we're talking about
    *not installing a VM guest operating system from scratch*, which is a huge time-saver.
    Imagine getting a task to deploy 500 VMs for some kind of testing environment
    to test how something works when scaled out. You'd lose weeks doing that from
    scratch, even allowing for the fact that you can do installations in parallel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机最常见的用例之一是创建虚拟机*模板*。因此，假设我们需要创建一个将用作模板的虚拟机。我们在这里字面上使用术语*模板*，就像我们可以为Word、Excel、PowerPoint等使用模板一样，因为虚拟机模板存在的原因与此相同—为了让我们拥有一个*熟悉*的预配置工作环境，以便我们不需要从头开始。在虚拟机模板的情况下，我们谈论的是*不从头安装虚拟机客户操作系统*，这是一个巨大的时间节省。想象一下，如果你得到一个任务，需要为某种测试环境部署500个虚拟机，以测试某种东西在扩展时的工作情况。即使考虑到你可以并行安装，也会花费数周时间。
- en: 'VMs need to be looked at as *objects*, and they have certain *properties* or
    *attributes*. From the *outside* perspective (meaning, from the perspective of
    `libvirt`), a VM has a name, a virtual disk, a virtual **central processing unit**
    (**CPU**) and memory configuration, connectivity to a virtual switch, and so on.
    We covered this subject in [*Chapter 7*](B14834_07_Final_ASB_ePub.xhtml#_idTextAnchor125),
    *VM: Installation, Configuration, and Life Cycle Management*. That being said,
    we didn''t touch the subject of *inside* a VM. From that perspective (basically,
    from the guest operating system perspective), a VM also has certain properties—installed
    guest operating system version, **Internet Protocol** (**IP**) configuration,
    **virtual local area network** (**VLAN**) configuration… After that, it depends
    on which operating system the family VM is based. We thus need to consider the
    following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机需要被视为*对象*，它们具有某些*属性*或*特性*。从*外部*的角度来看（即从`libvirt`的角度），虚拟机有一个名称、一个虚拟磁盘、一个虚拟中央处理单元（CPU）和内存配置、连接到虚拟交换机等等。我们在[*第7章*](B14834_07_Final_ASB_ePub.xhtml#_idTextAnchor125)中涵盖了这个主题，*VM：安装、配置和生命周期管理*。也就是说，我们没有涉及*虚拟机内部*的主题。从这个角度来看（基本上是从客户操作系统的角度），虚拟机也有一些属性—安装的客户操作系统版本、Internet
    Protocol（IP）配置、虚拟局域网（VLAN）配置...之后，这取决于基于哪个操作系统的家族虚拟机。因此，我们需要考虑以下内容：
- en: If we're talking about Microsoft Windows-based VMs, we have to consider service
    and software configuration, registry configuration, and license configuration.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们谈论基于Microsoft Windows的虚拟机，我们必须考虑服务和软件配置，注册表配置和许可证配置。
- en: If we're talking about Linux-based VMs, we have to consider service and software
    configuration, **Secure Shell** (**SSH**) key configuration, license configuration,
    and so on.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们谈论基于Linux的虚拟机，我们必须考虑服务和软件配置，安全外壳（SSH）密钥配置，许可证配置等等。
- en: It can be even more specific than that. For example, preparing a template for
    Ubuntu-based VMs is different from preparing a template for CentOS 8-based VMs.
    And to create these templates properly, we need to learn some basic procedures
    that we can then use repetitively every single time when creating a VM template.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以更具体。例如，为基于Ubuntu的虚拟机准备模板与为基于CentOS 8的虚拟机准备模板是不同的。为了正确创建这些模板，我们需要学习一些基本程序，然后每次创建虚拟机模板时都可以重复使用。
- en: 'Consider this example: suppose you wish to create four Apache web servers to
    host your web applications. Normally, with the traditional manual installation
    method, you would first have to create four VMs with specific hardware configurations,
    install an operating system on each of them one by one, and then download and
    install the required Apache packages using `yum` or some other software installation
    method. This is a time-consuming job, as you will be mostly doing repetitive work.
    But with a template approach, it can be done in considerably less time. How? Because
    you will bypass operating system installation and other configuration tasks and
    directly spawn VMs from a template that consists of a preconfigured operating
    system image, containing all the required web server packages ready for use.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：假设你希望创建四个Apache Web服务器来托管你的Web应用程序。通常，使用传统的手动安装方法，你首先必须创建四个具有特定硬件配置的虚拟机，逐个在每个虚拟机上安装操作系统，然后使用`yum`或其他软件安装方法下载并安装所需的Apache软件包。这是一项耗时的工作，因为你将主要进行重复的工作。但是使用模板方法，可以在较短的时间内完成。为什么？因为你将绕过操作系统安装和其他配置任务，直接从包含预配置操作系统镜像的模板中生成虚拟机，其中包含所有所需的Web服务器软件包，准备供使用。
- en: 'The following screenshot shows the steps involved in the manual installation
    method. You can clearly see that *Steps 2-5* are just repetitive tasks performed
    across all four VMs, and they would have taken up most of the time required to
    get your Apache web servers ready:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了手动安装方法涉及的步骤。您可以清楚地看到*步骤2-5*只是在所有四个VM上执行的重复任务，它们将占用大部分时间来准备您的Apache Web服务器：
- en: '![Figure 8.7 – Installing four Apache web servers without VM templates'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 - 不使用VM模板安装四个Apache Web服务器'
- en: '](img/B14834_08_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_07.jpg)'
- en: Figure 8.7 – Installing four Apache web servers without VM templates
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 - 不使用VM模板安装四个Apache Web服务器
- en: 'Now, see how the number of steps is drastically reduced by simply following
    *Steps 1-5* once, creating a template, and then using it to deploy four identical
    VMs. This will save you a lot of time. You can see the difference in the following
    diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看通过简单地遵循*步骤1-5*一次，创建一个模板，然后使用它部署四个相同的VM，步骤数量是如何大幅减少的。这将为您节省大量时间。您可以在以下图表中看到差异：
- en: '![Figure 8.8 – Installing four Apache web servers by using VM templates'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 使用VM模板安装四个Apache Web服务器'
- en: '](img/B14834_08_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_08.jpg)'
- en: Figure 8.8 – Installing four Apache web servers by using VM templates
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 使用VM模板安装四个Apache Web服务器
- en: 'This isn''t the whole story, though. There are different ways of actually going
    from *Step 3* to *Step 4* (from **Create a Template** to deployment of VM1-4),
    which either includes a full cloning process or a linked cloning process, detailed
    here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是全部。实际上从*步骤3*到*步骤4*（从**创建模板**到部署VM1-4）有不同的方式，其中包括完全克隆过程或链接克隆过程，详细介绍如下：
- en: '**Full clone**: A VM deployed using the full cloning mechanism creates a complete
    copy of the VM, the problem being that it''s going to use the same amount of capacity
    as the original VM.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全克隆**：使用完全克隆机制部署的VM将创建VM的完整副本，问题在于它将使用与原始VM相同的容量。'
- en: '**Linked clone**: A VM deployed using the thin cloning mechanism uses the template
    image as a base image in read-only mode and links an additional **copy-on-write****(COW)**
    image to store newly generated data. This provisioning method is *heavily* used
    in cloud and **Virtual Desktop Infrastructure** (**VDI**) environments as it saves
    a lot of disk space. Remember that fast storage capacity is something that''s
    really expensive, so any kind of optimization in this respect will be a big money
    saver. Linked clones will also have an impact on performance, as we will discuss
    a bit later.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接克隆**：使用薄克隆机制部署的VM将模板镜像作为只读模式的基础镜像，并链接一个额外的**写时复制**（COW）镜像来存储新生成的数据。这种配置方法在云和虚拟桌面基础设施（VDI）环境中被广泛使用，因为它可以节省大量磁盘空间。请记住，快速存储容量是非常昂贵的，因此在这方面的任何优化都将节省大量资金。链接克隆还会对性能产生影响，我们稍后会讨论一下。'
- en: Now, let's see how the templates work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看模板是如何工作的。
- en: Working with templates
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板
- en: In this section, you will learn how to create templates of Windows and Linux
    VMs using the `virt-clone` option available in `virt-manager`. Although the `virt-clone`
    utility was not originally intended for creating templates, when used with `virt-sysprep`
    and other operating system sealing utilities, it serves that purpose. Be aware
    that there is a difference between a clone and a master image. A clone image is
    just a VM, and a master image is a VM copy that can be used for deployment of
    hundreds and thousands of new VMs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用`virt-manager`中可用的`virt-clone`选项创建Windows和Linux VM的模板。虽然`virt-clone`实用程序最初并不是用于创建模板，但当与`virt-sysprep`和其他操作系统封装实用程序一起使用时，它可以实现这一目的。请注意，克隆和主镜像之间存在差异。克隆镜像只是一个VM，而主镜像是可以用于部署数百甚至数千个新VM的VM副本。
- en: Creating templates
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模板
- en: 'Templates are created by converting a VM into a template. This is actually
    a three-step procedure that includes the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是通过将VM转换为模板来创建的。实际上，这是一个包括以下步骤的三步过程：
- en: Installing and customizing the VM, with all the desired software, which will
    become the template or base image.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装和定制VM，包括所有所需的软件，这将成为模板或基础镜像。
- en: Removing all system-specific properties to ensure VM uniqueness—we need to take
    care of SSH host keys, network configuration, user accounts, **media access control**
    (**MAC**) address, license information, and so on.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有系统特定属性以确保VM的唯一性 - 我们需要处理SSH主机密钥、网络配置、用户帐户、媒体访问控制（MAC）地址、许可信息等。
- en: Mark the VM as a template by renaming it with a template as a prefix. Some virtualization
    technologies have special VM file types for this (for example, a VMware `.vmtx`
    file), which effectively means that you don't have to rename a VM to mark it as
    a template.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在名称前加上模板前缀将VM标记为模板。一些虚拟化技术对此有特殊的VM文件类型（例如VMware的`.vmtx`文件），这实际上意味着您不必重命名VM来标记它为模板。
- en: 'To understand the actual procedure, let''s create two templates and deploy
    a VM from them. Our two templates are going to be the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解实际的过程，让我们创建两个模板并从中部署一个VM。我们的两个模板将是以下内容：
- en: A CentOS 8 VM with a complete **Linux, Apache, MySQL, and PHP** (**LAMP**) stack
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有完整Linux、Apache、MySQL和PHP（LAMP）堆栈的CentOS 8 VM
- en: A Windows Server 2019 VM with SQL Server Express
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有SQL Server Express的Windows Server 2019 VM
- en: Let's go ahead and create these templates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建这些模板。
- en: Example 1 – Preparing a CentOS 8 template with a complete LAMP stack
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例1 - 准备一个带有完整LAMP堆栈的CentOS 8模板
- en: 'Installation of CentOS should be a familiar theme to us by now, so we''re just
    going to focus on the *AMP* part of the LAMP stack and the templating part. So,
    our procedure is going to look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CentOS的安装对我们来说应该是一个熟悉的主题，所以我们只会专注于LAMP堆栈的*AMP*部分和模板部分。因此，我们的过程将如下所示：
- en: Create a VM and install CentOS 8 on it, using the installation method that you
    prefer. Keep it minimal as this VM will be used as the base for the template that
    is being created for this example.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个VM并在其上安装CentOS 8，使用您喜欢的安装方法。保持最小化，因为这个VM将被用作为为此示例创建的模板的基础。
- en: 'SSH into or take control of the VM and install the LAMP stack. Here''s a script
    for you to install everything needed for a LAMP stack on CentOS 8, after the operating
    system installation has been done. Let''s start with the package installation,
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH进入或接管虚拟机并安装LAMP堆栈。以下是一个脚本，用于在操作系统安装完成后在CentOS 8上安装LAMP堆栈所需的一切。让我们从软件包安装开始，如下所示：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we''re done with the software installation, let''s do a bit of service
    configuration—start all the necessary services and enable them, and reconfigure
    the firewall to allow connections, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件安装完成后，让我们进行一些服务配置——启动所有必要的服务并启用它们，并重新配置防火墙以允许连接，如下所示：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also need to configure some security settings related to directory ownership—for
    example, **Security-Enhanced Linux** (**SELinux**) configuration for the Apache
    web server. Let''s do that next, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置一些与目录所有权相关的安全设置，例如Apache Web服务器的**安全增强型Linux**（**SELinux**）配置。让我们像这样进行下一步操作：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After this has been done, we need to configure MariaDB, as we have to set some
    kind of MariaDB root password for the database administrative user and configure
    basic settings. This is usually done via a `mysql_secure_installation` script
    provided by MariaDB packages. So, that is our next step, as illustrated in the
    following code snippet:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们需要配置MariaDB，因为我们必须为数据库管理用户设置某种MariaDB根密码并配置基本设置。这通常是通过MariaDB软件包提供的`mysql_secure_installation`脚本完成的。因此，这是我们的下一步，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the required LAMP settings are configured the way we want them, shut
    down the VM and run the `virt-sysprep` command to seal it. If you want to *expire*
    the root password (translation—force a change of the root password on the next
    login), type in the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，必需的LAMP设置已按我们的要求配置好，关闭虚拟机并运行`virt-sysprep`命令进行封存。如果要*过期*根密码（即在下次登录时强制更改根密码），请输入以下命令：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our test VM is called LAMP and the host is called `PacktTemplate`, so here
    are the necessary steps, presented via a one-line command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试虚拟机名为LAMP，主机名为`PacktTemplate`，因此以下是必要的步骤，通过一行命令呈现：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our LAMP VM is now ready to be reconfigured as template. For that, we will use
    the `virt-sysprep` command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LAMP虚拟机现在已准备好重新配置为模板。为此，我们将使用`virt-sysprep`命令。
- en: What is virt-sysprep?
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是virt-sysprep？
- en: This is a command-line utility provided by the `libguestfs-tools-c` package
    to ease the sealing and generalizing procedure of Linux VM. It prepares a Linux
    VM to become a template or clone by removing system-specific information automatically
    so that clones can be made from it. `virt-sysprep` can be used to add some additional
    configuration bits and pieces—such as users, groups, SSH keys, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`libguestfs-tools-c`软件包提供的命令行实用程序，用于简化Linux虚拟机的封存和通用化过程。它会自动删除系统特定信息，使克隆可以从中创建。`virt-sysprep`可用于添加一些额外的配置位和部分，例如用户、组、SSH密钥等。
- en: 'There are two ways to invoke `virt-sysprep` against a Linux VM: using the `-d`
    or `-a` option. The first option points to the intended guest using its name or
    `virt-sysprep` command even if the guest is not defined in `libvirt`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以针对Linux虚拟机调用`virt-sysprep`：使用`-d`或`-a`选项。第一个选项指向预期的客户端，使用其名称或`virt-sysprep`命令，即使客户端未在`libvirt`中定义。
- en: 'Once the `virt-sysprep` command is executed, it performs a bunch of `sysprep`
    operations that make the VM image clean by removing system-specific information
    from it. Add the `--verbose` option to the command if you are interested in knowing
    how this command works in the background. The process can be seen in the following
    screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`virt-sysprep`命令后，它会执行一系列的`sysprep`操作，通过从中删除系统特定信息使虚拟机镜像变得干净。如果您想了解此命令在后台的工作原理，请在命令中添加`--verbose`选项。该过程可以在以下截图中看到：
- en: '![Figure 8.11 – virt-sysprep works its magic on the VM'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – virt-sysprep在虚拟机上发挥魔力'
- en: '](img/B14834_08_11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_11.jpg)'
- en: Figure 8.11 – virt-sysprep works its magic on the VM
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – virt-sysprep在虚拟机上发挥魔力
- en: 'By default, `virt-sysprep` performs more than 30 operations. You can also choose
    which specific sysprep operations you want to use. To get a list of all the available
    operations, run the `virt-sysprep --list-operation` command. The default operations
    are marked with an asterisk. You can change the default operations using the `--operations`
    switch, followed by a comma-separated list of operations that you want to use.
    See the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`virt-sysprep`执行超过30个操作。您还可以选择要使用的特定sysprep操作。要获取所有可用操作的列表，请运行`virt-sysprep
    --list-operation`命令。默认操作用星号标记。您可以使用`--operations`开关更改默认操作，后跟逗号分隔的要使用的操作列表。请参阅以下示例：
- en: '![Figure 8.12 – Using virt-sysprep to customize operations to be done on a
    template VM'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – 使用virt-sysprep自定义在模板虚拟机上执行的操作'
- en: '](img/B14834_08_12.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_12.jpg)'
- en: Figure 8.12 – Using virt-sysprep to customize operations to be done on a template
    VM
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 使用virt-sysprep自定义在模板虚拟机上执行的操作
- en: Notice that this time, it only performed the `ssh-hostkeys` and `udev-persistentnet`
    operations instead of the typical operations. It's up to you how much cleaning
    you would like to undertake in the template.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次它只执行了`ssh-hostkeys`和`udev-persistentnet`操作，而不是典型的操作。您可以自行决定在模板中进行多少清理工作。
- en: Now, we can mark this VM as a template by adding the word *template* as a prefix
    in its name. You can even undefine the VM from `libvirt` after taking a backup
    of its **Extensible Markup Language** (**XML**) file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在名称前添加*template*来将此虚拟机标记为模板。甚至可以在从`libvirt`中取消定义虚拟机之前备份其**可扩展标记语言**（**XML**）文件。
- en: Important note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure that from now on, this VM is never started; otherwise, it will lose
    all sysprep operations and can even cause problems with VMs deployed using the
    thin method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确保从现在开始，此虚拟机永远不要启动；否则，它将丢失所有sysprep操作，甚至可能导致使用薄方法部署的虚拟机出现问题。
- en: 'In order to rename a VM, use `virsh domrename` as root, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名虚拟机，请使用`virsh domrename`作为root用户，如下所示：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`LAMP-Template`, our template, is now ready to be used for future cloning processes.
    You can check its settings by using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`LAMP-Template`，我们的模板，现在已准备好用于未来的克隆过程。您可以使用以下命令检查其设置：'
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The end result should be something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该是这样的：
- en: '![Figure 8.13 – virsh dominfo on our template VM'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 - 在我们的模板VM上使用virsh dominfo'
- en: '](img/B14834_08_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_13.jpg)'
- en: Figure 8.13 – virsh dominfo on our template VM
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 - 在我们的模板VM上使用virsh dominfo
- en: The next example is going to be about preparing a Windows Server 2019 template
    with a pre-installed Microsoft **Structured Query Language** (**SQL**) database—a
    common use case that many of us will need to use in our environments. Let's see
    how we can do that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将是关于准备一个预安装了Microsoft **结构化查询语言**（**SQL**）数据库的Windows Server 2019模板 - 这是我们许多人在环境中需要使用的常见用例。让我们看看我们如何做到这一点。
- en: Example 2 – Preparing a Windows Server 2019 template with a Microsoft SQL database
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例2 - 准备带有Microsoft SQL数据库的Windows Server 2019模板
- en: '`virt-sysprep` does not work for Windows guests, and there is little chance
    support will be added any time soon. So, in order to generalize a Windows machine,
    we would have to access the Windows system and directly run `sysprep`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`virt-sysprep` 不适用于Windows客户端，而且很少有可能在短时间内添加支持。因此，为了通用化Windows机器，我们需要访问Windows系统并直接运行`sysprep`。'
- en: 'The `sysprep`) tool is a native Windows utility for removing system-specific
    data from Windows images. To know more about this utility, refer to this article:
    [https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/sysprep--generalize--a-windows-installation](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/sysprep--generalize--a-windows-installation).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysprep`工具是一个用于从Windows映像中删除特定系统数据的本机Windows实用程序。要了解有关此实用程序的更多信息，请参阅本文：[https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/sysprep--generalize--a-windows-installation](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/sysprep--generalize--a-windows-installation)。'
- en: 'Our template preparation process is going to work like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板准备过程将如下进行：
- en: Create a VM and install the Windows Server 2019 operating system on it. Our
    VM is going to be called `WS2019SQL`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个VM并在其上安装Windows Server 2019操作系统。我们的VM将被称为`WS2019SQL`。
- en: Install the Microsoft SQL Express software and, once it's configured the way
    you want, restart the VM and launch the `sysprep` application. The `.exe` file
    of `sysprep` is present in the `C:\Windows\System32\sysprep` directory. Navigate
    there by entering `sysprep` in the run box and double-click on `sysprep.exe`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Microsoft SQL Express软件，并在配置好后，重新启动VM并启动`sysprep`应用程序。`sysprep`的`.exe`文件位于`C:\Windows\System32\sysprep`目录中。通过在运行框中输入`sysprep`并双击`sysprep.exe`来导航到那里。
- en: Under **System Cleanup Action**, select **Enter System Out-of-Box Experience
    (OOBE)** and click on the **Generalize** checkbox if you want to do **system identification
    number** (**SID**) regeneration, as illustrated in the following screenshot:![Figure
    8.14 – Be careful with sysprep options; OOBE, generalize,
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**系统清理操作**下，选择**进入系统的OOBE**并勾选**通用化**复选框，如果您想进行**系统标识号**（**SID**）重建，如下截图所示：![图8.14
    - 小心使用sysprep选项；OOBE，通用化，
- en: and shutdown options are highly recommended
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 并且强烈建议使用关闭选项
- en: '](img/B14834_08_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_14.jpg)'
- en: Figure 8.14 – Be careful with sysprep options; OOBE, generalize, and shutdown
    options are highly recommended
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 小心使用sysprep选项；OOBE，通用化和关闭选项是强烈建议的
- en: Under `sysprep` process will start after that, and when it's done, it will be
    shut down.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，`sysprep`过程将开始，并在完成后关闭。
- en: 'Rename the VM using the same procedure we used on the LAMP template, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与我们在LAMP模板上使用的相同过程来重命名VM，如下所示：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, we can use the `dominfo` option to check basic information about our
    newly created template, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`dominfo`选项来检查我们新创建的模板的基本信息，如下所示：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be careful when updating templates in the future—you need to run them, update
    them, and reseal them. With Linux distributions, you won't have many issues doing
    that. But serializing Microsoft Windows `sysprep` (start template VM, update,
    `sysprep`, and repeating that in the future) will get you to a situation in which
    `sysprep` will throw you an error. So, there's another school of thought that
    you can use here. You can do the whole procedure as we did it in this part of
    our chapter, but don't `sysprep` it. That way, you can easily update the VM, then
    clone it, and then `sysprep` it. It will save you a lot of time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在将来更新模板时要小心 - 您需要运行它们，更新它们，并重新密封它们。对于Linux发行版，这样做不会有太多问题。但是，对于Microsoft Windows
    `sysprep`（启动模板VM，更新，`sysprep`，并在将来重复）将使您陷入`sysprep`会抛出错误的情况。因此，这里还有另一种思路可以使用。您可以像我们在本章的这一部分中所做的那样执行整个过程，但不要`sysprep`它。这样，您可以轻松更新VM，然后克隆它，然后`sysprep`它。这将节省您大量时间。
- en: Next, we will see how to deploy VMs from a template.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何从模板部署VM。
- en: Deploying VMs from a template
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板部署VM
- en: In the previous section, we created two template images; the first template
    image is still defined in `libvirt` as `VM` and named `LAMP-Template`, and the
    second is called `WS2019SQL-Template`. We will now use these two VM templates
    to deploy new VMs from them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们创建了两个模板映像；第一个模板映像仍然在`libvirt`中定义为`VM`，并命名为`LAMP-Template`，第二个称为`WS2019SQL-Template`。我们现在将使用这两个VM模板来从中部署新的VM。
- en: Deploying VMs using full cloning
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用完全克隆部署VM
- en: 'Perform the following steps to deploy the VM using clone provisioning:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤使用克隆配置来部署VM：
- en: Open the VM Manager (`virt-manager`), and then select the `LAMP-Template` VM.
    Right-click on it and select the **Clone** option, which will open the **Clone
    Virtual Machine** window, as illustrated in the following screenshot:![Figure
    8.15 – Cloning a VM from VM Manager
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VM管理器（`virt-manager`），然后选择`LAMP-Template` VM。右键单击它，然后选择**克隆**选项，这将打开**克隆虚拟机**窗口，如下截图所示：![图8.15
    - 从VM管理器克隆VM
- en: '](img/B14834_08_15.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_15.jpg)'
- en: Figure 8.15 – Cloning a VM from VM Manager
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - 从VM管理器克隆VM
- en: Provide a name for the resulting VM and skip all other options. Click on the
    **Clone** button to start the deployment. Wait till the cloning operation finishes.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生成的VM提供名称并跳过所有其他选项。单击**克隆**按钮开始部署。等待克隆操作完成。
- en: 'Once it''s finished, your newly deployed VM is ready to use and you can start
    using it. You can see the output from the process in the following screenshot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您新部署的VM已经准备好使用，您可以开始使用它。您可以在以下截图中看到该过程的输出：
- en: '![Figure 8.16 – Full clone (LAMP01) has been created'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16-已创建完整克隆（LAMP01）'
- en: '](img/B14834_08_16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_16.jpg)'
- en: Figure 8.16 – Full clone (LAMP01) has been created
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16-已创建完整克隆（LAMP01）
- en: As a result of our previous operation, the `LAMP01` VM was deployed from `LAMP-Template`,
    but as we used the full cloning method, they are independent, and even if you
    remove `LAMP-Template`, they will operate just fine.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前的操作，`LAMP01` VM是从`LAMP-Template`部署的，但由于我们使用了完整克隆方法，它们是独立的，即使您删除`LAMP-Template`，它们也会正常运行。
- en: We can also use linked cloning, which will save us a whole lot of disk space
    by creating a VM that's anchored to a base image. Let's do that next.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用链接克隆，这将通过创建一个锚定到基本映像的VM来节省大量的磁盘空间。让我们接下来做这个。
- en: Deploying VMs using linked cloning
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用链接克隆部署VM
- en: 'Perform the following steps to get started with VM deployment using the linked
    cloning method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，使用链接克隆方法开始VM部署：
- en: 'Create two new `qcow2` images using `/var/lib/libvirt/images/WS2019SQL.qcow2`
    as the backing file, like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/var/lib/libvirt/images/WS2019SQL.qcow2`作为后备文件创建两个新的`qcow2`图像，如下所示：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Verify that the backing file attribute for the newly created `qcow2` images
    is pointing correctly to the `/var/lib/libvirt/images/WS2019SQL.qcow2` image,
    using the `qemu-img` command. The end result of these three procedures should
    look like this:![Figure 8.17 – Creating a linked clone image
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证新创建的`qcow2`图像的后备文件属性是否正确指向`/var/lib/libvirt/images/WS2019SQL.qcow2`图像，使用`qemu-img`命令。这三个步骤的最终结果应该如下所示：![图8.17-创建链接克隆图像
- en: '](img/B14834_08_17.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_17.jpg)'
- en: Figure 8.17 – Creating a linked clone image
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17-创建链接克隆图像
- en: 'Let''s now dump the template VM configuration to two XML files by using the
    `virsh` command. We''re doing this twice so that we have two VM definitions. We
    will import them as two new VMs after we change a couple of parameters, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`virsh`命令将模板VM配置转储到两个XML文件中。我们这样做两次，以便我们有两个VM定义。在更改了一些参数后，我们将它们导入为两个新的VM，如下所示：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By using the `uuidgen -r` command, generate two random UUIDs. We will need them
    for our VMs. The process can be seen in the following screenshot:![Figure 8.18
    – Generating two new UUIDs for our VMs
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`uuidgen -r`命令生成两个随机UUID。我们将需要它们用于我们的VM。该过程可以在以下截图中看到：![图8.18-为我们的VM生成两个新的UUID
- en: '](img/B14834_08_18.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_18.jpg)'
- en: Figure 8.18 – Generating two new UUIDs for our VMs
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18-为我们的VM生成两个新的UUID
- en: Edit the `SQL1.xml` and `SQL2.xml` files by assigning them new VM names and
    UUIDs. This step is mandatory as VMs have to have unique names and UUIDs. Let's
    change the name in the first XML file to `SQL1`, and the name in the second XML
    file to `SQL2`. We can achieve that by changing the `<name></name>` statement.
    Then, copy and paste the UUIDs that we created with the `uuidgen` command in the
    `SQL1.xml` and `SQL2.xml` `<uuid></uuid>` statement. So, relevant entries for
    those two lines in our configuration files should look like this:![Figure 8.19
    – Changing the VM name and UUID in their respective XML configuration files
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为它们分配新的VM名称和UUID编辑`SQL1.xml`和`SQL2.xml`文件。这一步是强制性的，因为VM必须具有唯一的名称和UUID。让我们将第一个XML文件中的名称更改为`SQL1`，将第二个XML文件中的名称更改为`SQL2`。我们可以通过更改`<name></name>`语句来实现这一点。然后，在`SQL1.xml`和`SQL2.xml`的`<uuid></uuid>`语句中复制并粘贴我们使用`uuidgen`命令创建的UUID。因此，配置文件中这两行的相关条目应该如下所示：![图8.19-更改其各自XML配置文件中的VM名称和UUID
- en: '](img/B14834_08_19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_19.jpg)'
- en: Figure 8.19 – Changing the VM name and UUID in their respective XML configuration
    files
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19-更改其各自XML配置文件中的VM名称和UUID
- en: We need to change the virtual disk location in our `SQL1` and `SQL2` image files.
    Find entries for `.qcow2` files later in these configuration files and change
    them so that they use the absolute path of files that we created in *Step 1*,
    as follows:![Figure 8.20 – Changing the VM image location so that it points to
    newly created linked clone images
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更改`SQL1`和`SQL2`镜像文件中虚拟磁盘的位置。在这些配置文件后面找到`.qcow2`文件的条目，并更改它们，使其使用我们在*步骤1*中创建的文件的绝对路径，如下所示：![图8.20-更改VM镜像位置，使其指向新创建的链接克隆图像
- en: '](img/B14834_08_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_20.jpg)'
- en: Figure 8.20 – Changing the VM image location so that it points to newly created
    linked clone images
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20-更改VM镜像位置，使其指向新创建的链接克隆图像
- en: Now, import these two XML files as VM definitions by using the `virsh` create
    command, as follows:![Figure 8.21 – Creating two new VMs from XML definition files
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`virsh create`命令将这两个XML文件作为VM定义导入，如下所示：![图8.21-从XML定义文件创建两个新的VM
- en: '](img/B14834_08_21.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_21.jpg)'
- en: Figure 8.21 – Creating two new VMs from XML definition files
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21-从XML定义文件创建两个新的VM
- en: Use the `virsh` command to verify if they are defined and running, as follows:![Figure
    8.22 – Two new VMs up and running
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`virsh`命令验证它们是否已定义和运行，如下所示：![图8.22-两个新的VM已经启动
- en: '](img/B14834_08_22.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_22.jpg)'
- en: Figure 8.22 – Two new VMs up and running
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22-两个新的VM已经启动
- en: 'The VMs are already started, so we can now check the end result of our linked
    cloning process. Our two virtual disks for these two VMs should be rather small,
    as they''re both using the same base image. Let''s check the guest disk image
    size—notice in the following screenshot that both `LinkedVM1.qcow` and `LinkedVM2.qcow`
    files are roughly 50 times smaller than their base image:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VM已经启动，所以我们现在可以检查我们链接克隆过程的最终结果。这两个VM的虚拟磁盘应该相当小，因为它们都使用相同的基本镜像。让我们检查客户磁盘映像大小-请注意在以下截图中，`LinkedVM1.qcow`和`LinkedVM2.qcow`文件的大小大约是其基本映像的50倍小：
- en: '![Figure 8.23 – Result of linked clone deployment: base image, small delta
    images'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – 链接克隆部署的结果：基础镜像，小增量镜像'
- en: '](img/B14834_08_23.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_23.jpg)'
- en: 'Figure 8.23 – Result of linked clone deployment: base image, small delta images'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 链接克隆部署的结果：基础镜像，小增量镜像
- en: This should provide plenty of examples and info about using the linked cloning
    process. Don't take it too far (many linked clones on a single base image) and
    you should be fine. But now, it's time to move to our next topic, which is about
    `virt-builder`. The `virt-builder` concept is very important if you want to deploy
    your VMs quickly – that is, without actually installing them. We can use `virt-builder`
    repos for that. Let's learn how to do that next.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该提供了大量关于使用链接克隆过程的示例和信息。不要走得太远（在单个基础镜像上创建许多链接克隆），你应该没问题。但现在，是时候转到我们的下一个主题了，那就是关于`virt-builder`。如果你想快速部署VM而不实际安装它们，`virt-builder`的概念非常重要。我们可以使用`virt-builder`存储库来实现这一点。让我们学习如何做到这一点。
- en: virt-builder and virt-builder repos
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: virt-builder和virt-builder存储库
- en: 'One of the most essential tools in the `libguestfs` package is `virt-builder`.
    Let''s say that you *really* don''t want to build a VM from scratch, either because
    you don''t have the time or you just cannot be bothered. We will use CentOS 8
    for this example, although the list of supported distributions is now roughly
    50 (distributions and their sub-versions), as you can see in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`libguestfs`软件包中最重要的工具之一是`virt-builder`。假设你*真的*不想从头构建一个VM，要么是因为你没有时间，要么是因为你根本不想麻烦。我们将以CentOS
    8为例，尽管现在支持的发行版列表大约有50个（发行版及其子版本），如你在以下截图中所见：
- en: '![Figure 8.24 – virt-builder supported OSes, and CentOS distributions'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 – virt-builder支持的操作系统和CentOS发行版'
- en: '](img/B14834_08_24.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_24.jpg)'
- en: Figure 8.24 – virt-builder supported OSes, and CentOS distributions
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – virt-builder支持的操作系统和CentOS发行版
- en: In our test scenario, we need to create a CentOS 8 image as soon as possible,
    and create a VM out of that image. All of the ways of deploying VMs so far have
    been based on the idea of installing them from scratch, or cloning, or templating.
    These are either *start-from-zero* or *deploy-first-template-or-template-second-provision-later*
    types of mechanisms. What if there's another way?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试场景中，我们需要尽快创建一个CentOS 8镜像，并从该镜像创建一个VM。到目前为止，部署VM的所有方式都是基于从头安装、克隆或模板化的想法。这些要么是*从零开始*，要么是*先部署模板，然后再进行配置*的机制。如果还有其他方法呢？
- en: '`virt-builder` provides us with a way of doing just that. By issuing a couple
    of simple commands, we can import a CentOS 8 image, import it to KVM, and start
    it. Let''s proceed, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`virt-builder`为我们提供了一种方法。通过发出几个简单的命令，我们可以导入一个CentOS 8镜像，将其导入到KVM，并启动它。让我们继续，如下所示：'
- en: First, let's use `virt-builder` to download a CentOS 8 image with specified
    parameters, as follows:![Figure 8.25 – Using virt-builder to grab a CentOS 8.0
    image and check its size
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`virt-builder`下载一个具有指定参数的CentOS 8镜像，如下所示：![图8.25 – 使用virt-builder获取CentOS
    8.0镜像并检查其大小
- en: '](img/B14834_08_25.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_25.jpg)'
- en: Figure 8.25 – Using virt-builder to grab a CentOS 8.0 image and check its size
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 使用virt-builder获取CentOS 8.0镜像并检查其大小
- en: A logical next step is to do `virt-install`—so, here we go:![Figure 8.26 – New
    VM configured, deployed, and added to our local KVM hypervisor
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个合乎逻辑的下一步是进行`virt-install`，所以，我们开始吧：![图8.26 – 配置、部署和添加到本地KVM虚拟化管理程序的新VM
- en: '](img/B14834_08_26.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_26.jpg)'
- en: Figure 8.26 – New VM configured, deployed, and added to our local KVM hypervisor
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 – 配置、部署和添加到本地KVM虚拟化管理程序的新VM
- en: 'If this seems cool to you, let''s expand on that. Let''s say that we want to
    take a `virt-builder` image, add a `yum` package group called `Virtualization
    Host` to that image, and, while we''re at it, add the root''s SSH key. This is
    what we''d do:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你觉得这很酷，让我们继续扩展。假设我们想要获取一个`virt-builder`镜像，向该镜像添加一个名为`Virtualization Host`的`yum`软件包组，并且在此过程中添加root的SSH密钥。我们会这样做：
- en: '![Figure 8.27 – Adding Virtualization Host'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27 – 添加虚拟化主机'
- en: '](img/B14834_08_27.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_27.jpg)'
- en: Figure 8.27 – Adding Virtualization Host
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 – 添加虚拟化主机
- en: In all reality, this is really, really cool—it makes our life much easier, does
    quite a bit of work for us, and does it in a pretty simple way, and it works with
    Microsoft Windows operating systems as well. Also, we can use custom `virt-builder`
    repositories to download specific VMs that are tailored to our own needs, as we're
    going to learn next.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这真的非常酷，它让我们的生活变得更加轻松，为我们做了很多工作，而且以一种非常简单的方式完成了，它也适用于微软Windows操作系统。此外，我们可以使用自定义的`virt-builder`存储库下载特定的虚拟机，以满足我们自己的需求，接下来我们将学习如何做到这一点。
- en: virt-builder repositories
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: virt-builder存储库
- en: 'Obviously, there are some pre-defined `virt-builder` repositories ([http://libguestfs.org/](http://libguestfs.org/)
    is one of them), but we can also create our own. If we go to the `/etc/virt-builder/repos.d`
    directory, we''ll see a couple of files there (`libguestfs.conf` and its key,
    and so on). We can easily create our own additional configuration file that will
    reflect our local or remote `virt-builder` repository. Let''s say that we want
    to create a local `virt-builder` repository. Let''s create a config file called
    `local.conf` in the `/etc/virt-builder/repos.d` directory, with the following
    content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有一些预定义的`virt-builder`存储库（[http://libguestfs.org/](http://libguestfs.org/)是其中之一），但我们也可以创建自己的存储库。如果我们转到`/etc/virt-builder/repos.d`目录，我们会看到那里有几个文件（`libguestfs.conf`及其密钥等）。我们可以轻松地创建自己的额外配置文件，以反映我们的本地或远程`virt-builder`存储库。假设我们想创建一个本地`virt-builder`存储库。让我们在`/etc/virt-builder/repos.d`目录中创建一个名为`local.conf`的配置文件，内容如下：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, copy or move an image to the `/root/virt-builder` directory (we will
    use our `centos-8.0.img` file created in the previous step, which we will convert
    to `xz` format by using the `xz` command), and create a file called `index` in
    that directory, with the following content:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将镜像复制或移动到`/root/virt-builder`目录（我们将使用在上一步中创建的`centos-8.0.img`文件，通过使用`xz`命令将其转换为`xz`格式），并在该目录中创建一个名为`index`的文件，内容如下：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A couple of explanations. `checksum` was calculated by using the `sha512sum`
    command on the `centos-8.0.img.xz`. `size` and `compressed_size` are real sizes
    of the original and XZd file. After this, if we issue the `virt-builder --list
    |more` command, we should get something like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解释。`checksum`是使用`centos-8.0.img.xz`上的`sha512sum`命令计算的。`size`和`compressed_size`是原始和XZd文件的实际大小。之后，如果我们发出`virt-builder
    --list |more`命令，我们应该会得到如下所示的内容：
- en: '![Figure 8.28 – We successfully added an image to our local virt-builder repository'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28-我们成功将图像添加到本地virt-builder存储库'
- en: '](img/B14834_08_28.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_28.jpg)'
- en: Figure 8.28 – We successfully added an image to our local virt-builder repository
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28-我们成功将图像添加到本地virt-builder存储库
- en: You can clearly see that our `Packt01` image is at the top of our list, and
    we can easily use it to deploy new VMs. By using additional repositories, we can
    greatly enhance our workflow and reuse our existing VMs and templates to deploy
    as many VMs as we want to. Imagine what this, combined with `virt-builder`'s customization
    options, does for cloud services on OpenStack, **Amazon Web Services** (**AWS**),
    and so on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到我们的`Packt01`映像位于列表的顶部，我们可以轻松使用它来部署新的VM。通过使用额外的存储库，我们可以极大地增强我们的工作流程，并重复使用我们现有的VM和模板来部署任意数量的VM。想象一下，这与`virt-builder`的自定义选项结合使用，对于OpenStack、**Amazon
    Web Services**（**AWS**）等云服务有何作用。
- en: The next topic on our list is related to snapshots, a hugely valuable and misused
    VM concept. Sometimes, you have concepts in IT that can be equally good and bad,
    and snapshots are the usual suspect in that regard. Let's explain what snapshots
    are all about.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表上的下一个主题与快照有关，这是一个非常有价值但被误用的VM概念。有时，您在IT中有一些概念，既可以是好的，也可以是坏的，快照通常是其中的嫌疑犯。让我们解释一下快照的全部内容。
- en: Snapshots
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照
- en: A VM snapshot is a file-based representation of the system state at a particular
    point in time. The snapshot includes configuration and disk data. With a snapshot,
    you can revert a VM to a point in time, which means by taking a snapshot of a
    VM, you preserve its state and can easily revert to it in the future if needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: VM快照是系统在特定时间点的基于文件的表示。快照包括配置和磁盘数据。通过快照，您可以将VM恢复到某个时间点，这意味着通过对VM进行快照，您可以保留其状态，并在将来需要时轻松恢复到该状态。
- en: Snapshots have many use cases, such as saving a VM's state before a potentially
    destructive operation. For example, suppose you want to make some changes on your
    existing web server VM, which is running fine at the moment, but you are not certain
    if the changes you are planning to make are going to work or will break something.
    In that case, you can take a snapshot of the VM before doing the intended configuration
    changes, and if something goes wrong, you can easily revert to the previous working
    state of the VM by restoring the snapshot.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 快照有许多用途，例如在进行可能具有破坏性操作之前保存VM的状态。例如，假设您想要对现有的Web服务器VM进行一些更改，目前它正在正常运行，但您不确定您计划进行的更改是否会起作用或会破坏某些内容。在这种情况下，您可以在执行预期的配置更改之前对VM进行快照，如果出现问题，您可以通过恢复快照轻松恢复到VM的先前工作状态。
- en: '`libvirt` supports taking live snapshots. You can take a snapshot of a VM while
    the guest is running. However, if there are any **input/output** (**I/O**)-intensive
    applications running on the VM, it is recommended to shut down or suspend the
    guest first to guarantee a clean snapshot.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`libvirt`支持拍摄实时快照。您可以在客户机运行时对VM进行快照。但是，如果VM上有任何**输入/输出**（**I/O**）密集型应用程序正在运行，建议首先关闭或暂停客户机，以确保干净的快照。'
- en: 'There are mainly two classes of snapshots for `libvirt` guests: internal and
    external; each has its own benefits and limitations, as detailed here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`libvirt`客户端主要有两类快照：内部和外部；每种都有其自己的优点和局限，如下所述：'
- en: '`qcow2` files. Before-snapshot and after-snapshot bits are stored in a single
    disk, allowing greater flexibility. `virt-manager` provides a graphical management
    utility to manage internal snapshots. The following are the limitations of an
    internal snapshot:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qcow2`文件。快照前后的位存储在单个磁盘中，从而提供更大的灵活性。`virt-manager`提供了一个图形管理实用程序来管理内部快照。以下是内部快照的限制：'
- en: a) Supported only with the `qcow2` format
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a) 仅支持`qcow2`格式
- en: b) VM is paused while taking the snapshot
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在拍摄快照时VM被暂停
- en: c) Doesn't work with LVM storage pools
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: c) 无法与LVM存储池一起使用
- en: '**External snapshot**: External snapshots are based on a COW concept. When
    a snapshot is taken, the original disk image becomes read-only, and a new overlay
    disk image is created to accommodate guest writes, as illustrated in the following
    diagram:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部快照**：外部快照基于COW概念。当快照被拍摄时，原始磁盘映像变为只读，并创建一个新的覆盖磁盘映像以容纳客户写入，如下图所示：'
- en: '![Figure 8.29 – Snapshot concept'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29-快照概念'
- en: '](img/B14834_08_29.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_29.jpg)'
- en: Figure 8.29 – Snapshot concept
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29-快照概念
- en: The overlay disk image is initially created as `0` bytes in length, and it can
    grow to the size of the original disk. The overlay disk image is always `qcow2`.
    However, external snapshots work with any base disk image. You can take external
    snapshots of raw disk images, `qcow2`, or any other `libvirt`-supported disk image
    format. However, there is no **graphical user interface** (**GUI**) support available
    yet for external snapshots, so they are more expensive to manage when compared
    to internal snapshots.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖磁盘映像最初创建为`0`字节的长度，它可以增长到原始磁盘的大小。覆盖磁盘映像始终为`qcow2`。但是，外部快照可以与任何基本磁盘映像一起使用。您可以对原始磁盘映像、`qcow2`或任何其他`libvirt`支持的磁盘映像格式进行外部快照。但是，目前尚无**图形用户界面**（**GUI**）支持外部快照，因此与内部快照相比，管理起来更昂贵。
- en: Working with internal snapshots
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内部快照
- en: In this section, you'll learn how to create, delete, and restore internal snapshots
    (offline/online) for a VM. You'll also learn how to use `virt-manager` to manage
    internal snapshots.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何为VM创建、删除和恢复内部快照（离线/在线）。您还将学习如何使用`virt-manager`来管理内部快照。
- en: Internal snapshots work only with `qcow2` disk images, so first make sure that
    the VM for which you want to take a snapshot uses the `qcow2` format for the base
    disk image. If not, convert it to `qcow2` format using the `qemu-img` command.
    An internal snapshot is a combination of disk snapshots and the VM memory state—it's
    a kind of checkpoint to which you can revert easily when needed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内部快照仅适用于`qcow2`磁盘映像，因此首先确保要为其创建快照的虚拟机使用`qcow2`格式作为基础磁盘映像。如果不是，请使用`qemu-img`命令将其转换为`qcow2`格式。内部快照是磁盘快照和虚拟机内存状态的组合——这是一种可以在需要时轻松恢复的检查点。
- en: 'I am using a `LAMP01` VM here as an example to demonstrate internal snapshots.
    The `LAMP01` VM is residing on a local filesystem-backed storage pool and has
    a `qcow2` image acting as a virtual disk. The following command lists the snapshot
    associated with the VM:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用`LAMP01`虚拟机作为示例来演示内部快照。`LAMP01`虚拟机位于本地文件系统支持的存储池上，并具有`qcow2`映像作为虚拟磁盘。以下命令列出了与虚拟机关联的快照：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As can be seen, currently, there are no existing snapshots associated with the
    VM; the `LAMP01` `virsh snapshot-list` command lists all of the available snapshots
    for the given VM. The default information includes the snapshot name, creation
    time, and domain state. There is a lot of other snapshot-related information that
    can be listed by passing additional options to the `snapshot-list` command.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，目前与虚拟机关联的快照不存在；`LAMP01` `virsh snapshot-list`命令列出了给定虚拟机的所有可用快照。默认信息包括快照名称、创建时间和域状态。通过向`snapshot-list`命令传递附加选项，可以列出许多其他与快照相关的信息。
- en: Creating the first internal snapshot
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建第一个内部快照
- en: 'The easiest and preferred way to create internal snapshots for a VM on a KVM
    host is through the `virsh` command. `virsh` has a series of options to create
    and manage snapshots, listed as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在KVM主机上为虚拟机创建内部快照的最简单和首选方法是通过`virsh`命令。`virsh`具有一系列选项来创建和管理快照，如下所示：
- en: '`snapshot-create`: Use XML file to create a snapshot'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-create`: 使用XML文件创建快照'
- en: '`snapshot-create-as`: Use list of arguments to create a snapshot'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-create-as`: 使用参数列表创建快照'
- en: '`snapshot-current`: Get or set the current snapshot'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-current`: 获取或设置当前快照'
- en: '`snapshot-delete`: Delete a VM snapshot'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-delete`: 删除虚拟机快照'
- en: '`snapshot-dumpxml`: Dump snapshot configuration in XML format'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-dumpxml`: 以XML格式转储快照配置'
- en: '`snapshot-edit`: Edit XML for a snapshot'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-edit`: 编辑快照的XML'
- en: '`snapshot-info`: Get snapshot information'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-info`: 获取快照信息'
- en: '`snapshot-list`: List VM snapshots'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-list`: 列出虚拟机快照'
- en: '`snapshot-parent`: Get the snapshot parent name'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-parent`: 获取快照的父名称'
- en: '`snapshot-revert`: Revert a VM to a specific snapshot'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-revert`: 将虚拟机恢复到特定快照'
- en: 'The following is a simple example of creating a snapshot. Running the following
    command will create an internal snapshot for the `LAMP01` VM:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建快照的简单示例。运行以下命令将为`LAMP01`虚拟机创建一个内部快照：
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By default, a newly created snapshot gets a unique number as its name. To create
    a snapshot with a custom name and description, use the `snapshot-create-as` command.
    The difference between these two commands is that the latter one allows configuration
    parameters to be passed as an argument, whereas the former one does not. It only
    accepts XML files as the input. We are using `snapshot-create-as` in this chapter
    as it's more convenient and easy to use.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新创建的快照会以唯一编号作为名称。要创建具有自定义名称和描述的快照，请使用`snapshot-create-as`命令。这两个命令之间的区别在于后者允许将配置参数作为参数传递，而前者不允许。它只接受XML文件作为输入。在本章中，我们使用`snapshot-create-as`，因为它更方便和易于使用。
- en: Creating an internal snapshot with a custom name and description
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义名称和描述创建内部快照
- en: 'To create an internal snapshot for the `LAMP01` VM with the name `Snapshot
    1` and the description `First snapshot`, type the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`LAMP01`虚拟机创建一个名称为`快照1`且描述为`第一个快照`的内部快照，请键入以下命令：
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `--atomic` option specified, `libvirt` will make sure that no changes
    happen if the snapshot operation is successful or fails. It''s always recommended
    to use the `--atomic` option to avoid any corruption while taking the snapshot.
    Now, check the `snapshot-list` output here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--atomic`选项指定，`libvirt`将确保如果快照操作成功或失败，不会发生任何更改。建议始终使用`--atomic`选项以避免在进行快照时发生任何损坏。现在，检查这里的`snapshot-list`输出：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our first snapshot is ready to use and we can now use it to revert the VM's
    state if something goes wrong in the future. This snapshot was taken while the
    VM was in a running state. The time to complete snapshot creation depends on how
    much memory the VM has and how actively the guest is modifying that memory at
    the time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个快照已准备就绪，现在我们可以使用它来恢复虚拟机的状态，如果将来出现问题。此快照是在虚拟机处于运行状态时拍摄的。快照创建所需的时间取决于虚拟机的内存量以及客户端在那个时间修改内存的活动程度。
- en: Note that the VM goes into paused mode while snapshot creation is in progress;
    therefore, it is always recommended you take the snapshot while the VM is not
    running. Taking a snapshot from a guest that is shut down ensures data integrity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虚拟机在创建快照时会进入暂停模式；因此，建议在虚拟机未运行时进行快照。从已关闭的虚拟机中进行快照可以确保数据完整性。
- en: Creating multiple snapshots
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建多个快照
- en: 'We can keep creating more snapshots as required. For example, if we create
    two more snapshots so that we have a total of three, the output of `snapshot-list`
    will look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要继续创建更多快照。例如，如果我们创建两个额外的快照，使总数达到三个，那么`snapshot-list`的输出将如下所示：
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we used the `--parent` switch, which prints the parent-children relation
    of snapshots. The first snapshot''s parent is `(null)`, which means it was created
    directly on the disk image, and `Snapshot1` is the parent of `Snapshot2` and `Snapshot2`
    is the parent of `Snapshot3`. This helps us know the sequence of snapshots. A
    tree-like view of snapshots can also be obtained using the `--tree` option, as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`--parent`开关，它打印出快照的父-子关系。第一个快照的父级是`(null)`，这意味着它直接在磁盘映像上创建，`Snapshot1`是`Snapshot2`的父级，`Snapshot2`是`Snapshot3`的父级。这有助于我们了解快照的顺序。使用`--tree`选项还可以获得类似树状的快照视图，如下所示：
- en: '[PRE21]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, check the `state` column, which tells us whether the particular snapshot
    is live or offline. In the preceding example, the first and second snapshots were
    taken while the VM was running, whereas the third was taken when the VM was shut
    down.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查`state`列，它告诉我们特定快照是在线还是离线。在前面的示例中，第一个和第二个快照是在VM运行时拍摄的，而第三个是在VM关闭时拍摄的。
- en: 'Restoring to a shutoff-state snapshot will cause the VM to shut down. You can
    also use the `qemu-img` command utility to get more information about internal
    snapshots—for example, the snapshot size, snapshot tag, and so on. In the following
    example output, you can see that the disk named as `LAMP01.qcow2` has three snapshots
    with different tags. This also shows you when a particular snapshot was taken,
    with its date and time:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复到关闭状态的快照将导致VM关闭。您还可以使用`qemu-img`命令实用程序获取有关内部快照的更多信息-例如，快照大小，快照标记等。在以下示例输出中，您可以看到名为`LAMP01.qcow2`的磁盘具有三个具有不同标记的快照。这还向您展示了特定快照的创建日期和时间：
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This can also be used to check the integrity of the `qcow2` image using the
    `check` switch, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用来使用`check`开关检查`qcow2`镜像的完整性，如下所示：
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If any corruption occurred in the image, the preceding command will throw an
    error. A backup from the VM should be immediately taken as soon as an error is
    detected in the `qcow2` image.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果镜像中发生了任何损坏，上述命令将抛出错误。一旦在`qcow2`镜像中检测到错误，就应立即对VM进行备份。
- en: Reverting to internal snapshots
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复内部快照
- en: 'The main purpose of taking snapshots is to revert to a clean/working state
    of the VM when needed. Let''s take an example. Suppose, after taking `Snapshot3`
    of your VM, you installed an application that messed up the whole configuration
    of the system. In such a situation, the VM can easily revert to the state it was
    in when `Snapshot3` was created. To revert to a snapshot, use the `snapshot-revert`
    command, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 拍摄快照的主要目的是在需要时恢复VM的干净/工作状态。让我们举个例子。假设在拍摄VM的`Snapshot3`之后，您安装了一个搞乱了整个系统配置的应用程序。在这种情况下，VM可以轻松地恢复到创建`Snapshot3`时的状态。要恢复到快照，请使用`snapshot-revert`命令，如下所示：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are reverting to a shutdown snapshot, then you will have to start the
    VM manually. Use the `--running` switch with `virsh snapshot-revert` to get it
    started automatically.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要恢复到一个关闭的快照，那么您将不得不手动启动VM。使用`virsh snapshot-revert`命令的`--running`开关可以使其自动启动。
- en: Deleting internal snapshots
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除内部快照
- en: 'Once you are certain that you no longer need a snapshot, you can—and should—delete
    it to save space. To delete a snapshot of a VM, use the `snapshot-delete` command.
    From our previous example, let''s remove the second snapshot, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定不再需要快照，就可以删除它以节省空间。要删除VM的快照，请使用`snapshot-delete`命令。根据我们之前的示例，让我们删除第二个快照，如下所示：
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's now check how to do these procedures by using `virt-manager`, our GUI
    utility for VM management.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用`virt-manager`执行这些程序，这是我们的VM管理的GUI实用程序。
- en: Managing snapshots using virt-manager
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用virt-manager管理快照
- en: As you might expect, `virt-manager` has a user-interface for creating and managing
    VM snapshots. At present, it works only with `qcow2` images, but soon, there will
    be support for raw images as well. Taking a snapshot with `virt-manager` is actually
    very easy; to get started, open VM Manager and click on the VM for which you would
    like to take a snapshot.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，`virt-manager`具有用于创建和管理VM快照的用户界面。目前，它仅适用于`qcow2`镜像，但很快也将支持原始镜像。使用`virt-manager`拍摄快照实际上非常简单；要开始，请打开VM
    Manager并单击要拍摄快照的VM。
- en: 'The snapshot user interface button (marked on the following screenshot in red)
    is present on the toolbar; this button gets activated only when the VM uses a
    `qcow2` disk:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 快照用户界面按钮（在下面的屏幕截图中用红色标记）出现在工具栏上；只有当VM使用`qcow2`磁盘时，此按钮才会被激活：
- en: '![Figure 8.30 – Working with snapshots from virt-manager'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30-使用virt-manager快照'
- en: '](img/B14834_08_30.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_30.jpg)'
- en: Figure 8.30 – Working with snapshots from virt-manager
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30-使用virt-manager快照
- en: 'Then, if we want to take a snapshot, just use the **+** button, which will
    open a simple wizard so that we can give the snapshot a name and description,
    as illustrated in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想要拍摄快照，只需使用**+**按钮，这将打开一个简单的向导，以便我们可以为快照命名和描述，如下面的屏幕截图所示：
- en: '![Figure 8.31 – Create snapshot wizard'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31-创建快照向导'
- en: '](img/B14834_08_31.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_31.jpg)'
- en: Figure 8.31 – Create snapshot wizard
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31-创建快照向导
- en: Let's check how to work with external disk snapshots next, a faster and more
    modern (albeit not as mature) concept for KVM/VM snapshotting. Bear in mind that
    external snapshots are here to stay as they have much more capability that's really
    important for modern production environments.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用外部磁盘快照，这是一种更快，更现代（尽管不太成熟）的KVM/VM快照概念。请记住，外部快照将会一直存在，因为它们具有对于现代生产环境非常重要的更多功能。
- en: Working with external disk snapshots
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部磁盘快照
- en: 'You learned about internal snapshots in the previous section. Internal snapshots
    are pretty simple to create and manage. Now, let''s explore external snapshots.
    External snapshotting is all about `overlay_image` and `backing_file`. Basically,
    it turns `backing_file` into the read-only state and starts writing on `overlay_image`.
    These two images are described as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您在上一节中了解了内部快照。内部快照非常简单，易于创建和管理。现在，让我们探索外部快照。外部快照主要涉及`overlay_image`和`backing_file`。基本上，它将`backing_file`转换为只读状态，并开始在`overlay_image`上写入。这两个图像描述如下：
- en: '`backing_file`: The original disk image of a VM (read-only)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backing_file`：VM的原始磁盘图像（只读）'
- en: '`overlay_image`: The snapshot image (writable)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overlay_image`：快照图像（可写）'
- en: If something goes wrong, you can simply discard the `overlay_image` image and
    you are back to the original state.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，您可以简单地丢弃`overlay_image`图像，然后回到原始状态。
- en: With external disk snapshots, the `backing_file` image can be any disk image
    (`raw`; `qcow`; even `vmdk`) unlike internal snapshots, which only support the
    `qcow2` image format.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部磁盘快照，`backing_file`图像可以是任何磁盘图像（`raw`；`qcow`；甚至`vmdk`），而不像内部快照只支持`qcow2`图像格式。
- en: Creating an external disk snapshot
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建外部磁盘快照
- en: 'We are using a `WS2019SQL-Template` VM here as an example to demonstrate external
    snapshots. This VM resided in a filesystem storage pool named `vmstore1` and has
    a raw image acting as a virtual disk. The following code snippet provides details
    of this VM:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`WS2019SQL-Template` VM作为示例来演示外部快照。此VM位于名为`vmstore1`的文件系统存储池中，并具有充当虚拟磁盘的原始图像。以下代码片段提供了有关此VM的详细信息：
- en: '[PRE26]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s see how to create an external snapshot of this VM, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建此VM的外部快照，如下所示：
- en: 'Check if the VM you want to take a snapshot of is running, by executing the
    following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下代码检查要对其进行快照的VM是否正在运行：
- en: '[PRE27]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can take an external snapshot while a VM is running or when it is shut down.
    Both live and offline snapshot methods are supported.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在VM运行时或关闭时进行外部快照。支持在线和离线快照方法。
- en: 'Create a VM snapshot via `virsh`, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`virsh`创建VM快照，如下所示：
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, check the `snapshot-list` output, as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`snapshot-list`输出，如下所示：
- en: '[PRE29]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the snapshot has been taken, but it is only a snapshot of the disk''s
    state; the contents of memory have not been stored, as illustrated in the following
    screenshot:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，快照已经创建，但它只是磁盘状态的快照；内存内容没有被存储，如下截图所示：
- en: '[PRE30]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, list all the block devices associated with the VM once again, as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次列出与VM关联的所有块设备，如下所示：
- en: '[PRE31]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: /var/lib/libvirt/images/WS2019SQL-Template.img.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: /var/lib/libvirt/images/WS2019SQL-Template.img。
- en: '[PRE32]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This indicates that the new `image /var/lib/libvirt/images/WS2019SQL-Template.snapshot1`
    snapshot is now a read/write snapshot of the original image, `/var/lib/libvirt/images/WS2019SQL-Template.img`;
    any changes made to `WS2019SQL-Template.snapshot1` will not be reflected in `WS2019SQL-Template.img`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明新的`image /var/lib/libvirt/images/WS2019SQL-Template.snapshot1`快照现在是原始镜像`/var/lib/libvirt/images/WS2019SQL-Template.img`的读/写快照；对`WS2019SQL-Template.snapshot1`所做的任何更改都不会反映在`WS2019SQL-Template.img`中。
- en: Important note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`/var/lib/libvirt/images/WS2019SQL-Template.img` is the backing file (original
    disk).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/lib/libvirt/images/WS2019SQL-Template.img`是支持文件（原始磁盘）。'
- en: '`/var/lib/libvirt/images/WS2019SQL-Template.snapshot1` is the newly created
    overlay image, where all the writes are now happening.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/lib/libvirt/images/WS2019SQL-Template.snapshot1`是新创建的叠加图像，现在所有写操作都在此进行。'
- en: 'Now, let''s create one more snapshot:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个快照：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we used the `--diskspec` option to create a snapshot in the desired location.
    The option needs to be formatted in the `disk[,snapshot=type][,driver=type][,file=name]`
    format. This is what the parameters used signify:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`--diskspec`选项在所需位置创建快照。该选项需要以`disk[,snapshot=type][,driver=type][,file=name]`格式进行格式化。使用的参数表示如下：
- en: '`disk`: The target disk shown in `virsh domblklist <vm_name>`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disk`：在`virsh domblklist <vm_name>`中显示的目标磁盘。'
- en: '`snapshot`: Internal or external.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot`：内部或外部。'
- en: '`driver`: `libvirt`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：`libvirt`。'
- en: '`file`: The path of the location where you want to create the resulting snapshot
    disk. You can use any location; just make sure the appropriate permissions have
    been set.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`：要创建结果快照磁盘的位置路径。您可以使用任何位置；只需确保已设置适当的权限。'
- en: 'Let''s create one more snapshot, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个快照，如下所示：
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that this time, I added one more option: `--quiesce`. Let''s discuss
    this in the next section.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我添加了一个选项：`--quiesce`。我们将在下一节讨论这个。
- en: What is quiesce?
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是quiesce？
- en: 'Quiesce is a filesystem freeze (`fsfreeze`/`fsthaw`) mechanism. This puts the
    guest filesystems into a consistent state. If this step is not taken, anything
    waiting to be written to disk will not be included in the snapshot. Also, any
    changes made during the snapshot process may corrupt the image. To work around
    this, the `qemu-guest` agent needs to be installed on—and running inside—the guest.
    The snapshot creation will fail with an error, as illustrated here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Quiesce是一个文件系统冻结（`fsfreeze`/`fsthaw`）机制。这将使客户文件系统处于一致状态。如果不执行此步骤，等待写入磁盘的任何内容都不会包含在快照中。此外，在快照过程中进行的任何更改可能会损坏图像。为了解决这个问题，需要在客户机上安装并运行`qemu-guest`代理。快照创建将失败并显示错误，如下所示：
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Always use this option to be on the safe side while taking a snapshot. Guest
    tool installation is covered in [*Chapter 5*](B14834_05_Final_ASB_ePub.xhtml#_idTextAnchor079),
    *Libvirt Storage*; you might want to revisit this and install the guest agent
    in your VM if it's not already installed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行快照时，始终使用此选项以确保安全。客户工具安装在[*第5章*](B14834_05_Final_ASB_ePub.xhtml#_idTextAnchor079)，*Libvirt
    Storage*中进行了介绍；如果尚未安装，您可能需要重新查看并在VM中安装客户代理。
- en: 'We have created three snapshots so far. Let''s see how they are connected with
    each other to understand how an external snapshot chain is formed, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了三个快照。让我们看看它们如何连接在一起，以了解外部快照链是如何形成的，如下所示：
- en: 'List all the snapshots associated with the VM, like this:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出与VM关联的所有快照，如下所示：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check which is the current active (read/write) disk/snapshot for the VM by
    running the following code:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码检查虚拟机的当前活动（读/写）磁盘/快照：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can enumerate the backing file chain of the current active (read/write)
    snapshot using the `--backing-chain` option provided with `qemu-img`. `--backing-chain`
    will show us the whole tree of parent-child relationships in a disk image chain.
    Refer to the following code snippet for a further description:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `qemu-img` 提供的 `--backing-chain` 选项枚举当前活动（读/写）快照的支持文件链。`--backing-chain`
    将向我们显示磁盘镜像链中父子关系的整个树。有关更多描述，请参考以下代码片段：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'From the preceding details, we can see the chain is formed in the following
    manner:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的细节中，我们可以看到链是以以下方式形成的：
- en: '![Figure 8.32 – Snapshot chain for our example VM'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32 – 我们示例虚拟机的快照链'
- en: '](img/B14834_08_32.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_32.jpg)'
- en: Figure 8.32 – Snapshot chain for our example VM
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32 – 我们示例虚拟机的快照链
- en: 'So, it has to be read as follows: `snapshot3` has `snapshot2` as its backing
    file; `snapshot2` has `snapshot1` as its backing file; and `snapshot1` has the
    base image as its backing file. Currently, `snapshot3` is the current active snapshot,
    where live guest writes happen.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它必须按照以下方式读取：`snapshot3` 有 `snapshot2` 作为其支持文件；`snapshot2` 有 `snapshot1` 作为其支持文件；`snapshot1`
    有基础镜像作为其支持文件。目前，`snapshot3` 是当前活动的快照，即发生实时客户写入的地方。
- en: Reverting to external snapshots
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复到外部快照
- en: 'External snapshot support in `libvirt` was incomplete in some older RHEL/CentOS
    versions, even as recently as RHEL/CentOS 7.5\. Snapshots can be created online
    or offline, and with RHEL/CentOS 8.0 there has been a significant change in terms
    of how snapshots are treated. For starters, Red Hat recommends using external
    snapshots now. Furthermore, to quote Red Hat:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些较旧的 RHEL/CentOS 版本中，`libvirt` 对外部快照的支持是不完整的，甚至在 RHEL/CentOS 7.5 中也是如此。快照可以在线或离线创建，在
    RHEL/CentOS 8.0 中，在快照处理方式方面发生了重大变化。首先，Red Hat 现在建议使用外部快照。此外，引用 Red Hat 的话：
- en: Creating or loading a snapshot of a running VM, also referred to as a live snapshot,
    is not supported in RHEL 8\. In addition, note that non-live VM snapshots are
    deprecated in RHEL 8\. Therefore, creating or loading a snapshot of a shut-down
    VM is supported, but Red Hat recommends not using it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 8 中不支持创建或加载运行中虚拟机的快照，也称为实时快照。此外，请注意，在 RHEL 8 中不建议使用非实时虚拟机快照。因此，支持创建或加载关闭的虚拟机快照，但
    Red Hat 建议不要使用它。
- en: 'A caveat to this is the fact that `virt-manager` still doesn''t support external
    snapshots, as evident by the following screenshot and the fact that when we created
    these snapshots just a couple of pages ago, we never got an option to select external
    snapshot as the snapshot type:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`virt-manager` 仍不支持外部快照，正如以下截图所示，以及我们几页前创建这些快照时，从未有选择外部快照作为快照类型的选项：
- en: '![Figure 8.33 – All snapshots made from virt-manager and libvirt commands'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33 – 从 virt-manager 和 libvirt 命令创建的所有快照'
- en: without additional options are internal snapshots
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外选项的是内部快照
- en: '](img/B14834_08_33.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_33.jpg)'
- en: Figure 8.33 – All snapshots made from virt-manager and libvirt commands without
    additional options are internal snapshots
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33 – 从 virt-manager 和 libvirt 命令创建的所有快照，没有额外选项的是内部快照
- en: 'Now, we also worked with the `WS2019SQL-Template` VM and created *external*
    snapshots on it, so the situation is different. Let''s check it, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还使用 `WS2019SQL-Template` 虚拟机并在其上创建了*外部*快照，因此情况有所不同。让我们检查一下，如下所示：
- en: '![Figure 8.34 – WS2019SQL-Template has external snapshots'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34 – WS2019SQL-Template 有外部快照'
- en: '](img/B14834_08_34.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_08_34.jpg)'
- en: Figure 8.34 – WS2019SQL-Template has external snapshots
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34 – WS2019SQL-Template 有外部快照
- en: 'The next step that we could take is to revert to a previous state—for example,
    `snapshot3`. We can easily do that from the shell, by using the `virsh snapshot-revert`
    command, as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的下一步是恢复到先前的状态—例如，`snapshot3`。我们可以轻松地通过使用 `virsh snapshot-revert` 命令从 shell
    中执行此操作，如下所示：
- en: '[PRE39]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Does that mean that, once an external disk snapshot is taken for a VM, there
    is no way to revert to that snapshot? No—it's not like that; you can definitely
    revert to a snapshot but there is no `libvirt` support to accomplish this. You
    will have to revert manually by manipulating the domain XML file.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着一旦为虚拟机创建了外部磁盘快照，就无法恢复到该快照？不—不是这样的；您肯定可以恢复到快照，但没有 `libvirt` 支持来完成这一点。您将不得不通过操纵域
    XML 文件来手动恢复。
- en: 'Take as an example a `WS2019SQL-Template` VM that has three snapshots associated
    with it, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `WS2019SQL-Template` 虚拟机为例，它有三个关联的快照，如下所示：
- en: '[PRE40]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Suppose you want to revert to `snapshot2`. The solution is to shut down the
    VM (yes—a shutdown/power-off is mandatory) and edit its XML file to point to the
    `snapshot2` disk image as the boot image, as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要恢复到 `snapshot2`。解决方案是关闭虚拟机（是的—关闭/关机是强制性的），并编辑其 XML 文件，将磁盘映像指向 `snapshot2`
    作为引导映像，如下所示：
- en: 'Locate the disk image associated with `snapshot2`. We need the absolute path
    of the image. You can simply look into the storage pool and get the path, but
    the best option is to check the snapshot XML file. How? Get help from the `virsh`
    command, as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到与 `snapshot2` 关联的磁盘映像。我们需要图像的绝对路径。您可以简单地查看存储池并获取路径，但最好的选择是检查快照 XML 文件。如何？从
    `virsh` 命令获取帮助，如下所示：
- en: '[PRE41]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`/snapshot_store/WS2019SQL-Template.snapshot2` is the file associated with
    `snapshot2`. Verify that it''s intact and properly connected to the `backing_file`,
    as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/snapshot_store/WS2019SQL-Template.snapshot2` 是与 `snapshot2` 相关的文件。验证它是否完好，并且与
    `backing_file` 正确连接，如下所示：'
- en: '[PRE42]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The -r switch with qemu-img tries to repair any inconsistencies that are found
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 qemu-img 的 -r 开关尝试修复发现的任何不一致性
- en: During the check. -r leaks repairs only cluster leaks, whereas –r all fixes
    all
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查期间。-r leaks 仅修复集群泄漏，而 -r all 修复所有
- en: Kinds of errors, with a higher risk of choosing the wrong fix or hiding
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误的类型，选择错误修复或隐藏的风险更高
- en: Corruption that has already occurred.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已经发生的损坏。
- en: 'Let''s check the information about this snapshot, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查有关此快照的信息，如下所示：
- en: '[PRE43]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is time to manipulate the XML file. You can remove the currently attached
    disk from the VM and `add /snapshot_store/WS2019SQL-Template.snapshot2`. Alternatively,
    edit the VM''s XML file by hand and modify the disk path. One of the better options
    is to use the `virt-xml` command, as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是操作XML文件的时候了。您可以从VM中删除当前附加的磁盘和`add /snapshot_store/WS2019SQL-Template.snapshot2`。或者，手动编辑VM的XML文件并修改磁盘路径。其中一个更好的选择是使用`virt-xml`命令，如下所示：
- en: '[PRE44]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: virt-xml command. Refer to its man page to get acquainted with it. It can also
    be used in scripts.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: virt-xml命令。请参阅其手册以熟悉它。它也可以在脚本中使用。
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Start the VM, and you are back to the state when `snapshot2` was taken. Similarly,
    you can revert to `snapshot1` or the base image when required.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动VM，您将回到`snapshot2`被拍摄时的状态。类似地，您可以在需要时恢复到`snapshot1`或基本镜像。
- en: The next topic on our list is about deleting external disk snapshot which—as
    we mentioned—is a bit complicated. Let's check how we can do that next.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个主题是删除外部磁盘快照，正如我们提到的那样，这有点复杂。让我们看看接下来我们如何做到这一点。
- en: Deleting external disk snapshots
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除外部磁盘快照
- en: 'Deleting external snapshots is somewhat tricky. An external snapshot cannot
    be deleted directly, unlike an internal snapshot. It first needs to be manually
    merged with the base layer or toward the active layer; only then can you remove
    it. There are two live block operations available for merging online snapshots,
    as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 删除外部快照有些棘手。外部快照不能像内部快照那样直接删除。它首先需要手动与基本层或向活动层合并，然后才能删除。有两种在线合并快照的实时块操作，如下所示：
- en: '`blockcommit`: Merges data with the base layer. Using this merging mechanism,
    you can merge overlay images into backing files. This is the fastest method of
    snapshot merging because overlay images are likely to be smaller than backing
    images.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockcommit`：将数据与基本层合并。使用此合并机制，您可以将叠加图像合并到后备文件中。这是最快的快照合并方法，因为叠加图像可能比后备图像小。'
- en: '`blockpull`: Merges data toward the active layer. Using this merging mechanism,
    you can merge data from `backing_file` to overlay images. The resulting file will
    always be in `qcow2` format.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockpull`：向活动层合并数据。使用此合并机制，您可以将数据从`backing_file`合并到叠加图像。结果文件将始终以`qcow2`格式存在。'
- en: Next, we are going to read about merging external snapshots using `blockcommit`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将阅读有关使用`blockcommit`合并外部快照的信息。
- en: Merging external snapshots using blockcommit
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`blockcommit`合并外部快照
- en: 'We created a new VM named `VM1`, which has a base image (raw) called `vm1.img`
    with a chain of four external snapshots. `/var/lib/libvirt/images/vm1.snap4` is
    the active snapshot image where live writes happen; the rest are in read-only
    mode. Our target is to remove all the snapshots associated with this VM, as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`VM1`的新VM，它有一个名为`vm1.img`的基本镜像（原始），有四个外部快照。`/var/lib/libvirt/images/vm1.snap4`是活动快照图像，实时写入发生在这里；其余的处于只读模式。我们的目标是删除与此VM相关的所有快照，操作如下：
- en: 'List the current active disk image in use, like this:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前正在使用的活动磁盘镜像，如下所示：
- en: '[PRE46]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, enumerate the backing file chain of `/var/lib/libvirt/images/vm1.snap4`,
    as follows:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，枚举`/var/lib/libvirt/images/vm1.snap4`的后备文件链，如下所示：
- en: '[PRE47]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Time to merge all the snapshot images into the base image, like this:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将所有快照图像合并到基本图像中了，如下所示：
- en: '[PRE48]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that now, the current active block device is the base image and all
    writes are switched to it, which means we successfully merged the snapshot images
    into the base image. But the `snapshot-list` output in the following code snippet
    shows that there are still snapshots associated with the VM:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当前活动的块设备现在是基本镜像，所有写入都切换到它，这意味着我们成功地将快照图像合并到基本镜像中。但是以下代码片段中的`snapshot-list`输出显示仍然有与VM相关的快照：
- en: '[PRE49]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you want to get rid of this, you will need to remove the appropriate metadata
    and delete the snapshot images. As mentioned earlier, `libvirt` does not have
    complete support for external snapshots. Currently, it can just merge the images,
    but no support is available for automatically removing snapshot metadata and overlaying
    image files. This has to be done manually. To remove snapshot metadata, run the
    following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想摆脱这个问题，您需要删除适当的元数据并删除快照图像。正如前面提到的，`libvirt`不完全支持外部快照。目前，它只能合并图像，但没有自动删除快照元数据和叠加图像文件的支持。这必须手动完成。要删除快照元数据，请运行以下代码：
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we learned how to merge external snapshots by using the `blockcommit`
    method. Let's learn how to merge external snapshot using the `blockpull` method
    next.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们学习了如何使用`blockcommit`方法合并外部快照。接下来让我们学习如何使用`blockpull`方法合并外部快照。
- en: Merging external snapshots using blockpull
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`blockpull`合并外部快照
- en: 'We created a new VM named `VM2`, which has a base image (raw) called `vm2.img`
    with only one external snapshot. The snapshot disk is the active image where live
    writes happen and the base image is in read-only mode. Our target is to remove
    snapshots associated with this VM. Proceed as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`VM2`的新VM，它有一个名为`vm2.img`的基本镜像（原始），只有一个外部快照。快照磁盘是活动镜像，可以进行实时写入，而基本镜像处于只读模式。我们的目标是删除与此VM相关的快照。操作如下：
- en: 'List the current active disk image in use, like this:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前正在使用的活动磁盘镜像，如下所示：
- en: '[PRE51]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, enumerate the backing file chain of `/var/lib/libvirt/imagesvar/lib/libvirt/images/vm2.snap1`,
    as follows:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，枚举`/var/lib/libvirt/imagesvar/lib/libvirt/images/vm2.snap1`的后备文件链，如下所示：
- en: '[PRE52]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Merge the base image into the snapshot image (base to overlay image merging),
    like this:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基本镜像合并到快照镜像（从基本镜像到叠加图像合并），如下所示：
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, you can remove the `base_image` and snapshot metadata, as follows:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以按以下方式删除`base_image`和快照元数据：
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We ran the merge and snapshot deletion tasks while the VM is in the running
    state, without any downtime. `blockcommit` and `blockpull` can also be used to
    remove a specific snapshot from the snapshot chain. See the man page for `virsh`
    to get more information and try it yourself. You will also find some additional
    links in the *Further reading* section of this chapter, so make sure that you
    go through them.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在VM运行状态下运行了合并和快照删除任务，没有任何停机时间。`blockcommit`和`blockpull`也可以用于从快照链中删除特定的快照。查看`virsh`的man页面以获取更多信息并尝试自己操作。在本章的*进一步阅读*部分中，你还会找到一些额外的链接，所以确保你仔细阅读它们。
- en: Use cases and best practices while using snapshots
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用快照时的用例和最佳实践
- en: 'We mentioned that there''s a big love-hate relationship in the IT world with
    regard to snapshots. Let''s discuss the reasons and some common-sense best practices
    when using snapshots, as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到在IT世界中关于快照存在着一种爱恨交织的关系。让我们讨论一下在使用快照时的原因和一些常识的最佳实践，如下所示：
- en: When you take a VM snapshot, you are creating new delta copy of the VM disk,
    `qemu2`, or a raw file, and then you are writing to that delta. So, the more data
    you write, the longer it's going to take to commit and consolidate it back into
    the parent. Yes—you will eventually need to commit snapshots, but it is not recommended
    you go into production with a snapshot attached to the VM.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你拍摄VM快照时，你正在创建VM磁盘的新增量副本，`qemu2`，或者一个原始文件，然后你正在写入该增量。因此，你写入的数据越多，提交和合并回父级的时间就越长。是的——你最终需要提交快照，但不建议你在VM上附加快照进入生产环境。
- en: Snapshots are not backups; they are just a picture of a state, taken at a specific
    point in time, to which you can revert when required. Therefore, do not rely on
    it as a direct backup process. For that, you should implement a backup infrastructure
    and strategy.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照不是备份；它们只是在特定时间点拍摄的状态图片，你可以在需要时恢复到该状态。因此，不要将其作为直接备份过程的依赖。为此，你应该实施备份基础设施和策略。
- en: Don't keep a VM with a snapshot associated with it for long time. As soon as
    you verify that reverting to the state at the time a snapshot was taken is no
    longer required, merge and delete the snapshot immediately.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将带有快照的VM保留很长时间。一旦你验证了不再需要恢复到快照拍摄时的状态，立即合并并删除快照。
- en: Use external snapshots whenever possible. The chances of corruption are much
    lower in external snapshots when compared to internal snapshots.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用外部快照。与内部快照相比，外部快照的损坏几率要低得多。
- en: Limit the snapshot count. Taking several snapshots in a row without any cleanup
    can hit VM and host performance, as `qemu` will have to trawl through each image
    in the snapshot chain to read a new file from `base_image`.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制快照数量。连续拍摄多个快照而没有任何清理可能会影响VM和主机的性能，因为`qemu`将不得不遍历快照链中的每个图像来从`base_image`读取新文件。
- en: Have Guest Agent installed in the VM before taking snapshots. Certain operations
    in the snapshot process can be improved through support from within the guest.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拍摄快照之前在VM中安装Guest Agent。通过来宾内的支持，快照过程中的某些操作可以得到改进。
- en: Always use the `--quiesce` and `--atomic` options while taking snapshots.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拍摄快照时始终使用`--quiesce`和`--atomic`选项。
- en: If you're using these best practices, we are comfortable recommending using
    snapshots for your benefit. They will make your life much easier and give you
    a point you can come back to, without all the problems and hoopla that comes with
    them.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这些最佳实践，我们建议你使用快照来获益。它们会让你的生活变得更轻松，并为你提供一个可以回到的点，而不会带来所有的问题和麻烦。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how to work with `libguestfs` utilities to modify
    VM disks, create templates, and manage snapshots. We also looked into `virt-builder`
    and various provisioning methodologies for our VMs, as these are some of the most
    common scenarios used in the real world. We will learn even more about the concept
    of deploying VMs in large numbers (hint: cloud services) in the next chapter,
    which is all about `cloud-init`.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用`libguestfs`实用程序来修改VM磁盘，创建模板和管理快照。我们还研究了`virt-builder`和各种为我们的VM提供方法，因为这些是现实世界中最常见的场景之一。在下一章中，我们将更多地了解在大量部署VM时的概念（提示：云服务），这就是关于`cloud-init`的一切。
- en: Questions
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why would we need to modify VM disks?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要修改VM磁盘？
- en: How can we convert a VM to KVM?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将VM转换为KVM？
- en: Why do we use VM templates?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用VM模板？
- en: How do we create a Linux-based template?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建基于Linux的模板？
- en: How do we create a Microsoft Windows-based template?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建基于Microsoft Windows的模板？
- en: Which cloning mechanisms for deploying from template do you know of? What are
    the differences between them?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道哪些从模板部署的克隆机制？它们之间有什么区别？
- en: Why do we use `virt-builder`?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用`virt-builder`？
- en: Why do we use snapshots?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用快照？
- en: What are the best practices of using snapshots?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用快照的最佳实践是什么？
- en: Further reading
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章内容的更多信息，请参考以下链接：
- en: '`libguesfs` documentation: [http://libguestfs.org/](http://libguestfs.org/)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libguesfs`文档：[http://libguestfs.org/](http://libguestfs.org/)'
- en: '`virt-builder`: [http://libguestfs.org/virt-builder.1.html](http://libguestfs.org/virt-builder.1.html)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-builder`：[http://libguestfs.org/virt-builder.1.html](http://libguestfs.org/virt-builder.1.html)'
- en: 'Managing snapshots: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-managing_guests_with_the_virtual_machine_manager_virt_manager-managing_snapshots](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-managing_guests_with_the_virtual_machine_manager_virt_manager-managing_snapshots)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理快照：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-managing_guests_with_the_virtual_machine_manager_virt_manager-managing_snapshots](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-managing_guests_with_the_virtual_machine_manager_virt_manager-managing_snapshots)
- en: 'Generate VM Images with `virt-builder`: [http://www.admin-magazine.com/Articles/Generate-VM-Images-with-virt-builder](http://www.admin-magazine.com/Articles/Generate-VM-Images-with-virt-builder)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`virt-builder`生成VM镜像：[http://www.admin-magazine.com/Articles/Generate-VM-Images-with-virt-builder](http://www.admin-magazine.com/Articles/Generate-VM-Images-with-virt-builder)
- en: 'QEMU snapshot documentation: [http://wiki.qemu.org/Features/Snapshots](http://wiki.qemu.org/Features/Snapshots)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU快照文档：[http://wiki.qemu.org/Features/Snapshots](http://wiki.qemu.org/Features/Snapshots)
- en: '`libvirt`—Snapshot XML format: [https://libvirt.org/formatsnapshot.html](https://libvirt.org/formatsnapshot.html)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirt`—快照XML格式：[https://libvirt.org/formatsnapshot.html](https://libvirt.org/formatsnapshot.html)'
