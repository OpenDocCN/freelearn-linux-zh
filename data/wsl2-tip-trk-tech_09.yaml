- en: '*Chapter 7*: Working with Containers in WSL'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：在WSL中使用容器
- en: 'Containers are a hot topic as a way of packaging and managing applications.
    While there are both Windows and Linux flavors of containers, since this is a
    book about WSL, we will focus on Linux containers and Docker containers in particular.
    If you want to learn about Windows containers, this link is a good starting point:
    [https://docs.microsoft.com/virtualization/windowscontainers/](https://docs.microsoft.com/virtualization/windowscontainers/)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器作为一种打包和管理应用程序的方式是一个热门话题。虽然有Windows和Linux版本的容器，但由于本书是关于WSL的，我们将重点介绍Linux容器和Docker容器。如果您想了解Windows容器，可以从这个链接开始：[https://docs.microsoft.com/virtualization/windowscontainers/](https://docs.microsoft.com/virtualization/windowscontainers/)
- en: After covering what a container is and getting Docker installed, this chapter
    will guide you through running a prebuilt Docker container before taking you through
    how to build a container image for your own application using a Python web application
    as an example. After creating the container image, you will take a quick tour
    of some key components of Kubernetes and then see how to use these components
    to host the containerized application inside Kubernetes, all running in WSL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了容器的概念并安装了Docker之后，本章将指导您运行一个预构建的Docker容器，然后通过使用Python Web应用程序作为示例，教您如何构建自己应用程序的容器镜像。创建容器镜像后，您将快速了解Kubernetes的一些关键组件，然后看看如何使用这些组件在WSL中托管容器化应用程序。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Overview of containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器概述
- en: Installing and using Docker with WSL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WSL中安装和使用Docker
- en: Running a container with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker运行容器
- en: Building and running a web application in Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行Docker中的Web应用程序
- en: Introducing orchestrators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍编排器
- en: Setting up Kubernetes in WSL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WSL中设置Kubernetes
- en: Running a web application in Kubernetes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行Web应用程序
- en: We'll start the chapter by exploring what a container is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索容器的概念开始本章。
- en: Overview of containers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器概述
- en: Containers provide a way of packaging up an application and its dependencies.
    This description might feel a bit like a **virtual machine** (**VM**), where you
    have a file system that you can install application binaries in and then run later.
    When you run a container, however, it feels more like a process, both in the speed
    with which it starts and the amount of memory it consumes. Under the covers, containers
    are a set of processes that are isolated through the use of features such as **Linux
    namespaces** and **control groups** (**cgroups**), to make it seem like those
    processes are running in their own environment (including with their own file
    system). Containers share the kernel with the host operating system so are less
    isolated than VMs, but for many purposes, this isolation is sufficient, and this
    sharing of host resources enables the low memory consumption and rapid start up
    time that containers can achieve.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了一种打包应用程序及其依赖项的方式。这个描述可能有点像一个虚拟机（VM），在虚拟机中，你可以在文件系统中安装应用程序二进制文件，然后稍后运行。然而，当你运行一个容器时，它更像一个进程，无论是启动速度还是内存消耗量。在底层，容器是一组通过使用诸如Linux命名空间和控制组（cgroups）等特性进行隔离的进程，使得这些进程看起来像在它们自己的环境中运行（包括有自己的文件系统）。容器与主机操作系统共享内核，因此与虚拟机相比，它们的隔离性较低，但对于许多目的来说，这种隔离已经足够了，而且主机资源的共享使得容器可以实现低内存消耗和快速启动时间。
- en: In addition to container execution, Docker also makes it easy to define what
    makes up a container (referred to as a container image) and to publish container
    images in a registry where they can be consumed by other users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了容器执行外，Docker还可以轻松定义容器的组成部分（称为容器镜像）并在注册表中发布容器镜像，供其他用户使用。
- en: We will see this in action a little later in the chapter, but first, let's get
    Docker installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后的部分中看到这一点，但首先让我们安装Docker。
- en: Installing and using Docker with WSL
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WSL中安装和使用Docker
- en: The traditional approach to running Docker on a Windows machine is to use Docker
    Desktop (https://www.docker.com/products/docker-desktop), which will create and
    manage a Linux VM for you and run the Docker service as a daemon in that VM. The
    downside of this is that the VM takes time to start up and has to pre-allocate
    enough memory to accommodate running various containers for you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上运行Docker的传统方法是使用Docker Desktop（https://www.docker.com/products/docker-desktop），它将为您创建和管理一个Linux虚拟机，并在该虚拟机中作为守护程序运行Docker服务。这样做的缺点是虚拟机需要时间启动，并且必须预先分配足够的内存来容纳运行各种容器。
- en: With WSL2, it became possible to install and run the standard Linux Docker daemon
    inside a WSL **distribution (distro)**. This had the benefits of starting up more
    quickly and consuming a smaller amount of memory on startup, and only increasing
    the memory consumption when you run containers. The downside was that you had
    to install and manage the daemon yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过WSL2，可以在WSL发行版中安装和运行标准的Linux Docker守护程序。这样做的好处是在启动时更快，占用的内存更少，并且只在运行容器时增加内存消耗。缺点是你必须自己安装和管理守护程序。
- en: Fortunately, there is now a third option, which is to install Docker Desktop
    and enable the WSL backend. With this approach, you keep the convenience of Docker
    Desktop from an installation and management perspective. The difference is that
    Docker Desktop runs the daemon in WSL for you, giving you the improvements to
    start up time and memory usage without losing ease of use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在有第三种选择，即安装Docker Desktop并启用WSL后端。通过这种方法，您可以保留Docker Desktop在安装和管理方面的便利性。不同之处在于，Docker
    Desktop会在WSL中为您运行守护程序，从而使您在不失便利性的情况下获得启动时间和内存使用方面的改进。
- en: 'To get started, download and install Docker Desktop from https://www.docker.com/products/docker-desktop.
    When installed, right-click on the Docker icon in your system icon tray and choose
    **Settings**. You will see the following screen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，请从https://www.docker.com/products/docker-desktop下载并安装Docker Desktop。安装完成后，在系统图标托盘中右键单击Docker图标，选择“设置”。您将看到以下屏幕：
- en: '![Figure 7.1 – A screenshot of the Docker settings showing the WSL 2 option'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - Docker设置的屏幕截图显示WSL 2选项'
- en: '](img/Figure_7.1_B16412.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16412.jpg)'
- en: Figure 7.1 – A screenshot of the Docker settings showing the WSL 2 option
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - Docker设置的屏幕截图显示WSL 2选项
- en: The preceding screenshot shows the **Use the WSL 2 based engine** option. Ensure
    this option is ticked to configure Docker Desktop to run under WSL 2 rather than
    a traditional VM.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了“使用基于WSL 2的引擎”选项。确保选中此选项以配置Docker Desktop在WSL 2下运行，而不是传统的虚拟机。
- en: 'You can choose which distros Docker Desktop integrates with from the **Resources**
    section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从“资源”部分选择Docker Desktop与哪些发行版集成：
- en: '![Figure 7.2 – A screenshot of the Docker settings for WSL integration'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - WSL集成的Docker设置的屏幕截图'
- en: '](img/Figure_7.2_B16412.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16412.jpg)'
- en: Figure 7.2 – A screenshot of the Docker settings for WSL integration
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - WSL集成的Docker设置的屏幕截图
- en: As you can see in the preceding screenshot, you can control which distros you
    want Docker Desktop to integrate with. When you choose to integrate with a WSL
    distro, the socket for the Docker daemon is made available to that distro and
    the docker **command-line interface** (**CLI**) is added for you. Select all the
    distros you want to be able to use Docker from and click **Apply & Restart**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的截图中看到的，您可以控制Docker Desktop与哪些发行版集成。当您选择与WSL发行版集成时，Docker守护程序的套接字将对该发行版可用，并为您添加docker命令行界面（CLI）。选择您想要能够从中使用Docker的所有发行版，并单击“应用并重新启动”。
- en: 'Once Docker has restarted, you will be able to use the `docker` CLI to interact
    with Docker from any of the selected WSL distros, for example, `docker info`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker重新启动后，您将能够使用`docker`命令行界面（CLI）与任何选定的WSL发行版交互，例如`docker info`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This snippet shows some of the output from running `docker info` and you can
    see that the server is running on `linux` with a kernel of `4.19.104-microsoft-standard`,
    which is the same as the WSL kernel version on my machine (you can check this
    on your machine by running `uname -r` from your WSL distro).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了运行`docker info`的一些输出，您可以看到服务器正在`linux`上运行，内核版本为`4.19.104-microsoft-standard`，这与我的机器上的WSL内核版本相同（您可以通过在WSL发行版中运行`uname
    -r`来检查您的机器上的版本）。
- en: More information on installing and configuring Docker Desktop with WSL can be
    found in the Docker documentation at https://docs.docker.com/docker-for-windows/wsl/.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用WSL安装和配置Docker Desktop的更多信息，请参阅Docker文档https://docs.docker.com/docker-for-windows/wsl/。
- en: Now that we have Docker installed, let's get started by running a container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Docker，让我们通过运行一个容器来开始。
- en: Running a container with Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker运行容器
- en: 'As was mentioned earlier, Docker gives us a standardized way of packaging up
    a container image. These container images can be shared through Docker registries,
    and Docker Hub (https://hub.docker.com/) is a commonly used registry for publicly
    available images. In this section, we will run a container with the `nginx` web
    server using the `docker run -d --name docker-nginx -p 8080:80 nginx` command
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Docker为我们提供了一种标准化的方式来打包容器镜像。这些容器镜像可以通过Docker注册表共享，Docker Hub（https://hub.docker.com/）是一个常用的公共镜像注册表。在本节中，我们将使用以下命令运行一个带有`nginx`
    Web服务器的容器：`docker run -d --name docker-nginx -p 8080:80 nginx`。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last part of the command we just ran tells Docker what container image
    we want to run (`nginx`). This snippet of output shows that Docker didn''t find
    the `nginx` image locally, so it has started to pull it (that is, download it)
    from Docker Hub. Container images consist of a number of layers (we''ll discuss
    this more later in the chapter) and in the output, one layer already exists and
    another is being downloaded. The `docker` CLI keeps updating the output as the
    download progresses, as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚运行的命令的最后一部分告诉Docker我们要运行哪个容器镜像（`nginx`）。这个输出片段显示Docker在本地没有找到`nginx`镜像，所以它开始拉取（即下载）来自Docker
    Hub的镜像。容器镜像由多个层组成（我们将在本章后面讨论这个问题），在输出中，已经存在一个层并且正在下载另一个层。`docker`命令行界面（CLI）会随着下载的进行不断更新输出，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When Docker has finished pulling the image, you will see something similar
    to the preceding output, which confirms that Docker has pulled the image and prints
    the ID of the container it created (`336ab5bed2d5…`). At this point, we can run
    `docker ps` to list the running containers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker完成拉取镜像时，您将看到类似于上面输出的内容，确认Docker已经拉取了镜像并打印了创建的容器的ID（`336ab5bed2d5…`）。此时，我们可以运行`docker
    ps`来列出正在运行的容器：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This output shows a single container running and we can see that the container
    ID `336ab5bed2d5` value matches the start of the container ID output from `docker
    run`. By default, `docker ps` outputs the short form of the container ID, whereas
    `docker run` outputs the full container ID value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了一个正在运行的容器，我们可以看到容器ID `336ab5bed2d5`的值与`docker run`命令输出的容器ID的开头匹配。默认情况下，`docker
    ps`输出容器ID的短格式，而`docker run`输出完整的容器ID值。
- en: 'Let''s return to the command we used to run a container: `docker run -d --name
    docker-nginx -p 8080:80 nginx`. This has various parts to it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们用来运行容器的命令：`docker run -d --name docker-nginx -p 8080:80 nginx`。这个命令有几个部分：
- en: '`-d` tells Docker to run this container detached from our terminal, that is,
    to run it in the background.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`告诉Docker在后台运行这个容器，即以分离模式运行。'
- en: '`--name` tells Docker to use a specific name, `docker-nginx`, for the container
    rather than generating a random one. This name can also be seen in the `docker
    ps` output and can be used.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`告诉Docker使用一个特定的名称`docker-nginx`来命名容器，而不是生成一个随机的名称。这个名称也可以在`docker ps`的输出中看到，并且可以使用。'
- en: '`-p` allows us to map ports on the host to ports inside the running container.
    The format is `<host port>:<container port>`, so in the case of `8080:80`, we
    have mapped port `8080` on our host to port `80` inside the container.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`允许我们将主机上的端口映射到正在运行的容器内部的端口。格式为`<主机端口>:<容器端口>`，因此在`8080:80`的情况下，我们将主机上的端口`8080`映射到容器内部的端口`80`。'
- en: 'The final argument is the name of the image to run: `nginx`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是要运行的镜像的名称：`nginx`。
- en: 'Since port `80` is the default port that `nginx` serves content on and we have
    mapped port `8080` to that container port, we can open our web browser to `http://localhost:8080`,
    as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口`80`是`nginx`默认提供内容的端口，并且我们已将端口`8080`映射到该容器端口，因此我们可以在Web浏览器中打开`http://localhost:8080`，如下图所示：
- en: '![Figure 7.3 – A screenshot of the browser showing nginx output'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3-浏览器显示nginx输出的屏幕截图'
- en: '](img/Figure_7.3_B16412.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16412.jpg)'
- en: Figure 7.3 – A screenshot of the browser showing nginx output
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3-浏览器显示nginx输出的屏幕截图
- en: The preceding screenshot shows the output from nginx in a web browser. At this
    point, we have used a single command (`docker run`) to download and run nginx
    in a Docker container. Container resources have a level of isolation, which means
    that the port `80` that nginx is serving traffic on inside the container isn't
    visible externally, so we mapped that to port `8080` outside the container. Since
    we're running Docker Desktop with the WSL 2 backend, that port `8080` is actually
    exposed on the WSL 2 VM, but thanks to the magic we saw in [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Windows to Linux Interoperability*, in the *Accessing Linux web applications
    from Windows* section, we can access that at `http://localhost:8080` from Windows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了Web浏览器中nginx的输出。此时，我们使用了一个命令（`docker run`）在Docker容器中下载和运行nginx。容器资源具有一定的隔离级别，这意味着容器内部提供流量的端口`80`在外部不可见，因此我们将其映射到容器外部的端口`8080`。由于我们正在使用WSL
    2后端的Docker Desktop，因此端口`8080`实际上在WSL 2虚拟机上公开，但由于我们在[*第4章*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047)中看到的魔法，即*Windows与Linux的互操作性*，在*从Windows访问Linux
    Web应用程序*部分，我们可以从Windows访问`http://localhost:8080`。
- en: 'If we leave the container running, it will continue to consume resources, so
    let''s stop and delete it before we move on, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让容器继续运行，它将继续消耗资源，因此在继续之前让我们停止并删除它，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this output, you can see `docker stop docker-nginx`, which stops the running
    container. At this point, it is no longer consuming memory or CPU, but it still
    exists and references the image that was used to create it, which prevents that
    image from being deleted. So, after stopping the container, we use `docker rm
    docker-nginx` to delete it. To free up disk space, we can also clean up the `nginx`
    image by running `docker image rm nginx:latest`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到`docker stop docker-nginx`，它停止了正在运行的容器。此时，它不再消耗内存或CPU，但它仍然存在并引用了用于创建它的镜像，这会阻止删除该镜像。因此，在停止容器后，我们使用`docker
    rm docker-nginx`来删除它。为了释放磁盘空间，我们还可以通过运行`docker image rm nginx:latest`来清理`nginx`镜像。
- en: Now that we've seen how to run a container, let's build our own container image
    to run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何运行容器，让我们构建自己的容器镜像来运行。
- en: Building and running a web application in Docker
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中构建和运行Web应用程序
- en: In this section, we will build a Docker container image that packages a Python
    web application. This container image will include the web application and all
    its dependencies so that it can be run on a machine that has the Docker daemon
    installed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个Docker容器镜像，该镜像打包了一个Python Web应用程序。该容器镜像将包含Web应用程序及其所有依赖项，以便在安装了Docker守护程序的机器上运行。
- en: To follow along with this example, make sure that you have the code for the
    book (from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques))
    cloned in a Linux distro and then open a terminal and navigate to the `chapter-07/01-docker-web-app`
    folder, which contains the sample application we will use here. Check the `README.md`
    file for instructions on installing the dependencies needed to run the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此示例进行操作，请确保您已经在Linux发行版中克隆了本书的代码（来自[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)），然后打开终端并导航到`chapter-07/01-docker-web-app`文件夹，其中包含我们将在此处使用的示例应用程序。请查看`README.md`文件以获取运行应用程序所需的依赖项的安装说明。
- en: The sample application is built on the **Flask** web framework for Python (https://github.com/pallets/flask)
    and uses the **Gunicorn HTTP server** to host the application (https://gunicorn.org/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序基于Python的**Flask** Web框架构建（https://github.com/pallets/flask），并使用**Gunicorn
    HTTP服务器**托管应用程序（https://gunicorn.org/）。
- en: 'To keep the focus of the chapter on Docker containers, the application has
    a single code file, `app.py`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章重点放在Docker容器上，该应用程序只有一个代码文件`app.py`：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the code shows, there is a single endpoint for the home page defined, which
    returns a message showing the hostname for the machine where the web server is
    running.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，定义了一个用于主页的单个端点，该端点返回一个显示Web服务器所在机器的主机名的消息。
- en: 'The application can be run using `gunicorn --bind 0.0.0.0:5000 app:app` and
    we can open `http://localhost:5000` in our web browser:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`gunicorn --bind 0.0.0.0:5000 app:app`运行该应用程序，并在Web浏览器中打开`http://localhost:5000`：
- en: '![Figure 7.4 – A screenshot showing the sample app in a web browser'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4-浏览器中显示示例应用程序的屏幕截图'
- en: '](img/Figure_7.4_B16412.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16412.jpg)'
- en: Figure 7.4 – A screenshot showing the sample app in a web browser
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4-浏览器中显示示例应用程序的屏幕截图
- en: In this screenshot, you can see the response from the sample application, showing
    the hostname (`wfhome`) that the app is running on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，您可以看到示例应用程序的响应，显示应用程序正在运行的主机名（`wfhome`）。
- en: Now that you have seen the sample application in action, we will start looking
    at how to package it as a container image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了示例应用程序的运行情况，我们将开始看如何将其打包为容器镜像。
- en: Introducing Dockerfiles
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Dockerfile
- en: 'To build an image, we need to be able to describe to Docker what the image
    should contain, and for this, we will use a `Dockerfile`. A `Dockerfile` contains
    a series of commands for Docker to execute in order to build a container image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个镜像，我们需要能够向 Docker 描述镜像应该包含什么内容，为此，我们将使用一个 `Dockerfile`。`Dockerfile` 包含了一系列命令，供
    Docker 执行以构建容器镜像：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This Dockerfile contains a number of commands. Let''s look at them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 包含了一系列命令。让我们来看看它们：
- en: The `FROM` command specifies the base image that Docker should use, in other
    words, the starting content for our container image. Any applications and packages
    installed in the base image become part of the image that we build on top of it.
    Here, we have specified the `python:3.8-slim-buster` image, which provides an
    image based on `python:3.8-buster` image, which includes a number of common packages
    in the image, but this makes the base image larger. Since this application only
    uses a few packages, we are using the `slim` variant.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM` 命令指定 Docker 应该使用的基础镜像，换句话说，是我们容器镜像的起始内容。在基础镜像中安装的任何应用程序和软件包都成为我们在其之上构建的镜像的一部分。在这里，我们指定了
    `python:3.8-slim-buster` 镜像，它提供了一个基于 `python:3.8-buster` 镜像的镜像，该镜像包含了一些常见的软件包，但这使得基础镜像变得更大。由于此应用程序只使用了几个软件包，我们使用了
    `slim` 变体。'
- en: '`EXPOSE` indicates that we want to expose a port (`5000` in this case, as that
    is the port that the web application will listen on).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE` 表示我们要暴露一个端口（在本例中为 `5000`，因为这是 Web 应用程序将监听的端口）。'
- en: We use the `ADD` command to add content to the container image. The first parameter
    to `ADD` specifies the content to add from the `host` folder, and the second parameter
    specifies where to place it in the container image. Here, we are adding `requirements.txt`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `ADD` 命令将内容添加到容器镜像中。`ADD` 的第一个参数指定要从 `host` 文件夹添加的内容，第二个参数指定要将其放置在容器镜像中的位置。在这里，我们正在添加
    `requirements.txt`。
- en: The `RUN` command is used to perform a `pip install` operation using the `requirements.txt`
    file that we just added to the image with the help of the `ADD` command.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN` 命令用于使用刚刚通过 `ADD` 命令添加到镜像中的 `requirements.txt` 文件执行 `pip install` 操作。'
- en: '`WORKDIR` is used to set the working directory in the container to `/app`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR` 用于将容器中的工作目录设置为 `/app`。'
- en: '`ADD` is used again to copy the full application contents into the `/app` directory.
    We''ll discuss why the application files have been copied in with two separate
    `ADD` commands in the next section.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD` 再次用于将完整的应用程序内容复制到 `/app` 目录中。我们将在下一节中讨论为什么使用两个单独的 `ADD` 命令将应用程序文件复制进去。'
- en: Lastly, the `CMD` command specifies what command will be executed when a container
    is run from this image. Here, we specify the same `gunicorn` command that we just
    used to run the web application locally.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`CMD` 命令指定当从此镜像运行容器时将执行的命令。在这里，我们指定与刚刚在本地运行 Web 应用程序时使用的相同的 `gunicorn` 命令。
- en: Now that we have a `Dockerfile`, let's take a look at using it to build an image.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个 `Dockerfile`，让我们来看看如何使用它来构建一个镜像。
- en: Building the image
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'To build a container image, we will use the `docker build` command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个容器镜像，我们将使用 `docker build` 命令：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have used the `-t` switch to specify that the resulting image should
    be tagged as `simple-python-app`. This is the name of the image that we can use
    later to run a container from the image. Finally, we tell Docker what directory
    to use as the build context, and here, we used `.` to indicate the current directory.
    The build context specifies what content is packaged up and passed to the Docker
    daemon to use for building the image – when you `ADD` a file to the `Dockerfile`,
    it is copied from the build context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `-t` 开关来指定生成的镜像应该被标记为 `simple-python-app`。这是我们以后可以使用的镜像名称来运行容器。最后，我们告诉
    Docker 使用哪个目录作为构建上下文，这里我们使用 `.` 表示当前目录。构建上下文指定要打包并传递给 Docker 守护进程用于构建镜像的内容 - 当您将文件
    `ADD` 到 `Dockerfile` 时，它会从构建上下文中复制。
- en: The output from this command is quite long, so rather than including it in full,
    we'll take a look at a few key pieces.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出非常长，所以我们不会完整地包含它，我们只会看一些关键部分。
- en: 'The initial output is from the `FROM` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的初始输出来自 `FROM` 命令：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you can see that Docker has determined that it doesn't have the base image
    locally, so has pulled it from Docker Hub, just like when we ran the `nginx` image
    previously.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 Docker 已经确定它在本地没有基础镜像，所以从 Docker Hub 上拉取了它，就像我们之前运行 `nginx` 镜像一样。
- en: 'A little further down the output, we can see that `pip install` has been executed
    to install the application requirements in the image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的稍后部分，我们可以看到 `pip install` 已经执行了安装应用程序要求的操作：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, you can see the output of `pip install` as it installs
    `flask` and `gunicorn`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，您可以看到 `pip install` 的输出，它正在安装 `flask` 和 `gunicorn`。
- en: 'At the end of the output, we see a couple of success messages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾，我们看到了一些成功的消息：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first of these success messages gives the ID of the image that we just
    created (`747c4a9481d8`), and the second shows that it has been tagged using the
    tag we specified (`simple-python-app`). To see the Docker images on your local
    machine, we can run `docker image ls`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成功消息中的第一个给出了我们刚刚创建的镜像的 ID (`747c4a9481d8`)，第二个显示它已经使用我们指定的标签进行了标记 (`simple-python-app`)。要查看本地机器上的
    Docker 镜像，可以运行 `docker image ls`：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this output, we can see the `simple-python-app` image we just built. Now
    that we have built a container image, we are ready to run it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，我们可以看到我们刚刚构建的 `simple-python-app` 镜像。现在我们已经构建了一个容器镜像，可以准备运行它了！
- en: Running the image
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行镜像
- en: 'As we saw previously, we can run the container with the `docker run` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以使用 `docker run` 命令运行容器：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you can see that we are running the `simple-python-app` image as a container
    named `chapter-07-example` and have exposed port `5000`. The command output shows
    the ID of the container that we just started.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们正在将 `simple-python-app` 镜像作为名为 `chapter-07-example` 的容器运行，并且已经暴露了端口
    `5000`。命令输出显示了我们刚刚启动的容器的 ID。
- en: 'With the container running, we can open `http://localhost:5000` in a web browser:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时，我们可以在Web浏览器中打开`http://localhost:5000`：
- en: '![Figure 7.5 – A screenshot showing the containerized sample app in the web
    browser'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 展示在Web浏览器中的容器化示例应用程序的屏幕截图'
- en: '](img/Figure_7.5_B16412.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16412.jpg)'
- en: Figure 7.5 – A screenshot showing the containerized sample app in the web browser
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 展示在Web浏览器中的容器化示例应用程序的屏幕截图
- en: In this screenshot, we can see the output from the sample app. Notice that the
    hostname it has output matches the start of the container ID in the output from
    the `docker run` command. When the isolated environment for a container is created,
    the hostname is set to the short form of the container ID.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，我们可以看到示例应用程序的输出。请注意，它输出的主机名与`docker run`命令的输出中容器ID的开头匹配。当创建容器的隔离环境时，主机名设置为容器ID的短格式。
- en: Now that we have an initial version of the container built and running, let's
    take a look at modifying the application and rebuilding the image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建和运行了容器的初始版本，让我们来看看如何修改应用程序并重新构建镜像。
- en: Rebuilding the image with changes
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更改重新构建镜像
- en: 'When developing an application, we will make changes to the source code. To
    simulate this, make a simple change to the message in `app.py` (for example, change
    `Hello from` to `Coming to you from`). Once we have made this change, we can rebuild
    the container image using the same `docker build` command we used previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，我们会对源代码进行更改。为了模拟这个过程，在`app.py`中对消息进行简单更改（例如，将`Hello from`更改为`Coming
    to you from`）。一旦我们进行了这个更改，我们可以使用与之前相同的`docker build`命令重新构建容器镜像：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output this time is a little different. Aside from the base image not being
    pulled (because we already have the base image downloaded), you might also note
    a number of lines with `---> Using cache`. When Docker runs the commands in the
    `Dockerfile`, each line (with a couple of exceptions) creates a new container
    image and the subsequent commands build upon that image just like we build on
    top of the base image. These images are often referred to as layers due to the
    way they build upon each other. When building an image, if Docker determines that
    the files used in a command match the previously built layer, then it will reuse
    that layer and indicate this with the `---> Using cache` output. If the files
    don't match, then Docker runs the command and invalidates the cache for any later
    layers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的输出有点不同。除了基本镜像不被拉取（因为我们已经下载了基本镜像）之外，您还可能注意到一些带有`---> Using cache`的行。当Docker运行`Dockerfile`中的命令时，每一行（有几个例外）都会创建一个新的容器镜像，后续的命令就像我们在基本镜像上构建一样。由于它们相互构建，这些镜像通常被称为层。在构建镜像时，如果Docker确定命令中使用的文件与先前构建的层匹配，则它将重用该层，并通过`--->
    Using cache`输出指示此情况。如果文件不匹配，则Docker运行该命令并使任何后续层的缓存无效。
- en: 'This layer caching is why we split out `requirements.txt` from the main application
    content in the `Dockerfile` for the application: installing the requirements is
    typically a slow operation and, generally, the rest of the application files change
    more frequently. Splitting out the requirements and performing `pip install` before
    copying the application code ensures that the layer caching works with us as we
    develop the application.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层缓存是为什么我们将`requirements.txt`从应用程序的主要内容中拆分出来放在`Dockerfile`中的原因：安装依赖通常是一个耗时的操作，并且通常应用程序的其他文件更频繁地发生变化。将依赖拆分出来，并在复制应用程序代码之前执行`pip
    install`，可以确保层缓存在我们开发应用程序时与我们一起工作。
- en: We've seen a range of Docker commands here; if you want to explore further (including
    how to push an image to a registry), take a look at the *Docker 101 tutorial*
    at https://www.docker.com/101-tutorial.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一系列Docker命令；如果您想进一步探索（包括如何将镜像推送到注册表），请查看https://www.docker.com/101-tutorial上的*Docker
    101教程*。
- en: In this section, we've seen how to build container images and how to run containers,
    whether our own images or those from Docker Hub. We've also seen how layer caching
    can speed up the development cycle. These are all foundational steps and, in the
    next section, we'll start to take a look at orchestrators, which are the next
    layer up for building systems using containers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了如何构建容器镜像以及如何运行容器，无论是我们自己的镜像还是来自Docker Hub的镜像。我们还看到了层缓存如何加速开发周期。这些都是基础步骤，在下一节中，我们将开始研究编排器，这是使用容器构建系统的上一层。
- en: Introducing orchestrators
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍编排器
- en: In the previous section, we saw how we can use the capabilities of Docker to
    easily package our application as a container image and run it. If we push our
    image to a Docker registry, then it becomes simple to pull and run that application
    from any machine with Docker installed. Larger systems, however, are made up of
    many such components and we will likely want to distribute these across a number
    of Docker hosts. This allows us to adapt to a changing load on the system by increasing
    or decreasing the number of instances of a component container that are running.
    The way to get these features with a containerized system is to use an orchestrator.
    Orchestrators provide other features, such as automatically restarting failed
    containers, running containers on a different host if a host fails, and a stable
    way to communicate with containers as they potentially restart and move between
    hosts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何使用Docker的功能将我们的应用程序打包成容器镜像并运行。如果我们将镜像推送到Docker注册表，那么从安装了Docker的任何机器上都可以简单地拉取和运行该应用程序。然而，较大的系统由许多这样的组件组成，我们可能希望将它们分布在多个Docker主机上。这样可以通过增加或减少运行的组件容器实例的数量来适应系统上的负载变化。使用容器化系统获得这些功能的方法是使用编排器。编排器提供其他功能，例如自动重新启动失败的容器，在主机故障时在不同的主机上运行容器，以及与容器进行稳定通信，因为它们可能会重新启动并在主机之间移动。
- en: There are a number of container orchestrators, such as **Kubernetes**, **Docker
    Swarm**, and **Mesosphere DC/OS** (built on Apache Mesos with Marathon). These
    orchestrators all provide slightly different features and ways of implementing
    the requirements we just described. Kubernetes has become a very popular orchestrator,
    and all the major cloud vendors have a Kubernetes offering (it even has support
    in Docker Enterprise and Mesosphere DC/OS). We will spend the rest of this chapter
    looking at how to create a Kubernetes development environment in WSL and run an
    application on it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多容器编排器，如Kubernetes、Docker Swarm和基于Apache Mesos和Marathon的Mesosphere DC/OS。这些编排器都提供了稍微不同的功能和实现我们刚才描述的要求的方式。Kubernetes已经成为一个非常流行的编排器，所有主要的云供应商都提供了Kubernetes的支持（它甚至在Docker
    Enterprise和Mesosphere DC/OS中都有支持）。本章的其余部分将介绍如何在WSL中创建一个Kubernetes开发环境并在其上运行应用程序。
- en: Setting up Kubernetes in WSL
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WSL中设置Kubernetes
- en: 'There is no shortage of options for installing Kubernetes, including the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Kubernetes有很多选择，包括以下几种：
- en: Kind ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kind（[https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)）
- en: Minikube ([https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/))
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube（[https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)）
- en: MicroK8s (https://microk8s.io/)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroK8s（https://microk8s.io/）
- en: k3s ([https://k3s.io/](https://k3s.io/))
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k3s（[https://k3s.io/](https://k3s.io/)）
- en: The first of these, Kind, stands for Kubernetes in Docker and was designed for
    testing Kubernetes. As long as your build tool can run Docker containers, it can
    be a good option as a way to run Kubernetes as part of your integration tests
    in your automated builds. By default, Kind will create a single-node Kubernetes
    cluster but you can configure it to run multi-node clusters, where each node is
    run as a separate container *(*we will see how to use Kind in[*Chapter 10*](B16412_10_Final_JC_ePub.xhtml#_idTextAnchor125)*,
    Visual Studio Code and Containers* in the *Working with Kubernetes in dev container*
    section*)*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是Kind，它代表Kubernetes in Docker，专为测试Kubernetes而设计。只要您的构建工具可以运行Docker容器，它就可以作为在自动化构建中运行Kubernetes的一种好选择，用于集成测试的一部分。默认情况下，Kind将创建一个单节点Kubernetes集群，但您可以配置它以运行多节点集群，其中每个节点都作为一个单独的容器运行（*我们将在第10章“使用Visual
    Studio Code和容器”中看到如何使用Kind在开发容器中使用Kubernetes*）。
- en: 'For this chapter, however, we will use the built-in Kubernetes capabilities
    in Docker Desktop, which provides a convenient way to enable a Kubernetes cluster
    that is managed for you:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将使用Docker Desktop中内置的Kubernetes功能，它提供了一种方便的方式来启用由您管理的Kubernetes集群。
- en: '![Figure 7.6 – A screenshot showing Kubernetes enabled in Docker Desktop'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 显示在Docker Desktop中启用Kubernetes的屏幕截图'
- en: '](img/Figure_7.6_B16412.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16412.jpg)'
- en: Figure 7.6 – A screenshot showing Kubernetes enabled in Docker Desktop
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 显示在Docker Desktop中启用Kubernetes的屏幕截图
- en: In this screenshot, you can see the **Kubernetes** page of the Docker Desktop
    settings, with the **Enable Kubernetes** option. By ticking this option and clicking
    **Apply & Restart**, Docker Desktop will install a Kubernetes cluster for you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，您可以看到Docker Desktop设置的Kubernetes页面，其中包含“启用Kubernetes”选项。勾选此选项并点击“应用并重启”，Docker
    Desktop将为您安装一个Kubernetes集群。
- en: 'Just as we''ve been using the `docker` CLI to interact with Docker, Kubernetes
    has its own CLI, `kubectl`. We can use `kubectl` to check that we are able to
    connect to the Kubernetes cluster that Docker Desktop has created for us with
    the `kubectl cluster-info` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们一直使用`docker` CLI与Docker进行交互一样，Kubernetes也有自己的CLI，即`kubectl`。我们可以使用`kubectl
    cluster-info`命令来检查我们是否能够连接到Docker Desktop为我们创建的Kubernetes集群：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output shows that `kubectl` has successfully connected to the Kubernetes
    cluster at `kubernetes.docker.internal`, indicating that we're using the *Docker
    Desktop Kubernetes integration*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示`kubectl`已成功连接到`kubernetes.docker.internal`上的Kubernetes集群，表示我们正在使用*Docker
    Desktop Kubernetes集成*。
- en: Now that we have a Kubernetes cluster running, let's look at running an application
    in it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个运行的Kubernetes集群，让我们来看看如何在其中运行一个应用程序。
- en: Running a web application in Kubernetes
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行Web应用程序
- en: Kubernetes introduces a few new terms, the first of these is a pod. **Pods**
    are the way to run a container in Kubernetes. When we ask Kubernetes to run a
    pod, we specify some details, such as the image we want it to run. Orchestrators
    such as Kubernetes are designed to enable us to run multiple components as part
    of a system, including being able to scale out the number of instances of components.
    To help serve this goal, Kubernetes adds another concept called **deployments**.
    Deployments are built on pods and allow us to specify how many instances of the
    corresponding pod we want Kubernetes to run, and this value can be changed dynamically,
    enabling us to scale out (and in) our application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes引入了一些新的术语，其中第一个是Pod。Pod是在Kubernetes中运行容器的方式。当我们要求Kubernetes运行一个Pod时，我们会指定一些细节，比如我们希望它运行的镜像。像Kubernetes这样的编排器旨在使我们能够作为系统的一部分运行多个组件，包括能够扩展组件实例的数量。为了帮助实现这个目标，Kubernetes添加了另一个概念，称为Deployments。Deployments是基于Pod构建的，允许我们指定我们希望Kubernetes运行的相应Pod的实例数量，并且这个值可以动态更改，使我们能够扩展（和缩小）我们的应用程序。
- en: We'll take a look at creating a deployment in a moment, but first, we need to
    create a new tag for our sample application. When we built the Docker image previously,
    we used the `simple-python-app` tag. Each tag has one or more associated versions
    and since we didn't specify the version, it is assumed to be `simple-python-app:latest`.
    When working with Kubernetes, using the *latest* image version means that Kubernetes
    will try to pull the image from a registry, even if it has the image locally.
    Since we haven't pushed our image to a registry, this will fail. We could rebuild
    the image, specifying `simple-python-app:v1` as the image name, but since we have
    already built the image, we can also create a new tagged version of our image
    by running `docker tag simple-python-app:latest simple-python-app:v1`. Now we
    have two tags referring to the same image, but by using the `simple-python-app:v1`
    tag, Kubernetes will only attempt to pull the image if it doesn't exist locally
    already. With our new tag in place, let's start deploying our application to Kubernetes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后查看如何创建部署，但首先，我们需要为我们的示例应用程序创建一个新的标签。在之前构建Docker镜像时，我们使用了`simple-python-app`标签。每个标签都有一个或多个关联的版本，由于我们没有指定版本，它被假定为`simple-python-app:latest`。在使用Kubernetes时，使用*latest*镜像版本意味着Kubernetes将尝试从注册表中拉取镜像，即使它已经在本地存在。由于我们还没有将镜像推送到注册表，这将失败。我们可以重新构建镜像，指定`simple-python-app:v1`作为镜像名称，但由于我们已经构建了镜像，我们也可以通过运行`docker
    tag simple-python-app:latest simple-python-app:v1`来创建一个新的带标签的版本。现在我们有两个引用同一镜像的标签，但是通过使用`simple-python-app:v1`标签，只有在本地不存在镜像时，Kubernetes才会尝试拉取镜像。有了我们的新标签，让我们开始将应用程序部署到Kubernetes。
- en: Creating a deployment
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个部署
- en: 'The first step of deploying our sample application to Kubernetes is to create
    a deployment object in Kubernetes. Using the versioned tag for our container image,
    we can use `kubectl` to create a deployment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的示例应用程序部署到Kubernetes的第一步是在Kubernetes中创建一个部署对象。使用我们容器镜像的版本标签，我们可以使用`kubectl`创建一个部署：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This output shows the creation of a deployment called `chapter-07-example`
    running the `simple-python-app:v1` image. After creating the deployment, it shows
    `kubectl get deployments` used to list the deployments and get summary information
    about the state of the deployment. Here, `1/1` in the `READY` column indicates
    that the deployment is configured to have one instance of the pod running and
    that it is available. If the application running in our pod crashes, Kubernetes
    will (by default) automatically restart it for us. We can run `kubectl get pods`
    to see the pod that the deployment has created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示创建了一个名为`chapter-07-example`的部署，运行着`simple-python-app:v1`镜像。创建部署后，它显示了使用`kubectl
    get deployments`列出部署并获取关于部署状态的摘要信息。在这里，`READY`列中的`1/1`表示部署配置为运行一个实例的pod，并且该实例可用。如果我们pod中运行的应用程序崩溃，Kubernetes将（默认情况下）自动重新启动它。我们可以运行`kubectl
    get pods`来查看部署创建的pod：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this output, we can see that the pod has been created with a name starting
    with the deployment name followed by a random suffix.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以看到pod的名称以部署名称开头，后面跟着一个随机后缀。
- en: 'As we mentioned earlier, one benefit of using a deployment over a pod is the
    ability to scale it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用部署而不是pod的一个好处是可以对其进行扩展：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we see the `kubectl scale` command being used on the `chapter-07-example`
    deployment to set the number of replicas to two, in other words, to scale the
    deployment to two pods. After scaling, we run `kubectl get pods` again and can
    see that we have a second pod created.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`kubectl scale`命令在`chapter-07-example`部署上使用，将副本数设置为2，换句话说，将部署扩展到两个pod。扩展后，我们再次运行`kubectl
    get pods`，可以看到我们创建了第二个pod。
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'When working with kubectl, you can improve your productivity by enabling bash
    completion. To configure this, run:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用kubectl时，您可以通过启用bash自动补全来提高生产力。要配置这个，请运行：
- en: '`echo ''source <(kubectl completion bash)'' >>~/.bashrc`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo ''source <(kubectl completion bash)'' >>~/.bashrc`'
- en: This adds kubectl bash completion to your `.bashrc` file, so you will need to
    restart Bash to enable it (for full details see [https://kubernetes.io/docs/tasks/tools/install-kubectl/#optional-kubectl-configurations](https://kubernetes.io/docs/tasks/tools/install-kubectl/#optional-kubectl-configurations)),
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将将kubectl bash自动补全添加到您的`.bashrc`文件中，因此您需要重新启动Bash以启用它（有关详细信息，请参阅[https://kubernetes.io/docs/tasks/tools/install-kubectl/#optional-kubectl-configurations](https://kubernetes.io/docs/tasks/tools/install-kubectl/#optional-kubectl-configurations)），
- en: 'With this change, you can now type the following (press the *Tab* key in place
    of `<TAB>`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，您现在可以键入以下内容（在<TAB>的位置按下*Tab*键）：
- en: '`kubectl sc<TAB> dep<TAB> chap<TAB> --re<TAB>2`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl sc<TAB> dep<TAB> chap<TAB> --re<TAB>2`'
- en: 'The end result of this with bash completion is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bash自动补全的最终结果是：
- en: '`kubectl scale deployment chapter-07-example --replicas=2`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl scale deployment chapter-07-example --replicas=2`'
- en: As you can see, this saves time entering commands and supports completion for
    both commands (such as `scale`) and resource names (`chapter-07-example`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这样可以节省输入命令的时间，并支持命令（如`scale`）和资源名称（`chapter-07-example`）的自动补全。
- en: Now that we have the application deployed, let's look at how to access it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了应用程序，让我们看看如何访问它。
- en: Creating a service
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: 'Next, we want to be able to access the web application running as the `chapter-07-example`
    deployment. Since we can have instances of the web application running across
    pods, we need a way to access the set of pods. For this purpose, Kubernetes has
    a concept called `kubectl expose` to create a service:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望能够访问作为`chapter-07-example`部署运行的Web应用程序。由于我们可以在多个pod上运行Web应用程序的实例，我们需要一种访问一组pod的方法。为此，Kubernetes有一个称为`kubectl
    expose`的概念来创建服务：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we run `kubectl expose`, instructing Kubernetes to create a service for
    our `chapter-07-example` deployment. We specify `NodePort` as the service type,
    which makes the service available on any node in the cluster, and pass `5000`
    as the port that the service targets to match the port that our web application
    is listening on. Next, we run `kubectl get services`, which shows the new `chapter-07-example`
    service. Under the `PORT(S)` column, we can see `5000:30123/TCP`, indicating that
    the service is listening on port `30123` and will forward traffic to port `5000`
    on the pods in the deployment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行`kubectl expose`命令，指示Kubernetes为我们的`chapter-07-example`部署创建一个服务。我们将服务类型指定为`NodePort`，这使得服务在集群中的任何节点上都可用，并将`5000`作为服务目标端口，以匹配我们的Web应用程序正在侦听的端口。接下来，我们运行`kubectl
    get services`命令，显示新创建的`chapter-07-example`服务。在`PORT(S)`列下，我们可以看到`5000:30123/TCP`，表示该服务正在端口`30123`上侦听，并将流量转发到部署中的端口`5000`。
- en: 'Thanks to the way Docker Desktop sets up the networking for the Kubernetes
    cluster (and the WSL forwarding of `localhost` from Windows to WSL), we can open
    `http://localhost:30123` in a web browser:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker Desktop为Kubernetes集群设置了网络（以及从Windows到WSL的`localhost`的WSL转发），我们可以在Web浏览器中打开`http://localhost:30123`。
- en: '![Figure 7.7 – A screenshot showing the Kubernetes web application in the browser'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 展示在浏览器中加载的Kubernetes Web应用程序的屏幕截图'
- en: '](img/Figure_7.7_B16412.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16412.jpg)'
- en: Figure 7.7 – A screenshot showing the Kubernetes web application in the browser
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 展示在浏览器中加载的Kubernetes Web应用程序的屏幕截图
- en: This screenshot shows the web application loaded in a browser and the hostname
    that it displays matches one of the pod names we saw when we listed the pods after
    scaling the deployment. If you refresh the page a few times, you will see the
    name changes between the pod names we created after scaling the deployment, showing
    that the Kubernetes service we created is distributing the traffic between the
    pods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕截图显示了在浏览器中加载的Web应用程序和显示的主机名与我们在缩放部署后列出的Pod名称之一相匹配。如果您刷新页面几次，您将看到名称在我们缩放部署后创建的Pod名称之间更改，这表明我们创建的Kubernetes服务正在在Pod之间分发流量。
- en: We have been interactively running `kubectl` commands to create deployments
    and services, but a powerful aspect of Kubernetes is its support for declarative
    deployments. Kubernetes allows you to define objects such as deployments and services
    in files written in the `YAML` format. In this way, you can specify multiple aspects
    of your system and then pass the set of `YAML` files to Kubernetes in one go and
    Kubernetes will create them all. You can later update the *YAML* specification
    and pass it to Kubernetes, and it will reconcile the differences in the specification
    to apply your changes. An example of this is in the code accompanying the book
    in the `chapter-07/02-deploy-to-kubernetes` folder (refer to the `README.md` file
    in the folder for instructions on how to deploy).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在交互式地运行`kubectl`命令来创建部署和服务，但Kubernetes的一个强大之处是它支持声明式部署。Kubernetes允许您在`YAML`格式的文件中定义部署和服务等对象。通过这种方式，您可以指定系统的多个方面，然后一次性将一组`YAML`文件传递给Kubernetes，Kubernetes将创建它们。您以后可以更新*YAML*规范并将其传递给Kubernetes，它将协调规范中的差异以应用您的更改。本书附带的代码示例位于`chapter-07/02-deploy-to-kubernetes`文件夹中（请参阅文件夹中的`README.md`文件以获取部署说明）。
- en: In this section, we've taken a look at how to deploy our web application packaged
    as a container image using a Kubernetes deployment. We saw how this creates pods
    for us and allows us to dynamically scale the number of pods that we have running.
    We also saw how we can use Kubernetes to create a service that distributes traffic
    across the pods in our deployment. This service gives a logical abstraction over
    the pods in the deployment and handles scaling the deployment as well as pods
    that have restarted (for example, if it has crashed). This gives a good starting
    point for working with Kubernetes, and if you want to take it further, Kubernetes
    has a great interactive tutorial at [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用Kubernetes部署我们打包为容器镜像的Web应用程序。我们看到这将为我们创建Pod，并允许我们动态扩展正在运行的Pod的数量。我们还看到如何使用Kubernetes创建一个服务，该服务在部署中的Pod之间分发流量。该服务为部署中的Pod提供了逻辑抽象，并处理部署的扩展以及已重新启动的Pod（例如，如果它已崩溃）。这为使用Kubernetes工作提供了一个很好的起点，如果您想进一步了解，Kubernetes在[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)上有一个很棒的交互式教程。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are interested in digging deeper into using *Docker* or *Kubernetes*
    for building applications, the following links give a good starting point (with
    further links to other content):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣深入了解使用*Docker*或*Kubernetes*构建应用程序，以下链接是一个很好的起点（还有其他内容的进一步链接）：
- en: '[https://docs.docker.com/develop/](https://docs.docker.com/develop/)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/develop/](https://docs.docker.com/develop/)'
- en: '[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you''ve been introduced to containers and have seen how they
    enable an application and its dependencies to be packaged together to enable it
    to be run simply on a machine with the Docker daemon running. We discussed Docker
    registries as a way of sharing images, including the commonly used public registry:
    `docker` CLI and used this to run the `nginx` image from Docker Hub, with Docker
    automatically pulling the image to the local machine from Docker Hub.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了容器，并看到它们如何使应用程序及其依赖项打包在一起，以便在运行Docker守护程序的机器上简单运行。我们讨论了Docker注册表作为共享镜像的一种方式，包括常用的公共注册表：`docker`
    CLI，并使用它来运行来自Docker Hub的`nginx`镜像，Docker会自动从Docker Hub将镜像拉取到本地机器上。
- en: After running the `nginx` image, you saw how to build an image from a custom
    web application using steps defined in a `Dockerfile`. You saw how Docker builds
    image layers for steps in the `Dockerfile` and reuses them in subsequent builds
    if files haven't changed, and also how this can be used to improve subsequent
    build times by carefully structuring the `Dockerfile` so that the most commonly
    changing content is added in later steps.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行了`nginx`镜像之后，你学会了如何使用在`Dockerfile`中定义的步骤来构建自定义Web应用程序的镜像。你了解到Docker会为`Dockerfile`中的步骤构建镜像层，并在后续构建中重用它们，如果文件没有更改的话。你还了解到可以通过精心构建`Dockerfile`，将最常变化的内容添加到后续步骤中，从而提高后续构建的时间。
- en: After looking at how to work with Docker, you were introduced to the concept
    of container orchestrators, before taking a look at Kubernetes. With Kubernetes,
    you saw how you can use different types of resources, such as pods, deployments,
    and services, to deploy an application. You saw how Kubernetes deployments build
    on pods to allow you to easily scale the number of instances of the pod running
    with a single command, and how to use Kubernetes services to provide an easy and
    consistent way to address the pods in a deployment independent of the scaling.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用Docker之后，你了解了容器编排器的概念，然后开始学习Kubernetes。通过Kubernetes，你了解到可以使用不同类型的资源，如pod、deployment和service来部署应用程序。你了解到Kubernetes的部署是基于pod构建的，可以通过一个命令轻松地扩展pod实例的数量，并且可以使用Kubernetes的service来提供一种简单且一致的方式来访问部署中的pod，而不受扩展的影响。
- en: In the next chapter, we will turn our attention more directly to WSL, where
    a knowledge of building and working with containers will prove useful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更直接地关注WSL，掌握构建和使用容器的知识将会很有用。
