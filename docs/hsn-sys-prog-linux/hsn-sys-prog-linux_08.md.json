["```\n[...]\nCAP_CHOWN\n              Make arbitrary changes to file UIDs and GIDs (see chown(2)).\n\nCAP_DAC_OVERRIDE\n              Bypass file read, write, and execute permission checks.  (DAC is an abbreviation of \"discretionary access control\".)\n[...]\n\nCAP_NET_ADMIN\n              Perform various network-related operations:\n              * interface configuration;\n              * administration of IP firewall, masquerading, and accounting;\n              * modify routing tables;\n[...]\n\nCAP_NET_RAW\n              * Use RAW and PACKET sockets;\n              * bind to any address for transparent proxying.\n[...]\n\nCAP_SETUID\n              * Make arbitrary manipulations of process UIDs (setuid(2),\n                setreuid(2), setresuid(2), setfsuid(2));\n\n[...]\n\n CAP_SYS_ADMIN\n              Note: this capability is overloaded; see Notes to kernel\n              developers, below.\n\n              * Perform a range of system administration operations\n                including: quotactl(2), mount(2), umount(2), swapon(2),\n                setdomainname(2);\n              * perform privileged syslog(2) operations (since Linux 2.6.37,\n                CAP_SYSLOG should be used to permit such operations);\n              * perform VM86_REQUEST_IRQ vm86(2) command;\n              * perform IPC_SET and IPC_RMID operations on arbitrary \n                System V IPC objects;\n              * override RLIMIT_NPROC resource limit;\n              * perform operations on trusted and security Extended\n                Attributes (see xattr(7));\n              * use lookup_dcookie(2);\n*<< a lot more follows >>*\n[...]\n```", "```\n$ grep -i cap /proc/self/status \nCapInh:    0000000000000000\nCapPrm:    0000000000000000\nCapEff:    0000000000000000\nCapBnd:    0000003fffffffff\nCapAmb:    0000000000000000\n```", "```\n$ grep -i cap /proc/1/status \nCapInh:    0000000000000000\nCapPrm:    0000003fffffffff\nCapEff:    0000003fffffffff\nCapBnd:    0000003fffffffff\nCapAmb:    0000000000000000\n$ \n```", "```\nCAP_SETFCAP (since Linux 2.6.24)\n              Set file capabilities.\n```", "```\nint main(void)\n{\n    printf(\"Hello, Linux System Programming, World!\\n\");\n    pause();\n    exit(EXIT_SUCCESS);\n}\n```", "```\n[...]\n#include <sys/capability.h>\n\nint main(int argc, char **argv)\n{\n    pid_t pid;\n    cap_t pcaps;\n    char *caps_text=NULL;\n\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s PID\\n\"\n                \" PID: process to query capabilities of\\n\"\n                , argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    pid = atoi(argv[1]);\n\n    [...]\n    pcaps = cap_get_pid(pid);\n    if (!pcaps)\n        FATAL(\"cap_get_pid failed; is process %d valid?\\n\", pid);\n\n    caps_text = cap_to_text(pcaps, NULL);\n    if (!caps_text)\n        FATAL(\"caps_to_text failed\\n\", argv[1]);\n\n    printf(\"\\nProcess %6d : capabilities are: %s\\n\", pid, caps_text);\n    cap_free(caps_text);\n    exit (EXIT_SUCCESS);\n}\n```", "```\n$ ./query_pcap \nUsage: ./query_pcap PID\n PID: process to query capabilities of\n$ ./query_pcap 1\nProcess      1 : capabilities are: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+ep\n$ \n```", "```\n$ make hello_pause\ngcc -Wall   -c -o hello_pause.o hello_pause.c\ngcc -Wall -o hello_pause hello_pause.c common.o\n$ ./hello_pause &\n[1] 14303\nHello, Linux System Programming, World!\n$ ./query_pcap 14303\nProcess  14303 : capabilities are: =\n$ \n```", "```\n$ setcap cap_net_admin,cap_net_raw+ep ./hello_pause\nunable to set CAP_SETFCAP effective capability: Operation not permitted\n$ sudo setcap cap_net_admin,cap_net_raw+ep ./hello_pause\n[sudo] password for <xyz>: xxx\n$ \n```", "```\n$ ./hello_pause &\n[2] 14821\nHello, Linux System Programming, World!\n$ ./query_pcap 14821\nProcess  14821 : capabilities are: = cap_net_admin,cap_net_raw+ep\n$ \n```", "```\n$ getcap /bin/bash\n$ getcap /usr/bin/ping\n/usr/bin/ping = cap_net_admin,cap_net_raw+p\n$ \n```", "```\n$ ls -l /bin/dumpcap\n-rwxr-x---. 1 root wireshark 107K Jan 19 19:45 /bin/dumpcap\n$ getcap /bin/dumpcap\n/bin/dumpcap = cap_net_admin,cap_net_raw+ep\n$ \n```", "```\n# ldd /bin/dumpcap | grep pcap\n    libpcap.so.1 => /lib64/libpcap.so.1 (0x00007f9723c66000)\n# \n```", "```\n #include <sys/capability.h>\n       int cap_set_flag(cap_t cap_p, cap_flag_t flag, int ncap,\n                       const cap_value_t *caps, cap_flag_value_t value);\n```", "```\nint main(int argc, char **argv)\n{\n    int opt, ncap;\n    cap_t mycaps;\n cap_value_t caps2set[2];\n\n    if (argc < 2)\n        usage(argv, EXIT_FAILURE);\n\n    opt = atoi(argv[1]);\n    if (opt != 1 && opt != 2)\n        usage(argv, EXIT_FAILURE);\n\n    /* Simple signal handling for the pause... */\n    [...]\n\n    //--- Set the required capabilities in the Thread Eff capset\n    mycaps = cap_get_proc();\n    if (!mycaps)\n        FATAL(\"cap_get_proc() for CAP_SETUID failed, aborting...\\n\");\n\n    if (opt == 1) {\n        ncap = 1;\n        caps2set[0] = CAP_SETUID;\n    } else if (opt == 2) {\n        ncap = 2;\n        caps2set[1] = CAP_SYS_ADMIN;\n    }\n    if (cap_set_flag(mycaps, CAP_EFFECTIVE, ncap, caps2set,\n               CAP_SET) == -1) {\n        cap_free(mycaps);\n        FATAL(\"cap_set_flag() failed, aborting...\\n\");\n    }\n\n/* For option 1, we need to explicitly CLEAR the CAP_SYS_ADMIN capability; this is because, if we don't, it's still there as it's a file capability embedded into the binary, thus becoming part of the process Eff+Prm capsets. Once cleared, it only shows up in the Prm Not in the Eff capset! */\n    if (opt == 1) {\n        caps2set[0] = CAP_SYS_ADMIN;\n        if (cap_set_flag(mycaps, CAP_EFFECTIVE, 1, caps2set, \n                CAP_CLEAR) == -1) {\n            cap_free(mycaps);\n            FATAL(\"cap_set_flag(clear CAP_SYS_ADMIN) failed, aborting...\\n\");\n        }\n    }\n\n  /* Have the caps take effect on the process.\n  * Without sudo(8) or file capabilities, it fails - as expected.\n  * But, we have set the file caps to CAP_SETUID (in the Makefile),\n  * thus the process gets that capability in it's effective and\n  * permitted capsets (as we do a '+ep'; see below):\"\n     *  sudo setcap cap_setuid,cap_sys_admin+ep ./set_pcap\n     */\n    if (cap_set_proc(mycaps) == -1) {\n        cap_free(mycaps);\n        FATAL(\"cap_set_proc(CAP_SETUID/CAP_SYS_ADMIN) failed, aborting...\\n\",\n                (opt==1?\"CAP_SETUID\":\"CAP_SETUID,CAP_SYS_ADMIN\"));\n    }\n    [...]\n\n    printf(\"Pausing #1 ...\\n\");\n    pause();\n    test_setuid();\n    cap_free(mycaps);\n\n    printf(\"Now dropping all capabilities and reverting to original self...\\n\");\n    drop_caps_be_normal();\n    test_setuid();\n\n    printf(\"Pausing #2 ...\\n\");\n    pause();\n    printf(\".. done, exiting.\\n\");\n    exit (EXIT_SUCCESS);\n}\n```", "```\n$ make set_pcap\ngcc -Wall -o set_pcap set_pcap.c common.o -lcap\nsudo setcap cap_setuid,cap_sys_admin+ep ./set_pcap\n$ getcap ./set_pcap\n./set_pcap = cap_setuid,cap_sys_admin+ep\n$ \n```", "```\n$ ./set_pcap 2 &\n[1] 3981\nPID   3981 now has CAP_SETUID,CAP_SYS_ADMIN capability.\nPausing #1 ...\n$ \n```", "```\n$ ./query_pcap 3981\nProcess   3981 : capabilities are: = cap_setuid,cap_sys_admin+ep\n$ grep -i cap /proc/3981/status \nName:    set_pcap\nCapInh:    0000000000000000\nCapPrm:    0000000000200080\nCapEff:    0000000000200080\nCapBnd:    0000003fffffffff\nCapAmb:    0000000000000000\n$ \n```", "```\n$ kill %1\n*(boing!)*\ntest_setuid:\nRUID = 1000 EUID = 1000\nRUID = 1000 EUID = 0\nNow dropping all capabilities and reverting to original self...\ntest_setuid:\nRUID = 1000 EUID = 1000\n!WARNING! set_pcap.c:test_setuid:55: seteuid(0) failed...\nperror says: Operation not permitted\nRUID = 1000 EUID = 1000\nPausing #2 ...\n$ \n```", "```\nstatic void test_setuid(void)\n{\n    printf(\"%s:\\nRUID = %d EUID = %d\\n\", __FUNCTION__, \n        getuid(), geteuid());\n    if (seteuid(0) == -1)\n        WARN(\"seteuid(0) failed...\\n\");\n    printf(\"RUID = %d EUID = %d\\n\", getuid(), geteuid());\n}\n```", "```\nstatic void drop_caps_be_normal(void)\n{\n    cap_t none;\n\n    /* cap_init() guarantees all caps are cleared */\n    if ((none = cap_init()) == NULL)\n        FATAL(\"cap_init() failed, aborting...\\n\");\n    if (cap_set_proc(none) == -1) {\n        cap_free(none);\n        FATAL(\"cap_set_proc('none') failed, aborting...\\n\");\n    }\n    cap_free(none);\n\n    /* Become your normal true self again! */\n    if (setuid(getuid()) < 0)\n        FATAL(\"setuid to lower privileges failed, aborting..\\n\");\n}\n```", "```\n$ ./query_pcap 3981\nProcess   3981 : capabilities are: =\n$ grep -i cap /proc/3981/status \nName:    set_pcap\nCapInh:    0000000000000000\nCapPrm:    0000000000000000\nCapEff:    0000000000000000\nCapBnd:    0000003fffffffff\nCapAmb:    0000000000000000\n$ \n```"]