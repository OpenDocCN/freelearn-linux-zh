- en: Chapter 5. Building a Root Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建根文件系统
- en: The root filesystem is the fourth and final element of embedded Linux. Once
    you have read this chapter, you will be able build, boot, and run a simple embedded
    Linux system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统是嵌入式Linux的第四个也是最后一个元素。阅读完本章后，您将能够构建、引导和运行一个简单的嵌入式Linux系统。
- en: This chapter explores the fundamental concepts behind the root filesystem by
    building one from scratch. The main aim is to provide the background information
    that you need to understand and make best use of build systems like Buildroot
    and the Yocto Project, which I will cover in [Chapter 6](ch06.html "Chapter 6. Selecting
    a Build System"), *Selecting a Build System*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了通过从头开始构建根文件系统来探索根文件系统背后的基本概念。主要目的是提供您理解和充分利用Buildroot和Yocto Project等构建系统所需的背景信息，我将在[第6章](ch06.html
    "第6章。选择构建系统")*选择构建系统*中进行介绍。
- en: 'The techniques I will describe here are broadly known as **roll your own**
    or **RYO**. Back in the earlier days of embedded Linux, it was the only way to
    create a root filesystem. There are still some use cases where an RYO root filesystem
    is applicable, for example, when the amount of RAM or storage is very limited,
    for quick demonstrations, or for any case in which your requirements are not (easily)
    covered by the standard build system tools. Nevertheless, these cases are quite
    rare. Let me emphasize that the purpose of this chapter is educational, it is
    not meant to be a recipe for building everyday embedded systems: use the tools
    described in the next chapter for that.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里描述的技术通常被称为**自定义**或**RYO**。在嵌入式Linux的早期，这是创建根文件系统的唯一方法。仍然有一些用例适用于RYO根文件系统，例如当RAM或存储量非常有限时，用于快速演示，或者用于任何标准构建系统工具（容易）无法满足您的要求的情况。然而，这些情况非常罕见。让我强调一下，本章的目的是教育性的，而不是为了构建日常嵌入式系统的配方：请使用下一章中描述的工具。
- en: The first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using that as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. Knowing how to
    build the root filesystem from scratch is a useful skill and it will help you
    to understand what is going on when we look at more complex examples in later
    chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目标是创建一个最小的根文件系统，以便给我们一个shell提示符。然后，以此为基础，我们将添加脚本来启动其他程序，并配置网络接口和用户权限。了解如何从头开始构建根文件系统是一项有用的技能，它将帮助您理解我们在后面章节中看到的更复杂的示例时发生了什么。
- en: What should be in the root filesystem?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: The kernel will get a root filesystem, either as a ramdisk, passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line by the `root=` parameter. Once it has a root filesystem, the kernel will
    execute the first program, by default named `init`, as described in the section
    *Early Userspace* in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel*. Then, as far as the kernel
    is concerned, its job is complete. It is up to the `init` program to begin processing
    scripts, start other programs, and so on, by calling system functions in the C
    library, which translate into kernel system calls.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将获得一个根文件系统，可以是ramdisk，从引导加载程序传递的指针，或者通过`root=`参数在内核命令行上挂载的块设备。一旦有了根文件系统，内核将执行第一个程序，默认情况下命名为`init`，如[第4章](ch04.html
    "第4章。移植和配置内核")*移植和配置内核*中的*早期用户空间*部分所述。然后，就内核而言，它的工作就完成了。由`init`程序开始处理脚本，启动其他程序等，调用C库中的系统函数，这些函数转换为内核系统调用。
- en: 'To make a useful system, you need these components as a minimum:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个有用的系统，您至少需要以下组件：
- en: '**init**: The program that starts everything off, usually by running a series
    of scripts.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**init**:通常通过运行一系列脚本来启动一切的程序。'
- en: '**shell**: Needed to give you a command prompt but, more importantly, to run
    the shell scripts called by `init` and other programs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shell**:需要为您提供命令提示符，但更重要的是运行`init`和其他程序调用的shell脚本。'
- en: '**daemons**: Various server programs, started by `init`.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**:由`init`启动的各种服务器程序。'
- en: '**libraries**: Usually, the programs mentioned so far are linked with shared
    libraries which must be present in the root filesystem.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**:通常，到目前为止提到的程序都链接到必须存在于根文件系统中的共享库。'
- en: '**Configuration files**: The configuration for `init` and other daemons is
    stored in a series of ASCII text files, usually in the `/etc` directory.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**: `init`和其他守护程序的配置存储在一系列ASCII文本文件中，通常位于`/etc`目录中。'
- en: '**Device nodes**: The special files that give access to various device drivers.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备节点**:特殊文件，提供对各种设备驱动程序的访问。'
- en: '**/proc and /sys**: Two pseudo filesystems that represent kernel data structures
    as a hierarchy of directories and files. Many programs and library functions read
    these files.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/proc和/sys**:代表内核数据结构的两个伪文件系统，以目录和文件的层次结构表示。许多程序和库函数读取这些文件。'
- en: '**kernel modules**: If you have configured some parts of your kernel to be
    modules, they will be here, usually in `/lib/modules/[kernel version]`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模块**:如果您已经配置了内核的某些部分为模块，它们通常会在`/lib/modules/[kernel version]`中。'
- en: In addition, there are the system application or applications that make the
    device do the job it is intended for, and the runtime end user data that they
    collect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有系统应用程序或应用程序，使设备能够完成其预期工作，并收集它们所收集的运行时最终用户数据。
- en: 'As an aside, it is possible to condense all of the above into a single program.
    You could create a statically linked program that is started instead of `init`
    and runs no others. I have come across such a configuration only once. For example,
    if your program was named `/myprog`, you would put the following command in the
    kernel command line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也有可能将上述所有内容压缩成一个单独的程序。您可以创建一个静态链接的程序，它会在`init`之外启动并且不运行其他程序。我只遇到过这样的配置一次。例如，如果您的程序命名为`/myprog`，您可以将以下命令放在内核命令行中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, if the root filesystem was loaded as a ramdisk, you would put the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果根文件系统被加载为ramdisk，你可以输入以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The downside of this approach is that you can't make use of the many tools that
    normally go into an embedded system; you have to do everything yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是你无法使用通常用于嵌入式系统的许多工具；你必须自己做一切。
- en: Directory layout
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录布局
- en: 'Interestingly, Linux does not care about the layout of files and directories
    beyond the existence of the program named by `init=` or `rdinit=`, so you are
    free to put things wherever you like. As an example, compare the file layout of
    a device running Android to that of a desktop Linux distribution: they are almost
    completely different.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Linux并不关心文件和目录的布局，只要存在由`init=`或`rdinit=`命名的程序，你可以自由地将东西放在任何你喜欢的地方。例如，比较运行安卓的设备的文件布局和桌面Linux发行版的文件布局：它们几乎完全不同。
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout, Android aside. The basic
    layout of a Linux system is defined in the **Filesystem Hierarchy Standard** (**FHS**),
    see the reference at the end of this chapter. The FHS covers all implementations
    of Linux operating systems from the largest to the smallest. Embedded devices
    have a sub-set based on need but it usually includes the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多程序希望某些文件在特定位置，如果设备使用类似的布局，对开发人员有所帮助，除了安卓。Linux系统的基本布局在**文件系统层次结构标准**（**FHS**）中定义，参见本章末尾的参考资料。FHS涵盖了从最大到最小的所有Linux操作系统的实现。嵌入式设备根据需要有一个子集，但通常包括以下内容：
- en: '`/bin`: programs essential for all users'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：所有用户必需的程序'
- en: '`/dev`: device nodes and other special files'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备节点和其他特殊文件'
- en: '`/etc`: system configuration'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：系统配置'
- en: '`/lib`: essential shared libraries, for example, those that make up the C library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：必需的共享库，例如组成C库的那些库'
- en: '`/proc`: the `proc` filesystem'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：`proc`文件系统'
- en: '`/sbin`: programs essential to the system administrator'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：对系统管理员至关重要的程序'
- en: '`/sys`: the `sysfs` filesystem'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`：`sysfs`文件系统'
- en: '`/tmp`: a place to put temporary or volatile files'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：放置临时或易失性文件的地方'
- en: '`/usr`: as a minimum, this should contain the directories `/usr/bin`, `/usr/lib`
    and `/usr/sbin,` which contain additional programs, libraries, and system administrator
    utilities'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：至少应包含目录`/usr/bin`、`/usr/lib`和`/usr/sbin`，其中包含额外的程序、库和系统管理员实用程序'
- en: '`/var`: a hierarchy of files and directories that may be modified at runtime,
    for example, log messages, some of which must be retained after boot'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：可能在运行时被修改的文件和目录的层次结构，例如日志消息，其中一些必须在引导后保留'
- en: 'There are some subtle distinctions here. The difference between `/bin` and
    `/sbin` is simply that `/sbin` need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this. The
    significance of `/usr` is that it may be in a separate partition from the root
    filesystem so it cannot contain anything that is needed to boot the system up.
    That is what essential means in the preceding description: it contains files that
    are needed at boot time and so must be part of the root filesystem.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙的区别。`/bin`和`/sbin`之间的区别仅仅是`/sbin`不需要包含在非root用户的搜索路径中。使用Red Hat衍生的发行版的用户会熟悉这一点。`/usr`的重要性在于它可能在与根文件系统不同的分区中，因此它不能包含任何引导系统所需的内容。这就是前面描述中所说的“必需”的含义：它包含了在引导时需要的文件，因此必须是根文件系统的一部分。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While it might seem like overkill to have four directories to store programs,
    a counter argument would be that it does no harm, and it may even do some good
    because it allows you to store `/usr` in a different filesystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然似乎在四个目录中存储程序有些多余，但反驳的观点是这并没有什么坏处，甚至可能有些好处，因为它允许你将`/usr`存储在不同的文件系统中。
- en: Staging directory
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存目录
- en: 'You should begin by creating a staging directory on your host computer where
    you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in that, for example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先在主机计算机上创建一个暂存目录，在那里你可以组装最终将传输到目标设备的文件。在下面的示例中，我使用了`~/rootfs`。你需要在其中创建一个骨架目录结构，例如：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see the directory hierarchy more clearly you can use the handy `tree` command,
    used in the following example with the `-d` option to show only directories:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地看到目录层次结构，你可以使用方便的`tree`命令，下面的示例中使用了`-d`选项只显示目录：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: POSIX file access permissions
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX文件访问权限
- en: Every process which, in the context of this discussion, means every running
    program, belongs to a user and one or more groups. The user is represented by
    a 32-bit number called the **user ID** or **UID**. Information about users, including
    the mapping from a UID to a name, is kept in `/etc/passwd`. Likewise, groups are
    represented by a **group ID** or **GID**, with information kept in `/etc/group`.
    There is always a root user with a UID of 0 and a root group with a GID of 0\.
    The root user is also called the super-user because, in a default configuration,
    it bypasses most permission checks and can access all the resources in the system.
    Security in Linux-based systems is mainly about restricting access to the root
    account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里讨论的上下文中，每个进程，也就是每个正在运行的程序，都属于一个用户和一个或多个组。用户由一个称为**用户ID**或**UID**的32位数字表示。关于用户的信息，包括从UID到名称的映射，保存在`/etc/passwd`中。同样，组由**组ID**或**GID**表示，信息保存在`/etc/group`中。始终存在一个UID为0的root用户和一个GID为0的root组。root用户也被称为超级用户，因为在默认配置中，它可以绕过大多数权限检查，并且可以访问系统中的所有资源。基于Linux的系统中的安全性主要是关于限制对root账户的访问。
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags, called the mode of the file. There are three collections
    of three bits: the first collection applies to the owner of the file, the second
    to members of the same group as the file, and the last to everyone else, the rest
    of the world. The bits are for read (r), write (w), and execute (x) permissions
    on the file. Since three bits fit neatly into an octal digit, they are usually
    represented in octal, as shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件和目录也都有一个所有者，并且属于一个组。进程对文件或目录的访问级别由一组访问权限标志控制，称为文件的模式。有三组三个位：第一组适用于文件的所有者，第二组适用于与文件相同组的成员，最后一组适用于其他人，即世界其他地方的人。位用于文件的读取（r）、写入（w）和执行（x）权限。由于三个位恰好适合八进制数字，它们通常以八进制表示，如下图所示：
- en: '![POSIX file access permissions](img/B03982_05_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![POSIX文件访问权限](img/B03982_05_01.jpg)'
- en: 'There is a further group of three bits that have special meanings:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组特殊含义的三个位：
- en: '**SUID (4)**: If the file is an executable, change the effective UID of the
    process to that of the owner of the file.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SUID (4)**：如果文件是可执行文件，则将进程的有效UID更改为文件的所有者的UID。'
- en: '**SGID (2)**: If the file is an executable, change the effective GID of the
    process to that of the group of the file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SGID (2)**：如果文件是可执行文件，则将进程的有效GID更改为文件的组的GID。'
- en: '**Sticky (1)**: In a directory, restrict deletion so that one user cannot delete
    files that are owned by another user. This is usually set on `/tmp` and `/var/tmp`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sticky (1)**：在目录中，限制删除，以便一个用户不能删除属于另一个用户的文件。这通常设置在`/tmp`和`/var/tmp`上。'
- en: 'The SUID bit is probably the most often used. It gives non-root users a temporary
    privilege escalation to super-user to perform a task. A good example is the `ping`
    program: `ping` opens a raw socket which is a privileged operation. In order for
    normal users to use `ping`, it is normally owned by the root and has the SUID
    bit set so that, when you run `ping`, it executes with UID 0 regardless of your
    UID.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SUID位可能是最常用的。它为非root用户提供了临时特权升级到超级用户以执行任务。一个很好的例子是`ping`程序：`ping`打开一个原始套接字，这是一个特权操作。为了让普通用户使用`ping`，通常由root拥有并设置了SUID位，这样当您运行`ping`时，它将以UID
    0执行，而不管您的UID是多少。
- en: 'To set these bits, use the octal numbers, 4, 2, 1, with the `chmod` command.
    For example, to set SUID on `/bin/ping` in your staging root directory, you could
    use the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这些位，请使用八进制数字4、2、1和`chmod`命令。例如，要在您的暂存根目录中设置`/bin/ping`的SUID，您可以使用以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note the `s` in the last file listing: that is the indication that SUID is
    set.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意最后一个文件列表中的`s`：这表明设置了SUID。
- en: File ownership permissions in the staging directory
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂存目录中的文件所有权权限
- en: For security and stability reasons, it is vitally important to pay attention
    to the ownership and permissions of the files that will be placed on the target
    device. Generally speaking, you want to restrict sensitive resources to be accessible
    only by the root and to run as many of the programs using non-root users so that,
    if they are compromised by an outside attack, they offer as few system resources
    to the attacker as possible. For example, the device node `/dev/mem` gives access
    to system memory, which is necessary in some programs. But, if it is readable
    and writeable by everyone, then there is no security because everyone can access
    everything. So `/dev/mem` should be owned by root, belong to the root group and
    have a mode of 600, which denies read and write access to all but the owner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全和稳定性原因，非常重要的是要注意将要放置在目标设备上的文件的所有权和权限。一般来说，您希望将敏感资源限制为只能由root访问，并尽可能多地使用非root用户运行程序，以便如果它们受到外部攻击，它们尽可能少地向攻击者提供系统资源。例如，设备节点`/dev/mem`提供对系统内存的访问，这在某些程序中是必要的。但是，如果它可以被所有人读取和写入，那么就没有安全性，因为每个人都可以访问一切。因此，`/dev/mem`应该由root拥有，属于root组，并且具有600的模式，这样除了所有者之外，其他人都无法读取和写入。
- en: 'There is a problem with the staging directory though. The files you create
    there will be owned by you but, when they are installed on the device, they should
    belong to specific owners and groups, mostly the root user. An obvious fix is
    to change the ownership at this stage with the command shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，暂存目录存在问题。您在那里创建的文件将归您所有，但是，当它们安装到设备上时，它们应该属于特定的所有者和组，主要是root用户。一个明显的修复方法是使用以下命令在此阶段更改所有权：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The problem is that you need root privileges to run that command and, from that
    point onward, you will need to be root to modify any files in the staging directory.
    Before you know it, you are doing all your development logged on as root, which
    is not a good idea. This is a problem that we will come back to later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是您需要root权限来运行该命令，并且从那时起，您将需要root权限来修改暂存目录中的任何文件。在您知道之前，您将以root身份进行所有开发，这不是一个好主意。这是我们稍后将回头解决的问题。
- en: Programs for the root filesystem
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统的程序
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files that it needs to operate,
    beginning with an overview of the types of program you will need.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始用必要的程序和支持库、配置和数据文件填充根文件系统了，首先概述您将需要的程序类型。
- en: The init program
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: init程序
- en: 'You have seen in the previous chapter that `init` is the first program to be
    run and so has PID 1\. It runs as the root user and so has maximum access to system
    resources. Usually, it runs shell scripts which start daemons: a daemon is a program
    that runs in the background with no connection to a terminal, in other places
    it would be called a server program.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您在上一章中已经看到`init`是第一个要运行的程序，因此具有PID 1。它以root用户身份运行，因此对系统资源具有最大访问权限。通常，它运行启动守护程序的shell脚本：守护程序是在后台运行且与终端没有连接的程序，在其他地方可能被称为服务器程序。
- en: Shell
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell
- en: 'We need a shell to run scripts and to give us a command-line prompt so that
    we can interact with the system. An interactive shell is probably not necessary
    in a production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use in embedded systems:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个shell来运行脚本，并给我们一个命令行提示符，以便我们可以与系统交互。在生产设备中可能不需要交互式shell，但它对开发、调试和维护非常有用。嵌入式系统中常用的各种shell有：
- en: '`bash`: is the big beast that we all know and love from desktop Linux. It is
    a superset of the Unix Bourne shell, with many extensions or *bashisms*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`：是我们从桌面Linux中熟悉和喜爱的大型工具。它是Unix Bourne shell的超集，具有许多扩展或*bashisms*。'
- en: '`ash`: also based on the Bourne shell, and has a long history with the BSD
    variants of Unix. Busybox has a version of ash which has been extended to make
    it more compatible with `bash`. It is much smaller than `bash` and hence is a
    very popular choice for embedded systems.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ash`：也基于Bourne shell，并且在Unix的BSD变体中有着悠久的历史。Busybox有一个ash的版本，已经扩展以使其与`bash`更兼容。它比`bash`小得多，因此是嵌入式系统的非常受欢迎的选择。'
- en: '`hush`: is a very small shell that we briefly looked at in the chapter on bootloaders.
    It is useful on devices with very little memory. There is a version in BusyBox.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hush`：是一个非常小的shell，在引导加载程序章节中我们简要介绍过。它在内存非常少的设备上非常有用。BusyBox中有一个版本。'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host, using `bash`, and then be surprised that they don't work when you
    copy them to the target.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在目标上使用`ash`或`hush`作为shell，请确保在目标上测试您的shell脚本。很容易只在主机上测试它们，使用`bash`，然后当您将它们复制到目标时发现它们无法工作。
- en: Utilities
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用程序
- en: The shell is just a way of launching other programs and a shell script is little
    more than a list of programs to run, with some flow control and a means of passing
    information between programs. To make a shell useful, you need the utility programs
    that the Unix command-line is based on. Even for a basic root filesystem, there
    are approximately 50 utilities, which presents two problems. Firstly, tracking
    down the source code for each and cross compiling it would be quite a big job.
    Secondly, the resulting collection of programs would take up several tens of megabytes,
    which was a real problem in the early days of embedded Linux when a few megabytes
    was all you had. To solve this problem, BusyBox was born.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: shell只是启动其他程序的一种方式，shell脚本只不过是要运行的程序列表，带有一些流程控制和在程序之间传递信息的手段。要使shell有用，您需要基于Unix命令行的实用程序。即使对于基本的根文件系统，也有大约50个实用程序，这带来了两个问题。首先，追踪每个程序的源代码并进行交叉编译将是一项相当大的工作。其次，由此产生的程序集将占用数十兆字节的空间，在嵌入式Linux的早期阶段，几兆字节就是一个真正的问题。为了解决这个问题，BusyBox诞生了。
- en: BusyBox to the rescue!
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BusyBox来拯救！
- en: The genesis of BusyBox had nothing to do with embedded Linux. The project was
    instigated in 1996 by Bruce Perens for the Debian installer so that he could boot
    Linux from a 1.44 MB floppy disk. Coincidentally, that was about the size of the
    storage on contemporary devices and so the embedded Linux community quickly took
    it up. BusyBox has been at the heart of embedded Linux ever since.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox的起源与嵌入式Linux无关。该项目是由Bruce Perens于1996年发起的，用于Debian安装程序，以便他可以从1.44 MB软盘启动Linux。巧合的是，当时的设备存储容量大约是这个大小，因此嵌入式Linux社区迅速接受了它。从那时起，BusyBox一直是嵌入式Linux的核心。
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80:20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functions of the desktop equivalents, but they
    do enough to be useful in the majority of cases.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox是从头开始编写的，以执行这些基本Linux实用程序的基本功能。开发人员利用了80:20规则：程序最有用的80%在代码的20%中实现。因此，BusyBox工具实现了桌面等效工具功能的子集，但它们足够在大多数情况下使用。
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its main function in the form
    `[applet]_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The main function of BusyBox itself dispatches the call
    to the correct applet based on the command-line arguments.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox采用的另一个技巧是将所有工具合并到一个单一的二进制文件中，这样可以很容易地在它们之间共享代码。它的工作原理是这样的：BusyBox是一组小工具，每个小工具都以`[applet]_main`的形式导出其主要函数。例如，`cat`命令是在`coreutils/cat.c`中实现的，并导出`cat_main`。BusyBox本身的主函数根据命令行参数将调用分派到正确的小工具。
- en: 'So, to read a file, you can launch `busybox` with the name of the applet you
    want to run, followed by any arguments the applet expects, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要读取文件，您可以启动`busybox`，后面跟上您想要运行的小工具的名称，以及小工具期望的任何参数，如下所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also run `busybox` with no arguments to get a list of all the applets
    that have been compiled.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行`busybox`而不带任何参数，以获取已编译的所有小工具的列表。
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用BusyBox相当笨拙。让BusyBox运行`cat`小工具的更好方法是创建一个从`/bin/cat`到`/bin/busybox`的符号链接。
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you type `cat` at the command line, `busybox` is the program that actually
    runs. BusyBox only has to check the command tail passed in `argv[0]`, which will
    be `/bin/cat`, extract the application name, `cat`, and do a table look-up to
    match `cat` with `cat_main`. All this is in `libbb/appletlib.c` in this section
    of code (slightly simplified):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在命令行输入`cat`时，实际运行的程序是`busybox`。BusyBox只需要检查传递给`argv[0]`的命令尾部，它将是`/bin/cat`，提取应用程序名称`cat`，并进行表查找以匹配`cat`与`cat_main`。所有这些都在`libbb/appletlib.c`中的这段代码中（稍微简化）：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: BusyBox has over three hundred applets including an `init` program, several
    shells of varying levels of complexity, and utilities for most admin tasks. There
    is even a simple version of the `vi` editor so you can change text files on your
    device.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox有300多个小程序，包括一个`init`程序，几个不同复杂级别的shell，以及大多数管理任务的实用程序。甚至还有一个简化版的`vi`编辑器，这样你就可以在设备上更改文本文件。
- en: To summarize, a typical installation of BusyBox consists of a single program
    with a symbolic link for each applet, but which behaves exactly as if it were
    a collection of individual applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，BusyBox的典型安装包括一个程序和每个小程序的符号链接，但它的行为就像是一个独立应用程序的集合。
- en: Building BusyBox
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建BusyBox
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system of the kernel, so cross
    compiling is straightforward. You can get the source by cloning the git archive
    and checking out the version you want (1_24_1 was the latest at the time of writing),
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox使用与内核相同的`Kconfig`和`Kbuild`系统，因此交叉编译很简单。你可以通过克隆git存档并检出你想要的版本（写作时最新的是1_24_1）来获取源代码，就像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also download the corresponding `tarball` file from [http://busybox.net/downloads](http://busybox.net/downloads).
    Then, configure BusyBox, starting in this case with the default configuration,
    which enables pretty much all of the features of BusyBox:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从[http://busybox.net/downloads](http://busybox.net/downloads)下载相应的`tarball`文件。然后，配置BusyBox，从默认配置开始，这样可以启用几乎所有BusyBox的功能：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, you probably want to run `make menuconfig` to fine tune the
    configuration. You almost certainly want to set the install path in **Busybox
    Settings** | **Installation Options** (`CONFIG_PREFIX`) to point to the staging
    directory. Then, you can cross compile in the usual way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想要运行`make menuconfig`来微调配置。你几乎肯定想要在**Busybox Settings** | **Installation
    Options** (`CONFIG_PREFIX`)中设置安装路径，指向暂存目录。然后，你可以像通常一样进行交叉编译：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is the executable, `busybox`. For a `defconfig` build for ARM v7a,
    it comes out at about 900 KiB. If that is too big for you, you can slim it down
    by configuring out the utilities you don't need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是可执行文件`busybox`。对于ARM v7a的`defconfig`构建，它的大小约为900 KiB。如果这对你来说太大了，你可以通过配置掉你不需要的实用程序来减小它。
- en: 'To install BusyBox, use the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装BusyBox，请使用以下命令：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will copy the binary to the directory configured in `CONFIG_PREFIX` and
    create all the symbolic links to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把二进制文件复制到`CONFIG_PREFIX`配置的目录，并创建所有的符号链接。
- en: ToyBox – an alternative to BusyBox
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToyBox - BusyBox的替代品
- en: BusyBox is not the only game in town. For example, Android has an equivalent
    named Toolbox, but it is more tuned to the needs of Android and not useful in
    a general purpose embedded environment. A more useful option is ToyBox, a project
    started and maintained by Rob Landley, who was previously a maintainer of BusyBox.
    ToyBox has the same aim as BusyBox, but with more emphasis on complying with standards,
    especially POSIX-2008 and LSB 4.1, and less on compatibility with GNU extensions
    to those standards. ToyBox is smaller than BusyBox, partly because it implements
    fewer applets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox并不是唯一的选择。例如，Android有一个名为Toolbox的等效工具，但它更适合Android的需求，对于一般嵌入式环境没有用。一个更有用的选择是ToyBox，这是一个由Rob
    Landley发起和维护的项目，他以前是BusyBox的维护者。ToyBox的目标与BusyBox相同，但更注重遵守标准，特别是POSIX-2008和LSB
    4.1，而不是与GNU对这些标准的扩展的兼容性。ToyBox比BusyBox小，部分原因是它实现的小程序更少。
- en: However, the main difference is the license, BSD rather than GPL v2, which makes
    it license-compatible with operating systems with a BSD-licensed user space, such
    as Android itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，主要的区别是许可证，是BSD而不是GPL v2，这使它与具有BSD许可的用户空间的操作系统兼容，比如Android本身。
- en: Libraries for the root filesystem
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统的库
- en: Programs are linked with libraries. You could link them all statically, in which
    case, there would be no libraries on the target device. But, that takes up an
    unnecessarily large amount of storage if you have more than two or three programs.
    So, you need to copy shared libraries from the toolchain to the staging directory.
    How do you know which libraries?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序与库链接。你可以将它们全部静态链接，这样目标设备上就不会有库了。但是，如果你有两三个以上的程序，这将占用不必要的大量存储空间。所以，你需要将共享库从工具链复制到暂存目录。你怎么知道哪些库？
- en: One option is to copy all of them since they must be of some use, otherwise
    they wouldn't exist! That is certainly logical and, if you are creating a platform
    to be used by others for a range of applications, that would be the correct approach.
    Be aware, though, that a full `glibc` is quite large. In the case of a CrossTool-NG
    build of `glibc` 2.19, the space taken by `/lib` and `/usr/lib` is 33 MiB. Of
    course, you could cut down on that considerably by using uClibc or Musel `libc`
    libraries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将它们全部复制，因为它们肯定有些用处，否则它们就不会存在！这当然是合乎逻辑的，如果你正在为他人用于各种应用程序的平台创建一个平台，那么这将是正确的方法。但要注意，一个完整的`glibc`相当大。在CrossTool-NG构建的`glibc`
    2.19的情况下，`/lib`和`/usr/lib`占用的空间为33 MiB。当然，你可以通过使用uClibc或Musel `libc`库大大减少这个空间。
- en: 'Another option is to cherry pick only those libraries that you require, for
    which you need a means of discovering library dependencies. Using some of our
    knowledge from [Chapter 2](ch02.html "Chapter 2. Learning About Toolchains"),
    *Learning About Toolchains* libraries, you can use `readelf` for that task:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是只挑选你需要的那些库，为此你需要一种发现库依赖关系的方法。使用我们从[第2章](ch02.html "第2章。了解工具链")中的一些知识，*了解工具链*库，你可以使用`readelf`来完成这个任务：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now you need to find these files in the toolchain and copy them to the staging
    directory. Remember that you can find `sysroot` like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在工具链中找到这些文件，并将它们复制到暂存目录。记住你可以这样找到`sysroot`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To reduce the amount of typing, I am going to keep a copy of that in a shell
    variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入量，我将把它保存在一个shell变量中：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you look at `/lib/ld-linux-armhf.so.3,` in `sysroot`, you will see that,
    it is, in fact, a symbolic link:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`sysroot`中查看`/lib/ld-linux-armhf.so.3`，你会发现，它实际上是一个符号链接：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Repeat the exercise for `libc.so.6` and `libm.so.6` and you will end up with
    a list of three files and three symbolic links. Copy them using `cp -a`, which
    will preserve the symbolic link:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对`libc.so.6`和`libm.so.6`重复此操作，您将得到三个文件和三个符号链接的列表。使用`cp -a`进行复制，这将保留符号链接：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeat this procedure for each program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个程序重复此过程。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls - plugins mostly. We will look at an example with the NSS libraries when
    we come to configure network interfaces later on in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做只有在获取最小的嵌入式占用空间时才值得。有可能会错过通过`dlopen(3)`调用加载的库，主要是插件。我们将在本章后面配置网络接口时，通过NSS库的示例来说明。
- en: Reducing size by stripping
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过剥离来减小尺寸
- en: 'Libraries and programs are often compiled with a symbol table information built
    in, more so if you have compiled with the debug switch, `-g`. You seldom need
    these on the target. A quick and easy way to save space is to strip them. This
    example shows `libc` before and after stripping:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，库和程序都会编译时内置符号表信息，如果使用了调试开关`-g`，则更多。您很少需要这些信息。节省空间的一种快速简单的方法是剥离它们。此示例显示了剥离前后的`libc`：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we saved 321,347 bytes, which was about 20%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们节省了321,347字节，大约为20%。
- en: 'When stripping kernel modules, use the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在剥离内核模块时，使用以下命令：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, you will strip out the symbols needed to relocate the module code
    and it will fail to load.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您将剥离重定位模块代码所需的符号，导致加载失败。
- en: Device nodes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备节点
- en: Most devices in Linux are represented by device nodes, in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else, once again with the exception of network
    interfaces. The conventional location for device nodes is the directory `/dev`.
    For example, a serial port may be represented by the device node `/dev/ttyS0`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的大多数设备都由设备节点表示，符合Unix哲学的*一切皆文件*（除了网络接口，它们是套接字）。设备节点可能是块设备或字符设备。块设备是诸如SD卡或硬盘等大容量存储设备。字符设备基本上是其他任何东西，再次除了网络接口。设备节点的传统位置是目录`/dev`。例如，串行端口可以由设备节点`/dev/ttyS0`表示。
- en: 'Device nodes are created using the program `mknod` (short for make node):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序`mknod`（缩写为make node）创建设备节点：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`name` is the name of the device node that you want to create, `type` is either,
    `c` for character devices, and `b` for block. They each have a major number and
    a minor number which is used by the kernel to route file requests to the appropriate
    device driver code. There is a list of standard major and minor numbers in the
    kernel source in `Documentation/devices.txt`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`是您要创建的设备节点的名称，`type`可以是`c`表示字符设备，`b`表示块设备。它们各自有一个主要号和次要号，内核使用这些号码将文件请求路由到适当的设备驱动程序代码。内核源代码中有一个标准主要和次要号的列表，位于`Documentation/devices.txt`中。'
- en: You will need to create device nodes for all the devices you want to access
    on your system. You can do that manually by using the `mknod` command as I will
    illustrate here, or you can use one of the device managers mentioned later to
    create them automatically, at runtime.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为系统上要访问的所有设备创建设备节点。您可以手动使用`mknod`命令来执行此操作，就像我在这里所示的那样，或者您可以使用稍后提到的设备管理器之一来在运行时自动创建它们。
- en: 'You need just two nodes to boot with BusyBox: `console` and `null`. The console
    only needs to be accessible to root, the owner of the device node, so the access
    permissions are 600\. The null device should be readable and writable by everyone,
    so the mode is 666\. You can use the `-m` option to `mknod` to set the mode when
    creating the node. You need to be root to create a device node:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BusyBox启动只需要两个节点：`console`和`null`。控制台只需要对root可访问，设备节点的所有者，因此访问权限为600。空设备应该对所有人可读可写，因此模式为666。您可以使用`mknod`的`-m`选项在创建节点时设置模式。您需要是root才能创建设备节点：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You delete device nodes by using the standard `rm` command: there is no `rmnod`
    command because, once created, they are just files.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的`rm`命令删除设备节点：没有`rmnod`命令，因为一旦创建，它们就是普通文件。
- en: The proc and sysfs filesystems
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: proc和sysfs文件系统
- en: '`proc` and `sysfs` are two pseudo filesystems that give a window onto the inner
    workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories: when you read one of the files, the contents you see do not come
    from disk storage, it has been formatted on-the-fly by a function in the kernel.
    Some files are also writable, meaning that a kernel function is called with the
    new data you have written and, if it is of the correct format and you have sufficient
    permissions, it will modify the value stored in the kernel''s memory. In other
    works, `proc` and `sysfs` provide another way to interact with device drivers
    and other kernel code.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`和`sysfs`是两个伪文件系统，它们提供了内核内部工作的窗口。它们都将内核数据表示为目录层次结构中的文件：当您读取其中一个文件时，您看到的内容并不来自磁盘存储，而是由内核中的一个函数即时格式化的。一些文件也是可写的，这意味着将调用内核函数并使用您写入的新数据，如果格式正确且您有足够的权限，它将修改内核内存中存储的值。换句话说，`proc`和`sysfs`提供了另一种与设备驱动程序和其他内核代码交互的方式。'
- en: '`proc` and `sysfs` should be mounted on the directories `/proc` and `/sys`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`和`sysfs`应该挂载在目录`/proc`和`/sys`上：'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although they are very similar in concept, they perform different functions.
    `proc` has been part of Linux since the early days. Its original purpose was to
    expose information about processes to user space, hence the name. To this end,
    there is a directory for each process named `/proc/<PID>` which contains information
    about its state. The process list command, `ps`, reads these files to generate
    its output. In addition, there are files that give information about other parts
    of the kernel, for example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts`
    has information about interrupts, and so on. Finally, in `/proc/sys`, there are
    files that display and control the state and behavior of kernel sub-systems, especially
    scheduling, memory management, and networking. The best reference for the files
    you will find in `proc` is man page `proc(5)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在概念上非常相似，但它们执行不同的功能。`proc`从Linux的早期就存在。它的最初目的是向用户空间公开有关进程的信息，因此得名。为此，有一个名为`/proc/<PID>`的目录，其中包含有关其状态的信息。进程列表命令`ps`读取这些文件以生成其输出。此外，还有一些文件提供有关内核其他部分的信息，例如`/proc/cpuinfo`告诉您有关CPU的信息，`/proc/interrupts`包含有关中断的信息，等等。最后，在`/proc/sys`中，有一些文件显示和控制内核子系统的状态和行为，特别是调度、内存管理和网络。有关您将在`proc`中找到的文件的最佳参考是`proc(5)`手册页。
- en: In fact, over time, the number of files in `proc` and their layout has become
    rather chaotic. In Linux 2.6, `sysfs` was introduced to export a subset of the
    data in an ordered way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，随着时间的推移，`proc`中的文件数量及其布局变得相当混乱。在Linux 2.6中，`sysfs`被引入以有序方式导出数据的子集。
- en: In contrast, `sysfs` exports a very ordered hierarchy of files relating to devices
    and the way they are connected to each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`sysfs`导出了一个与设备及其相互连接方式相关的文件的有序层次结构。
- en: Mounting filesystems
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the root filesystem. The format of the
    `mount` command is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令允许我们将一个文件系统附加到另一个文件系统中的目录，形成文件系统的层次结构。在顶部被内核挂载时，称为根文件系统。`mount`命令的格式如下：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You need to specify the type of the filesystem, `vfstype`, the block device
    node it resides on, and the directory you want to mount it to. There are various
    options you can give after the `-o`, have a look at the manual for more information.
    As an example, if you want to mount an SD card containing an `ext4` filesystem
    in the first partition onto directory `/mnt`, you would type the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指定文件系统的类型`vfstype`，它所在的块设备节点，以及您要将其挂载到的目录。在`-o`之后，您可以给出各种选项，更多信息请参阅手册。例如，如果您想要将包含`ext4`文件系统的SD卡的第一个分区挂载到目录`/mnt`，您可以输入以下内容：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Assuming the mount succeeds, you would be able to see the files stored on the
    SD card in the directory `/mnt`. In some cases, you can leave out the filesystem
    type and let the kernel probe the device to find out what is stored there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设挂载成功，您将能够在目录`/mnt`中看到存储在SD卡上的文件。在某些情况下，您可以省略文件系统类型，让内核探测设备以找出存储的内容。
- en: 'Looking at the example of mounting the `proc` filesystem, there is something
    odd: there is no device node, `/dev/proc`, since it is a pseudo filesystem, not
    a real one. But the `mount` command requires a device as a parameter. Consequently
    we have to give a string where the device should go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看挂载`proc`文件系统的例子，有一些奇怪的地方：没有设备节点`/dev/proc`，因为它是一个伪文件系统，而不是一个真正的文件系统。但`mount`命令需要一个设备作为参数。因此，我们必须提供一个字符串来代替设备，但这个字符串是什么并不重要。这两个命令实现了完全相同的结果：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is fairly common to use the filesystem type in the place of the device when
    mounting pseudo filesystems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载伪文件系统时，通常在设备的位置使用文件系统类型。
- en: Kernel modules
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you have kernel modules, they need to be installed into the root filesystem,
    using the kernel `make modules_install` target, as we saw in the last chapter.
    This will copy them into the directory `/lib/modules/<kernel version>` together
    with the configuration files needed by the `modprobe` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有内核模块，它们需要安装到根文件系统中，使用内核`make modules_install`目标，就像我们在上一章中看到的那样。这将把它们复制到目录`/lib/modules/<kernel
    version>`中，以及`modprobe`命令所需的配置文件。
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, you will have to update the other.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您刚刚在内核和根文件系统之间创建了一个依赖关系。如果您更新其中一个，您将不得不更新另一个。
- en: Transfering the root filesystem to the target
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标位置
- en: 'Having created a skeleton root filesystem in your staging directory, the next
    task is to transfer it to the target. In the sections that follow, I will describe
    three possibilities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存目录中创建了一个骨架根文件系统后，下一个任务是将其传输到目标位置。在接下来的章节中，我将描述三种可能性：
- en: '**ramdisk**: a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fall-back maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in small embedded
    devices and, of course, as the early user space in mainstream Linux distributions.
    A compressed ramdisk uses the minimum amount of storage but still consumes RAM.
    The contents are volatile so you need another storage type to store permanent
    data such as configuration parameters.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ramdisk**：由引导加载到RAM中的文件系统映像。Ramdisks易于创建，并且不依赖于大容量存储驱动程序。当主根文件系统需要更新时，它们可以用于后备维护模式。它们甚至可以用作小型嵌入式设备的主根文件系统，当然也可以用作主流Linux发行版中的早期用户空间。压缩的ramdisk使用最少的存储空间，但仍然消耗RAM。内容是易失性的，因此您需要另一种存储类型来存储永久数据，例如配置参数。'
- en: '**disk image**: a copy of the root filesystem formatted and ready to be loaded
    onto a mass storage device on the target. For example, it could be an image in
    `ext4` format ready to be copied onto an SD card, or it could be in `jffs2` format
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘映像**：根文件系统的副本，格式化并准备好加载到目标设备的大容量存储设备上。例如，它可以是一个`ext4`格式的映像，准备好复制到SD卡上，或者它可以是一个`jffs2`格式的映像，准备好通过引导加载到闪存中。创建磁盘映像可能是最常见的选项。有关不同类型的大容量存储的更多信息，请参阅[第7章](ch07.html
    "第7章 创建存储策略")，“创建存储策略”。'
- en: '**network filesystem**: the staging directory can be exported to the network
    via an NFS server and mounted by the target at boot-time. This is often done during
    the development phase in preference to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which is quite a slow process.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统**：暂存目录可以通过NFS服务器导出到网络，并在启动时由目标设备挂载。在开发阶段通常会这样做，而不是重复创建磁盘映像并重新加载到大容量存储设备上，这是一个相当慢的过程。'
- en: I will start with ramdisk and use it to illustrate a few refinements to the
    root filesystem, like adding user names and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and, finally,
    how to use NFS to mount the root filesystem over a network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从ramdisk开始，并用它来说明对根文件系统的一些改进，比如添加用户名和设备管理器以自动创建设备节点。然后，我将向您展示如何创建磁盘映像，最后，如何使用NFS在网络上挂载根文件系统。
- en: Creating a boot ramdisk
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建引导ramdisk
- en: A Linux boot ramdisk, strictly speaking, an **initial RAM filesystem** or **initramfs**,
    is a compressed `cpio` archive. `cpio` is an old Unix archive format, similar
    to TAR and ZIP but easier to decode and so requiring less code in the kernel.
    You need to configure your kernel with `CONFIG_BLK_DEV_INITRD` to support `initramfs`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Linux引导ramdisk，严格来说，是一个**初始RAM文件系统**或**initramfs**，是一个压缩的`cpio`存档。`cpio`是一个古老的Unix存档格式，类似于TAR和ZIP，但更容易解码，因此在内核中需要更少的代码。您需要配置内核以支持`initramfs`的`CONFIG_BLK_DEV_INITRD`。
- en: 'In fact, there are three different ways to create a boot ramdisk: as a standalone
    `cpio` archive, as a `cpio` archive embedded in the kernel image, and as a device
    table which the kernel build system processes as part of the build. The first
    option gives the most flexibility because we can mix and match kernels and ramdisks
    to our hearts content. However, it means that you have two files to deal with
    instead of one and not all bootloaders have the facility to load a separate ramdisk.
    I will show you how to build one into the kernel later.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有三种不同的方法可以创建引导ramdisk：作为一个独立的`cpio`存档，作为嵌入在内核映像中的`cpio`存档，以及作为内核构建系统在构建过程中处理的设备表。第一种选项提供了最大的灵活性，因为我们可以随心所欲地混合和匹配内核和ramdisk。但是，这意味着您需要处理两个文件而不是一个，并且并非所有的引导加载程序都具有加载单独ramdisk的功能。稍后我将向您展示如何将其构建到内核中。
- en: Standalone ramdisk
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的ramdisk
- en: 'The following sequence of instructions creates the archive, compresses it and
    adds a U-Boot header ready for loading onto the target:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列指令创建存档，对其进行压缩，并添加一个U-Boot标头，以便加载到目标设备上：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we ran `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier, making everything in the
    `cpio` file UID and GID 0.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`cpio`选项`--owner root:root`。这是对前面提到的文件所有权问题的一个快速修复，使`cpio`文件中的所有内容的UID和GID都为0。
- en: 'The final size of the `uRamdisk` file is ~ 2.9 MiB, with no kernel modules.
    Add to that 4.4 MiB for the kernel `zImage` file, and 440 KiB for U-Boot and this
    gives a total of 7.7 MiB of storage needed to boot this board. We are a little
    way off the 1.44 MiB floppy that started it all off. If size was a real problem,
    you could use one of these options:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`uRamdisk`文件的最终大小约为2.9 MiB，没有内核模块。再加上内核`zImage`文件的4.4 MiB，以及U-Boot的440 KiB，总共需要7.7
    MiB的存储空间来引导此板。我们离最初的1.44 MiB软盘还有一段距离。如果大小是一个真正的问题，您可以使用以下选项之一：'
- en: Make the kernel smaller by leaving out drivers and functions you don't need
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过留出您不需要的驱动程序和功能，使内核变得更小
- en: Make BusyBox smaller by leaving out utilities you don't need
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过留出您不需要的实用程序，使BusyBox变得更小
- en: Use uClibc or musl libc in place of glibc
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用uClibc或musl libc代替glibc
- en: Compile BusyBox statically
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态编译BusyBox
- en: Booting the ramdisk
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导ramdisk
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the device. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. Now, you can boot the device.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的事情是在控制台上运行一个shell，以便与设备进行交互。我们可以通过将`rdinit=/bin/sh`添加到内核命令行来实现这一点。现在，您可以引导设备。
- en: Booting with QEMU
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QEMU引导
- en: 'QEMU has the option `-initrd` to load `initframfs` into memory, so the full
    command is now as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU有`-initrd`选项，可以将`initframfs`加载到内存中，因此完整的命令现在如下所示：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Booting the BeagleBone Black
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导BeagleBone Black
- en: 'To boot the BeagleBone Black, boot to the U-Boot prompt and enter these commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动BeagleBone Black，请引导到U-Boot提示符，并输入以下命令：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If all goes well, you will get a root shell prompt on the console.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将在控制台上获得一个根shell提示符。
- en: Mounting proc
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载proc
- en: 'Note that the `ps` command doesn''t work: that is because the `proc` filesystem
    has not been mounted yet. Try mounting it and run `ps` again.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ps`命令不起作用：这是因为`proc`文件系统尚未被挂载。尝试挂载它，然后再次运行`ps`。
- en: 'A refinement to this setup is to write a shell script that contains things
    that need to be done at boot-up and give that as the parameter to `rdinit=`. The
    script would look like the following snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对此设置的一个改进是编写一个包含需要在启动时执行的内容的shell脚本，并将其作为`rdinit=`的参数。脚本将类似于以下代码片段：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a shell as `init` in this way is very handy for quick hacks, for example,
    when you want to rescue a system with a broken `init` program. However, in most
    cases, you would use an `init` program, which we will cover further down.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用shell作为`init`对于快速修补非常方便，例如，当您想要修复带有损坏`init`程序的系统时。但是，在大多数情况下，您将使用一个`init`程序，我们将在后面进一步介绍。
- en: Building a ramdisk cpio into the kernel image
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ramdisk cpio构建到内核映像中
- en: In some cases, it is preferable to build the ramdisk into the kernel image,
    for example, if the bootloader cannot handle a ramdisk file. To do this, change
    the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full path of
    the `cpio` archive you created earlier. If you are using `menuconfig`, it is in
    **General setup** | **Initramfs source file(s)**. Note that it has to be the uncompressed
    `cpio` file ending in `.cpio`; not the gzipped version. Then, build the kernel.
    You should see that it is larger than before.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，最好将ramdisk构建到内核映像中，例如，如果引导加载程序无法处理ramdisk文件。要做到这一点，更改内核配置并将`CONFIG_INITRAMFS_SOURCE`设置为您之前创建的`cpio`存档的完整路径。如果您使用`menuconfig`，它在**常规设置**
    | **Initramfs源文件**中。请注意，它必须是以`.cpio`结尾的未压缩`cpio`文件；而不是经过gzip压缩的版本。然后，构建内核。您应该看到它比以前大。
- en: 'Booting is the same as before, except that there is no ramdisk file. For QEMU,
    the command is like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 引导与以前相同，只是没有ramdisk文件。对于QEMU，命令如下：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the BeagleBone Black, enter these commands into U-Boot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeagleBone Black，将这些命令输入U-Boot：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, you must remember to rebuild the kernel each time you change the
    contents of the ramdisk and regenerate the `.cpio` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您必须记住每次更改ramdisk的内容并重新生成`.cpio`文件时都要重新构建内核。
- en: Another way to build a kernel with ramdisk
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种构建带有ramdisk的内核的方法
- en: An interesting way to build the ramdisk into the kernel image is by using a
    **device table** to generate a `cpio` archive. A `device table` is a text file
    which lists the files, directories, device nodes, and links that go into the archive.
    The overwhelming advantage is that you can create entries in the `cpio` file that
    are owned by root, or any other UID, without having root privileges yourself.
    You can even create device nodes. All this is possible because the archive is
    just a data file. It is only when it is expanded by Linux at boot time that real
    files and directories get created, using the attributes you have specified.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将ramdisk构建到内核映像中的一个有趣的方法是使用**设备表**生成`cpio`存档。`设备表`是一个文本文件，列出了存档中包含的文件、目录、设备节点和链接。压倒性的优势在于，您可以在`cpio`文件中创建属于root或任何其他UID的条目，而无需自己拥有root权限。您甚至可以创建设备节点。所有这些都是可能的，因为存档只是一个数据文件。只有在Linux在引导时扩展它时，才会使用您指定的属性创建真实的文件和目录。
- en: 'Here is a device table for our simple `rootfs`, but missing most of the symbolic
    links to `busybox` to make it manageable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们简单的`rootfs`的设备表，但缺少大部分到`busybox`的符号链接，以便更易管理：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The syntax is fairly obvious:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 语法相当明显：
- en: '`dir <name> <mode> <uid> <gid>`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir <name> <mode> <uid> <gid>`'
- en: '`file <name> <location> <mode> <uid> <gid>`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file <name> <location> <mode> <uid> <gid>`'
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slink <name> <target> <mode> <uid> <gid>`'
- en: The kernel provides a tool that reads this file and creates a `cpio` archive.
    The source is in `usr/gen_init_cpio.c`. There is a handy script in `scripts/gen_initramfs_list.sh`
    that creates a device table from a given directory, which saves a lot of typing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供了一个工具，读取此文件并创建`cpio`存档。源代码在`usr/gen_init_cpio.c`中。`scripts/gen_initramfs_list.sh`中有一个方便的脚本，它从给定目录创建设备表，这样可以节省很多输入。
- en: To complete, the task, you need to set `CONFIG_INITRAMFS_SOURCE` to point to
    the device table file and then build the kernel. Everything else is the same as
    before.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成任务，您需要将`CONFIG_INITRAMFS_SOURCE`设置为指向设备表文件，然后构建内核。其他一切都和以前一样。
- en: The old initrd format
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧的initrd格式
- en: There is an older format for a Linux ramdisk, known as `initrd`. It was the
    only format available before Linux 2.6 and is still needed if you are using the
    mmu-less variant of Linux, uCLinux. It is pretty obscure and I will not cover
    it here. There is more information in the kernel source, in `Documentation/initrd.txt`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Linux ramdisk的旧格式称为`initrd`。在Linux 2.6之前，这是唯一可用的格式，并且如果您使用Linux的无mmu变体uCLinux，则仍然需要它。它相当晦涩，我在这里不会涉及。内核源代码中有更多信息，在`Documentation/initrd.txt`中。
- en: The init program
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: init程序
- en: Running a shell, or even a shell script, at boot time is fine for simple cases,
    but really you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [Chapter 9](ch09.html
    "Chapter 9. Starting up - the init Program"), *Starting up - the init Program*.
    For now, I will briefly introduce the `init` from BusyBox.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导时运行shell，甚至是shell脚本，对于简单情况来说是可以的，但实际上您需要更灵活的东西。通常，Unix系统运行一个名为`init`的程序，它启动并监视其他程序。多年来，已经有许多`init`程序，其中一些我将在[第9章](ch09.html
    "第9章。启动 - init程序")中描述，*启动 - init程序*。现在，我将简要介绍BusyBox中的`init`。
- en: '`init` begins by reading the configuration file, `/etc/inittab`. Here is a
    simple example which is adequate for our needs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`开始读取配置文件`/etc/inittab`。这是一个对我们的需求足够简单的示例：'
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line runs a shell script, `rcS`, when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console, and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will be a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before giving the shell prompt. One of the advantages of launching the shell like
    this is that job control is enabled. The most immediate effect is that you can
    use *Ctrl* + *C* to terminate the current program. Maybe you didn't notice it
    before but, wait until you run the `ping` program and find you can't stop it!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在启动`init`时运行一个shell脚本`rcS`。第二行将消息**请按Enter键激活此控制台**打印到控制台，并在按下*Enter*时启动一个shell。`/bin/ash`前面的`-`表示它将是一个登录shell，在给出shell提示之前会源自`/etc/profile`和`$HOME/.profile`。以这种方式启动shell的一个优点是启用了作业控制。最直接的影响是您可以使用*Ctrl*
    + *C*来终止当前程序。也许您之前没有注意到，但是等到您运行`ping`程序并发现无法停止它时！
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox `init`在根文件系统中没有`inittab`时提供默认的`inittab`。它比前面的更加广泛。
- en: 'The script `/etc/init.d/rcS` is the place to put initialization commands that
    need to be performed at boot, for example, mounting the `proc` and `sysfs` filesystems:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`/etc/init.d/rcS`是放置需要在启动时执行的初始化命令的地方，例如挂载`proc`和`sysfs`文件系统：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make sure that you make `rcS` executable, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使`rcS`可执行，就像这样：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can try it out on QEMU by changing the `-append` parameter, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改`-append`参数在QEMU上尝试它，就像这样：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To achieve the same on the BeagelBone Black, you need to change the `bootargs`
    variable in U-Boot as shown:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要在BeagelBone Black上实现相同的效果，需要更改U-Boot中的`bootargs`变量，如下所示：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Configuring user accounts
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置用户帐户
- en: As I have hinted already, it is not good practice to run all programs as root
    since, if one is compromised by an outside attack, then the whole system is at
    risk and a misbehaving program can do more damage if it is running as root. It
    is preferable to create unprivileged user accounts and use them where full root
    is not necessary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经暗示的，以root身份运行所有程序并不是一个好的做法，因为如果一个程序受到外部攻击，那么整个系统都处于风险之中，而且如果作为root运行的程序行为不端，它可能会造成更大的破坏。最好创建非特权用户帐户，并在不需要完全root权限的地方使用它们。
- en: 'User names are configured in `/etc/passwd`. There is one line per user, with
    seven fields of information separated by colons:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名称配置在`/etc/passwd`中。每个用户一行，由冒号分隔的七个信息字段：
- en: The login name
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录名
- en: A hash code used to verify the password , or more usually an `x` to indicate
    that the password is stored in `/etc/shadow`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于验证密码的哈希码，或者更通常地是一个`x`，表示密码存储在`/etc/shadow`中
- en: UID
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UID
- en: GID
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GID
- en: A comment field, often left blank
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个注释字段，通常留空
- en: The user's home directory
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的主目录
- en: (Optional) the shell this user will use
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）此用户将使用的shell
- en: 'For example, this creates users `root` with UID 0 and `daemon` with UID 1:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这将创建用户`root`，UID为0，和`daemon`，UID为1：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Setting the shell for user daemon to `/bin/false` ensures that any attempt to
    log on with that name will fail.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户daemon的shell设置为`/bin/false`可以确保使用该名称登录的任何尝试都会失败。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Various programs have to read `/etc/passwd` so as to be able to look up UIDs
    and names, and so it has to be word-readable. That is a problem if the password
    hashes are stored in there because a malicious program would be able to take a
    copy and discover the actual passwords using a variety of cracker programs. Therefore,
    to reduce the exposure of this sensitive information, the passwords are stored
    in `/etc/shadow` and an `x` is placed in the password field to indicate that this
    is the case. `/etc/shadow` is only accessible as `root`, and, so as long as the
    `root` user is restricted, the passwords are safe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 各种程序必须读取`/etc/passwd`以便能够查找UID和名称，因此它必须是可读的。如果密码哈希存储在其中，那就是一个问题，因为恶意程序将能够复制并使用各种破解程序发现实际密码。因此，为了减少这些敏感信息的暴露，密码存储在`/etc/shadow`中，并在密码字段中放置一个`x`以指示这种情况。`/etc/shadow`只能由`root`访问，只要`root`用户受限，密码就是安全的。
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the `passwd` file shown in the preceding paragraph:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 影子密码文件由每个用户的一个条目组成，由九个字段组成。这是一个与前一段中显示的`passwd`文件相似的例子：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first two fields are the username and the password hash. The remaining seven
    are related to password aging, which is not usually an issue on embedded devices.
    If you are curious about the full details, refer to the manual page *shadow(5)*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段是用户名和密码哈希。剩下的七个与密码老化有关，这在嵌入式设备上通常不是问题。如果您对完整的细节感兴趣，请参阅手册页*shadow(5)*。
- en: In the example, the password for `root` is empty, meaning that `root` can log
    on without giving a password, which is useful during development, but not for
    production! You can generate a password hash by using the command `mkpasswd` or
    by running the `passwd` command on the target and copy and pasting the hash field
    from `/etc/shadow` on the target into the default shadow file in the staging directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`root`的密码是空的，这意味着`root`可以在不输入密码的情况下登录，这在开发过程中很有用，但在生产中不适用！您可以使用`mkpasswd`命令生成密码哈希，或者在目标上运行`passwd`命令，并将目标上的`/etc/shadow`中的哈希字段复制并粘贴到分段目录中的默认shadow文件中。
- en: The password for daemon is `*`, which will not match any logon password, once
    again ensuring that the daemon cannot be used as a regular user account.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: daemon的密码是`*`，这不会匹配任何登录密码，再次确保daemon不能用作常规用户帐户。
- en: 'Group names are stored in a similar way in `/etc/group`. The format is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 组名以类似的方式存储在`/etc/group`中。格式如下：
- en: The name of the group
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组的名称
- en: The group password, usually an `x` character, indicating that there is no group
    password
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组密码，通常是一个`x`字符，表示没有组密码
- en: The GID
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GID
- en: An optional list of users who belong to this group, separated by commas.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于该组的用户的可选列表，用逗号分隔。
- en: 'Here is an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Adding user accounts to the root filesystem
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向根文件系统添加用户帐户
- en: Firstly, you have to add to your staging directory `etc/passwd`, `etc/shadow`,
    and `etc/group`, as shown in the preceding section. Make sure that the permissions
    of shadow are 0600.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须向你的暂存目录添加`etc/passwd`、`etc/shadow`和`etc/group`，就像前面的部分所示的那样。确保`shadow`的权限为0600。
- en: 'The login procedure is started by a program called `getty`, which is part of
    BusyBox. You launch it from `inittab` using the keyword `respawn`, which restarts
    `getty` when a login shell is terminated, so `inittab` should read like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 登录过程由一个名为`getty`的程序启动，它是BusyBox的一部分。你可以使用`inittab`中的`respawn`关键字启动它，当登录shell终止时，`getty`将被重新启动，因此`inittab`应该如下所示：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then rebuild the ramdisk and try it out using QEMU or BeagelBone Black as before.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新构建ramdisk，并像之前一样使用QEMU或BeagelBone Black进行尝试。
- en: Starting a daemon process
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动守护进程
- en: Typically, you would want to run certain background processes at start up. Let's
    take the log daemon, `syslogd`, as an example. The purpose of `syslogd` is to
    accumulate log messages from other programs, mostly other daemons. Naturally,
    BusyBox has an applet for that!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望在启动时运行某些后台进程。让我们以日志守护程序`syslogd`为例。`syslogd`的目的是积累来自其他程序（大多数是其他守护程序）的日志消息。当然，BusyBox有一个适用于此的小工具！
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 启动守护进程就像在`etc/inittab`中添加这样一行那样简单：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`respawn` means that, if the program terminates, it will be automatically restarted;
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`respawn`表示，如果程序终止，它将自动重新启动；`-n`表示它应该作为前台进程运行。日志将被写入`/var/log/messages`。'
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may also want to start `klogd` in the same way: `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也想以同样的方式启动`klogd`：`klogd`将内核日志消息发送到`syslogd`，以便将其记录到永久存储中。
- en: As an aside, I should mention that, in the case of a typical embedded Linux
    system, writing log files to flash memory is not such a good idea as it will wear
    it out. I will cover the options for logging in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在典型的嵌入式Linux系统中，将日志文件写入闪存并不是一个好主意，因为这样会使其磨损。我将在[第7章](ch07.html "第7章。创建存储策略")中介绍日志记录的选项，*创建存储策略*。
- en: A better way of managing device nodes
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地管理设备节点
- en: 'Creating device nodes statically with `mknod` is quite hard work and inflexible.
    There are other ways to create device nodes automatically on demand:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mknod`静态创建设备节点非常费力且不灵活。还有其他方法可以根据需要自动创建设备节点：
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about and creates nodes for new devices as they are detected at
    runtime. The nodes are owned by `root` and have default permissions of 0600\.
    Some well-known device nodes, such as `/dev/null` and `/dev/random`, override
    the default to 0666 (see `struct` `memdev` in `drivers/char/mem.c`).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtmpfs`：这是一个伪文件系统，在引导时挂载到`/dev`上。内核会为内核当前已知的所有设备填充它，并在运行时检测到新设备时创建节点。这些节点由`root`拥有，并具有默认权限0600。一些众所周知的设备节点，如`/dev/null`和`/dev/random`，覆盖默认值为0666（请参阅`drivers/char/mem.c`中的`struct`
    `memdev`）。'
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and to create new nodes as needed. There is a configuration file,
    `/etc/mdev.conf`, which contains rules for ownership and the mode of the nodes.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdev`：这是一个BusyBox小工具，用于向目录填充设备节点，并根据需要创建新节点。有一个配置文件`/etc/mdev.conf`，其中包含节点所有权和模式的规则。'
- en: '`udev`: This is now part of `systemd` and is the solution you will find on
    desktop Linux and some embedded devices. It is very flexible and a good choice
    for higher end embedded devices.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udev`：现在是`systemd`的一部分，是桌面Linux和一些嵌入式设备上的解决方案。它非常灵活，是高端嵌入式设备的不错选择。'
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although both `mdev` and `udev` create the device nodes themselves, it is more
    usual to let `devtmpfs` do that job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`mdev`和`udev`都可以自行创建设备节点，但更常见的做法是让`devtmpfs`来完成这项工作，并使用`mdev/udev`作为实施设置所有权和权限策略的一层。
- en: An example using devtmpfs
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用devtmpfs的示例
- en: 'If you have booted up one of the earlier ramdisk examples, trying out `devtmpfs`
    is as simple as entering this command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经启动了之前的ramdisk示例之一，尝试`devtmpfs`就像输入这个命令一样简单：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see that `/dev` is full of device nodes. For a permanent fix, add
    this to `/etc/init.d/rcS`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`/dev`里面充满了设备节点。要进行永久修复，将这个添加到`/etc/init.d/rcS`中：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In point of fact, kernel initialization does this automatically unless you have
    supplied an `initramfs` ramdisk as we have done! To see the code, look in the
    `init/do_mounts.c`, function `prepare_namespace()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，内核初始化会自动执行这一操作，除非你提供了`initramfs` ramdisk，就像我们所做的那样！要查看代码，请查看`init/do_mounts.c`，函数`prepare_namespace()`。
- en: An example using mdev
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mdev的示例
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. Firstly, there is a startup phase,
    selected by the `-s` option, when `mdev` scans the `/sys` directory looking for
    information about current devices and populates the `/dev` directory with the
    corresponding nodes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置`mdev`有点复杂，但它允许你在创建设备节点时修改权限。首先，有一个启动阶段，通过`-s`选项选择，当`mdev`扫描`/sys`目录查找有关当前设备的信息并用相应的节点填充`/dev`目录。
- en: 'If you want to keep track of new devices coming on line and create nodes for
    them as well, you need to make `mdev` a hotplug client by writing to `/proc/sys/kernel/hotplug`.
    These additions to `/etc/init.d/rcS` will achieve all of that:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟踪新设备的上线并为它们创建节点，你需要将`mdev`作为热插拔客户端写入`/proc/sys/kernel/hotplug`。将这些添加到`/etc/init.d/rcS`将实现所有这些：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The default mode is 660 and ownership is `root:root`. You can change that by
    adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`, and
    `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模式为660，所有权为`root:root`。您可以通过在`/etc/mdev.conf`中添加规则来更改。例如，要为`null`，`random`和`urandom`设备提供正确的模式，您需要将其添加到`/etc/mdev.conf`中：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The format is documented in the BusyBox source code in `docs/mdev.txt` and there
    are more examples in the directory named `examples`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式在BusyBox源代码中的`docs/mdev.txt`中有记录，并且在名为`examples`的目录中有更多示例。
- en: Are static device nodes so bad after all?
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态设备节点到底有多糟糕？
- en: 'Statically created device nodes do have one advantage: they don''t take any
    time during boot to create, whereas the other methods do. If minimizing boot time
    is a priority, using statically-created device nodes will save a measurable amount
    of time.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 静态创建的设备节点确实有一个优点：它们在引导过程中不需要花费任何时间来创建，而其他方法则需要。如果最小化引导时间是一个优先考虑的问题，使用静态创建的设备节点将节省可测量的时间。
- en: Configuring the network
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置网络
- en: Next, let's look at some basic network configurations so that we can communicate
    with the outside world. I am assuming that there is an Ethernet interface, `eth0`,
    and that we only need a simple IP v4 configuration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一些基本的网络配置，以便我们可以与外部世界通信。我假设有一个以太网接口`eth0`，我们只需要一个简单的IP v4配置。
- en: 'These examples use the network utilities that are part of BusyBox, and are
    sufficient for a simple use case, using the `old-but-reliable ifup` and `ifdown`
    programs. You can read the man pages on both for more details. The main network
    configuration is stored in `/etc/network/interfaces`. You will need to create
    these directories in the staging directory:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了BusyBox的网络实用程序，并且对于简单的用例来说足够了，使用`old-but-reliable ifup`和`ifdown`程序。您可以阅读这两者的man页面以获取更多细节。主要的网络配置存储在`/etc/network/interfaces`中。您需要在暂存目录中创建这些目录：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a static IP address, `etc/network/interfaces` would look like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态IP地址，`etc/network/interfaces`看起来像这样：
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For a dynamic IP address allocated using DHCP, `etc/network/interfaces` would
    look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用DHCP分配的动态IP地址，`etc/network/interfaces`看起来像这样：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You will also have to configure a DHCP client program. BusyBox has one named
    `udchpcd`. It needs a shell script that should go in `/usr/share/udhcpc/default.script`.
    There is a suitable default in the BusyBox source code in the directory `examples//udhcp/simple.script`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要配置一个DHCP客户端程序。BusyBox有一个名为`udchpcd`的程序。它需要一个应该放在`/usr/share/udhcpc/default.script`中的shell脚本。在BusyBox源代码的`examples//udhcp/simple.script`目录中有一个合适的默认值。
- en: Network components for glibc
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: glibc的网络组件
- en: '`glibc` uses a mechanism known as the **name service switch** (**NSS**) to
    control the way that names are resolved to numbers for networking and users. User
    names, for example, may be resolved to UIDs via the file `/etc/passwd`; network
    services such as HTTP can be resolved to the service port number via `/etc/services`,
    and so on. All this is configured by `/etc/nsswitch.conf`, see the manual page,
    *nss(5)* for full details. Here is a simple example that will suffice for most
    embedded Linux implementations:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`使用一种称为**名称服务开关**（**NSS**）的机制来控制名称解析为网络和用户的数字的方式。例如，用户名可以通过文件`/etc/passwd`解析为UID；网络服务（如HTTP）可以通过`/etc/services`解析为服务端口号，等等。所有这些都由`/etc/nsswitch.conf`配置，有关详细信息，请参阅手册页*nss(5)*。以下是一个对大多数嵌入式Linux实现足够的简单示例：'
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    the host names, which may additionally be resolved by a DNS lookup.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都由`/etc`中同名的文件解决，除了主机名，它可能还会通过DNS查找来解决。
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` in your development PC. `/etc/hosts` should, at least contain,
    the loopback address:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，您需要使用这些文件填充`/etc`。网络、协议和服务在所有Linux系统中都是相同的，因此可以从开发PC中的`/etc`中复制。`/etc/hosts`至少应包含环回地址：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will come to the others, `passwd`, `group`, and `shadow`, later.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论其他的`passwd`，`group`和`shadow`。
- en: 'The last piece of the jigsaw is the libraries that perform the name resolution.
    They are plugins that are loaded as needed based on the contents of `nsswitch.conf`,
    meaning that they do not show up as dependencies if you use `readelf` or similar.
    You will simply have to copy them from the toolchain''s `sysroot`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块是执行名称解析的库。它们是根据`nsswitch.conf`的内容按需加载的插件，这意味着如果您使用`readelf`或类似工具，它们不会显示为依赖项。您只需从工具链的`sysroot`中复制它们：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Creating filesystem images with device tables
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备表创建文件系统映像
- en: The kernel has a utility, `gen_init_cpio`, that creates a `cpio` file based
    on format instructions set out in a text file, called a `device table`, which
    allows a non-root user to create device nodes and to allocate arbitrary UID and
    GID values to any file or directory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有一个实用程序`gen_init_cpio`，它根据文本文件中设置的格式指令创建一个`cpio`文件，称为`设备表`，允许非根用户创建设备节点，并为任何文件或目录分配任意UID和GID值。
- en: 'The same concept has been applied to tools that create other filesystem image
    formats:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的概念已应用于创建其他文件系统映像格式的工具：
- en: '`jffs2`: `mkfs.jffs2`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jffs2`：`mkfs.jffs2`'
- en: '`ubifs`: `mkfs.ubifs`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubifs`：`mkfs.ubifs`'
- en: '`ext2`: `genext2fs`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext2`：`genext2fs`'
- en: We will look at `jffs2` and `ubifs` in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*, when we look at filesystems
    for flash memory. The third, `ext2`, is a fairly old format for hard drives.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](ch07.html "第7章。创建存储策略")中讨论`jffs2`和`ubifs`，*创建存储策略*，当我们研究用于闪存的文件系统时。第三个`ext2`是一个相当古老的硬盘格式。
- en: 'They each take a device table file with the format `<name> <type> <mode> <uid>
    <gid> <major> <minor> <start> <inc> <count>` in which the following applies:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都需要一个设备表文件，格式为`<name> <type> <mode> <uid> <gid> <major> <minor> <start> <inc>
    <count>`，其中以下内容适用：
- en: '`name`: Filename'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：文件名'
- en: '`type`: One of the following:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：以下之一：'
- en: '`f`: A regular file'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：一个常规文件'
- en: '`d`: A directory'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：一个目录'
- en: '`c`: A character special device file'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：字符特殊设备文件'
- en: '`b`: A block special device file'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：块特殊设备文件'
- en: '`p`: A FIFO (named pipe)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：FIFO（命名管道）'
- en: '`uid` The UID of the file'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid`：文件的UID'
- en: '`gid`: The GID of the file'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gid`：文件的GID'
- en: '`major` and `minor`: the device numbers (device nodes only)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`major`和`minor`：设备号（仅设备节点）'
- en: '`start`, `inc`, and `count`: (device nodes only) allow you to create a group
    of device nodes starting from the `minor` number in `start`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`，`inc`和`count`：（仅设备节点）允许您从`start`中的`minor`号开始创建一组设备节点'
- en: 'You do not have to specify every file, as with `gen_init_cpio`: you just have
    to point them at a directory – the staging directory – and list the changes and
    exceptions you need to make in the final filesystem image.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必像使用`gen_init_cpio`那样指定每个文件：您只需将它们指向一个目录-暂存目录-并列出您需要在最终文件系统映像中进行的更改和异常。
- en: 'A simple example which populates static device nodes for us is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例，为我们填充静态设备节点如下：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, use `genext2fs` to generate a filesystem image of 4 MiB (that is 4,096
    blocks of the default size, 1,024 bytes):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`genext2fs`生成一个4 MiB（即默认大小的4,096个块，每个块1,024字节）的文件系统映像：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, you can copy the resulting image, `rootfs.ext`, to an SD card or similar.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将生成的映像`rootfs.ext`复制到SD卡或类似的设备。
- en: Putting the root filesytem onto an SD card
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将根文件系统放入SD卡中
- en: This is an example of mounting a filesystem from a normal block device, such
    as an SD card. The same principles apply to other filesystem types and we will
    look at them in more detail in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从普通块设备（如SD卡）挂载文件系统的示例。相同的原则适用于其他文件系统类型，我们将在[第7章](ch07.html "第7章。创建存储策略")*创建存储策略*中更详细地讨论它们。
- en: 'Assuming that you have a device with an SD card, and that the first partition
    is used for the boot files, `MLO` and `u-boot.img` – as on a BeagleBone Black.
    Assume also that you have used `genext2fs` to create a filesystem image. To copy
    it to the SD card, insert the card and identify the block device it has been assigned:
    typically `/dev/sd` or `/dev/mmcblk0`. If it is the latter, copy the filesystem
    image to the second partition:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个带有SD卡的设备，并且第一个分区用于引导文件，`MLO`和`u-boot.img`-就像BeagleBone Black上一样。还假设您已经使用`genext2fs`创建了一个文件系统映像。要将其复制到SD卡，请插入卡并识别其被分配的块设备：通常为`/dev/sd`或`/dev/mmcblk0`。如果是后者，请将文件系统映像复制到第二个分区：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, slot the SD card into the device, and set the kernel command line to
    `root=/dev/mmcblk0p2`. The complete boot sequence is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将SD卡插入设备，并将内核命令行设置为`root=/dev/mmcblk0p2`。完整的引导顺序如下：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Mounting the root filesystem using NFS
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NFS挂载根文件系统
- en: If your device has a network interface, it is best to mount the root filesystem
    over the network during development. It gives you access to almost unlimited storage
    so you can add in debug tools and executables with large symbol tables. As an
    added bonus, updates made to the root filesystem hosted on the development machine
    are made available on the target immediately. You also have a copy of log files.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备有网络接口，最好在开发过程中通过网络挂载根文件系统。这样可以访问几乎无限的存储空间，因此您可以添加具有大型符号表的调试工具和可执行文件。作为额外的奖励，对于开发机上托管的根文件系统所做的更新将立即在目标上生效。您还有日志文件的副本。
- en: 'For this to work, your kernel has to be configured with `CONFIG_ROOT_NFS`.
    Then, you can configure Linux to do the mount at boot time by adding the following
    to the kernel command line:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，您的内核必须配置为`CONFIG_ROOT_NFS`。然后，您可以通过将以下内容添加到内核命令行来配置Linux在引导时进行挂载：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Give the details of the NFS export as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 给出NFS导出的详细信息如下：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Configure the network interface that connects to the NFS server so that it
    is available at boot time, before the `init` program runs by using this command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 配置连接到NFS服务器的网络接口，以便在引导时，在`init`程序运行之前使用此命令：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There is more information about NFS root mounts in the kernel source in `Documentation/filesystems/nfs/nfsroot.txt`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NFS根挂载的更多信息，请参阅内核源中的`Documentation/filesystems/nfs/nfsroot.txt`。
- en: 'You also need to install and configure an NFS server on your host which, for
    Ubuntu, you can do with this command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在主机上安装和配置NFS服务器，对于Ubuntu，您可以使用以下命令完成：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The NFS server needs to be told which directories are being exported to the
    network, which is controlled by `/etc/exports`. Add a line like this one to that
    file:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: NFS服务器需要告知哪些目录正在导出到网络，这由`/etc/exports`控制。向该文件添加类似以下行：
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, restart the server to pick up the change which, for Ubuntu, is:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动服务器以应用更改，对于Ubuntu来说是：
- en: '[PRE62]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Testing with QEMU
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用QEMU进行测试
- en: 'The following script creates a virtual network between the network device `tap0`
    on the host and `eth0` on the target using a pair of static IPv4 addresses and
    then launches QEMU with the parameters to use `tap0` as the emulated interface.
    You will need to change the path to the root filesystem to be the full path to
    your staging directory, and maybe the IP addresses if they conflict with your
    network configuration:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本创建了一个虚拟网络，将主机上的网络设备`tap0`与目标上的`eth0`使用一对静态IPv4地址连接起来，然后使用参数启动QEMU，以使用`tap0`作为模拟接口。您需要更改根文件系统的路径为您的暂存目录的完整路径，如果它们与您的网络配置冲突，可能还需要更改IP地址：
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The script is available as `run-qemu-nfs.sh`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本可用作`run-qemu-nfs.sh`。
- en: It should boot up as before, but now using the staging directory directly via
    the NFS export. Any files that you create in that directory will be immediately
    visible to the target device and any files created in the device will be visible
    to the development PC.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该像以前一样启动，但现在直接通过NFS导出使用暂存目录。您在该目录中创建的任何文件将立即对目标设备可见，而在设备上创建的文件将对开发PC可见。
- en: Testing with BeagleBone Black
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BeagleBone Black进行测试
- en: 'In a similar way, you can enter these commands at the U-Boot prompt of the
    BeagleBone Black:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以在BeagleBone Black的U-Boot提示符下输入这些命令：
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then; to boot it, load the kernel and `dtb` from `sdcard,` as before:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要引导它，从`sdcard`中加载内核和`dtb`，就像以前一样：
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Problems with file permissions
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限问题
- en: The files that were already in the staging directory are owned by you and will
    show up on the target when you run `ls -l` with whatever your UID is, typically
    1,000\. Any files created by the target device will be owned by root. The whole
    thing is a mess.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在暂存目录中的文件由您拥有，并且在运行`ls -l`时会显示在目标上，无论您的UID是什么，通常为1,000。由目标设备创建的任何文件都将由root拥有。整个情况一团糟。
- en: Unfortunately, there is no simple way out. The best advice is to make a copy
    of the staging directory and change ownership to `root:root` (using `sudo chown
    -R 0:0 *`) and export this directory as the NFS mount. It reduces the inconvenience
    of having just one copy of the root filesystem shared between development and
    target systems.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有简单的方法。最好的建议是复制暂存目录并将所有权更改为`root:root`（使用`sudo chown -R 0:0 *`），并将此目录导出为NFS挂载。这样可以减少在开发和目标系统之间共享根文件系统的不便。
- en: Using TFTP to load the kernel
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TFTP加载内核
- en: When working with real hardware such as the BeagleBone Black, it is best to
    load the kernel over the network, especially when the root filesystem is mounted
    via NFS. In this way, you are not using any local storage on the device. It saves
    time if you don't have to keep re-flashing the memory and means that you can get
    work done while the flash storage drivers are still being developed (it happens).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用诸如BeagleBone Black之类的真实硬件时，最好通过网络加载内核，特别是当根文件系统通过NFS挂载时。这样，您就不会使用设备上的任何本地存储。如果不必一直重新刷新内存，可以节省时间，并且意味着您可以在闪存存储驱动程序仍在开发中时完成工作（这种情况经常发生）。
- en: U-Boot has supported the **Trivial File Transfer Protocol** (**TFTP**) for many
    years. Firstly, you need to install a `tftp` daemon on your development machine.
    On Ubuntu, you would install the `tftpd-hpa` package, which grants read access
    to files in the directory `/var/lib/tftpboot` to `tftp` clients like U-Boot.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot多年来一直支持**简单文件传输协议**（**TFTP**）。首先，您需要在开发机器上安装`tftp`守护程序。在Ubuntu上，您将安装`tftpd-hpa`软件包，该软件包授予`/var/lib/tftpboot`目录中的文件对`U-Boot`等`tftp`客户端的读取访问权限。
- en: 'Assuming that you have copied `zImage` and `am335x-boneblack.dtb` into `/var/lib/tftpboot`,
    enter these commands into U-Boot to load and boot:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已将`zImage`和`am335x-boneblack.dtb`复制到`/var/lib/tftpboot`，请在U-Boot中输入以下命令以加载和启动：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is fairly common for the response to `tftpboot` to look like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`tftpboot`的响应通常是这样的：
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The row of `T` characters on the last line indicate that there is something
    wrong and the TFTP requests are timing out. The most common reasons are as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的`T`字符行表示有些问题，TFTP请求超时。最常见的原因如下：
- en: Incorrect IP address for server.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的IP地址不正确。
- en: TFTP daemon not running on server.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上没有运行TFTP守护程序。
- en: Firewall on server is blocking the TFTP protocol. Most firewalls do indeed block
    the TFTP port, 69, by default.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上的防火墙阻止了TFTP协议。大多数防火墙默认确实会阻止TFTP端口69。
- en: 'In this case, the tftp daemon was not running, so I started it with the following
    command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，tftp守护程序没有运行，所以我用以下命令启动了它：
- en: '[PRE68]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Additional reading
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: '*Filesystem Hierarchy Standard*, currently at version 3.0 available at [http://refspecs.linuxfoundation.org/fhs.shtml](http://refspecs.linuxfoundation.org/fhs.shtml).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统层次结构标准*，目前版本为3.0，可在[http://refspecs.linuxfoundation.org/fhs.shtml](http://refspecs.linuxfoundation.org/fhs.shtml)上找到。'
- en: '*ramfs, rootfs and initramfs , Rob Landley*, October 17, 2005, which is part
    of the Linux source code available at `Documentation/filesystems/ramfs-rootfs-initramfs.txt`.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ramfs, rootfs and initramfs , Rob Landley*，2005年10月17日，这是Linux源代码中的一部分，可在`Documentation/filesystems/ramfs-rootfs-initramfs.txt`上找到。'
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: One of the strengths of Linux is that it can support a wide range of root filesystems
    which allow it to be tailored to suit a wide range of needs. We have seen that
    it is possible to construct a simple root filesystem manually with a small number
    of components, and that BusyBox is especially useful in this regard. By going
    through the process one step at a time, it has given us insight into some of the
    basic workings of Linux systems, including network configuration and user accounts.
    However, the task rapidly becomes unmanageable as devices get more complex. And,
    there is the ever-present worry that there may be a security hole in the implementation
    which we have not noticed. In the next chapter, we will look at using embedded
    build systems to help us out.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是它可以支持各种根文件系统，从而使其能够满足各种需求。我们已经看到可以手动使用少量组件构建简单的根文件系统，并且BusyBox在这方面特别有用。通过一步一步地进行这个过程，我们对Linux系统的一些基本工作原理有了了解，包括网络配置和用户帐户。然而，随着设备变得更加复杂，任务很快变得难以管理。而且，我们始终担心可能存在我们没有注意到的实现中的安全漏洞。在下一章中，我们将研究使用嵌入式构建系统来帮助我们。
