["```\nstruct regmap_config { \n    const char *name; \n\n    int reg_bits; \n    int reg_stride; \n    int pad_bits; \n    int val_bits; \n\n    bool (*writeable_reg)(struct device *dev, unsigned int reg); \n    bool (*readable_reg)(struct device *dev, unsigned int reg); \n    bool (*volatile_reg)(struct device *dev, unsigned int reg); \n    bool (*precious_reg)(struct device *dev, unsigned int reg); \n    regmap_lock lock; \n    regmap_unlock unlock; \n    void *lock_arg; \n\n    int (*reg_read)(void *context, unsigned int reg, \n                    unsigned int *val); \n    int (*reg_write)(void *context, unsigned int reg, \n                    unsigned int val); \n\n    bool fast_io; \n\n    unsigned int max_register; \n    const struct regmap_access_table *wr_table; \n    const struct regmap_access_table *rd_table; \n    const struct regmap_access_table *volatile_table; \n    const struct regmap_access_table *precious_table; \n    const struct reg_default *reg_defaults; \n    unsigned int num_reg_defaults; \n    enum regcache_type cache_type; \n    const void *reg_defaults_raw; \n    unsigned int num_reg_defaults_raw; \n\n    u8 read_flag_mask; \n    u8 write_flag_mask; \n\n    bool use_single_rw; \n    bool can_multi_write; \n\n    enum regmap_endian reg_format_endian; \n    enum regmap_endian val_format_endian; \n    const struct regmap_range_cfg *ranges; \n    unsigned int num_ranges; \n} \n```", "```\nstatic bool foo_writeable_register(struct device *dev, \n                                    unsigned int reg) \n{ \n    switch (reg) { \n    case 0x30 ... 0x38: \n    case 0x40 ... 0x45: \n    case 0x50 ... 0x57: \n    case 0x60 ... 0x6e: \n    case 0x70 ... 0x75: \n    case 0x80 ... 0x85: \n    case 0x90 ... 0x95: \n    case 0xa0 ... 0xa5: \n    case 0xb0 ... 0xb2: \n        return true; \n    default: \n        return false; \n    } \n} \n```", "```\nstatic bool foo_volatile_register(struct device *dev, \n                                    unsigned int reg) \n{ \n    switch (reg) { \n    case 0x24 ... 0x29: \n    case 0xb6 ... 0xb8: \n        return true; \n    default: \n        return false; \n    } \n} \n```", "```\nstatic const struct regmap_config regmap_config = { \n    .reg_bits     = 8, \n    .val_bits     = 8, \n    .max_register = LM3533_REG_MAX, \n    .readable_reg = lm3533_readable_register, \n    .volatile_reg = lm3533_volatile_register, \n    .precious_reg = lm3533_precious_register, \n}; \n```", "```\nvoid regmap_exit(struct regmap *map) \n```", "```\nstruct regmap * regmap_init_spi(struct spi_device *spi, \nconst struct regmap_config); \n```", "```\nstatic int foo_spi_probe(struct spi_device *client) \n{ \n    int err; \n    struct regmap *my_regmap; \n    struct regmap_config bmp085_regmap_config; \n\n        /* fill bmp085_regmap_config somewhere */ \n        [...] \n    client->bits_per_word = 8; \n\n    my_regmap = \n           regmap_init_spi(client,&bmp085_regmap_config); \n\n    if (IS_ERR(my_regmap)) { \n        err = PTR_ERR(my_regmap); \n        dev_err(&client->dev, \"Failed to init regmap: %d\\n\", err); \n        return err; \n    } \n    [...] \n} \n```", "```\nstruct regmap * regmap_init_i2c(struct i2c_client *i2c, \nconst struct regmap_config); \n```", "```\nstatic int bar_i2c_probe(struct i2c_client *i2c, \nconst struct i2c_device_id *id) \n{ \n    struct my_struct * bar_struct; \n    struct regmap_config regmap_cfg; \n\n        /* fill regmap_cfgsome  where */ \n        [...] \n    bar_struct = kzalloc(&i2c->dev, \nsizeof(*my_struct), GFP_KERNEL); \n    if (!bar_struct) \n        return -ENOMEM; \n\n    i2c_set_clientdata(i2c, bar_struct); \n\n    bar_struct->regmap = regmap_init_i2c(i2c, \n&regmap_config); \n    if (IS_ERR(bar_struct->regmap)) \n        return PTR_ERR(bar_struct->regmap); \n\n    bar_struct->dev = &i2c->dev; \n    bar_struct->irq = i2c->irq; \n    [...] \n} \n```", "```\nint regmap_read(struct regmap *map, unsigned int reg, \n                 unsigned int *val); \nint regmap_write(struct regmap *map, unsigned int reg, \n                 unsigned int val); \nint regmap_update_bits(struct regmap *map, unsigned int reg, \n                 unsigned int mask, unsigned int val); \n```", "```\nint regmap_update_bits(struct regmap *map, unsigned int reg, \n         unsigned int mask, unsigned int val) \n```", "```\nstatic int _regmap_update_bits(struct regmap *map, \n                    unsigned int reg, unsigned int mask,  \n                    unsigned int val, bool *change) \n{ \n    int ret; \n    unsigned int tmp, orig; \n\n    ret = _regmap_read(map, reg, &orig); \n    if (ret != 0) \n        return ret; \n\n    tmp = orig& ~mask; \n    tmp |= val & mask; \n\n    if (tmp != orig) { \n        ret = _regmap_write(map, reg, tmp); \n        *change = true; \n    } else { \n        *change = false; \n    } \n\n    return ret; \n} \n```", "```\nint regmap_multi_reg_write(struct regmap *map, \n                    const struct reg_sequence *regs, int num_regs) \n```", "```\n/** \n * Register/value pairs for sequences of writes with an optional delay in \n * microseconds to be applied after each write. \n * \n * @reg: Register address. \n * @def: Register value. \n * @delay_us: Delay to be applied after the register write in microseconds \n */ \nstruct reg_sequence { \n    unsigned int reg; \n    unsigned int def; \n    unsigned int delay_us; \n}; \n```", "```\nstatic const struct reg_sequence foo_default_regs[] = { \n    { FOO_REG1,          0xB8 }, \n    { BAR_REG1,          0x00 }, \n    { FOO_BAR_REG1,      0x10 }, \n    { REG_INIT,          0x00 }, \n    { REG_POWER,         0x00 }, \n    { REG_BLABLA,        0x00 }, \n}; \n\nstaticint probe ( ...) \n{ \n    [...] \n    ret = regmap_multi_reg_write(my_regmap, foo_default_regs, \n                                   ARRAY_SIZE(foo_default_regs)); \n    [...] \n} \n```", "```\nint regmap_bulk_read(struct regmap *map, unsigned int reg, void \n                     *val, size_tval_count); \nint regmap_bulk_write(struct regmap *map, unsigned int reg, \n                     const void *val, size_t val_count); \n```", "```\n/* Anenum of all the supported cache types */ \nenum regcache_type { \n   REGCACHE_NONE, \n   REGCACHE_RBTREE, \n   REGCACHE_COMPRESSED, \n   REGCACHE_FLAT, \n}; \n```", "```\n/** \n * Default value for a register.  We use an array of structs rather \n * than a simple array as many modern devices have very sparse \n * register maps. \n * \n * @reg: Register address. \n * @def: Register default value. \n */ \nstruct reg_default { \n    unsigned int reg; \n    unsigned int def; \n}; \n```", "```\nstatic const struct reg_default ltc3589_reg_defaults[] = { \n{ LTC3589_SCR1,   0x00 }, \n{ LTC3589_OVEN,   0x00 }, \n{ LTC3589_SCR2,   0x00 }, \n{ LTC3589_VCCR,   0x00 }, \n{ LTC3589_B1DTV1, 0x19 }, \n{ LTC3589_B1DTV2, 0x19 }, \n{ LTC3589_VRRCR,  0xff }, \n{ LTC3589_B2DTV1, 0x19 }, \n{ LTC3589_B2DTV2, 0x19 }, \n{ LTC3589_B3DTV1, 0x19 }, \n{ LTC3589_B3DTV2, 0x19 }, \n{ LTC3589_L2DTV1, 0x19 }, \n{ LTC3589_L2DTV2, 0x19 }, \n}; \nstatic const struct regmap_config ltc3589_regmap_config = { \n        .reg_bits = 8, \n        .val_bits = 8, \n        .writeable_reg = ltc3589_writeable_reg, \n        .readable_reg = ltc3589_readable_reg, \n        .volatile_reg = ltc3589_volatile_reg, \n        .max_register = LTC3589_L2DTV2, \n        .reg_defaults = ltc3589_reg_defaults, \n        .num_reg_defaults = ARRAY_SIZE(ltc3589_reg_defaults), \n        .use_single_rw = true, \n        .cache_type = REGCACHE_RBTREE, \n}; \n```", "```\n/* mandatory for regmap */ \n#include <linux/regmap.h> \n/* Depending on your need you should include other files */ \n\nstatic struct private_struct \n{ \n    /* Feel free to add whatever you want here */ \n    struct regmap *map; \n    int foo; \n}; \n\nstatic const struct regmap_range wr_rd_range[] = \n{ \n    { \n            .range_min = 0x20, \n            .range_max = 0x4F, \n    },{ \n            .range_min = 0x60, \n            .range_max = 0x7F \n    }, \n};  \n\nstruct regmap_access_table drv_wr_table = \n{ \n        .yes_ranges =   wr_rd_range, \n        .n_yes_ranges = ARRAY_SIZE(wr_rd_range), \n}; \n\nstruct regmap_access_table drv_rd_table = \n{ \n        .yes_ranges =   wr_rd_range, \n        .n_yes_ranges = ARRAY_SIZE(wr_rd_range), \n}; \n\nstatic bool writeable_reg(struct device *dev, unsigned int reg) \n{ \n    if (reg>= 0x20 &&reg<= 0x4F) \n        return true; \n    if (reg>= 0x60 &&reg<= 0x7F) \n        return true; \n    return false; \n} \n\nstatic bool readable_reg(struct device *dev, unsigned int reg) \n{ \n    if (reg>= 0x20 &&reg<= 0x4F) \n        return true; \n    if (reg>= 0x60 &&reg<= 0x7F) \n        return true; \n    return false; \n} \n\nstatic int my_spi_drv_probe(struct spi_device *dev) \n{ \n    struct regmap_config config; \n    struct custom_drv_private_struct *priv; \n    unsigned char data; \n\n    /* setup the regmap configuration */ \n    memset(&config, 0, sizeof(config)); \n    config.reg_bits = 8; \n    config.val_bits = 8; \n    config.write_flag_mask = 0x80; \n    config.max_register = 0x80; \n    config.fast_io = true; \n    config.writeable_reg = drv_writeable_reg; \n    config.readable_reg = drv_readable_reg; \n\n    /*  \n     * If writeable_reg and readable_reg are set, \n     * there is no need to provide wr_table nor rd_table. \n     * Uncomment below code only if you do not want to use \n     * writeable_reg nor readable_reg. \n     */ \n    //config.wr_table = drv_wr_table; \n    //config.rd_table = drv_rd_table; \n\n    /* allocate the private data structures */ \n    /* priv = kzalloc */ \n\n    /* Init the regmap spi configuration */ \n    priv->map = regmap_init_spi(dev, &config); \n    /* Use regmap_init_i2c in case of i2c bus */ \n\n    /*  \n     * Let us write into some register \n     * Keep in mind that, below operation will remain same \n     * whether you use SPI or I2C. It is and advantage when \n     * you use regmap. \n     */  \n    regmap_read(priv->map, 0x30, &data); \n    [...] /* Process data */ \n\n    data = 0x24; \n    regmap_write(priv->map, 0x23, data); /* write new value */ \n\n    /* set bit 2 (starting from 0) and 6 of register 0x44 */ \n    regmap_update_bits(priv->map, 0x44, 0b00100010, 0xFF); \n    [...] /* Lot of stuff */      \n    return 0; \n} \n```"]