- en: CPU Scheduling on Linux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux上的CPU调度
- en: An often-posed question that people have about Linux is, how does scheduling
    work? We will address this question for user space application developers in this
    chapter in some detail. In order for the reader to clearly grasp important concepts
    regarding CPU scheduling on Linux and how you can powerfully use this in applications, we
    will cover essential background information (the process state machine, real time,
    and so on) as well. This chapter will end with a brief note on how the Linux OS
    can even be used as a hard, real-time OS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常问关于Linux的一个问题是，调度是如何工作的？我们将在本章中详细解答这个问题，以便用户空间应用程序开发人员清楚地掌握有关Linux上CPU调度的重要概念，以及如何在应用程序中强大地使用这些概念，我们还将涵盖必要的背景信息（进程状态机，实时等）。本章将以简要说明Linux操作系统如何甚至可以用作硬实时操作系统而结束。
- en: 'In this chapter, the reader will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将了解以下主题：
- en: The Linux process (or thread) state machine and, importantly, the POSIX scheduling
    policies that Linux implements under the hood
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux进程（或线程）状态机，以及Linux在幕后实现的POSIX调度策略
- en: Related concepts, such as real-time and CPU affinity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关概念，如实时和CPU亲和力
- en: How to exploit the fact that, on a per-thread basis, you can program threads
    with a given scheduling policy and real time priority (a sample app will be shown)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用这一事实，即在每个线程基础上，您可以使用给定的调度策略和实时优先级来编程线程（将显示一个示例应用程序）
- en: A brief note on the fact that Linux can also be used as an RTOS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Linux也可以用作RTOS的简要说明
- en: The Linux OS and the POSIX scheduling model
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux操作系统和POSIX调度模型
- en: In order to understand scheduling at the level of the application developer
    (and how you can leverage this knowledge in actual code), we must first cover
    some required background information.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解应用程序开发人员的调度（以及如何在实际代码中利用这些知识），我们首先必须涵盖一些必需的背景信息。
- en: The first and very important concept for the developer to understand is that
    OSes maintain a construct called the **Kernel Schedulable Entity** (**KSE**)*. *The
    KSE is the granularity at which the OS scheduling code operates. In effect, what
    object exactly does the OS schedule?Is it the application, the process, the thread?
    Well, the short answer is that the KSE on the Linux OS is a thread. In other words,
    all runnable threads compete for the CPU resource; the kernel scheduler is ultimately
    the arbiter that decides which thread gets which CPU core and when.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须理解的第一个非常重要的概念是，操作系统维护一种称为**内核可调度实体**（**KSE**）的构造。*KSE是操作系统调度代码操作的粒度。实际上，操作系统调度的是什么对象？是应用程序、进程还是线程？嗯，简短的答案是Linux操作系统上的KSE是一个线程。换句话说，所有可运行的线程都竞争CPU资源；内核调度程序最终是决定哪个线程在哪个CPU核心上运行以及何时运行的仲裁者。
- en: Next, we present an overview of the process, or thread's, state machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将概述进程或线程的状态机。
- en: The Linux process state machine
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux进程状态机
- en: On the Linux OS, every process or thread runs through a variety of definite
    states, and by encoding these, we can form the state machine of a process (or
    thread)  on the Linux OS (do refer to *Figure 1* in the following section while
    reading this).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统上，每个进程或线程都会经历各种明确定义的状态，并通过对这些状态进行编码，我们可以形成Linux操作系统上进程（或线程）的状态机（在阅读本文时，请参考下一节中的*图1*）。
- en: Since we now understand that the KSE on the Linux OS is a thread and not a process,
    we shall ignore convention—which uses the word *process*—and instead use the word *thread* when
    describing the entity that cycles through various states of the state machine.
    (If more comfortable, you could always, in your mind, substitute the word process
    for thread in the following matter.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在了解了Linux操作系统上的KSE是一个线程而不是一个进程，我们将忽略使用单词*进程*的传统，而在描述通过各种状态的实体时使用单词*线程*。（如果更舒适的话，您可以在脑海中用*线程*替换*进程*。）
- en: 'The states that a Linux thread can cycle through are as follows (the `ps(1)`
    utility encodes the state via the letter shown here):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Linux线程可以循环经历的状态如下（`ps(1)`实用程序通过此处显示的字母对*状态*进行编码）：
- en: '**R**: Ready-to-run or Running'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**：准备运行或正在运行'
- en: 'Sleeping:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 睡眠：
- en: '**S**: Interruptible Sleep'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：可中断睡眠'
- en: '**D**: Uninterruptible Sleep'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：不可中断睡眠'
- en: '**T**: Stopped (or suspended/frozen)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**：停止（或暂停/冻结）'
- en: '**Z**: Zombie (or defunct)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**：僵尸（或无效）'
- en: '**X**: Dead'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**：死亡'
- en: When a thread is newly created (either via the `fork(2)`, `pthread_create(3)`or `clone(2)`APIs),
    and once the OS determines that the thread is fully born, it informs the scheduler
    of its existence by putting the thread into a runnable state. A thread in the
    **R** state is either actually running on a CPU core or is in the ready-to-run
    state. What we need to understand is that in both cases, the thread is enqueued
    on a data structure within the OS called a **run queue** (**RQ**). The threads
    in the run queue are the valid candidates to run; no thread can possibly run unless
    it is enqueued on an OS run queue. (For your information, Linux from version 2.6
    onward best exploits all possible CPU cores by setting up one RQ per CPU core, thus
    obtaining perfect SMP scalability.) Linux does not explicitly distinguish between
    the ready-to-run and running states; it merely marks the thread in either state
    as **R**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程新创建（通过`fork(2)`，`pthread_create(3)`或`clone(2)`API）时，一旦操作系统确定线程完全创建，它通过将线程放入可运行状态来通知调度程序其存在。**R**状态的线程实际上正在CPU核心上运行，或者处于准备运行状态。我们需要理解的是，在这两种情况下，线程都被排队在操作系统内的一个称为**运行队列**（**RQ**）的数据结构上。运行队列中的线程是可以运行的有效候选者；除非线程被排队在操作系统运行队列上，否则不可能运行任何线程。
    （供您参考，从2.6版开始，Linux通过为每个CPU核心设置一个RQ来充分利用所有可能的CPU核心，从而获得完美的SMP可伸缩性。）Linux不明确区分准备运行和运行状态；它只是将处于**R**状态的线程标记为准备运行或运行状态。
- en: The sleep states
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 睡眠状态
- en: 'Once a thread is running its code, it obviously keeps doing so, until, typically,
    one of a few things (mentioned as follows) happen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程正在运行其代码，显然会一直这样做，直到通常发生以下几种情况：
- en: It blocks on I/O, thus sleeping—entering state of **S** or **D**, depending
    (see the following paragraph).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在I/O上阻塞，因此进入睡眠状态**S**或**D**，具体取决于（见下一段）。
- en: It is preempted; there's no state change, and it remains in a ready-to-run state
    **R** on a run queue.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被抢占；没有状态改变，它仍然处于就绪运行状态**R**，在运行队列上。
- en: It is sent a signal that causes it to stop, thus entering state **T**.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它收到一个导致其停止的信号，因此进入状态**T**。
- en: It is sent a signal (typically SIGSTOP or SIGTSTP)  that causes it to terminate, thus
    first entering state **Z** (zombie is a transient state on the way to death),
    and then actually dying (state X).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它收到一个信号（通常是SIGSTOP或SIGTSTP），导致其终止，因此首先进入状态**Z**（僵尸状态是通向死亡的瞬态状态），然后实际死亡（状态X）。
- en: Often, a thread will encounter in its code path a blocking API—one that will
    cause it to enter a sleep state, waiting on an event. While blocked, it is removed
    (or dequeued) from the run queue it was on, and instead added (enqueued) onto
    what's called a **wait queue** (**WQ**). When the event it was waiting upon arises,
    the OS will issue it a wakeup, causing it to become runnable (dequeued from its
    wait queue and enqueued onto a run queue) again. Note that the thread won't run
    instantaneously; it will become runnable (**Rr** in *Figure 1*, Linux state machine),
    and a candidate for the scheduler; soon enough, it will get a chance and actually
    run on the CPU (**Rcpu**).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线程在其代码路径中会遇到一个阻塞API，这会导致它进入睡眠状态，等待事件。在被阻塞时，它会从原来的运行队列中移除（或出队），然后添加到所谓的**等待队列**（**WQ**）上。当它等待的事件发生时，操作系统会发出唤醒信号，导致它变为可运行状态（从等待队列中出队并加入运行队列）。请注意，线程不会立即运行；它将变为可运行状态（*图1*中的**Rr**），成为调度程序的候选；很快，它将有机会在CPU上实际运行（**Rcpu**）。
- en: A common misconception is to think that the OS maintains one run queue and one
    wait queue. No—the Linux kernel maintains one run queue per CPU. Wait queues are
    often created and used by device drivers (as well as the kernel); thus, there
    can be any number of them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是认为操作系统维护一个运行队列和一个等待队列。不，Linux内核为每个CPU维护一个运行队列。等待队列通常由设备驱动程序（以及内核）创建和使用；因此，可以有任意数量的等待队列。
- en: The depth of the sleep determines precisely which state the thread is put into.
    If a thread issues a blocking call and the underlying kernel code (or device driver
    code) puts it into an interruptible sleep, the state is marked as **S**. An interruptible
    sleep state implies that the thread will be awoken when any signal destined for
    it is delivered; then, it will run the signal handler code, and if not terminated
    (or stopped), will resume the sleep (recall the `SA_RESTART` flag to `sigaction(2)`from [Chapter
    11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)*, Signaling - Part I*). This interruptible
    sleepstate **S** is indeed very commonly seen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠的深度确定了线程被放入的确切状态。如果一个线程发出了一个阻塞调用，底层内核代码（或设备驱动程序代码）将其放入可中断睡眠状态，状态标记为**S**。可中断的睡眠状态意味着当发送给它的任何信号被传递时，线程将被唤醒；然后，它将运行信号处理程序代码，如果没有终止（或停止），将恢复睡眠（回想一下`sigaction(2)`中的`SA_RESTART`标志，来自[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)*，信号-第一部分*）。这种可中断的睡眠状态**S**确实非常常见。
- en: On the other hand, the OS (or driver) could put the blocking thread into a deeper uninterruptible
    sleep, in which case the state is marked as **D**. An uninterruptible sleep state
    implies that the thread will not respond to signals (none; not even a SIGKILL
    from root!). This is done when the kernel determines that the sleep is critical
    and the thread must await the pending event, blocking upon at any cost. (A common
    example is a `read(2)` from a file—while data is being actually read, the thread
    is placed into an uninterruptible sleep state; another is the mounting and unmounting
    of a filesystem.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，操作系统（或驱动程序）可能会将阻塞线程放入更深的不可中断睡眠状态，此时状态标记为**D**。不可中断的睡眠状态意味着线程不会响应信号（没有；甚至没有来自root的SIGKILL！）。当内核确定睡眠是关键的，并且线程必须等待挂起的事件时，会这样做（一个常见的例子是从文件中读取`read(2)`—当实际读取数据时，线程被放入不可中断的睡眠状态；另一个是挂载和卸载文件系统）。
- en: 'Performance issues are often caused by very high I/O bottlenecks; high CPU
    usage is not always a major problem, but continually high I/O will make the system
    feel very slow. A quick way to determine which application(s) (processes and threads,
    really) are causing the heavy I/O is to filter the `ps(1)`output looking for processes
    (or threads) in the **D**, uninterruptible sleep state. As an example, refer to
    the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题通常是由非常高的I/O瓶颈引起的；高CPU使用率并不总是一个主要问题，但持续高的I/O会使系统感觉非常慢。确定哪个应用程序（实际上是进程和线程）导致了大量I/O的一个快速方法是过滤`ps(1)`输出，查找处于**D**状态的进程（或线程），即不可中断的睡眠状态。例如，参考以下内容：
- en: '**`$ ps -LA -o state,pid,cmd | grep`** `"^D"`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ ps -LA -o state,pid,cmd | grep`** `"^D"`'
- en: '`**D** 10243 /usr/bin/gnome-shell`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`**D** 10243 /usr/bin/gnome-shell`'
- en: '`**D** 13337 [kworker/0:2+eve]`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`**D** 13337 [kworker/0:2+eve]`'
- en: '`**D** 22545 /home/<user>/.dropbox-dist/dropbox-lnx.x86_64-58.4.92/dropbox`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`**D** 22545 /home/<user>/.dropbox-dist/dropbox-lnx.x86_64-58.4.92/dropbox`'
- en: '`$`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: Notice that we use `ps -LA`; the `-L` switch shows all threads alive as well.
    (FYI, the thread shown in the preceding square brackets,`[kworker/...]`, is a kernel
    thread.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用了`ps -LA`；`-L`开关显示所有活动的线程。 （FYI，前面方括号中显示的线程，`[kworker/...]`，是一个内核线程。）
- en: 'The following diagram represents the Linux state machine for any process or
    thread:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了任何进程或线程的Linux状态机：
- en: '![](img/b25cef64-61ac-4c07-99f0-8cf2773c27cb.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b25cef64-61ac-4c07-99f0-8cf2773c27cb.png)'
- en: 'Figure 1: Linux state machine'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Linux状态机
- en: The preceding diagram shows transitionsbetween states via red arrows. Do note
    that for clarity, some transitions (for example, a thread, can be killed while
    asleep or stopped) are not explicitly shown in the preceding diagram.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了状态之间的转换，通过红色箭头。请注意，为了清晰起见，一些转换（例如，线程在睡眠或停止时可能被终止）在前面的图表中没有明确显示。
- en: What is real time?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是实时？
- en: Many misconceptions exist regarding the meaning of real time (in application
    programming and OS contexts). Real time essentially means that not only do the
    real-time thread (or threads) perform their work correctly, but they must perform
    within a given worst-case deadline. Actually, the key factor in a real time system
    is called determinism. Deterministic systems have a guaranteed worst-case response
    time to real-world (or artificially generated) events; they will process them
    within a bounded time constraint. Determinism leads to predictable response, under
    any conditions—even extreme load. One way in which computer scientists classify
    algorithms is via their time complexity: the big-O notation. O(1) algorithms are deterministic; they
    guarantee that they will complete within a certain worst-case time, no matter
    the input load. True real-time systems require O(1) algorithms for implementing
    their performance-sensitive code paths.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“实时”（在应用程序编程和操作系统上下文中）的含义存在许多误解。实时基本上意味着实时线程（或线程）不仅要正确执行其工作，而且它们必须在给定的最坏情况截止日期内执行。实际上，实时系统的关键因素称为确定性。确定性系统对真实世界（或人工生成的）事件有保证的最坏情况响应时间；它们将在有限的时间约束内处理这些事件。确定性导致可预测的响应，在任何条件下都是如此，甚至在极端负载下也是如此。计算机科学家对算法进行分类的一种方式是通过它们的时间复杂度：大O符号。O(1)算法是确定性的；它们保证无论输入负载如何，都将在一定的最坏情况时间内完成。真实的实时系统需要O(1)算法来实现其性能敏感的代码路径。
- en: Interestingly, real time does not necessarily mean real fast. A VDC survey (refer
    to the *Further reading* section on the GitHub repository for more details) shows
    that the majority of real-time systems have a deadline (real-time response time)
    requirement of 1 to 9 milliseconds. As long as the system can consistently and
    without fail service the event within its given deadline (which could be fairly
    large), it's real time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，实时并不一定意味着真正快速。 VDC调查（有关更多详细信息，请参阅GitHub存储库上的“进一步阅读”部分）显示，大多数实时系统的截止日期（实时响应时间）要求为1至9毫秒。只要系统能够始终且无故障地在给定的截止日期内处理事件（可能相当长），它就是实时的。
- en: Types of real time
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时类型
- en: 'Real time is often classified into three types, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实时通常被分类为三种类型，如下：
- en: '**Hard real-time systems** are defined as those that must always meet all deadlines. Failure
    to meet a deadline even once results in the catastrophic failure of the system,
    including possible loss to human life, financial loss, and so on. A hard real
    time system requires a **Real-Time Operating System** (**RTOS**) to drive it.
    (Also, it''s really important that the applications are written to be hard real
    time as well!). Possible hard real-time domains include human transportation vehicles
    of many types (aircraft, marine vessels, spacecraft, trains, and elevators) and
    some kinds of military grade or defense equipment, nuclear reactors, medical electronics,
    and stock exchanges. (Yes, stock exchanges are very much a hard real time system;
    do read the book *Automate This: How Algorithms Came to Rule Our World*—refer
    to the *Further reading* section on the GitHub repository for more information.)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬实时系统**被定义为必须始终满足所有截止日期的系统。甚至一次未能满足截止日期都会导致系统的灾难性失败，包括可能造成人员伤亡、财务损失等。硬实时系统需要一个**实时操作系统**（RTOS）来驱动它。（此外，应用程序编写成硬实时也非常重要！）。可能的硬实时领域包括各种人员运输工具（飞机、船舶、宇宙飞船、火车和电梯）以及某些类型的军用或国防设备、核反应堆、医疗电子设备和股票交易所。（是的，股票交易所确实是一个硬实时系统；请阅读书籍《自动化：算法如何统治我们的世界》—请参阅GitHub存储库上的“进一步阅读”部分获取更多信息。）'
- en: '**Soft real-timesystems** are all about best effort; deadlines do exist, but
    there is absolutely no guarantee that they will be met. The system will do its
    best to meet them; failure to do so is considered okay (often, it''s just more
    of an annoyance to the end user rather than anything dangerous). Consumer electronics
    products (such as  our smartphones, MP3 players, cameras, tablets, and smart speakers)
    are typical examples. While using them, it quite often happens that you will hear
    a glitch while listening to music, or a streaming video stutters, buffers, and
    jitters. While annoying, it''s unlikely the user will perish.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软实时系统**都是尽最大努力；截止日期确实存在，但绝对不能保证会被满足。系统将尽最大努力满足它们；未能做到这一点被认为是可以接受的（通常只是对最终用户而言更多是一种烦恼而不是危险）。消费类电子产品（如我们的智能手机、MP3播放器、相机、平板电脑和智能音箱）是典型的例子。在使用它们时，经常会发生听音乐时出现故障，或者流媒体视频出现卡顿、缓冲和抖动。虽然令人讨厌，但用户不太可能因此而丧生。'
- en: '**Firm real-timesystems** fall in-between the hard and soft real-time ones—deadlines
    are important and will be met as far as is possible, but again, no ironclad guarantees
    can be made. Performance degradation due to missing too many deadlines is an issue
    here.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中实时系统**介于硬实时和软实时系统之间——截止日期很重要，尽可能会被满足，但同样，无法做出铁clad保证。由于错过太多截止日期而导致性能下降是一个问题。'
- en: Scheduling policies
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度策略
- en: 'A key job of the **operating system** (**OS**) is to schedule runnable tasks.
    The POSIX standard states that a POSIX-complaint OS must provide (at least) three scheduling
    policies. A scheduling policy is really the scheduling algorithm used by the OS
    to schedule tasks. In this book, we will not delve into such details, but we do
    need the application developer to be aware of the scheduling policies available.
    These are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统**（OS）的一个关键工作是调度可运行的任务。POSIX标准规定POSIX兼容的操作系统必须提供（至少）三种调度策略。调度策略实际上是操作系统用于调度任务的调度算法。在本书中，我们不会深入探讨这些细节，但我们确实需要应用程序开发人员了解可用的调度策略。这些如下：'
- en: '`SCHED_FIFO`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO`'
- en: '`SCHED_RR`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_RR`'
- en: '`SCHED_OTHER` (also known as `SCHED_NORMAL`)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_OTHER`（也称为`SCHED_NORMAL`）'
- en: Our discussions on this, naturally, will be solely with regard to the Linux
    OS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论自然而然地将仅涉及Linux操作系统。
- en: The first important thing to understand is that the vanilla Linux OS is not
    an RTOS; it does not support hard real-time and is classified as a **General Purpose
    Operating System** (**GPOS**), like the others—Unix, Windows, and macOS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的第一件重要事情是，普通的Linux操作系统不是实时操作系统；它不支持硬实时，并且被分类为**通用目的操作系统**（**GPOS**），就像其他操作系统一样——Unix，Windows和macOS。
- en: Do read on, though; we shall see that while hard real-time is not possible with
    vanilla Linux, it is indeed possible to run an appropriately patched Linux as
    an RTOS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，请继续阅读；我们将看到，虽然普通的Linux不支持硬实时，但确实可以运行一个经过适当打补丁的Linux作为RTOS。
- en: Linux, though a GPOS, easily performs as a soft real-timesystem. Indeed, its
    high performance characteristics bring it close to being a firm real-time system.
    Thus, the predominant use of the Linux OS in consumer electronics (and enterprise)
    products is not at all surprising.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux是一个GPOS，但它很容易表现为一个软实时系统。事实上，它的高性能特征使其接近成为一个坚实的实时系统。因此，Linux操作系统在消费电子产品（和企业）产品中的主要使用并不奇怪。
- en: Next, the first two scheduling policies that we mentioned—`SCHED_FIFO` and `SCHED_RR`
    —are Linux's soft real-time scheduling policies. The `SCHED_OTHER` (also known
    as `SCHED_NORMAL`) policy is the non-real-time scheduling policy and is always
    the default one*.* The `SCHED_OTHER` policy is implemented on modern Linux kernels
    as the **Completely Fair Scheduler** (**CFS**); it's an implementation whose primary
    design goals are to provide overall high system throughput and fairness to every
    runnable task (thread), ensuring that a thread does not starve. This is quite
    the anti-thesis of a real-time policy algorithm, whose overriding motivation is priority of
    the thread.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提到的前两个调度策略——`SCHED_FIFO`和`SCHED_RR`——是Linux的软实时调度策略。`SCHED_OTHER`（也称为`SCHED_NORMAL`）策略是非实时调度策略，并且始终是默认的。`SCHED_OTHER`策略在现代Linux内核上实现为**完全公平调度器**（**CFS**）；其主要设计目标是提供整体高系统吞吐量和对每个可运行任务（线程）的公平性，确保线程不会饿死。这与实时策略算法的主要动机——线程的优先级相反。
- en: For both the `SCHED_FIFO` and `SCHED_RR` soft real-time policies, the Linux
    OS specifies a priority range. This range is from 1 to 99, where 1 is the lowest
    real-time priority and 99 is the highest. The soft real-time scheduling policy
    design on Linux follows what is known as *f**ixed priority preemptive scheduling*,
    and this is important to understand. Fixed priority implies that the applicationdecides
    and fixes the thread priority (and can change it); the OS does not. Preemption is
    the act of the OS snatching away the CPU from the running thread, relegating it
    back to its run queue, and context switching to another thread. The precise preemptive
    semantics with regard to the scheduling policies will be covered next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SCHED_FIFO`和`SCHED_RR`软实时策略，Linux操作系统指定了一个优先级范围。这个范围是从1到99，其中1是最低的实时优先级，99是最高的。Linux上的软实时调度策略设计遵循所谓的*固定优先级抢占调度*，这一点很重要。固定优先级意味着应用程序决定并固定线程优先级（并且可以更改它）；操作系统不会。抢占是操作系统从运行线程手中夺走CPU的行为，将其降回运行队列，并切换到另一个线程。关于调度策略的精确抢占语义将在接下来进行介绍。
- en: We shall now briefly describe, in real-world terms, what it means to be running
    under these differing scheduling policies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要描述在这些不同的调度策略下运行意味着什么。
- en: 'A running `SCHED_FIFO` thread can only be preempted under the following three
    conditions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的`SCHED_FIFO`线程只能在以下三种情况下被抢占：
- en: It (in)voluntarily yields the processor (technically, it moves out from the
    **R** state). This happens when a task issues a blocking call or invokes a system
    call like `sched_yield(2)`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它（不）自愿地放弃处理器（从技术上讲，它从**R**状态移出）。当任务发出阻塞调用或调用`sched_yield(2)`等系统调用时会发生这种情况。
- en: It stops or dies.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它停止或终止。
- en: A higher priority real-time task becomes runnable.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高优先级的实时任务变为可运行状态。
- en: 'This is the key point to understand: a `SCHED_FIFO` task is aggressive; it
    runs with infinite timeslice, and unless it blocks (or is stopped or killed),
    will continue to run on the processor indefinitely. However, the moment a higher
    priority thread becomes runnable (state **R**, entering the run queue), it will
    be preempted in favor of this thread.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要理解的关键点：`SCHED_FIFO`任务是具有侵略性的；它以无限时间片运行，除非它被阻塞（或停止或终止），否则将继续在处理器上运行。然而，一旦更高优先级的线程变为可运行状态（状态**R**，进入运行队列），它将被优先于这个线程。
- en: '`SCHED_RR` behavior is nearly identical to that of `SCHED_FIFO`, except that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCHED_RR`的行为几乎与`SCHED_FIFO`相同，唯一的区别是：'
- en: 'It has a finite timeslice, and thus has an additional scenario under which
    it can be preempted: when its timeslice expires.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个有限的时间片，因此在时间片到期时可以被抢占的额外情况。
- en: When preempted, the task is moved to the tail of the run queue for its priority
    level, ensuring that all `SCHED_RR` tasks at the same priority level are executed
    in turn (hence its name round robin).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被抢占时，任务被移动到其优先级级别的运行队列尾部，确保所有相同优先级级别的`SCHED_RR`任务依次执行（因此它的名称为轮询）。
- en: Notice that on an RTOS the scheduling algorithm is simple, as all it really
    has to do is implement this semantic: the highest priority runnable thread must
    be the thread that is running.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在RTOS上，调度算法是简单的，因为它实际上只需要实现这个语义：最高优先级的可运行线程必须是正在运行的线程。
- en: 'All threads run under the `SCHED_OTHER` (or `SCHED_NORMAL`) scheduling policy
    by default. It is a decidedly non-real-time policy, the emphasis being on fairness
    and overall throughput. Its implementation from Linux kernel version 2.6.0 up
    until 2.6.22 (inclusive) was via the so-called O(1) scheduler; from 2.6.23 onward,
    a further improved algorithm called the **Completely Fair Scheduler** (**CFS**) implements
    this scheduling policy (actually a scheduling class). Refer to the following table
    for more information:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程默认情况下都在`SCHED_OTHER`（或`SCHED_NORMAL`）调度策略下运行。这是一个明显的非实时策略，重点是公平性和整体吞吐量。从Linux内核版本2.6.0到2.6.22（包括）的实现是通过所谓的O(1)调度程序；从2.6.23开始，进一步改进的算法称为**完全公平调度器**（**CFS**）实现了这种调度策略（实际上是一种调度类）。有关更多信息，请参考以下表格：
- en: '| **Scheduling policy** | **Type** | **Priority range** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **调度策略** | **类型** | **优先级范围** |'
- en: '| `SCHED_FIFO` | Soft real-time: Aggressive, unfair | 1 to 99 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_FIFO` | 软实时：激进，不公平 | 1到99 |'
- en: '| `SCHED_RR` | Soft real-time: Less aggressive | 1 to 99 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_RR` | 软实时：较不激进 | 1到99 |'
- en: '| `SCHED_OTHER` | Non real-time: Fair, time sharing; the default | Nice value
    (-20 to +19) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `SCHED_OTHER` | 非实时：公平，时间共享；默认值 | 优先级范围（-20到+19）|'
- en: Though not very commonly used, we point out that Linux also supports a batched
    mode process execution policy with the SCHED_BATCH policy. Also, the SCHED_IDLE
    policy is used for very low priority background tasks. (In fact, the CPU idle
    thread—(mis)named `swapper` with PID `0`, exists for each CPU and runs only when
    absolutely no other task wants the processor).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不太常用，但我们指出Linux也支持使用SCHED_BATCH策略的批处理模式进程执行策略。此外，SCHED_IDLE策略用于非常低优先级的后台任务。（实际上，CPU空闲线程
    - 名为`swapper`，PID为`0`，每个CPU都存在，并且只有在绝对没有其他任务想要处理器时才运行）。
- en: Peeking at the scheduling policy and priority
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看调度策略和优先级
- en: 'Linux provides the `chrt(1)`utility to view and change a thread''s (or process)
    real-time scheduling policy and priority. A quick demonstration of using it to
    display the scheduling policy and priority of a given process (by PID) can be
    seen in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了`chrt(1)`实用程序来查看和更改线程（或进程）的实时调度策略和优先级。可以在以下代码中看到使用它来显示给定进程（按PID）的调度策略和优先级的快速演示：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding, we have queried the scheduling policy and priority of the `chrt(1)` process
    itself (with the shell's `$$` variable). Try this for other threads; you will
    notice the policy is (almost) always `SCHED_OTHER` and that the real-time priority
    is zero. A real-time priority of zero implies that the process is not real time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内容中，我们已经查询了`chrt(1)`进程本身的调度策略和优先级（使用shell的`$$`变量）。尝试对其他线程执行此操作；您会注意到策略（几乎）总是`SCHED_OTHER`，而实时优先级为零。实时优先级为零意味着该进程不是实时的。
- en: You can always query a thread's scheduling policy and (real-time) priority by
    passing the thread PID (via the output of `ps -LA` or similar) to `chrt(1)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将线程PID（通过`ps -LA`的输出或类似方式）传递给`chrt(1)`来查询线程的调度策略和（实时）优先级。
- en: The nice value
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`nice value`'
- en: 'So, now you may be wondering, if all non-real-time threads (the `SCHED_OTHER`
    chaps) have a priority of zero, then how can I support prioritization between
    them? Well, that''s exactly what the nice value of a `SCHED_OTHER` thread is for:
    it''s the (older) Unix-style priority model and now, on Linux, specifies a relative
    priority between the non-real-time threads.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在您可能会想知道，如果所有非实时线程（`SCHED_OTHER`）的优先级都为零，那么我如何在它们之间支持优先级？好吧，这正是`SCHED_OTHER`线程的`nice
    value`的用途：这是（较旧的）Unix风格的优先级模型，现在在Linux上指定了非实时线程之间的相对优先级。
- en: 'The nice value is a priority range between **-20** to **+19** (on modern Linux),
    with the base priority being zero. On Linux, it''s a per-thread attribute; when
    a thread is created, it inherits the nice value of its creator thread—zero being
    the default. Refer to the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`nice value`是在现代Linux上介于`-20`到`+19`之间的优先级范围，基本优先级为零。在Linux上，这是一个每个线程的属性；当创建线程时，它会继承其创建者线程的`nice
    value` - 零是默认值。请参考以下图表：'
- en: '![](img/7552b647-8192-4284-ab25-ef4e8ba443a2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7552b647-8192-4284-ab25-ef4e8ba443a2.png)'
- en: 'Figure 2: Linux thread priority ranges'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Linux线程优先级范围
- en: From 2.6.23 (with the CFS kernel scheduler), the nice value of a thread has
    a large impact (a factor of 1.25 for each degree of nice value) on scheduling;
    thus, **-20** nice value threads get much more CPU bandwidth (this is good for
    CPU-sensitive applications like multimedia) and **+19** nice value threads get
    very little CPU.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.6.23（使用CFS内核调度程序），线程的`nice value`对调度有很大影响（每个`nice value`度的因素为1.25）；因此，`-20`的`nice
    value`线程获得更多的CPU带宽（这对于像多媒体这样对CPU敏感的应用程序很有好处），而`+19`的`nice value`线程获得的CPU很少。
- en: An application programmer can query and set the nice value via the `nice(1)` command-line
    utility, and the `nice(2)`, `setpriority(2)`, and `sched_setattr(2)` system calls
    (the last being the most recent and correct one to use). We refer you to the respective
    man pages for these APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序员可以通过`nice(1)`命令行实用程序以及`nice(2)`，`setpriority(2)`和`sched_setattr(2)`系统调用（最后一个是最近和正确的使用方法）来查询和设置`nice
    value`。我们建议您参考这些API的相应手册页。
- en: Keep in mind that a real-time (`SCHED_FIFO` or `SCHED_RR`) thread is always
    superior to a `SCHED_OTHER` thread in terms of priority (thus pretty much guaranteeing
    that it will get a chance to run earlier).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，实时（`SCHED_FIFO`或`SCHED_RR`）线程在优先级方面始终优于`SCHED_OTHER`线程（因此几乎可以保证它将有机会更早运行）。
- en: CPU affinity
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU亲和力
- en: Let's visualize a Linux system with four CPU cores and, for simplicity, one
    ready-to-run thread. On which CPU core will this thread run? The kernel will decide
    this; the key thing to realize is that it could run upon any of the four available
    CPUs!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个具有四个CPU核心的Linux系统，为简单起见，有一个准备运行的线程。这个线程将在哪个CPU核心上运行？内核将决定这一点；要意识到的关键事情是它可以在四个可用的CPU中的任何一个上运行！
- en: 'Can the CPU(s) it could possibly be run upon be specified by the programmer?
    Yes, indeed; just this feature alone is called CPU affinity. On Linux, it is a
    per-thread attribute (within the OS). The CPU affinity can be changed on a per-thread
    basis by changing the thread''s CPU affinity mask; this is achieved, of course,
    via a system call. Let''s take a look at the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以指定它可能运行的CPU吗？是的，确实；这个特性本身就叫做CPU亲和力。在Linux上，这是一个每个线程的属性（在操作系统内）。CPU亲和力可以通过改变线程的CPU亲和力掩码来在每个线程上进行更改；当然，这是通过系统调用实现的。让我们看一下下面的代码：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The kernel scheduler will honor the CPU mask—the set of CPUs the thread is allowed
    to execute upon—set by the programmer. We are expected to specify the CPU affinity
    mask as a `cpu_set_t` object. (We refer the reader to the man page on `sched_setaffinity(2)`, which
    helpfully provides an example program).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 内核调度程序将遵守程序员设置的CPU掩码，即线程被允许执行的CPU集合。我们期望将CPU亲和力掩码指定为`cpu_set_t`对象。（我们建议读者参考`sched_setaffinity(2)`的手册页，它提供了一个示例程序）。
- en: Note that the pthreads framework provides the wrapper APIs `pthread_setaffinity_np(3)` and `pthread_getaffinity_np(3)` to
    perform the same on a given thread (they internally invoke the `sched_setaffinity(2)` system
    call).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pthread框架提供了包装API `pthread_setaffinity_np(3)`和`pthread_getaffinity_np(3)`，以在给定线程上执行相同的操作（它们在内部调用`sched_setaffinity(2)`系统调用）。
- en: 'An interesting design is that of CPU reservation. On a sufficiently multi-core
    system (say we have a system with four CPU cores: 0, 1, 2, and 3), you can use
    the preceding CPU affinity mask model to effectively set aside one CPU core (say
    core 3) for a given thread (or threads) that are crucial to performance. This
    implies that you must set the CPU mask for that thread to the particular CPU (say
    core 3) and, importantly, set the CPU mask for all other threads to exclude core
    3.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CPU预留的一个有趣设计是CPU亲和力掩码模型，可以在多核系统上有效地为性能关键的线程（或线程）设置一个CPU核心。这意味着必须为该线程设置特定的CPU掩码，并且将所有其他线程的CPU掩码设置为排除核心3。
- en: 'Though it may sound simple, it''s really not a trivial exercise; some of the
    reasons why this is the case are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来很简单，但这并不是一个微不足道的练习；其中一些原因如下：
- en: You must realize that the CPU set aside is not really exclusively reserved for
    the thread(s) specified; for true CPU reservation, except for the given thread(s)
    running on that CPU, all other threads on the entire system must somehow be excluded
    from running on that CPU.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须意识到，预留的CPU并不是真正专门为指定的线程（们）保留的；对于真正的CPU预留，除了在该CPU上运行的给定线程（们）之外，整个系统上的所有其他线程都必须以某种方式被排除在该CPU之外。
- en: As a general guideline, the OS scheduler best understands how to allocate CPU
    bandwidth among available CPU cores (it has a load balancer component and understands
    the CPU hierarchy); thus, CPU allocation is best left to the OS.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一般准则，操作系统调度程序最了解如何在可用的CPU核心之间分配CPU带宽（它具有负载平衡器组件并了解CPU层次结构）；因此，最好将CPU分配留给操作系统。
- en: 'Modern Linux kernels have support for a very powerful feature: **control groups** (**cgroups**).
    (see [Appendix B](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf), *Daemon
    Processes*, for a note). With regard to CPU reservation, it can be achieved via
    the cgroup model. Please refer to the following Q&A on Stack Overflow for more
    details: *How to use cgroups to limit all processes except whitelist to a single
    CPU*:[https://unix.stackexchange.com/questions/247209/how-to-use-cgroups-to-limit-all-processes-except-whitelist-to-a-single-cpu](https://unix.stackexchange.com/questions/247209/how-to-use-cgroups-to-limit-all-processes-except-whitelist-to-a-single-cpu).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux内核支持一个非常强大的功能：**控制组**（**cgroups**）。关于CPU预留，可以通过cgroup模型实现。请参考Stack Overflow上的以下问答以获取更多详细信息：*如何使用cgroups限制除白名单之外的所有进程到单个CPU*：[https://unix.stackexchange.com/questions/247209/how-to-use-cgroups-to-limit-all-processes-except-whitelist-to-a-single-cpu](https://unix.stackexchange.com/questions/247209/how-to-use-cgroups-to-limit-all-processes-except-whitelist-to-a-single-cpu)。
- en: 'For convenience, Linux provides the `taskset(1)` utility as a simple way to
    query and specify the CPU affinity mask of any given process (or thread). Here,
    we shall query the CPU affinity mask of two processes. (we assume that the system
    we are running on has four CPU cores; we can use `lscpu(1)` to query this):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Linux提供了`taskset(1)`实用程序，作为查询和指定任何给定进程（或线程）的CPU亲和力掩码的简单方法。在这里，我们将查询两个进程的CPU亲和力掩码。（我们假设我们运行的系统有四个CPU核心；我们可以使用`lscpu(1)`来查询这一点）：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: PID 1's (systemd) CPU affinity mask is `0xf`, which, of course, is binary `1111`.
    If a bit is set `1`, it implies the thread can run on the CPU represented by that
    bit. If the bit is cleared `0`, it implies the thread cannot run on the CPU represented
    by that bit. Exactly as expected, on a four-CPU box, the CPU affinity bitmask
    is 0xf (1111) by default, implying that, the process (or thread) can run on any
    available CPU. Interestingly, in the preceding output the bash process appears
    to have a CPU affinity mask of `7`, which translates to binary `0111`, implying
    that it will never be scheduled to run on CPU 3.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: PID 1（systemd）的CPU亲和力掩码是`0xf`，当然，这是二进制`1111`。如果设置了一个位`1`，则表示线程可以在由该位表示的CPU上运行。如果清除了该位`0`，则表示线程不能在由该位表示的CPU上运行。正如预期的那样，在一个四CPU的盒子上，CPU亲和力位掩码默认为0xf（1111），这意味着进程（或线程）可以在任何可用的CPU上运行。有趣的是，在前面的输出中，bash进程似乎具有CPU亲和力掩码为`7`，这对应于二进制`0111`，这意味着它永远不会被调度到CPU
    3上运行。
- en: 'In the following code, a simple shell script invokes the `chrt(1)` as well
    as the `taskset(1)` utility in a loop, displaying the scheduling policy, (real-time)
    priority, and CPU affinity mask of every process that''s alive on the system:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，一个简单的shell脚本在循环中调用`chrt(1)`和`taskset(1)`实用程序，显示系统上每个进程的调度策略（实时）优先级和CPU亲和力掩码。
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We encourage the reader to try this out on their own system. In the following
    code, we `grep(1)` for any `SCHED_FIFO` tasks:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励读者在自己的系统上尝试这个。在下面的代码中，我们使用`grep(1)`来查找任何`SCHED_FIFO`任务：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Yes! We find some threads. Wow, they are all of `SCHED_FIFO` real-time priority
    99! Let''s check out who these threads are (with a cool one-liner script, too):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们找到了一些线程。哇，它们都是`SCHED_FIFO`实时优先级99！让我们来看看这些线程是谁（还有一个很酷的一行脚本）：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For clarity, the `ps aux` heading—which would not normally be displayed—is shown
    in the preceding code. Also, we use the `ps aux` style as, conveniently, kernel
    threads are displayed in brackets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，前面的代码中显示了通常不会显示的`ps aux`标题。此外，我们使用`ps aux`样式，因为内核线程会显示在括号中。
- en: 'It turns out (here, in this particular example, at least) that they are all
    kernel threads (see the following information box). The important thing to understand
    is that they are deliberately `SCHED_FIFO` (real-time) priority 99, so that, when
    they want to run on the CPU, they will run pretty much immediately. In fact, let''s
    take a glance at their CPU affinity mask: it''s deliberately allocated (with values
    like 1,2,4,8) so that they are affined to a particular CPU core. It''s important
    to understand that these kernel threads are not CPU hoggers; in reality, they
    will spend most of the time asleep (state **S**) and only spring into action when
    required.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明（至少在这个特定的例子中），它们都是内核线程（请参阅下面的信息框）。要理解的重要一点是，它们故意设置为`SCHED_FIFO`（实时）优先级99，这样，当它们想要在CPU上运行时，它们几乎立即就会运行。实际上，让我们来看一下它们的CPU亲和性掩码：它们被故意分配（具有值如1,2,4,8），以便它们与特定的CPU核心相关联。重要的是要理解，这些内核线程并不会占用CPU；实际上，它们大部分时间都处于睡眠状态（状态**S**），只有在需要时才会立即行动。
- en: 'Kernel threads are not very different from their user space counterparts; they
    too compete for the CPU resource. The key difference is that kernel threads have
    no view of user space—they only execute in kernel virtual address space (whereas
    user space threads, of course, see both: userland in normal user mode and, upon
    issuing a system call, they switch to kernel space).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 内核线程与它们的用户空间对应物并没有太大的不同；它们也会竞争CPU资源。关键的区别在于，内核线程无法看到用户空间，它们只在内核虚拟地址空间中执行（而用户空间线程当然可以看到用户模式下的用户空间，并且在发出系统调用时会切换到内核空间）。
- en: Exploiting Linux's soft real-time capabilities
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Linux的软实时能力
- en: 'Recall that, earlier in this chapter, we stated: The soft real-time scheduling
    policy design on Linux follows what is known as fixed priority preemptive scheduling;
    fixed priority implies that the application decides and fixes the thread priority
    (and can change it); the OS does not.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章的前面，我们曾经说过：Linux上的软实时调度策略设计遵循所谓的固定优先级抢占式调度；固定优先级意味着应用程序决定并固定线程优先级（并且可以更改它）；操作系统不会。
- en: Not only can the application switch between thread priorities, but even the
    scheduling policy (in effect, the scheduling algorithm used under the hood by
    the OS) can be changed by the application developer; this can be done on a per-thread
    basis. That's indeed very powerful; it implies that an application having, say,
    five threads, can decide what scheduling policy and priority to assign to each
    of these threads!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不仅可以在线程优先级之间切换，甚至可以由应用程序开发人员更改调度策略（实际上是操作系统在后台使用的调度算法）；这可以在每个线程的基础上进行。这确实非常强大；这意味着一个应用程序拥有，比如说，五个线程，可以决定为每个线程分配什么调度策略和优先级！
- en: Scheduling policy and priority APIs
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度策略和优先级API
- en: Obviously, in order to achieve this, the OS must expose some APIs; indeed, there
    are a few system calls that deal with exactly this—changing a given process or
    thread's scheduling policy and priority.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了实现这一点，操作系统必须暴露一些API；事实上，有一些系统调用处理这一点——改变给定进程或线程的调度策略和优先级。
- en: 'Here''s a list—a sampling, really—of some of the more important of these APIs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些更重要的这些API中的一部分，实际上只是一小部分：
- en: '`sched_setscheduler(2)`: Sets the scheduling policy and parameters of a specified
    thread.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_setscheduler(2)`: 设置指定线程的调度策略和参数。'
- en: '`sched_getscheduler(2)`: Returns the scheduling policy of a specified thread.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_getscheduler(2)`: 返回指定线程的调度策略。'
- en: '`sched_setparam(2)`: Sets the scheduling parameters of a specified thread.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_setparam(2)`: 设置指定线程的调度参数。'
- en: '`sched_getparam(2)`: Fetches the scheduling parameters of a specified thread.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_getparam(2)`: 获取指定线程的调度参数。'
- en: '`sched_get_priority_max(2)`: Returns the maximum priority available in a specified
    scheduling policy.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_get_priority_max(2)`: 返回指定调度策略中可用的最大优先级。'
- en: '`sched_get_priority_min(2)`: Returns the minimum priority available in a specified
    scheduling policy.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_get_priority_min(2)`: 返回指定调度策略中可用的最小优先级。'
- en: '`sched_rr_get_interval(2)`: Fetches the quantum used for threads that are scheduled
    under the round-robin scheduling policy.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_rr_get_interval(2)`: 获取在轮转调度策略下调度的线程使用的时间片。'
- en: '`sched_setattr(2)`: Sets the scheduling policy and parameters of a specified
    thread. This (Linux-specific) system call provides a superset of the functionality
    of `sched_setscheduler(2)` and `sched_setparam(2)`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_setattr(2)`: 设置指定线程的调度策略和参数。这个（特定于Linux的）系统调用提供了`sched_setscheduler(2)`和`sched_setparam(2)`功能的超集。'
- en: '`sched_getattr(2)`: Fetches the scheduling policy and parameters of a specified
    thread. This (Linux-specific) system call provides a superset of the functionality
    of `sched_getscheduler(2)` and `sched_getparam(2)`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_getattr(2)`: 获取指定线程的调度策略和参数。这个（特定于Linux的）系统调用提供了`sched_getscheduler(2)`和`sched_getparam(2)`功能的超集。'
- en: '`sched_setattr(2)` and `sched_getattr(2)` are currently considered to be the
    latest and more powerful of these APIs. Also, on Ubuntu, one can issue the convenient
    `man -k sched` command to see all utils and APIs related to scheduling (-k: keyword).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`sched_setattr(2)`和`sched_getattr(2)`目前被认为是这些API中最新和最强大的。此外，在Ubuntu上，可以使用方便的`man
    -k sched`命令来查看与调度相关的所有实用程序和API（-k：关键字）。'
- en: 'The astute reader will quickly notice that all of the APIs we mentioned previously are
    system calls (section 2 of the manual), but what about pthreads APIs? Indeed,
    they do exist and, as you may have guessed, are mostly just wrappers that invoke
    the underlying system calls; in the following code, we show two of them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者很快会注意到我们之前提到的所有API都是系统调用（手册的第2节），但pthread API呢？的确，它们也存在，并且，正如你可能已经猜到的那样，它们大多只是调用底层系统调用的包装器；在下面的代码中，我们展示了其中的两个：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s important to note that, in order to set the scheduling policy and priority
    of a thread (or process), you need to be running with root access. Recall that
    the modern way to bestow privileges to threads is via the Linux Capabilities model
    (we covered this in detail in [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*). A thread with the capability `CAP_SYS_NICE` can arbitrarily
    set its scheduling policy and priority to any value it desires. Think about it:
    if this were not the case, then pretty much all apps could insist that they run
    as `SCHED_FIFO` priority 99, effectively rendering the whole concept meaningless!'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，为了设置线程（或进程）的调度策略和优先级，您需要以root访问权限运行。请记住，赋予线程特权的现代方式是通过Linux Capabilities模型（我们在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)中详细介绍了*进程特权*）。具有`CAP_SYS_NICE`能力的线程可以任意将其调度策略和优先级设置为任何它想要的值。想一想：如果不是这样的话，那么几乎所有的应用程序都可以坚持以`SCHED_FIFO`优先级99运行，从而有效地使整个概念变得毫无意义！
- en: '`pthread_setschedparam(3)` internally invokes the the `sched_setscheduler(2)` system
    call, and `pthread_getschedparam(3)` invokes the `sched_getscheduler(2)` system
    call under the hood. Their API signatures are:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_setschedparam(3)`在内部调用了`sched_setscheduler(2)`系统调用，`pthread_getschedparam(3)`在底层调用了`sched_getscheduler(2)`系统调用。它们的API签名是：'
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Other pthreads APIs exist as well. Notice that the ones shown here help set
    up the thread attribute structure: `pthread_attr_setinheritsched(3)`, `pthread_attr_setschedparam(3)`, `pthread_attr_setschedpolicy(3)`, and
    `pthread_setschedprio(3)`, to name a few.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他pthread API。请注意，这里显示的API有助于设置线程属性结构：`pthread_attr_setinheritsched(3)`、`pthread_attr_setschedparam(3)`、`pthread_attr_setschedpolicy(3)`和`pthread_setschedprio(3)`等。
- en: The man page on `sched(7)` (look it up by typing `man 7 sched` in a terminal
    window) details the available APIs for controlling scheduling policy, priority,
    and behavior for threads. It provides details on current Linux scheduling policies,
    privileges required to change them, relevant resource limit values, and kernel
    tunables for scheduling, as well as other miscellaneous details.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`sched(7)`的man页面（在终端窗口中键入`man 7 sched`查找）详细介绍了用于控制线程调度策略、优先级和行为的可用API。它提供了有关当前Linux调度策略、更改它们所需的权限、相关资源限制值和调度的内核可调参数，以及其他杂项细节。'
- en: Code example – setting a thread scheduling policy and priority
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例-设置线程调度策略和优先级
- en: To help solidify the concepts that we learned about in the previous sections
    of this chapter, we will design and implement a small demo program, illustrating
    how a modern Linux pthreads application can set an individual thread's scheduling
    policy and priority to make threads (soft) real-time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固本章前几节学到的概念，我们将设计并实现一个小型演示程序，演示现代Linux pthreads应用程序如何设置单个线程的调度策略和优先级，以使线程（软）实时。
- en: 'Our demo app will have a total of three threads. The first is `main()`, of
    course. The following bullet points show what the application is designed to do:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示应用程序将有三个线程。第一个当然是`main()`。以下要点显示了应用程序的设计目的：
- en: 'Thread 0 (`main()`, really):'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程0（实际上是`main()`）：
- en: 'This runs as a `SCHED_OTHER` scheduling policy with real-time priority 0, which
    is the default. It does the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这以`SCHED_OTHER`调度策略和实时优先级0运行，这是默认值。它执行以下操作：
- en: Queries the priority range of `SCHED_FIFO`, printing out the values
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询`SCHED_FIFO`的优先级范围，并打印出值
- en: Creates two worker threads (with joinability state set to detached); they will
    automatically inherit the scheduling policy and priority of main
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个工作线程（可连接状态设置为分离状态）；它们将自动继承主线程的调度策略和优先级
- en: Prints the character `m` to the terminal in a loop (using our `DELAY_LOOP` macro;
    for a little longer than usual)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中向终端打印字符`m`（使用我们的`DELAY_LOOP`宏；比平常长一点）
- en: Terminates
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止
- en: 'Worker thread 1:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程1：
- en: Changes its scheduling policy to `SCHED_RR`, setting its real-time priority
    to the value passed on the command line
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其调度策略更改为`SCHED_RR`，将其实时优先级设置为命令行传递的值
- en: Sleeps for 2 seconds (thus blocking on I/O, allowing main to get some work done)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠2秒（因此在I/O上阻塞，允许主线程完成一些工作）
- en: Upon waking up, it prints the character `1` to the terminal in a loop (via the `DELAY_LOOP` macro)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒后，它在循环中向终端打印字符`1`（通过`DELAY_LOOP`宏）
- en: Terminates
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止
- en: 'Worker thread 2:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程2：
- en: Changes its scheduling policy to `SCHED_FIFO`, setting its real-time priority
    to the value passed on the command line plus 10
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其调度策略更改为`SCHED_FIFO`，将其实时优先级设置为命令行传递的值加上10
- en: Sleeps for 4 seconds (thus blocking on I/O, allowing Thread 1 to do some work)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠4秒（因此在I/O上阻塞，允许线程1完成一些工作）
- en: Upon waking up, it prints the character `2` to the terminal in a loop
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒后，它在循环中向终端打印字符`2`
- en: Terminates
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止
- en: 'Let''s take a quick look at the code (`ch17/sched_rt_eg.c`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下代码（`ch17/sched_rt_eg.c`）：
- en: For readability, only key parts of the source code are displayed here; to view
    the complete source code, and build and run it, the entire tree is available for
    cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，这里只显示了源代码的关键部分；要查看完整的源代码，并构建和运行它，整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'The following code is the code for `main()`. (We have omitted showing the error
    checking code):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`main()`的代码。（我们省略了显示错误检查代码）：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is for worker thread 1. We have omitted showing the error
    checking code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是工作线程1的代码。我们省略了显示错误检查代码：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code of worker thread 2 is almost identical to that of the preceding worker
    thread; the difference, however, is that we set the policy to `SCHED_FIFO` and
    the real-time priority is bumped up by 10 points, thus making it more aggressive.
    We only show this snippet here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程2的代码几乎与前面的工作线程相同；然而，不同之处在于我们将策略设置为`SCHED_FIFO`，并且将实时优先级提高了10分，从而使其更具侵略性。我们只在这里显示这个片段：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s build it (we definitely recommend building the debug version, as then
    the `DELAY_LOOP` macro''s effect is clearly seen) and give it a spin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建它（我们强烈建议构建调试版本，因为这样`DELAY_LOOP`宏的效果就可以清楚地看到），然后试一试：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We must run our app as root; we use `sudo(8)` to do so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以root身份运行我们的应用程序；我们使用`sudo(8)`来做到这一点：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding output, we can see the following characters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到以下字符：
- en: '`m`: This implies that the main thread is currently running on CPU'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：这意味着`main`线程目前正在CPU上运行'
- en: '`1`: This implies that the (soft) real-time worker thread 1 is currently running
    on CPU'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这意味着（软）实时工作线程1目前正在CPU上运行'
- en: '`2`: This implies that the (soft) real-time worker thread 2 is currently running
    on CPU'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这意味着（软）实时工作线程2目前正在CPU上运行'
- en: 'But, oops, the preceding output really isn''t what we expect: the `m`, `1`,
    and `2` characters are intermingled, leading us to conclude that they have been
    time-sliced.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，哎呀，前面的输出并不是我们期望的：`m`，`1`和`2`字符混在一起，让我们得出它们已经被分时切片的结论。
- en: 'But this isn''t the case. Think about it—the output is as it appears in the
    preceding code for the simple reason that we have run the app on a multi-core system
    (in the preceding code, on a laptop with four CPU cores); thus, the kernel scheduler
    has cleverly exploited the hardware and run all three threads in parallel on different
    CPU cores! So, in order to have our demo application run the way we expect, we
    need to ensure that it runs on exactly one CPU core and no more. How? Recall CPU
    affinity: we can use the `sched_setaffinity(2)` system call to do this. There
    is an easier way: we can use `taskset(1)` to guarantee that the process (and thus
    all threads within it) run on only one CPU core (for example, CPU 0) by specifying
    the CPU mask value as `01`. So, let''s perform the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实并非如此。仔细想想——输出与前面的代码中所显示的一样，是因为我们在多核系统上运行了应用程序（在前面的代码中，在一个具有四个CPU核心的笔记本电脑上）；因此，内核调度程序巧妙地利用了硬件，在不同的CPU核心上并行运行了所有三个线程！因此，为了使我们的演示应用程序按我们的期望运行，我们需要确保它只在一个CPU核心上运行，而不是更多。如何做到？回想一下CPU亲和力：我们可以使用`sched_setaffinity(2)`系统调用来做到这一点。还有一种更简单的方法：我们可以使用`taskset(1)`来保证进程（因此其中的所有线程）只在一个CPU核心上运行（例如，CPU
    0），方法是将CPU掩码值指定为`01`。因此，让我们执行以下命令：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Yes, using the `taskset(1)` to ensure that the whole app—all three threads—runs
    on the first CPU core has the desired effect. Now, study the preceding output
    carefully; we can see that the `main()` thread – non-real-time—runs first for
    about 2 seconds; once 2 seconds have elapsed, the worker thread 1 wakes up, becoming
    runnable. As its policy and priority far outweighs that of main(), it preempts
    main() and runs, printing 1s to the terminal. Remember that worker thread 2 is
    also running in parallel, but, of course, it sleeps for 4 seconds. So, 2 seconds
    later—once a total of 4 seconds have elapsed – worker thread 2 wakes up, becoming
    runnable. As its policy is `SCHED_FIFO` and, more importantly, its priority  is
    10 points higher than thread 1, it preempts thread 1 and runs, printing `2s` to
    the terminal. Until it terminates, the other threads cannot run; once it does,
    worker thread 1 runs. Again, until it terminates, main() cannot run; once it does
    die, main() finally gets the CPU and finishes, and so the application terminates.
    Interesting; do try it out for yourself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，使用`taskset(1)`来确保整个应用程序——所有三个线程——在第一个CPU核心上运行产生了期望的效果。现在，仔细研究前面的输出；我们可以看到`main()`线程——非实时——首先运行了大约2秒；一旦经过了2秒，工作线程1就会醒来，变得可运行。由于它的策略和优先级远远超过了`main()`，它抢占了`main()`并运行，向终端打印1s。请记住，工作线程2也在并行运行，但是它当然会睡眠4秒。所以，2秒后——一共经过了4秒——工作线程2醒来，变得可运行。由于它的策略是`SCHED_FIFO`，更重要的是，它的优先级比线程1高10分，它抢占了线程1并运行，向终端打印`2s`。在它终止之前，其他线程无法运行；一旦它终止，工作线程1运行。同样，在它终止之前，`main()`无法运行；一旦它终止，`main()`最终获得CPU并完成，应用程序终止。有趣；你自己试试吧。
- en: For your information, the man page on `pthread_setschedparam(3)` has a fairly
    detailed example program: [http://man7.org/linux/man-pages/man3/pthread_setschedparam.3.html](http://man7.org/linux/man-pages/man3/pthread_setschedparam.3.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考，关于`pthread_setschedparam(3)`的man页面有一个相当详细的示例程序：[http://man7.org/linux/man-pages/man3/pthread_setschedparam.3.html](http://man7.org/linux/man-pages/man3/pthread_setschedparam.3.html)。
- en: Soft real-time – additional considerations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软实时——额外考虑
- en: 'A few additional points to think about: we have the power to associate threads
    with a (soft) real-time policy and priority (with the caveat that we have root
    access; or the CAP_SYS_NICE capability). For most human interactive application
    domains this is not only unnecessary, but it will cause disconcerting feedback
    and side effects to the typical desktop or server system end user. As a general
    rule, you should avoid using these real-time policies on interactive applications.
    Only when it is essential to highly prioritize a thread—typically for a real-time application
    (perhaps running on an embedded Linux box), or some kinds of benchmarking or profiling
    software (`perf(1)` being a good example; one can specify the `--realtime=n` parameter
    to `perf` to have it run as `SCHED_FIFO` priority `n`)—should you consider using
    these powerful technologies.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的要点需要考虑：我们有权将线程与（软）实时策略和优先级相关联（前提是我们拥有root访问权限；或者CAP_SYS_NICE能力）。对于大多数人机交互应用领域来说，这不仅是不必要的，而且会给典型的桌面或服务器系统最终用户带来令人不安的反馈和副作用。一般来说，您应该避免在交互式应用程序上使用这些实时策略。只有在必须高度优先考虑一个线程时——通常是为了实时应用程序（可能在嵌入式Linux盒子上运行），或某些类型的基准测试或分析软件（`perf(1)`是一个很好的例子；可以指定`--realtime=n`参数给`perf`，使其以`SCHED_FIFO`优先级`n`运行）——您才应该考虑使用这些强大的技术。
- en: Also, the precise real-time priorities to be used are left to the application
    architects; using the same priority values for `SCHED_FIFO` and `SCHED_RR` threads
    (recall that both policies are peers, with `SCHED_FIFO` being more aggressive)
    can lead to unpredictable scheduling. Carefully think about the design and accordingly
    set the policy and priority of each real-time thread.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要使用的精确实时优先级留给应用架构师；对于`SCHED_FIFO`和`SCHED_RR`线程使用相同的优先级值（请记住，这两种策略是同级的，`SCHED_FIFO`更为激进）可能会导致不可预测的调度。仔细考虑设计，并相应地设置每个实时线程的策略和优先级。
- en: Finally, though not covered in depth in this book, Linux's cgroups model allows
    you to powerfully control the bandwidth allocation of a resource (CPUs, network,
    and block I/O) for a given process or group of processes. If this is what is required,
    consider using the cgroups framework to achieve your goals.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管本书没有深入介绍，但Linux的cgroups模型允许您强大地控制资源（CPU、网络和块I/O）的带宽分配给特定进程或一组进程。如果需要这样做，请考虑使用cgroups框架来实现您的目标。
- en: RTL – Linux as an RTOS
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTL - Linux作为RTOS
- en: The fact is, incredible as it may seem, the Linux OS can be used as an RTOS;
    that is, a hard real-time-capable RTOS. The project started out as the brainchild
    of Thomas Gleixner (of Linutronix), who wanted to port Linux to become an RTOS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，令人难以置信的是，Linux操作系统可以用作RTOS；也就是说，可以用作硬实时RTOS。该项目最初是Linutronix的Thomas Gleixner的构想。
- en: Again, this is really the beauty of the open source model and Linux; being open
    source, interested, and motivated people take Linux (or other projects) as a starting
    point and build upon it, often coming up with significantly new and useful products.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这真的是开源模型和Linux的美丽之处；作为开源项目，有兴趣和动力的人将Linux（或其他项目）作为起点，并在此基础上构建，通常会产生显著新颖和有用的产品。
- en: 'A few points to note regarding this project are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该项目的一些要点如下：
- en: Modifying the Linux kernel to become an RTOS is a necessarily invasive procedure;
    Linus Torvalds, the de facto Linux boss, does not want this code in the upstream
    (vanilla) Linux kernel. Thus, the real-time Linux kernel project lives as a patch
    series (on kernel.org itself; see the links in the *Further reading* section on
    the GitHub repository for more information) that can be applied upon a mainline
    kernel.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改Linux内核以成为RTOS是一个必然具有侵入性的过程；事实上，Linux的领导者Linus Torvalds不希望这些代码出现在上游（原始）Linux内核中。因此，实时Linux内核项目作为一个补丁系列存在（在kernel.org本身上；请参阅GitHub存储库上的*进一步阅读*部分中的链接以获取更多信息），可以应用于主线内核。
- en: This effort has been successfully undertaken right from the 2.6.18 Linux kernel
    (from perhaps around 2006 or 2007).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一努力从Linux 2.6.18内核开始就已经成功进行（大约从2006年或2007年开始）。
- en: For many years, the project was called Preempt-RT (with the patches themselves
    called PREEMPT_RT).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多年来，该项目被称为Preempt-RT（补丁本身被称为PREEMPT_RT）。
- en: Later (from October 2015 onward), stewardship of the project was taken over
    by the **Linux Foundation** (**LF**)—a positive step. The name was changed from Preempt
    RT to **real-time Linux** (**RTL**).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后来（从2015年10月起），该项目的管理权被**Linux基金会**（**LF**）接管——这是一个积极的举措。名称从Preempt RT更改为**real-time
    Linux**（**RTL**）。
- en: Indeed, the RTL roadmap very much has the goal of pushing relevant PREEMPT_RT
    work upstream (into the mainline Linux kernel; see the *Further reading* on the
    GitHub repository section for a link on this).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，RTL路线图非常有推动相关的PREEMPT_RT工作上游（进入主线Linux内核；请参阅GitHub存储库上的*进一步阅读*部分以获取相关链接）的目标。
- en: In effect, you can apply the appropriate RTL patches and then use Linux as a hard
    real-time RTOS. Industry has already begun to use the project (in industrial control
    apps, drones,  and TV cameras); we can only imagine that this will grow tremendously.
    It's also important to note that having a hard real-time OS is not sufficient
    for true real-time usage; even the applications have to be written to conform
    to real-time expectations. Do check out the *HOWTO* documentation provided on
    this by the RTL project wiki site (see the *Further reading* section on the GitHub
    repository).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以应用适当的RTL补丁，然后将Linux用作硬实时RTOS。行业已经开始在工业控制应用程序、无人机和电视摄像机中使用该项目；我们只能想象这将会大大增长。还要注意的是，拥有硬实时操作系统并不足以满足真正实时使用的要求；甚至应用程序也必须按照实时预期进行编写。请查看RTL项目维基站点上提供的*HOWTO*文档（请参阅GitHub存储库上的*进一步阅读*部分）。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered important concepts related to CPU scheduling on
    Linux and real-time. The reader has been taken through progressive topics on the
    Linux thread state-machine, real-time, CPU affinity, and the available POSIX scheduling
    policies. Furthermore, we have shown APIs—both at the pthreads and system call
    layers—to exploit these powerful mechanisms. A demo application reinforced the
    concepts that we learned. Finally, a quick note on the fact that Linux can also
    be used as a hard real-time (RTOS) was covered.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了与Linux和实时CPU调度相关的重要概念。读者已经逐步了解了Linux线程状态机、实时性、CPU亲和力以及可用的POSIX调度策略等主题。此外，我们展示了在pthread和系统调用层面利用这些强大机制的API。演示应用程序强化了我们学到的概念。最后，我们简要介绍了Linux也可以用作硬实时（RTOS）的事实。
- en: In the next chapter, the reader will be shown how to achieve the best I/O performance
    using modern techniques.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将学习如何利用现代技术实现最佳的I/O性能。
