- en: Chapter 13. Profiling and Tracing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。性能分析和跟踪
- en: Interactive debugging using a source level debugger, as described in the previous
    chapter, can give you an insight into the way a program works, but it constrains
    your view to a small body of code. In this chapter, I will look at the larger
    picture to see if the system is performing as intended.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源级调试器进行交互式调试，如前一章所述，可以让您深入了解程序的工作方式，但它将您的视野限制在一小部分代码上。在本章中，我将着眼于更大的图片，以查看系统是否按预期运行。
- en: Programmers and system designers are notoriously bad at guessing where bottlenecks
    are. So, if your system has performance issues, it is wise to start by looking
    at the full system and then work down, using more sophisticated tools. In this
    chapter I begin with the well-known command, `top`, as a means of getting an overview.
    Often the problem can be localized to a single program, which you can analyze
    using the Linux profiler, `perf`. If the problem is not so localized and you want
    to get a broader picture, `perf` can do that as well. To diagnose problems associated
    with the kernel, I will describe the trace tools, `Ftrace` and `LTTng`, as a means
    of gathering detailed information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和系统设计师在猜测瓶颈位置时通常表现得很糟糕。因此，如果您的系统存在性能问题，最好从整个系统开始查看，然后逐步使用更复杂的工具。在本章中，我首先介绍了众所周知的`top`命令，作为获取概述的手段。问题通常可以局限在单个程序上，您可以使用Linux分析器`perf`进行分析。如果问题不是如此局限，而您想获得更广泛的图片，`perf`也可以做到。为了诊断与内核相关的问题，我将描述跟踪工具`Ftrace`和`LTTng`，作为收集详细信息的手段。
- en: I will also cover Valgrind which, because of its sandboxed execution environment,
    can monitor a program and report on code as it runs. I will complete the chapter
    with a description of a simple trace tool, `strace`, which reveals the execution
    of a program by tracing the system calls it makes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将介绍Valgrind，由于其沙箱执行环境，可以监视程序并在其运行时报告代码。我将以描述一个简单的跟踪工具`strace`来完成本章，它通过跟踪程序所做的系统调用来揭示程序的执行。
- en: The observer effect
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者效应
- en: 'Before diving into the tools, let''s talk about what the tools will show you.
    As is the case in many fields, measuring a certain property affects the observation
    itself. Measuring the electric current in a line requires measuring the voltage
    drop over a small resistor. However, the resistor itself affects the current.
    The same is true for profiling: every system observation has a cost in CPU cycles
    and that resource is no longer spent on the application. Measurement tools also
    mess up caching behavior, eat memory space, and write to disk, which all make
    it worse. There is no measurement without overhead.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解工具之前，让我们谈谈工具将向您展示什么。就像在许多领域一样，测量某个属性会影响观察本身。测量线路中的电流需要测量一个小电阻上的电压降。然而，电阻本身会影响电流。性能分析也是如此：每个系统观察都会消耗CPU周期，这些资源将不再用于应用程序。测量工具还会影响缓存行为，占用内存空间，并写入磁盘，这些都会使情况变得更糟。没有不带开销的测量。
- en: I've often heard engineers say that the results of a profiling job were totally
    misleading. That is usually because they were performing the measurements on something
    approaching a real situation. Always try to measure on the target, using release
    builds of the software, with a valid data set, using as few extra services as
    possible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到工程师说，性能分析的结果完全是误导性的。这通常是因为他们在接近真实情况下进行测量。始终尝试在目标上进行测量，使用软件的发布版本构建，使用有效的数据集，尽可能少地使用额外服务。
- en: Symbol tables and compile flags
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号表和编译标志
- en: We will hit a problem immediately. While it is important to observe the system
    in its natural state, the tools often need additional information to make sense
    of the events.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即遇到一个问题。虽然观察系统处于其自然状态很重要，但工具通常需要额外的信息来理解事件。
- en: Some tools require special kernel options, specifically from those listed in
    the introduction, `perf`, `Ftrace`, and `LTTng`. Therefore, you will probably
    have to build and deploy a new kernel for these tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具需要特殊的内核选项，特别是在介绍中列出的那些，如`perf`，`Ftrace`和`LTTng`。因此，您可能需要为这些测试构建和部署新的内核。
- en: Debug symbols are very helpful in translating raw program addresses into function
    names and lines of code. Deploying executables with debug symbols does not change
    the execution of the code but it does require that you have copies of the binaries
    and the kernel compiled with `debug`, at least for the components you want to
    profile. Some tools work best if you have these installed on the target system,
    `perf`, for example. The techniques are the same as for general debugging, as
    I discussed in [Chapter 12](ch12.html "Chapter 12. Debugging with GDB"), *Debugging
    with GDB*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号对将原始程序地址转换为函数名称和代码行非常有帮助。部署带有调试符号的可执行文件不会改变代码的执行，但这确实需要您拥有使用`debug`编译的二进制文件和内核的副本，至少对于您想要进行性能分析的组件。例如，一些工具在目标系统上安装这些组件效果最佳，比如`perf`。这些技术与一般调试相同，正如我在[第12章](ch12.html
    "第12章。使用GDB进行调试")中所讨论的那样，*使用GDB进行调试*。
- en: If you want a tool to generate call graphs, you may have to compile with stack
    frames enabled. If you want the tool to attribute addresses with lines of code
    accurately, you may need to compile with lower levels of optimization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个工具生成调用图，您可能需要启用堆栈帧进行编译。如果您希望工具准确地将地址与代码行对应起来，您可能需要以较低级别的优化进行编译。
- en: Finally, some tools require instrumentation to be inserted into the program
    to capture samples, so you will have to recompile those components. This applies
    to `gprof` for applications, and `Ftrace` and `LTTng` for the kernel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些工具需要将插装仪器插入程序中以捕获样本，因此您将不得不重新编译这些组件。这适用于应用程序的`gprof`，以及内核的`Ftrace`和`LTTng`。
- en: Be aware that, the more you change the system you are observing, the harder
    it is to relate the measurements you make to the production system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您观察的系统发生的变化越大，您所做的测量与生产系统之间的关系就越难以建立。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is best to adopt a wait-and-see approach, making changes only when the need
    is clear, and being mindful that each time you do so, you will change what you
    are measuring.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好采取等待和观察的方法，只有在需要明确时才进行更改，并且要注意，每次这样做时，都会改变您正在测量的内容。
- en: Beginning to profile
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始进行分析
- en: When looking at the entire system, a good place to start is with a simple tool
    like `top`, which gives you an overview very quickly. It shows you how much memory
    is being used, which processes are eating CPU cycles, and how this is spread across
    different cores and time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看整个系统时，一个很好的起点是使用`top`这样的简单工具，它可以让您快速地获得概览。它会显示正在使用多少内存，哪些进程正在占用CPU周期，以及这些情况如何分布在不同的核心和时间上。
- en: If `top` shows that a single application is using up all the CPU cycles in user
    space then you can profile that application using `perf`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`top`显示单个应用程序在用户空间中使用了所有的CPU周期，那么您可以使用`perf`对该应用程序进行分析。
- en: If two or more processes have a high CPU usage, there is probably something
    that is coupling them together, perhaps data communication. If a lot of cycles
    are spent in system calls or handling interrupts, then there may be an issue with
    the kernel configuration or with a device driver. In either case you need to start
    by taking a profile of the whole system, again using `perf`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多进程的CPU使用率很高，那么它们之间可能存在某种耦合，也许是数据通信。如果大量的周期花费在系统调用或处理中断上，那么可能存在内核配置或设备驱动程序的问题。在任何一种情况下，您需要从整个系统开始进行分析，再次使用`perf`。
- en: If you want to find out more about the kernel and the sequencing of events there,
    you would use `Ftrace` or `LTTng`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于内核和事件顺序的信息，可以使用`Ftrace`或`LTTng`。
- en: 'There could be other problems that `top` will not help you with. If you have
    multi-threaded code and there are problems with lockups, or if you have random
    data corruption then Valgrind plus the Helgrind plug-in might be helpful. Memory
    leaks also fit into this category: I covered memory-related diagnosis in [Chapter
    11](ch11.html "Chapter 11. Managing Memory"), *Managing Memory*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`可能无法帮助您解决其他问题。如果您有多线程代码，并且存在死锁问题，或者存在随机数据损坏问题，那么Valgrind加上Helgrind插件可能会有所帮助。内存泄漏也属于这一类问题：我在[第11章](ch11.html
    "第11章。管理内存")中介绍了与内存相关的诊断，*管理内存*。'
- en: Profiling with top
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用top进行分析
- en: '`top` is a simple tool that doesn''t require any special kernel options or
    symbol tables. There is a basic version in BusyBox, and a more functional version
    in the `procps` package which is available in the Yocto Project and Buildroot.
    You may also want to consider using `htop` which is functionally similar to `top`
    but has a nicer user interface (some people think).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`是一个简单的工具，不需要任何特殊的内核选项或符号表。BusyBox中有一个基本版本，`procps`包中有一个更功能齐全的版本，该包在Yocto
    Project和Buildroot中可用。您还可以考虑使用`htop`，它在功能上类似于`top`，但具有更好的用户界面（有些人这样认为）。'
- en: 'To begin with, focus on the summary line of `top`, which is the second line
    if you are using BusyBox and the third line if using `procps` `top`. Here is an
    example, using BusyBox `top`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关注`top`的摘要行，如果您使用的是BusyBox，则是第二行，如果使用`procps` `top`则是第三行。以下是一个使用BusyBox `top`的示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The summary line shows the percentage of time spent running in various states,
    as shown in this table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要行显示了在各种状态下运行的时间百分比，如下表所示：
- en: '| procps | Busybox |   |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| procps | Busybox |   |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `us` | `usr` | User space programs with default nice value |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `us` | `usr` | 默认优先级值的用户空间程序 |'
- en: '| `sy` | `sys` | Kernel code |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `sy` | `sys` | 内核代码 |'
- en: '| `ni` | `nic` | User space programs with non-default nice value |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `ni` | `nic` | 非默认优先级值的用户空间程序 |'
- en: '| `id` | `idle` | Idle |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `idle` | 空闲 |'
- en: '| `wa` | `io` | I/O wait |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `wa` | `io` | I/O等待 |'
- en: '| `hi` | `irq` | Hardware interrupts |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `hi` | `irq` | 硬件中断 |'
- en: '| `si` | `sirq` | Software interrupts |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `si` | `sirq` | 软件中断 |'
- en: '| `st` | `--` | Steal time: only relevant in virtualized environments |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `st` | `--` | 窃取时间：仅在虚拟化环境中相关 |'
- en: 'In the preceding example, almost all of the time (58%) is spent in user mode,
    with a small amount (4%) in system mode, so this is a system that is CPU-bound
    in user space. The first line after the summary shows that just one application
    is responsible: `ffmpeg`. Any efforts towards reducing CPU usage should be directed
    there.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，几乎所有的时间（58%）都花在用户模式下，只有一小部分时间（4%）花在系统模式下，因此这是一个在用户空间中CPU绑定的系统。摘要后的第一行显示只有一个应用程序负责：`ffmpeg`。任何减少CPU使用率的努力都应该集中在那里。
- en: 'Here is another example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This system is spending almost all of the time in kernel space, as a result
    of `cat` reading from `/dev/urandom`. In this artificial, case, profiling `cat`
    by itself would not help, but profiling the kernel functions that `cat` calls
    might be.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统几乎所有的时间都花在内核空间，因为`cat`正在从`/dev/urandom`读取。在这种人为的情况下，仅对`cat`进行分析是没有帮助的，但对`cat`调用的内核函数进行分析可能会有所帮助。
- en: The default view of `top` shows only processes, so the CPU usage is the total
    of all the threads in the process. Press *H* to see information for each thread.
    Likewise, it aggregates the time across all CPUs. If you are using `procps top`,
    you can see a summary per CPU by pressing the *1* key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`的默认视图只显示进程，因此CPU使用率是进程中所有线程的总和。按*H*键查看每个线程的信息。同样，它会汇总所有CPU上的时间。如果您使用的是`procps
    top`，可以通过按*1*键查看每个CPU的摘要。'
- en: Imagine that there is a single user space process taking up most of the time
    and look at how to profile that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有一个单独的用户空间进程占用了大部分时间，看看如何对其进行分析。
- en: Poor man's profiler
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 穷人的分析器
- en: You can profile an application just by using GDB to stop it at arbitrary intervals
    and see what it is doing. This is the *poor man's profiler*. It is easy to set
    up and it is one way of gathering profile data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用GDB在任意间隔停止应用程序并查看其正在执行的操作来对应用程序进行分析。这就是*穷人的分析器*。它很容易设置，也是收集分析数据的一种方法。
- en: 'The procedure is simple and explained here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单，这里进行了解释：
- en: Attach to the process using `gdbserver` (for a remote debug) or gbd (for a native
    debug). The process stops.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gdbserver`（用于远程调试）或gbd（用于本地调试）附加到进程。进程停止。
- en: Observe the function it stopped in. You can use the `backtrace GDB` command
    to see the call stack.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察它停在哪个功能上。您可以使用`backtrace GDB`命令查看调用堆栈。
- en: Type `continue` so that the program resumes.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`continue`以使程序恢复。
- en: After a while, type *Ctrl* + *C* to stop it again and go back to step 2.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过一会儿，输入*Ctrl* + *C*再次停止它，然后回到步骤2。
- en: If you repeat steps 2 to 4 several times, you will quickly get an idea of whether
    it is looping or making progress and, if you repeat them often enough, you will
    get an idea of where the hotspots in the code are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次重复步骤2到4，您将很快了解它是在循环还是在进行，如果您重复这些步骤足够多次，您将了解代码中的热点在哪里。
- en: There is a whole web page dedicated to the idea at [http://poormansprofiler.org](http://poormansprofiler.org),
    together with scripts which make it a little easier. I have used this technique
    many times over the years with various operating systems and debuggers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个专门的网页致力于这个想法，网址为[http://poormansprofiler.org](http://poormansprofiler.org)，还有一些脚本可以使它变得更容易。多年来，我已经在各种操作系统和调试器中多次使用了这种技术。
- en: This is an example of statistical profiling, in which you sample the program
    state at intervals. After a number of samples, you begin to learn the statistical
    likelihood of the functions being executed. It is surprising how few you really
    need. Other statistical profilers are `perf record`, `OProfile`, and `gprof`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是统计分析的一个例子，您可以在间隔时间内对程序状态进行采样。经过一些样本后，您开始了解执行函数的统计可能性。您真正需要的样本数量是令人惊讶的少。其他统计分析器包括`perf
    record`、`OProfile`和`gprof`。
- en: Sampling using a debugger is intrusive because the program is stopped for a
    significant period while you collect the sample. Other tools can do that with
    much lower overhead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器进行采样是具有侵入性的，因为在收集样本时程序会停止一段时间。其他工具可以以更低的开销做到这一点。
- en: I will now consider how to use `perf` to do statistical profiling.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将考虑如何使用`perf`进行统计分析。
- en: Introducing perf
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍perf
- en: '`perf` is an abbreviation of the **Linux performance event counter subsystem**,
    `perf_events`, and also the name of the command-line tool for interacting with
    `perf_events`. Both have been part of the kernel since Linux 2.6.31\. There is
    plenty of useful information in the Linux source tree in `tools/perf/Documentation`,
    and also at [https://perf.wiki.kernel.org](https://perf.wiki.kernel.org).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`是**Linux性能事件计数子系统**`perf_events`的缩写，也是与`perf_events`进行交互的命令行工具的名称。自Linux
    2.6.31以来，它们一直是内核的一部分。在`tools/perf/Documentation`目录中的Linux源树中有大量有用的信息，还可以在[https://perf.wiki.kernel.org](https://perf.wiki.kernel.org)找到。'
- en: The initial impetus for developing `perf` was to provide a unified way to access
    the registers of the **performance measurement unit** (**PMU**), which is part
    of most modern processor cores. Once the API was defined and integrated into Linux,
    it became logical to extend it to cover other types of performance counters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 开发`perf`的最初动力是提供一种统一的方式来访问大多数现代处理器核心中的**性能测量单元**（**PMU**）的寄存器。一旦API被定义并集成到Linux中，将其扩展到涵盖其他类型的性能计数器就变得合乎逻辑。
- en: At its heart, `perf` is a collection of event counters with rules about when
    they actively collect data. By setting the rules, you can capture data from the
    whole system, or just the kernel, or just one process and its children, and do
    it across all CPUs or just one CPU. It is very flexible. With this one tool you
    can start by looking at the whole system, then zero in on a device driver that
    seems to be causing problems, or an application that is running slowly, or a library
    function that seems to being taking longer to execute than you thought.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，`perf`是一组事件计数器，具有关于何时主动收集数据的规则。通过设置规则，您可以从整个系统中捕获数据，或者只是内核，或者只是一个进程及其子进程，并且可以跨所有CPU或只是一个CPU进行。它非常灵活。使用这个工具，您可以从查看整个系统开始，然后关注似乎导致问题的设备驱动程序，或者运行缓慢的应用程序，或者似乎执行时间比您想象的长的库函数。
- en: The code for the `perf` command-line tool is part of the kernel, in the `tools/perf`
    directory. The tool and the kernel subsystem are developed hand-in-hand, meaning
    that they must be from the same version of the kernel. `perf` can do a lot. In
    this chapter, I will examine it only as a profiler. For a description of its other
    capabilities, read the `perf` man pages and refer to the documentation mentioned
    in the previous paragraph.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`命令行工具的代码是内核的一部分，位于`tools/perf`目录中。该工具和内核子系统是手牵手开发的，这意味着它们必须来自相同版本的内核。`perf`可以做很多事情。在本章中，我将仅将其作为分析器进行检查。有关其其他功能的描述，请阅读`perf`手册页并参考前一段提到的文档。'
- en: Configuring the kernel for perf
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为perf配置内核
- en: You need a kernel that is configured for `perf_events` and you need the `perf`
    command cross compiled to run on the target. The relevant kernel configuration
    is `CONFIG_PERF_EVENTS` present in the menu **General setup** | **Kernel Performance
    Events And Counters**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个配置为`perf_events`的内核，并且需要交叉编译的`perf`命令才能在目标上运行。相关的内核配置是`CONFIG_PERF_EVENTS`，位于菜单**General
    setup** | **Kernel Performance Events And Counters**中。
- en: If you want to profile using tracepoints—more on this subject later—also enable
    the options described in the section about `Ftrace`. While you are there, it is
    worthwhile enabling `CONFIG_DEBUG_INFO` as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用tracepoints进行分析（稍后会详细介绍），还要启用有关`Ftrace`部分中描述的选项。当您在那里时，也值得启用`CONFIG_DEBUG_INFO`。
- en: The `perf` command has many dependencies which makes cross compiling it quite
    messy. However, both the Yocto Project and Buildroot have target packages for
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`命令有许多依赖项，这使得交叉编译变得非常混乱。然而，Yocto Project和Buildroot都有针对它的目标软件包。'
- en: You will also need debug symbols on the target for the binaries that you are
    interested in profiling, otherwise `perf` will not be able to resolve addresses
    to meaningful symbols. Ideally, you want debug symbols for the whole system including
    the kernel. For the latter, remember that the debug symbols for the kernel are
    in the `vmlinux` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在目标上为您感兴趣的二进制文件安装调试符号，否则`perf`将无法将地址解析为有意义的符号。理想情况下，您希望为整个系统包括内核安装调试符号。对于后者，请记住内核的调试符号位于`vmlinux`文件中。
- en: Building perf with the Yocto Project
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Yocto Project构建perf
- en: If you are using the standard linux-yocto kernel, `perf_events` is enabled already,
    so there is nothing more to do.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用标准的linux-yocto内核，`perf_events` 已经启用，因此无需进行其他操作。
- en: 'To build the `perf` tool, you can add it explicitly to the target image dependencies,
    or you can add the tools-profile feature which also brings in `gprof`. As I mentioned
    previously, you will probably want debug symbols on the target image, and also
    the kernel `vmlinux` image. In total, this is what you will need in `conf/local.conf`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建`perf`工具，您可以将其明确添加到目标镜像的依赖项中，或者您可以添加tools-profile功能，该功能还会引入`gprof`。如前所述，您可能希望在目标镜像上有调试符号，以及内核`vmlinux`镜像。总之，这是您在`conf/local.conf`中需要的内容：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Building perf with Buildroot
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Buildroot构建perf
- en: Many Buildroot kernel configurations do not include `perf_events`, so you should
    begin by checking that your kernel includes the options mentioned in the preceding
    section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Buildroot内核配置不包括`perf_events`，因此您应该首先检查您的内核是否包括前面部分提到的选项。
- en: 'To cross compile perf, run the Buildroot `menuconfig` and select the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要交叉编译perf，请运行Buildroot的`menuconfig`并选择以下内容：
- en: '`BR2_LINUX_KERNEL_TOOL_PERF` in **Kernel** | **Linux Kernel Tools**. To build
    packages with debug symbols and install them unstripped on the target, select
    these two settings.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_LINUX_KERNEL_TOOL_PERF` 在**Kernel** | **Linux Kernel Tools**中。要构建带有调试符号的软件包并在目标上安装未剥离的软件包，请选择这两个设置。'
- en: '`BR2_ENABLE_DEBUG` in the menu **Build options** | **build packages with debugging
    symbols** menu.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_ENABLE_DEBUG` 在**Build options** | **build packages with debugging symbols**菜单中。'
- en: '`BR2_STRIP = none` in the menu **Build options** | **strip command for binaries
    on target**.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_STRIP = none` 在**Build options** | **strip command for binaries on target**菜单中。'
- en: Then, run `make clean`, followed by `make`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`make clean`，然后运行`make`。
- en: When you have built everything, you will have to copy `vmlinux` into the target
    image manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完所有内容后，您将需要手动将`vmlinux`复制到目标镜像中。
- en: Profiling with perf
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用perf进行性能分析
- en: You can use `perf` to sample the state of a program using one of the event counters
    and accumulate samples over a period of time to create a profile. This is another
    example of statistical profiling. The default event counter is called cycles,
    which is a generic hardware counter that is mapped to a PMU register representing
    a count of cycles at the core clock frequency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`perf`来使用事件计数器之一对程序的状态进行采样，并在一段时间内累积样本以创建一个性能分析。这是统计分析的另一个例子。默认事件计数器称为循环，这是一个通用的硬件计数器，映射到表示核心时钟频率的PMU寄存器的循环计数。
- en: 'Creating a profile using `perf` is a two stage process: the `perf record` command
    captures samples and writes them to a file named `perf.data` (by default) and
    then `perf report` analyzes the results. Both commands are run on the target.
    The samples being collected are filtered for the process and its children, for
    a command you specify. Here is an example profiling a shell script that searches
    for the string `linux`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`perf`创建性能分析是一个两阶段过程：`perf record`命令捕获样本并将其写入一个名为`perf.data`的文件（默认情况下），然后`perf
    report`分析结果。这两个命令都在目标上运行。正在收集的样本已经被过滤，以用于您指定的进程及其子进程，以及您指定的命令。以下是一个示例，对搜索字符串`linux`的shell脚本进行性能分析：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you can show the results from `perf.data` using the command `perf report`.
    There are three user interfaces which you can select on the command line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用命令`perf report`显示来自`perf.data`的结果。您可以在命令行上选择三种用户界面：
- en: '`--stdio`: This is a pure text interface with no user interaction. You will
    have to launch `perf report` and annotate for each view of the trace.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--stdio`：这是一个纯文本界面，没有用户交互。您将需要启动`perf report`并为跟踪的每个视图进行注释。'
- en: '`--tui`: This is a simple text-based menu interface with traversal between
    screens.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tui`：这是一个简单的基于文本的菜单界面，可以在屏幕之间进行遍历。'
- en: '`--gtk`: This is a graphical interface that otherwise acts in the same way
    as `--tui`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gtk`：这是一个图形界面，其行为与`--tui`相同。'
- en: 'The default is TUI, as shown in this example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为TUI，如此示例所示：
- en: '![Profiling with perf](img/B03982_13_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用perf进行性能分析](img/B03982_13_01.jpg)'
- en: '`perf` is able to record the kernel functions executed on behalf of the processes
    because it collects samples in kernel space.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`能够记录代表进程执行的内核函数，因为它在内核空间中收集样本。'
- en: The list is ordered with the most active functions first. In this example, all
    but one are captured while `grep` is running. Some are in a library, `libc-2.20`,
    some in a program, `busybox.nosuid`, and some are in the kernel. We have symbol
    names for program and library functions because all the binaries have been installed
    on the target with debug information, and kernel symbols are being read from `/boot/vmlinux`.
    If you have `vmlinux` in a different location, add `-k <path>` to the `perf report`
    command. Rather than storing samples in `perf.data`, you can save them to a different
    file using `perf record -o <file name>` and analyze them using `perf report -i
    <file name>`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表按最活跃的函数首先排序。在此示例中，除了一个函数在运行`grep`时捕获之外，其他所有函数都被捕获。有些在库`libc-2.20`中，有些在程序`busybox.nosuid`中，有些在内核中。我们对程序和库函数有符号名称，因为所有二进制文件都已安装在目标上，并带有调试信息，并且内核符号是从`/boot/vmlinux`中读取的。如果您的`vmlinux`位于不同的位置，请在`perf
    report`命令中添加`-k <path>`。您可以使用`perf record -o <file name>`将样本保存到不同的文件中，而不是将样本存储在`perf.data`中，并使用`perf
    report -i <file name>`进行分析。
- en: By default, `perf record` samples at a frequency of 1000Hz using the cycles
    counter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`perf record` 使用循环计数器以1000Hz的频率进行采样。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A sampling frequency of 1000Hz may be higher than you really need, and may
    be the cause of an observer effect. Try with lower rates: 100Hz is enough for
    most cases, in my experience. You can set the sample frequency using the `-F`
    option.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1000Hz的采样频率可能比您实际需要的要高，并且可能是观察效应的原因。尝试较低的频率：根据我的经验，100Hz对大多数情况已经足够了。您可以使用`-F`选项设置采样频率。
- en: Call graphs
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用图
- en: This is still not really making life easy; the functions at the top of the list
    are mostly low level memory operations and you can be fairly sure that they have
    already been optimized. It would be nice to step back and see where these functions
    are being called from. You can do that by capturing the backtrace from each sample,
    which you can do with the `-g` option to `perf record`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然并不是真的让生活变得容易；列表顶部的函数大多是低级内存操作，你可以相当肯定它们已经被优化过了。很高兴能够退后一步，看看这些函数是从哪里被调用的。您可以通过在每个样本中捕获回溯来做到这一点，可以使用`perf
    record`的`-g`选项来实现。
- en: 'Now `perf report` shows a plus sign (**+**) where the function is part of a
    call chain. You can expand the trace to see the functions lower down in the chain:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`perf report`在函数是调用链的一部分时显示加号（**+**）。您可以展开跟踪以查看链中较低的函数：
- en: '![Call graphs](img/B03982_13_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![调用图](img/B03982_13_02.jpg)'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generating call graphs relies on the ability to extract call frames from the
    stack, just as is necessary for backtraces in GDB. The information needed to unwind
    stacks is encoded in the debug information of the executables but not all combinations
    of architecture and toolchains are capable of doing so.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成调用图依赖于从堆栈中提取调用帧的能力，就像在GDB中需要回溯一样。解开堆栈所需的信息被编码在可执行文件的调试信息中，但并非所有架构和工具链的组合都能够做到这一点。
- en: perf annotate
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: perf annotate
- en: Now that you know which functions to look at, it would be nice to step inside
    and see the code and to have hit counts for each instruction. That is what `perf
    annotate` does, by calling down to a copy of `objdump` installed on the target.
    You just need to use `perf annotate` in place of `perf report`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道要查看哪些函数，很高兴能够深入了解并查看代码，并对每条指令进行计数。这就是`perf annotate`的作用，它调用了安装在目标上的`objdump`的副本。您只需要使用`perf
    annotate`来代替`perf report`。
- en: '`perf annotate` requires symbol tables for the executables and vmlinux. Here
    is an example of an annotated function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf annotate`需要可执行文件和vmlinux的符号表。这是一个带注释的函数的示例：'
- en: '![perf annotate](img/B03982_13_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![perf annotate](img/B03982_13_03.jpg)'
- en: 'If you want to see the source code interleaved with the assembler, you can
    copy the relevant parts to the target device. If you are using the Yocto Project
    and build with the extra image feature `dbg-pkgs`, or have installed the individual
    `-dbg` package, then the source will have been installed for you in `/usr/src/debug`.
    Otherwise, you can examine the debug information to see the location of the source
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到与汇编程序交错的源代码，可以将相关部分复制到目标设备。如果您正在使用Yocto Project并使用额外的镜像功能`dbg-pkgs`构建，或者已安装了单独的`-dbg`软件包，则源代码将已经安装在`/usr/src/debug`中。否则，您可以检查调试信息以查看源代码的位置：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The path on the target should be exactly the same as the path you can see in
    `DW_AT_comp_dir`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目标上的路径应该与`DW_AT_comp_dir`中看到的路径完全相同。
- en: 'Here is an example of annotation with source and assembler code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有源代码和汇编代码的注释示例：
- en: '![perf annotate](img/B03982_13_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![perf annotate](img/B03982_13_04.jpg)'
- en: 'Other profilers: OProfile and gprof'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他分析器：OProfile和gprof
- en: These two statistical profilers predate `perf`. They are both subsets of the
    functionality of `perf`, but they are still quite popular. I will mention them
    only briefly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个统计分析器早于`perf`。它们都是`perf`功能的子集，但仍然非常受欢迎。我只会简要提到它们。
- en: OProfile is a kernel profiler that started out in 2002\. Originally, it had
    its own kernel sampling code, but recent versions use the `perf_events` infrastructure
    for that purpose. There is more information about it at [http://oprofile.sourceforge.net](http://oprofile.sourceforge.net).
    OProfile consists of a kernel-space component and a user space daemon and analysis
    commands.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: OProfile是一个内核分析器，始于2002年。最初，它有自己的内核采样代码，但最近的版本使用`perf_events`基础设施来实现这一目的。有关更多信息，请访问[http://oprofile.sourceforge.net](http://oprofile.sourceforge.net)。OProfile由内核空间组件和用户空间守护程序和分析命令组成。
- en: 'OProfile needs these two kernel options to be enabled:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: OProfile需要启用这两个内核选项：
- en: '`CONFIG_PROFILING` in **General setup** | **Profiling support**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规设置** | **分析支持**中的`CONFIG_PROFILING`'
- en: '`CONFIG_OPROFILE` in **General setup** | **OProfile system profiling**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规设置** | **OProfile系统分析**中的`CONFIG_OPROFILE`'
- en: If you are using the Yocto Project, the user-space components are installed
    as part of the `tools-profile` image feature. If you are using Buildroot, the
    package is enabled by `BR2_PACKAGE_OPROFILE`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Yocto Project，则用户空间组件将作为`tools-profile`镜像功能的一部分安装。如果您正在使用Buildroot，则该软件包将通过`BR2_PACKAGE_OPROFILE`启用。
- en: 'You can collect samples by using this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令收集样本：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wait for your application to finish, or press *Ctrl* + *C*, to stop profiling.
    The profile data is stored in `<cur-dir>/oprofile_data/samples/current`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 等待应用程序完成，或按下*Ctrl* + *C*停止分析。分析数据存储在`<cur-dir>/oprofile_data/samples/current`中。
- en: Use `opreport` to generate a profile summary. There are various options which
    are documented in the OProfile manual.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`opreport`生成概要文件。OProfile手册中记录了各种选项。
- en: '`gprof` is part of the GNU toolchain and was one of the earliest open source
    code profiling tools. It combines compile-time instrumentation and sampling techniques,
    using a 100 Hz sample rate. It has the advantage that it does not require kernel
    support.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`gprof`是GNU工具链的一部分，是最早的开源代码分析工具之一。它结合了编译时的插装和采样技术，使用100 Hz的采样率。它的优点是不需要内核支持。'
- en: To prepare a program for profiling with `gprof`, you add `-pg` to the compile
    and link flags, which injects code that collects information about the call tree
    into the function preamble. When you run the program, samples are collected and
    stored in a buffer, which is written to a file named `gmon.out`, when the program
    terminates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备使用`gprof`进行分析的程序，您需要在编译和链接标志中添加`-pg`，这会注入收集有关调用树信息的代码到函数前言中。运行程序时，会收集样本并将其存储在一个缓冲区中，当程序终止时，会将其写入名为`gmon.out`的文件中。
- en: You use the `gprof` command to read the samples from `gmon.out` and the debug
    information from a copy of the program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`gprof`命令从`gmon.out`中读取样本和程序的副本中的调试信息。
- en: 'As an example, if you wanted to profile the BusyBox `grep` applet. you would
    rebuild BusyBox with the `-pg` option, run the command, and view the results:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要对BusyBox的`grep` applet进行分析。您需要使用`-pg`选项重新构建BusyBox，运行命令，并查看结果：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you would analyze the captured samples on either the target or the host,
    using the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在目标机或主机上分析捕获的样本，使用以下内容：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the execution times are all shown as zero, because most of the time
    was spent in system calls, which are not traced by `gprof`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，执行时间都显示为零，因为大部分时间都花在系统调用上，而`gprof`不会对系统调用进行跟踪。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`gprof` does not capture samples from threads other than the main thread of
    a multi-threaded process, and it does not sample kernel space, all of which limits
    its usefulness.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`gprof`不会捕获多线程进程的主线程以外的线程的样本，并且不会对内核空间进行采样，这些限制了它的实用性。'
- en: Tracing events
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪事件
- en: 'The tools we have seen so far all use statistical sampling. You often want
    to know more about the ordering of events so that you can see them and relate
    them to each other. Function tracing involves instrumenting the code with trace
    points which capture information about the event, and may include some or all
    of the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有工具都使用统计采样。通常您希望了解事件的顺序，以便能够看到它们并将它们与彼此关联起来。函数跟踪涉及使用跟踪点对代码进行仪器化，以捕获有关事件的信息，并可能包括以下一些或全部内容：
- en: Timestamp
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Context, such as the current PID
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文，例如当前PID
- en: Function parameters and return value
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数和返回值
- en: Callstack
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用堆栈
- en: It is more intrusive than statistical profiling and it can generate a large
    amount of data. The latter can be mitigated by applying filters when the sample
    is captured, and later on when viewing the trace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它比统计分析更具侵入性，并且可能会生成大量数据。通过在捕获样本时应用过滤器，以及在查看跟踪时稍后应用过滤器，可以减轻后者。
- en: 'I will cover two trace tools here: the kernel function tracers, `Ftrace` and
    `LTTng`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里介绍两个跟踪工具：内核函数跟踪器`Ftrace`和`LTTng`。
- en: Introducing Ftrace
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Ftrace
- en: The kernel function tracer, `Ftrace`, evolved from work done by Steven Rostedt,
    and many others, as they were tracking down the causes of high latency. `Ftrace`
    appeared in Linux 2.6.27 and has been actively developed since then. There are
    a number of documents describing kernel tracing in the kernel source in `Documentation/trace`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数跟踪器`Ftrace`是由Steven Rostedt等人进行的工作发展而来，他们一直在追踪高延迟的原因。`Ftrace`出现在Linux 2.6.27中，并自那时以来一直在积极开发。在内核源代码的`Documentation/trace`中有许多描述内核跟踪的文档。
- en: '`Ftrace` consists of a number of tracers that can log various types of activity
    in the kernel. Here, I am going to talk about the `function` and `function_graph`
    tracers, and about the event tracepoints. In [Chapter 14](ch14.html "Chapter 14. Real-time
    Programming"), *Real-time Programming*, I will revisit Ftrace and use it to show
    real-time latencies.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ftrace`由许多跟踪器组成，可以记录内核中各种类型的活动。在这里，我将讨论`function`和`function_graph`跟踪器，以及事件tracepoints。在[第14章](ch14.html
    "第14章。实时编程")中，*实时编程*，我将重新讨论Ftrace，并使用它来显示实时延迟。'
- en: The `function` tracer instruments each kernel function so that calls can be
    recorded and timestamped. As a matter of interest, it compiles the kernel with
    the `-pg` switch to inject the instrumentation, but there the resemblance to gprof
    ends. The `function_graph` tracer goes further and records both the entry and
    exit of functions so that it can create a call graph. The event tracepoints feature
    also records parameters associated with the call.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`跟踪器对每个内核函数进行仪器化，以便可以记录和时间戳调用。值得一提的是，它使用`-pg`开关编译内核以注入仪器化，但与gprof的相似之处就到此为止了。`function_graph`跟踪器进一步记录函数的进入和退出，以便可以创建调用图。事件tracepoints功能还记录与调用相关的参数。'
- en: '`Ftrace` has a very embedded-friendly user interface that is entirely implemented
    through virtual files in the `debugfs` filesystem, meaning that you do not have
    to install any tools on the target to make it work. Nevertheless, there are other
    user interfaces if you prefer: `trace-cmd` is a command-line tool which records
    and views traces and is available in Buildroot (`BR2_PACKAGE_TRACE_CMD`) and the
    Yocto Project (`trace-cmd`). There is a graphical trace viewer named KernelShark
    which is available as a package for the Yocto Project.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ftrace`具有非常适合嵌入式的用户界面，完全通过`debugfs`文件系统中的虚拟文件实现，这意味着您无需在目标机上安装任何工具即可使其工作。尽管如此，如果您愿意，还有其他用户界面可供选择：`trace-cmd`是一个命令行工具，可记录和查看跟踪，并且在Buildroot（`BR2_PACKAGE_TRACE_CMD`）和Yocto
    Project（`trace-cmd`）中可用。还有一个名为KernelShark的图形跟踪查看器，可作为Yocto Project的一个软件包使用。'
- en: Preparing to use Ftrace
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备使用Ftrace
- en: '`Ftrace` and its various options are configured in the kernel configuration
    menu. You will need the following as a minimum:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ftrace`及其各种选项在内核配置菜单中进行配置。您至少需要以下内容：'
- en: '`CONFIG_FUNCTION_TRACER` in the menu **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**内核调试** | **跟踪器** | **内核函数跟踪器**中的`CONFIG_FUNCTION_TRACER`
- en: 'For reasons that will become clear later, you would be well advised to turn
    on these options as well:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 出于以后会变得清晰的原因，您最好也打开这些选项：
- en: '`CONFIG_FUNCTION_GRAPH_TRACER` in the menu **Kernel hacking** | **Tracers**
    | **Kernel Function Graph Tracer**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**内核调试** | **跟踪器** | **内核函数图跟踪器**中的`CONFIG_FUNCTION_GRAPH_TRACER`
- en: '`CONFIG_DYNAMIC_FTRACE` in the menu **Kernel hacking** | **Tracers** | **enable/disable
    function tracing dynamically**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**内核调试** | **跟踪器** | **启用/禁用动态函数跟踪**中的`CONFIG_DYNAMIC_FTRACE`
- en: Since the whole thing is hosted in the kernel, there is no user space configuration
    to be done.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个系统托管在内核中，因此不需要进行用户空间配置。
- en: 'Using Ftrace     Before you can use `Ftrace,` you have to mount the `debugfs` filesystem which,
    by convention, goes in the `/sys/kernel/debug` directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Ftrace`之前，您必须挂载`debugfs`文件系统，按照惯例，它位于`/sys/kernel/debug`目录中：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All the controls for `Ftrace` are in the `/sys/kernel/debug/tracing` directory;
    there is even a mini `HOWTO` in the `README` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Ftrace`的控件都在`/sys/kernel/debug/tracing`目录中；甚至在`README`文件中有一个迷你的`HOWTO`。
- en: 'This is the list of tracers available in the kernel:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核中可用的跟踪器列表：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The active tracer is shown by `current_tracer`, which, initially, will be the
    null tracer, `nop`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`current_tracer`显示的是活动跟踪器，最初将是空跟踪器`nop`。'
- en: 'To capture a trace, select the tracer by writing the name of one of the `available_tracers`
    to `current_tracer`, then enable tracing for a short while, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获跟踪，请通过将`available_tracers`中的一个名称写入`current_tracer`来选择跟踪器，然后启用跟踪一小段时间，如下所示：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In that one second, the trace buffer will have been filled with the details
    of every function called by the kernel. The format of the trace buffer is plain
    text, as described in `Documentation/trace/ftrace.txt`. You can read the trace
    buffer from the `trace` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在一秒钟内，跟踪缓冲区将被填满内核调用的每个函数的详细信息。跟踪缓冲区的格式是纯文本，如`Documentation/trace/ftrace.txt`中所述。您可以从`trace`文件中读取跟踪缓冲区：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can capture a large number of data points in just one second.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在短短一秒钟内捕获大量数据点。
- en: 'As with profilers, it is difficult to make sense of a flat function list like
    this. If you select the `function_graph` tracer, Ftrace captures call graphs like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析器一样，很难理解这样的平面函数列表。如果选择`function_graph`跟踪器，Ftrace会捕获如下的调用图：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now you can see the nesting of the function calls, delimited by parentheses,
    `{` and `}`. At the terminating brace, there is a measurement of the time taken
    in the function, annotated with a plus sign, `+`, if it takes more than `10 µs`,
    and an exclamation mark, `!`, if it takes more than `100 µs`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到函数调用的嵌套，由括号`{`和`}`分隔。在终止括号处，有一个函数中所花费的时间的测量，如果花费的时间超过`10 µs`，则用加号`+`进行注释，如果花费的时间超过`100
    µs`，则用感叹号`!`进行注释。
- en: You are often only interested in the kernel activity caused by a single process
    or thread, in which case you can restrict the trace to the one thread by writing
    the thread ID to `set_ftrace_pid`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您只对由单个进程或线程引起的内核活动感兴趣，这种情况下，您可以通过将线程ID写入`set_ftrace_pid`来限制跟踪到一个线程。
- en: Dynamic Ftrace and trace filters
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态Ftrace和跟踪过滤器
- en: Enabling `CONFIG_DYNAMIC_FTRACE` allows Ftrace to modify the function `trace`
    sites at runtime, which has a couple of benefits. Firstly, it triggers additional
    build-time processing of the trace function probes which allows the Ftrace subsystem
    to locate them at boot time and overwrite them with NOP instructions, thus reducing
    the overhead of the function trace code to almost nothing. You can then enable
    Ftrace in production or near production kernels with no impact on performance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`CONFIG_DYNAMIC_FTRACE`允许Ftrace在运行时修改函数`trace`站点，这有一些好处。首先，它触发了跟踪函数探针的额外构建时间处理，使Ftrace子系统能够在引导时定位它们并用NOP指令覆盖它们，从而将函数跟踪代码的开销几乎降为零。然后，您可以在生产或接近生产的内核中启用Ftrace而不会影响性能。
- en: 'The second advantage is that you can selectively enable function `trace sites`
    rather than trace everything. The list of functions is put into `available_filter_functions`;
    there are several tens of thousands of them. You can selectively enable function
    traces as you need them by copying the name from `available_filter_functions`
    to `set_ftrace_filter`, and then stop tracing that function by writing the name
    to `set_ftrace_notrace`. You can also use wildcards and append names to the list.
    For example, suppose you are interested in `tcp` handling:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优点是您可以有选择地启用函数`trace sites`而不是跟踪所有内容。函数列表放入`available_filter_functions`中；有数万个函数。您可以通过将名称从`available_filter_functions`复制到`set_ftrace_filter`来根据需要有选择地启用函数跟踪，然后通过将名称写入`set_ftrace_notrace`来停止跟踪该函数。您还可以使用通配符并将名称附加到列表中。例如，假设您对`tcp`处理感兴趣：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run some tests and then look at the trace:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一些测试，然后查看跟踪：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`set_ ftrace_filter` can also contain commands, for example, to start and stop
    tracing when certain functions are executed. There isn''t space to go into these
    details here but, if you want to find out more, please read the **Filter commands**
    section in `Documentation/trace/ftrace.txt`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_ftrace_filter`也可以包含命令，例如在执行某些函数时启动和停止跟踪。这里没有空间来详细介绍这些内容，但如果您想了解更多，请阅读`Documentation/trace/ftrace.txt`中的**Filter
    commands**部分。'
- en: Trace events
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪事件
- en: The function and `function_graph` tracers described in the preceding section
    record only the time at which the function was executed. The trace events feature
    also records parameters associated with the call, making the trace more readable
    and informative. For example, instead of just recording that the function `kmalloc`
    had been called, a trace event will record the number of bytes requested and the
    returned pointer. Trace events are used in perf and LTTng as well as Ftrace, but
    the development of the trace events subsystem was prompted by the LTTng project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中描述的函数和`function_graph`跟踪器仅记录执行函数的时间。跟踪事件功能还记录与调用相关的参数，使跟踪更易读和信息丰富。例如，跟踪事件将记录请求的字节数和返回的指针，而不仅仅是记录调用了函数`kmalloc`。跟踪事件在perf和LTTng以及Ftrace中使用，但跟踪事件子系统的开发是由LTTng项目促成的。
- en: 'It takes effort from kernel developers to create trace events since each one
    is different. They are defined in the source code using the `TRACE_EVENT` macro:
    there are over a thousand of them now. You can see the list of events available
    at runtime in `/sys/kernel/debug/tracing/available_events`. They are named `subsystem:function`,
    for example, `kmem:kmalloc`. Each event is also represented by a subdirectory
    in `tracing/events/[subsystem]/[function]`, as demonstrated here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建跟踪事件需要内核开发人员的努力，因为每个事件都是不同的。它们在源代码中使用`TRACE_EVENT`宏进行定义：现在有一千多个。您可以在`/sys/kernel/debug/tracing/available_events`中看到运行时可用的事件列表。它们的名称是`subsystem:function`，例如，`kmem:kmalloc`。每个事件还由`tracing/events/[subsystem]/[function]`中的子目录表示，如下所示：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The files are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 文件如下：
- en: '`enable`: You write a `1` to this file to enable the event.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable`：您可以将`1`写入此文件以启用事件。'
- en: '`filter`: This is an expression which must evaluate to true for the event to
    be traced.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：这是一个必须对事件进行跟踪的表达式。'
- en: '`format`: This is the format of the event and parameters.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`格式`：这是事件和参数的格式。'
- en: '`id`: This is a numeric identifier.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是一个数字标识符。'
- en: '`trigger`: This is a command that is executed when the event occurs using the
    syntax defined in the **Filter commands** section of `Documentation/trace/ftrace.txt`.
    I will show you a simple example involving `kmalloc` and `kfree`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`触发器`：这是在事件发生时执行的命令，使用`Documentation/trace/ftrace.txt`中`过滤命令`部分定义的语法。我将为您展示一个涉及`kmalloc`和`kfree`的简单示例。'
- en: 'Event tracing does not depend on the function tracers, so begin by selecting
    the `nop` tracer:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 事件跟踪不依赖于功能跟踪器，因此首先选择`nop`跟踪器：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, select the events to trace by enabling each one individually:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过逐个启用每个事件来选择要跟踪的事件：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also write the event names to `set_event`, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将事件名称写入`set_event`，如下所示：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, when you read the trace, you can see the functions and their parameters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您阅读跟踪时，您可以看到函数及其参数：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exactly the same trace events are visible in perf as *tracepoint events*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在perf中，完全相同的跟踪事件可见为*tracepoint事件*。
- en: Using LTTng
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LTTng
- en: The Linux Trace Toolkit project was started by Karim Yaghmour as a means of
    tracing kernel activity and was one of the first trace tools generally available
    for the Linux kernel. Later, Mathieu Desnoyers took up the idea and re-implemented
    it as the next generation trace tool, LTTng. It was then expanded to cover user
    space traces as well as the kernel. The project website is at [http://lttng.org/](http://lttng.org/)
    and contains a comprehensive user manual.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Linux Trace Toolkit项目是由Karim Yaghmour发起的，作为跟踪内核活动的手段，并且是最早为Linux内核提供的跟踪工具之一。后来，Mathieu
    Desnoyers接受了这个想法，并将其重新实现为下一代跟踪工具LTTng。然后，它被扩展以覆盖用户空间跟踪以及内核。项目网站位于[http://lttng.org/](http://lttng.org/)，包含了全面的用户手册。
- en: 'LTTng consists of three components:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng由三个组件组成：
- en: A core session manager
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心会话管理器
- en: A kernel tracer implemented as a group of kernel modules
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一组内核模块实现的内核跟踪器
- en: A user space tracer implemented as a library
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为库实现的用户空间跟踪器
- en: In addition to those, you will need a trace viewer such as Babeltrace ([http://www.efficios.com/babeltrace](http://www.efficios.com/babeltrace))
    or the Eclipse Trace Compaas plug-in to display and filter the raw trace data
    on the host or target.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还需要一个跟踪查看器，比如Babeltrace（[http://www.efficios.com/babeltrace](http://www.efficios.com/babeltrace)）或Eclipse
    Trace Compaas插件，以在主机或目标上显示和过滤原始跟踪数据。
- en: LTTng requires a kernel configured with `CONFIG_TRACEPOINTS`, which is enabled
    when you select **Kernel hacking** | **Tracers** | **Kernel Function Tracer**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng需要一个配置了`CONFIG_TRACEPOINTS`的内核，当您选择**内核调试** | **跟踪器** | **内核函数跟踪器**时会启用。
- en: The description that follows refers to LTTng version 2.5; other versions may
    be different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述是针对LTTng版本2.5的；其他版本可能有所不同。
- en: LTTng and the Yocto Project
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LTTng和Yocto项目
- en: 'You need to add these packages to the target dependencies, for example, in
    `conf/local.conf`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将这些软件包添加到目标依赖项中，例如在`conf/local.conf`中：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you want to run Babeltrace on the target, also append the package `babeltrace`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在目标上运行Babeltrace，还需要附加软件包`babeltrace`。
- en: LTTng and Buildroot
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LTTng和Buildroot
- en: 'You need to enable the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要启用以下内容：
- en: '`BR2_PACKAGE_LTTNG_MODULES` in the menu **Target packages** | **Debugging,
    profiling and benchmark** | **lttng-modules**.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**目标软件包** | **调试、性能分析和基准测试** | **lttng-modules**中的`BR2_PACKAGE_LTTNG_MODULES`。
- en: '`BR2_PACKAGE_LTTNG_TOOLS` in the menu **Target packages** | **Debugging, profiling
    and benchmark** | **lttng-tools**.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**目标软件包** | **调试、性能分析和基准测试** | **lttng-tools**中的`BR2_PACKAGE_LTTNG_TOOLS`。
- en: 'For user space trace tracing, enable this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户空间跟踪，启用此选项：
- en: '`BR2_PACKAGE_LTTNG_LIBUST` in the menu **Target packages** | **Libraries**
    | **Other**, enable **lttng-libust**.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**目标软件包** | **库** | **其他**中的`BR2_PACKAGE_LTTNG_LIBUST`，启用**lttng-libust**。
- en: There is a package called `lttng-babletrace` for the target. Buildroot builds
    the host `babeltrace` automatically and places in `output/host/usr/bin/babeltrace`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`lttng-babletrace`的软件包供目标使用。Buildroot会自动构建主机的`babeltrace`并将其放置在`output/host/usr/bin/babeltrace`中。
- en: Using LTTng for kernel tracing
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LTTng进行内核跟踪
- en: LTTng can use the set of `ftrace` events described above as potential trace
    points. Initially, they are disabled.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng可以使用上述`ftrace`事件集作为潜在的跟踪点。最初，它们是禁用的。
- en: 'The control interface for LTTng is the `lttng` command. You can list the kernel
    probes using the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng的控制接口是`lttng`命令。您可以使用以下命令列出内核探针：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Traces are captured in the context of a session which, in this example, is
    called `test`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，跟踪是在会话的上下文中捕获的，会话名为`test`：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now enable a few events in the current session. You can enable all kernel tracepoints
    using the `--all` option but remember the warning about generating too much trace
    data. Let''s start with a couple of scheduler-related trace events:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在当前会话中启用一些事件。您可以使用`--all`选项启用所有内核跟踪点，但请记住关于生成过多跟踪数据的警告。让我们从一些与调度器相关的跟踪事件开始：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check that everything is set up:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一切是否设置好：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now start tracing:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始跟踪：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the test load and then stop tracing:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试负载，然后停止跟踪：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Traces for the session are written to the session directory, `lttng-traces/<session>/kernel`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 会话的跟踪写入会话目录`lttng-traces/<session>/kernel`。
- en: 'You can use the Babeltrace viewer to dump the raw trace data in text format,
    in this case, I ran it on the host computer:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Babeltrace查看器以文本格式转储原始跟踪数据，在这种情况下，我在主机计算机上运行它：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output is too verbose to fit on this page, so I will leave it as an exercise
    for you, the reader, to capture and display a trace in this way. The text output
    from eBabeltrace does have the advantage that it is easy to search for strings
    using grep and similar commands.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容过于冗长，无法适应本页，因此我将其留给您，读者，以此方式捕获和显示跟踪。eBabeltrace的文本输出具有一个优点，那就是可以使用grep和类似的命令轻松搜索字符串。
- en: 'A good choice for a graphical trace viewer is the Trace Compass plug-in for
    Eclipse, which is now part of the Eclipse IDE for C/C++ Developers bundle. Importing
    the trace data into Eclipse is characteristically fiddly. Briefly, you need to
    follow these steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于图形跟踪查看器的不错选择是Eclipse的Trace Compass插件，它现在是Eclipse IDE for C/C++ Developers捆绑包的一部分。将跟踪数据导入Eclipse通常有点麻烦。简而言之，您需要按照以下步骤进行操作：
- en: Open the tracing perspective.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开跟踪透视图。
- en: Create a new project by selecting **File** | **New** | **Tracing project**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**文件** | **新建** | **跟踪项目**来创建一个新项目。
- en: Enter a project name and click **Finish**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称，然后点击**完成**。
- en: Right-click on the **New Project** option in the **Project Explorer** menu and
    select **Import**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目资源管理器**菜单中右键单击**新建项目**选项，然后选择**导入**。
- en: Expand **Tracing** and then select **Trace Import**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**跟踪**，然后选择**跟踪导入**。
- en: Browse to the directory containing the traces (for example, `test-20150824-140942`),
    tick the box to indicate which sub-directories you want (it might be the kernel)
    and click **Finish**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到包含跟踪的目录（例如`test-20150824-140942`），选中要指示的子目录的复选框（可能是内核），然后点击**完成**。
- en: Now, expand the project and, within that, expand **Traces[1]** and, within that,
    double-click on **kernel**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，展开项目，在其中展开**Traces[1]**，然后在其中双击**kernel**。
- en: You should see the trace data shown in the following screenshot:![Using LTTng
    for kernel tracing](img/B03982_13_05.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在以下截图中看到跟踪数据：![使用LTTng进行内核跟踪](img/B03982_13_05.jpg)
- en: In the preceding screenshot, I have zoomed in on the control flow view to show
    state transitions between `dropbear` and a shell, and also some activity of the
    `lttng` daemon.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我已经放大了控制流视图，以显示`dropbear`和shell之间的状态转换，以及`lttng`守护程序的一些活动。
- en: Using Valgrind for application profiling
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind进行应用程序分析。
- en: I introduced Valgrind in [Chapter 11](ch11.html "Chapter 11. Managing Memory"),
    *Managing Memory*, as a tool for identifying memory problems using the memcheck
    tool. Valgrind has other useful tools for application profiling. The two I am
    going to look at here are **Callgrind** and **Helgrind**. Since Valgrind works
    by running the code in a sandbox, it is able to check the code as it runs and
    report certain behaviors, which native tracers and profilers cannot do.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第11章](ch11.html "第11章。内存管理")中介绍了Valgrind，*内存管理*，作为使用memcheck工具识别内存问题的工具。Valgrind还有其他有用的应用程序分析工具。我要在这里看的两个是**Callgrind**和**Helgrind**。由于Valgrind通过在沙盒中运行代码来工作，它能够在代码运行时检查并报告某些行为，而本地跟踪器和分析器无法做到这一点。
- en: Callgrind
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Callgrind
- en: Callgrind is a call-graph generating profiler that also collects information
    about processor cache hit rate and branch prediction. Callgrind is only useful
    if your bottleneck is CPU-bound. It's not useful if heavy I/O or multiple processes
    are involved.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Callgrind是一个生成调用图的分析器，还收集有关处理器缓存命中率和分支预测的信息。如果您的瓶颈是CPU密集型，Callgrind才有用。如果涉及大量I/O或多个进程，则没有用。
- en: Valgrind does not require kernel configuration but it does need debug symbols.
    It is available as a target package in both the Yocto Project and Buildroot (`BR2_PACKAGE_VALGRIND`).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind不需要内核配置，但需要调试符号。它在Yocto Project和Buildroot（`BR2_PACKAGE_VALGRIND`）中都作为目标软件包提供。
- en: 'You run Callgrind in Valgrind on the target, like so:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在目标上使用Valgrind中的Callgrind运行，如下所示：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This produces a file called `callgrind.out.<PID>` which you can copy to the
    host and analyze with `callgrind_annotate`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为`callgrind.out.<PID>`的文件，您可以将其复制到主机并使用`callgrind_annotate`进行分析。
- en: The default is to capture data for all the threads together in a single file.
    If you add option `--separate-threads=yes` when capturing, there will be profiles
    for each of the threads in files named `callgrind.out.<PID>-<thread id>`, for
    example, `callgrind.out.122-01`, `callgrind.out.122-02`, and so on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，会将所有线程的数据捕获到单个文件中。如果在捕获时添加`--separate-threads=yes`选项，则将每个线程的配置文件分别保存在名为`callgrind.out.<PID>-<thread
    id>`的文件中，例如`callgrind.out.122-01`，`callgrind.out.122-02`等。
- en: Callgrind can simulate the processor L1/L2 cache and report on cache misses.
    Capture the trace with the `--simulate-cache=yes` option. L2 misses are much more
    expensive than L1 misses, so pay attention to code with high D2mr or D2mw counts.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Callgrind可以模拟处理器L1/L2缓存并报告缓存未命中。使用`--simulate-cache=yes`选项捕获跟踪。L2未命中比L1未命中要昂贵得多，因此要注意具有高D2mr或D2mw计数的代码。
- en: Helgrind
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helgrind
- en: This is a thread error detector for detecting synchronization errors in C, C++,
    and Fortran programs that include POSIX threads.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于检测C、C++和Fortran程序中包含POSIX线程的同步错误的线程错误检测器。
- en: Helgrind can detect three classes of error. Firstly, it can detect the incorrect
    use of the API. For example, it can unlock a mutex that is already unlocked, unlock
    a mutex that was locked by a different thread, not checking the return value of
    certain Pthread functions. Secondly, it monitors the order in which threads acquire
    locks and thus detects potential deadlocks which could arise from the formation
    of cycles of locks. Finally, it detects data races which can happen when two threads
    access a shared memory location without using suitable locks or other synchronization
    to ensure single-threaded access.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind可以检测三类错误。首先，它可以检测API的不正确使用。例如，它可以解锁已经解锁的互斥锁，解锁由不同线程锁定的互斥锁，不检查某些Pthread函数的返回值。其次，它监视线程获取锁的顺序，从而检测可能由于锁的循环形成而产生的潜在死锁。最后，它检测数据竞争，当两个线程访问共享内存位置而不使用适当的锁或其他同步来确保单线程访问时可能发生。
- en: 'Using Helgrind is simple, you just need this command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helgrind很简单，您只需要这个命令：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It prints problems and potential problems as it finds them. You can direct these
    messages to a file by adding `--log-file=<filename>`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它在发现问题和潜在问题时打印出来。您可以通过添加`--log-file=<filename>`将这些消息定向到文件。
- en: Using strace to show system calls
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用strace显示系统调用
- en: 'I started the chapter with the simple and ubiquitous tool, `top`, and I will
    finish with another: `strace`. It is a very simple tracer that captures system
    calls made by a program and, optionally, its children. You can use it to do the
    following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我从简单且无处不在的工具`top`开始了本章，我将以另一个工具`strace`结束。它是一个非常简单的跟踪器，可以捕获程序及其子进程所进行的系统调用。您可以使用它来执行以下操作：
- en: Learn which system calls a program makes.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解程序进行了哪些系统调用。
- en: Find those system calls that fail together with the error code. I find this
    useful if a program fails to start but doesn't print an error message or if the
    message is too general. `strace` shows the failing syscall.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出那些一起失败的系统调用以及错误代码。如果程序无法启动但没有打印错误消息，或者消息太一般化，我发现这很有用。`strace`显示了失败的系统调用。
- en: Find which files a program opens.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找程序打开了哪些文件。
- en: Find out what syscalls a running program is making, for example to see if it
    is stuck in a loop.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出正在运行的程序进行了哪些系统调用，例如查看它是否陷入了循环中。
- en: There are many more examples online, just search for `strace` tips and tricks.
    Everybody has their own favorite story, for example, [http://chadfowler.com/blog/2014/01/26/the-magic-of-strace](http://chadfowler.com/blog/2014/01/26/the-magic-of-strace)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在线上还有更多的例子，只需搜索`strace`的技巧和窍门。每个人都有自己喜欢的故事，例如，[http://chadfowler.com/blog/2014/01/26/the-magic-of-strace](http://chadfowler.com/blog/2014/01/26/the-magic-of-strace)
- en: '`strace` uses the `ptrace(2)` function to hook calls from user space to the
    kernel. If you want to know more about how `ptrace` works, the man page is detailed
    and surprisingly legible.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`使用`ptrace(2)`函数来挂钩用户空间到内核的调用。如果您想了解更多关于`ptrace`如何工作的信息，man手册详细且易懂。'
- en: 'The simplest way to get a trace is to run the command with `strace` as shown
    here (the listing has been edited to make it clearer):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 获取跟踪的最简单方法是像这样运行带有`strace`的命令（列表已经编辑过以使其更清晰）：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Most of the trace shows how the runtime environment is created. In particular
    you can see how the library loader hunts for `libc.so.6`, eventually finding it
    in `/lib`. Finally, it gets to running the `main()` function of the program, which
    prints its message and exits.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的跟踪显示了运行时环境是如何创建的。特别是您可以看到库加载器是如何寻找`libc.so.6`的，最终在`/lib`中找到它。最后，它开始运行程序的`main()`函数，打印其消息并退出。
- en: If you want `strace` to follow any child processes or threads created by the
    original process, add the `-f` option.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望`strace`跟踪原始进程创建的任何子进程或线程，请添加`-f`选项。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using `strace` to trace a program that creates threads, you almost
    certainly want the `-f` option. Better still, use `-ff` and `-o <file name>` so
    that the output for each child process or thread is written to a separate file
    named `<filename>.<PID | TID>`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`strace`来跟踪创建线程的程序，几乎肯定需要`-f`选项。最好使用`-ff`和`-o <file name>`，这样每个子进程或线程的输出都将被写入一个名为`<filename>.<PID
    | TID>`的单独文件中。
- en: 'A common use of `strace` is to discover which files a program tries to open
    at start up. You can restrict the system calls that are traced through the `-e`
    option, and you can write the trace to a file instead of `stdout` by using the
    `-o` option:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`的常见用途是发现程序在启动时尝试打开哪些文件。您可以通过`-e`选项限制要跟踪的系统调用，并且可以使用`-o`选项将跟踪写入文件而不是`stdout`：'
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This shows the libraries and configuration files `ssh` opens when it is setting
    up a connection.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`ssh`在建立连接时打开的库和配置文件。
- en: 'You can even use `strace` as a basic profile tool: if you use the `-c` option,
    it accumulates the time spent in system calls and prints out a summary like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将`strace`用作基本的性能分析工具：如果使用`-c`选项，它会累积系统调用所花费的时间，并打印出类似这样的摘要：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Nobody can complain that Linux lacks options to profile and trace. This chapter
    has given you an overview of some of the most common ones.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能抱怨Linux缺乏性能分析和跟踪的选项。本章为您概述了一些最常见的选项。
- en: When faced with a system that is not performing as well as you would like, start
    with `top` and try to identify the problem. If it proves to be a single application,
    then you can use `perf record/report` to profile it, bearing in mind that you
    will have to configure the kernel to enable `perf` and you will need debug symbols
    for the binaries and kernel. OProfile is an alternative to `perf record` and can
    tell you similar things. `gprof` is, frankly, outdated but it does have the advantage
    of not requiring kernel support. If the problem is not so well localized, use
    `perf` (or OProfile) to get a system-wide view.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对性能不如预期的系统时，从`top`开始并尝试识别问题。如果问题被证明是单个应用程序引起的，那么您可以使用`perf record/report`来对其进行性能分析，但需要注意您必须配置内核以启用`perf`，并且需要二进制文件和内核的调试符号。OProfile是`perf
    record`的替代方案，可以提供类似的信息。`gprof`已经过时，但它的优势是不需要内核支持。如果问题没有那么局部化，使用`perf`（或OProfile）来获取系统范围的视图。
- en: '`Ftrace` comes into its own when you have specific questions about the behavior
    of the kernel. The `function` and `function_graph` tracers give a detailed view
    of the relationship and sequence of function calls. The event tracers allow you
    to extract more information about functions including the parameters and return
    values. LTTng performs a similar role, making use the event trace mechanism, and
    adds high speed ring buffers to extract large quantities of data from the kernel.
    Valgrind has the particular advantage that it runs code in a sandbox and can report
    on errors that are hard to track down in other ways.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对内核的行为有特定问题时，`Ftrace`就派上用场了。`function`和`function_graph`跟踪器提供了函数调用关系和顺序的详细视图。事件跟踪器允许您提取有关函数的更多信息，包括参数和返回值。LTTng执行类似的角色，利用事件跟踪机制，并添加了高速环形缓冲区以从内核中提取大量数据。Valgrind具有特殊优势，它在沙盒中运行代码，并且可以报告其他方式难以跟踪到的错误。
- en: Using the Callgrind tool, it can generate call graphs and report on processor
    cache usage and, with Helgrind, it can report on thread-related problems. Finally,
    don't forget `strace`. It is a good standby for finding out what system calls
    a program is making, from tracking file open calls to find file path names to
    checking for system wake ups and incoming signals.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Callgrind工具，它可以生成调用图并报告处理器缓存的使用情况，而使用Helgrind时，它可以报告与线程相关的问题。最后，不要忘记`strace`。它是发现程序正在进行哪些系统调用的良好工具，从跟踪文件打开调用以查找文件路径名到检查系统唤醒和传入信号。
- en: 'All the while, be aware of, and try to avoid, the observer effect: make sure
    that the measurements you are making are valid for a production system. In the
    next chapter, I will continue the theme as I delve into the latency tracers that
    help us quantify the real-time performance of a target system.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，要注意并尽量避免观察者效应：确保您正在进行的测量对生产系统是有效的。在下一章中，我将继续探讨这一主题，深入探讨帮助我们量化目标系统实时性能的延迟跟踪工具。
