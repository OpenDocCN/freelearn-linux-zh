- en: Interprocess Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信
- en: A complex application-programming model might include a number of processes,
    each implemented to handle a specific job, which contribute to the end functionality
    of the application as a whole. Depending on the objective, design, and environment
    in which such applications are hosted, processes involved might be related (parent-child,
    siblings) or unrelated. Often, such processes need various resources to communicate,
    share data, and synchronize their execution to achieve desired results. These
    are provided by the operating system's kernel as services called **interprocess
    communication** (**IPC**). We have already discussed the usage of signals as an
    IPC mechanism; in this chapter, we shall begin to explore various other resources
    available for process communication and data sharing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序编程模型可能包括许多进程，每个进程都实现为处理特定的工作，这些工作共同为应用程序的最终功能做出贡献。根据目标、设计和应用程序所托管的环境，所涉及的进程可能是相关的（父子、兄弟）或无关的。通常，这些进程需要各种资源来进行通信、共享数据并同步它们的执行以实现期望的结果。这些资源由操作系统的内核作为称为**进程间通信**（**IPC**）的服务提供。我们已经讨论了信号作为IPC机制的使用；在本章中，我们将开始探索各种其他可用于进程通信和数据共享的资源。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Pipes and FIFOs as messaging resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和FIFO作为消息资源
- en: SysV IPC resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysV IPC资源
- en: POSX IPC mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSX IPC机制
- en: Pipes and FIFOs
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和FIFO
- en: 'Pipes form a basic unidirectional, self-synchronous means of communication
    between processes. As the name suggests, they have two ends: one where a process
    writes and the opposite end from where another process reads the data. Presumably
    what goes in first will be read out first in this kind of a setup. Pipes innately
    result in communication synchronization due to their limited capacity: if the
    writing process writes much faster than the reading process reads, the pipe’s
    capacity will fail to hold excess data and invariably block the writing process
    until the reader reads and frees up data. Similarly, if the reader reads data
    faster than the writer, it will be left with no data to read, thus being blocked
    until data becomes available.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 管道形成了进程之间基本的单向、自同步的通信方式。顾名思义，它们有两端：一个进程写入数据，另一个进程从另一端读取数据。在这种设置中，首先输入的数据将首先被读取。由于管道的有限容量，管道本身会导致通信同步：如果写入进程写入速度比读取进程读取速度快得多，管道的容量将无法容纳多余的数据，并且不可避免地阻塞写入进程，直到读取者读取并释放数据。同样，如果读取者读取数据的速度比写入者快，它将没有数据可供读取，因此会被阻塞，直到数据变得可用。
- en: 'Pipes can be used as a messaging resource for both cases of communication:
    between related processes and between unrelated processes. When applied between
    related processes, pipes are referred to as **unnamed pipes**, since they are
    not enumerated as files under the `rootfs` tree. An unnamed pipe can be allocated
    through the `pipe()` API.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可以用作通信的消息资源，用于相关进程之间和无关进程之间的通信。当应用于相关进程之间时，管道被称为**未命名管道**，因为它们不被列为`rootfs`树下的文件。未命名管道可以通过`pipe()`API分配。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: API invokes a corresponding system call, which allocates appropriate data structures
    and sets up pipe buffers. It maps a pair of file descriptors, one for reading
    on the pipe buffer and another for writing on the pipe buffer. These descriptors
    are returned to the caller. The caller process normally forks the child process,
    which inherits the pipe file descriptors that can be used for messaging.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: API调用相应的系统调用，分配适当的数据结构并设置管道缓冲区。它映射一对文件描述符，一个用于在管道缓冲区上读取，另一个用于在管道缓冲区上写入。这些描述符将返回给调用者。调用者进程通常会fork子进程，子进程会继承可以用于消息传递的管道文件描述符。
- en: 'The following code excerpt shows the pipe system call implementation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘录显示了管道系统调用的实现：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Communication between unrelated processes requires the pipe file to be enumerated
    into **rootfs***.* Such pipes are often called **named pipes***,* and can be created
    either from the command line (`mkfifo`) or from a process using the `mkfifo` API*.*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无关进程之间的通信需要将管道文件列入**rootfs**。这种管道通常被称为**命名管道**，可以通过命令行（`mkfifo`）或使用`mkfifo`
    API的进程创建。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A named pipe is created with the name specified and with appropriate permissions
    as specified by the mode argument. The `mknod` system call is invoked for creating
    a FIFO, which internally invokes VFS routines to set up the named pipe. Processes
    with access permissions can initiate operations on FIFOs through common VFS file
    APIs `open`, `read`, `write`, and `close`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道是使用指定的名称和适当的权限创建的，如模式参数所指定的那样。调用`mknod`系统调用来创建FIFO，它在内部调用VFS例程来设置命名管道。具有访问权限的进程可以通过常见的VFS文件API
    `open`、`read`、`write`和`close`在FIFO上启动操作。
- en: pipefs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pipefs
- en: 'Pipes and FIFOs are created and managed by a special filesystem called `pipefs`.
    It registers with VFS as a special filesystem. The following is a code excerpt
    from `fs/pipe.c`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和FIFO由一个名为`pipefs`的特殊文件系统创建和管理。它在VFS中注册为特殊文件系统。以下是来自`fs/pipe.c`的代码摘录：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It integrates pipe files into VFS by enumerating an `inode` instance representing
    each pipe; this allows applications to engage common file APIs `read` and `write`.
    The `inode` structure contains a union of pointers that are relevant for special
    files such as pipes and device files. For pipe file `inodes`, one of the pointers,
    `i_pipe`, is initialized to `pipefs`, defined as an instance of type `pipe_inode_info`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过列举代表每个管道的`inode`实例将管道文件集成到VFS中；这允许应用程序使用常见的文件API `read`和`write`。`inode`结构包含了一组指针，这些指针与管道和设备文件等特殊文件相关。对于管道文件`inodes`，其中一个指针`i_pipe`被初始化为`pipefs`，定义为`pipe_inode_info`类型的实例。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`struct pipe_inode_info` contains all pipe-related metadata as defined by `pipefs`,
    which includes information of the pipe buffer and other important management data.
    This structure is defined in `<linux/pipe_fs_i.h>`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct pipe_inode_info`包含由`pipefs`定义的所有与管道相关的元数据，包括管道缓冲区的信息和其他重要的管理数据。此结构在`<linux/pipe_fs_i.h>`中定义。'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `bufs` pointer refers to the pipe buffer; each pipe is by default assigned
    a total buffer of 65,535 bytes (64k) arranged as a circular array of 16 pages.
    User processes can alter the total size of the pipe buffer via a `fcntl()` operation
    on the pipe descriptor. The default maximum limit for the pipe buffer is 1,048,576
    bytes, which can be changed by a privileged process via the `/proc/sys/fs/pipe-max-size`
    file interface. Following is a summarized table that describes the rest of the
    important elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufs`指针指向管道缓冲区；每个管道默认分配总缓冲区大小为65,535字节（64k），排列为16页的循环数组。用户进程可以通过管道描述符上的`fcntl()`操作改变管道缓冲区的总大小。管道缓冲区的默认最大限制为1,048,576字节，可以通过特权进程通过`/proc/sys/fs/pipe-max-size`文件接口进行更改。以下是一个总结表，描述了其他重要元素：'
- en: '| **Name** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `mutex` | Exclusion lock protecting the pipe |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `mutex` | 保护管道的排他锁 |'
- en: '| `wait` | Wait queue for readers and writers |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `wait` | 读取者和写入者的等待队列 |'
- en: '| `nrbufs` | Count of non-empty pipe buffers for this pipe |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `nrbufs` | 此管道的非空管道缓冲区计数 |'
- en: '| `curbuf` | Current pipe buffer |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `curbuf` | 当前管道缓冲区 |'
- en: '| `buffers` | Total number of buffers |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `buffers` | 缓冲区的总数 |'
- en: '| `readers` | Number of current readers |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `readers` | 当前读取者的数量 |'
- en: '| `writers` | Number of current writers |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `writers` | 当前写入者的数量 |'
- en: '| `files` | Number of struct file instances currently referring to this pipe
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `files` | 当前引用此管道的struct文件实例的数量 |'
- en: '| `waiting_writers` | Number of writers currently blocked on the pipe |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `waiting_writers` | 当前在管道上阻塞的写入者数量 |'
- en: '| `r_coutner` | Reader counter (relevant for FIFO) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `r_coutner` | 读取者计数器（FIFO相关） |'
- en: '| `w_counter` | Writer counter (relevant for FIFO) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `w_counter` | 写入者计数器（FIFO相关） |'
- en: '| `*fasync_readers` | Reader side fasync |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `*fasync_readers` | 读取者端的fasync |'
- en: '| `*fasync_writers` | Writer side fasync |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `*fasync_writers` | 写入者端的fasync |'
- en: '| `*bufs` | Pointer to circular array of pipe buffers |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `*bufs` | 指向管道缓冲区的循环数组的指针 |'
- en: '| `*user` | Pointer to the `user_struct` instance that represents the user
    who created this pipe |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `*user` | 指向表示创建此管道的用户的`user_struct`实例的指针 |'
- en: 'Reference to each page of the pipe buffer is wrapped into a circular array
    of instances of *type* `struct pipe_buffer`. This structure is defined in `<linux/pipe_fs_i.h>`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对管道缓冲区的每个页面的引用被封装到*类型*`struct pipe_buffer`的实例的循环数组中。此结构在`<linux/pipe_fs_i.h>`中定义。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`*page` is a pointer to the page descriptor of the page buffer, and the `offset`
    and `len` fields contain the offset to the data contained in the page buffer and
    its length. `*ops` is a pointer to a structure of type `pipe_buf_operations`,
    which encapsulates pipe buffer operations implemented by `pipefs`. It also implements
    file operations that are bound to pipe and FIFO inodes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`*page`是指向页面缓冲区的页面描述符的指针，`offset`和`len`字段包含页面缓冲区中数据的偏移量和长度。`*ops`是指向`pipe_buf_operations`类型的结构的指针，它封装了`pipefs`实现的管道缓冲区操作。它还实现了绑定到管道和FIFO索引节点的文件操作：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00039.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Message queues
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列
- en: '**Message queues** are lists of message buffers through which an arbitrary
    number of processes can communicate. Unlike pipes, the writer does not have to
    wait for the reader to open the pipe and listen for data. Similar to a mailbox,
    writers can drop a fixed-length message wrapped in a buffer into the queue, which
    the reader can pick whenever it is ready. The message queue does not retain the
    message packet after it is picked by the reader, which means that each message
    packet is assured to be process persistent. Linux supports two distinct implementations
    of message queues: classic Unix SYSV message queues and contemporary POSIX message
    queues.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息队列**是消息缓冲区的列表，通过它可以进行任意数量的进程通信。与管道不同，写入者无需等待读取者打开管道并监听数据。类似于邮箱，写入者可以将包含在缓冲区中的固定长度消息放入队列中，读取者可以在准备好时随时提取。消息队列在读取者提取后不保留消息包，这意味着每个消息包都是进程持久的。Linux支持两种不同的消息队列实现：经典的Unix
    SYSV消息队列和当代的POSIX消息队列。'
- en: System V message queues
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V消息队列
- en: This is the classic AT&T message queue implementation suitable for messaging
    between an arbitrary number of unrelated processes. Sender processes wrap each
    message into a packet containing message data and a message number. The message
    queue implementation does not define the meaning of the message number, and it
    is left to the application designers to define appropriate meanings for message
    numbers and program readers and writers to interpret the same. This mechanism
    provides flexibility for programmers to use message numbers as message IDs or
    receiver IDs. It enables reader processes to selectively read messages that match
    specific IDs. However, messages with the same ID are always read in FIFO order
    (first in, first out).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经典的AT&T消息队列实现，适用于任意数量的不相关进程之间的消息传递。发送进程将每条消息封装成一个包，其中包含消息数据和消息编号。消息队列的实现不定义消息编号的含义，而是由应用程序设计者定义消息编号和程序读者和写者解释相同的适当含义。这种机制为程序员提供了灵活性，可以将消息编号用作消息ID或接收者ID。它使读取进程能够选择性地读取与特定ID匹配的消息。但是，具有相同ID的消息始终按照FIFO顺序（先进先出）读取。
- en: 'Processes can create and open a SysV message queue with:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以使用以下命令创建和打开SysV消息队列：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `key` parameter is a unique constant that serves as a magic number to identify
    the message queue. All programs that are required to access this message queue
    will need to use the same magic number; this number is usually hard-coded into
    relevant processes at compile time. However, applications need to ensure that
    the key value is unique for each message queue, and there are alternate library
    functions available through which unique keys can be dynamically generated.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`参数是一个唯一的常数，用作魔术数字来标识消息队列。所有需要访问此消息队列的程序都需要使用相同的魔术数字；这个数字通常在编译时硬编码到相关进程中。但是，应用程序需要确保每个消息队列的键值是唯一的，并且有可通过其动态生成唯一键的替代库函数。'
- en: 'The unique key and `msgflag` parameter values, if set to `IPC_CREATE`, will
    cause a new message queue to be set up. Valid processes that have access to the
    queue can read or write messages into the queue using `msgsnd` and `msgrcv` routines
    (we will not discuss them in detail here; refer to Linux system programming manuals):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将唯一键和`msgflag`参数值设置为`IPC_CREATE`，将会建立一个新的消息队列。有权访问队列的有效进程可以使用`msgsnd`和`msgrcv`例程向队列中读取或写入消息（我们这里不会详细讨论它们；请参考Linux系统编程手册）：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Data structures
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'Each message queue is created by enumerating a set of data structures by the
    underlying SysV IPC subsystem. `struct msg_queue` is the core data structure,
    and an instance of this is enumerated for each message queue:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息队列都是通过底层SysV IPC子系统枚举一组数据结构来创建的。`struct msg_queue`是核心数据结构，每个消息队列都会枚举一个该结构的实例：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `q_messages` field represents the head node of a double-linked circular
    list that contains all messages currently in the queue. Each message begins with
    a header followed by message data; each message can consume one of more pages
    depending on length of message data. The message header is always at the start
    of the first page and is represented by an instance of `struct msg_msg`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`q_messages`字段表示双向循环链表的头节点，该链表包含当前队列中的所有消息。每条消息以标头开头，后跟消息数据；每条消息可以根据消息数据的长度占用一个或多个页面。消息标头始终位于第一页的开头，并由`struct
    msg_msg`的一个实例表示：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `m_list` field contains pointers to previous and next messages in the queue.
    The `*next` pointer refers to an instance of type `struct msg_msgseg`, which contains
    the address of the next page of message data. This pointer is relevant only when
    message data exceeds the first page. The second page frame starts with a descriptor
    `msg_msgseg`, which further contains a pointer to a subsequent page, and this
    order continues until the last page of the message data is reached:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_list`字段包含队列中前一条和后一条消息的指针。`*next`指针指向`struct msg_msgseg`的一个实例，该实例包含消息数据的下一页的地址。当消息数据超过第一页时，此指针才相关。第二页框架以`msg_msgseg`描述符开头，该描述符进一步包含指向后续页面的指针，这种顺序一直持续到消息数据的最后一页：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00040.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: POSIX message queues
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX消息队列
- en: POSIX message queues implement priority-ordered messages. Each message written
    by a sender process is associated with an integer number which is interpreted
    as message priority; messages with a higher number are considered higher in priority.
    The message queue orders current messages as per priority and delivers them to
    the reader process in descending order (highest priority first). This implementation
    also supports a wider API interface with facilities of bounded wait send and receive
    operations and asynchronous message arrival notifications for receivers through
    signals or threads.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX消息队列实现了按优先级排序的消息。发送进程写入的每条消息都与一个整数相关联，该整数被解释为消息优先级；数字越大的消息被认为优先级越高。消息队列按优先级对当前消息进行排序，并按降序（优先级最高的先）将它们传递给读取进程。该实现还支持更广泛的API接口，包括有界等待发送和接收操作，以及通过信号或线程进行异步消息到达通知的接收者。
- en: 'This implementation provides a distinct API interface to `create`, `open`,
    `read`, `write`, and `destroy` message queues. Following is a summarized description
    of APIs (we will not discuss usage semantics here, refer to system programming
    manuals for more details):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现提供了一个独特的API接口来创建、打开、读取、写入和销毁消息队列。以下是API的摘要描述（我们这里不会讨论使用语义，请参考系统编程手册了解更多细节）：
- en: '| **API interface** | **Description** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **API接口** | **描述** |'
- en: '| `mq_open()` | Create or open a POSIX message queue |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `mq_open()` | 创建或打开一个POSIX消息队列'
- en: '| `mq_send()` | Write a message to the queue |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '`mq_send()` | 将消息写入队列'
- en: '| `mq_timedsend()` | Similar to `mq_send`, but with a timeout parameter for
    bounded operations |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '`mq_timedsend()` | 类似于`mq_send`，但具有用于有界操作的超时参数'
- en: '| `mq_receive()` | Fetch a message from the queue; this operation is possible
    on unbounded blocking calls |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '`mq_receive()` | 从队列中获取消息；这个操作可以在无界阻塞调用上执行'
- en: '| `mq_timedreceive()` | Similar to `mq_receive()` but with a timeout parameter
    that limits possible blocking for bounded time |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '`mq_timedreceive()` | 类似于`mq_receive()`，但具有限制可能阻塞一段时间的超时参数'
- en: '| `mq_close()` | Close a message queue |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '`mq_close()` | 关闭消息队列'
- en: '| `mq_unlink()` | Destroy message queue |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '`mq_unlink()` | 销毁消息队列'
- en: '| `mq_notify()` | Customize and set up message arrival notifications |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '`mq_notify()` | 自定义和设置消息到达通知'
- en: '| `mq_getattr()` | Get attributes associated with a message queue |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '`mq_getattr()` | 获取与消息队列关联的属性'
- en: '| `mq_setattr()` | Set attributes specified on a message queue |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '`mq_setattr()` | 设置消息队列上指定的属性'
- en: 'POSIX message queues are managed by a special filesystem called `mqueue`. Each
    message queue is identified by a filename. Metadata for each queue is described
    by an instance of struct `mqueue_inode_info`, which symbolizes the inode object
    associated with the message queue file in the `mqueue` filesystem:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX消息队列由一个名为`mqueue`的特殊文件系统管理。每个消息队列都由文件名标识。每个队列的元数据由`mqueue_inode_info`结构的一个实例描述，该结构表示与`mqueue`文件系统中消息队列文件关联的inode对象：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `*node_cache` pointer refers to the `posix_msg_tree_node` descriptor that
    contains the header to a linked list of message nodes, in which each message is
    represented by a descriptor of type `msg_msg`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`*node_cache`指针指向包含消息节点链表头的`posix_msg_tree_node`描述符，其中每条消息由`msg_msg`类型的描述符表示：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Shared memory
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存
- en: Unlike message queues, which offer a process-persistent messaging infrastructure,
    the shared memory service of IPC provides kernel-persistent memory that can be
    attached by an arbitrary number of processes that share common data. A shared
    memory infrastructure provides operation interfaces to allocate, attach, detach,
    and destroy shared memory regions. A process that needs access to shared data
    will *attach* or *map* a shared memory region into its address space; it can then
    access data in shared memory through the address returned by the mapping routine.
    This makes shared memory one of the fastest means of IPC since from a process's
    perspective it is akin to accessing local memory, which does not involve switch
    into kernel mode.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与提供进程持久消息基础设施的消息队列不同，IPC的共享内存服务提供了可以被任意数量的共享相同数据的进程附加的内核持久内存。共享内存基础设施提供了用于分配、附加、分离和销毁共享内存区域的操作接口。需要访问共享数据的进程将共享内存区域*附加*或*映射*到其地址空间中；然后它可以通过映射例程返回的地址访问共享内存中的数据。这使得共享内存成为IPC的最快手段之一，因为从进程的角度来看，它类似于访问本地内存，不涉及切换到内核模式。
- en: System V shared memory
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V共享内存
- en: Linux supports legacy SysV shared memory implementation under the IPC subsystem.
    Similar to SysV message queues, each shared memory region is identified by a unique
    IPC identifier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Linux支持IPC子系统下的传统SysV共享内存实现。与SysV消息队列类似，每个共享内存区域都由唯一的IPC标识符标识。
- en: Operation interfaces
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作接口
- en: 'The kernel provides distinct system call interfaces for initiating shared memory
    operations as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为启动共享内存操作提供了不同的系统调用接口，如下所示：
- en: Allocating shared memory
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配共享内存
- en: '`shmget()` system call is invoked by a process to get an IPC identifier for
    a shared memory region; if the region does not exists, it creates one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进程通过调用`shmget()`系统调用来获取共享内存区域的IPC标识符；如果该区域不存在，则创建一个：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function returns the identifier of the shared memory segment corresponding
    to the value contained in the *key* parameter. If other processes intend to use
    an existing segment, they can use the segment's *key* value when looking for its
    identifier. A new segment is however created if the *key* parameter is unique
    or has the value `IPC_PRIVATE`.`size` indicates the number of bytes that needs
    to be allocated, as segments are allocated as memory pages. The number of pages
    to be allocated is obtained by rounding off the *size* value to the nearest multiple
    of a page size.\
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与*key*参数中包含的值对应的共享内存段的标识符。如果其他进程打算使用现有段，它们可以在查找其标识符时使用段的*key*值。但是，如果*key*参数是唯一的或具有值`IPC_PRIVATE`，则会创建一个新段。`size`表示需要分配的字节数，因为段是分配为内存页面。要分配的页面数是通过将*size*值四舍五入到页面大小的最近倍数来获得的。
- en: 'The `shmflg` flag specifies how the segment needs to be created. It can contain
    two values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`shmflg`标志指定了如何创建段。它可以包含两个值：'
- en: '`IPC_CREATE`: This indicates creating a new segment. If this flag is unused,
    the segment associated with the key value is found, and if the user has the access
    permissions, the segment''s identifier is returned.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_CREATE`：这表示创建一个新段。如果未使用此标志，则找到与键值关联的段，并且如果用户具有访问权限，则返回段的标识符。'
- en: '`IPC_EXCL`: This flag is always used with `IPC_CREAT`, to ensure that the call
    fails if the *key* value exists.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`：此标志始终与`IPC_CREAT`一起使用，以确保如果*key*值存在，则调用失败。'
- en: Attaching a shared memory
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加共享内存
- en: 'The shared memory region must be attached to its address space for a process
    to access it. `shmat()` is invoked to attach the shared memory to the address
    space of the calling process:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存区域必须附加到其地址空间，进程才能访问它。调用`shmat()`将共享内存附加到调用进程的地址空间：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The segment indicated by `shmid` is attached by this function. `shmaddr` specifies
    a pointer indicating the location in the process''s address space where the segment
    is to be mapped. The third argument `shmflg` is a flag, which can be one of the
    following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数附加了由`shmid`指示的段。`shmaddr`指定了一个指针，指示了段要映射到的进程地址空间中的位置。第三个参数`shmflg`是一个标志，可以是以下之一：
- en: '`SHM_RND`: This is specified when `shmaddr` isn''t a NULL value, indicating
    the function to attach the segment at the address, computed by rounding off the
    `shmaddr` value to the nearest multiple of page size; otherwise, the user must
    take care that `shmaddr` be page-aligned so that the segment gets attached correctly.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_RND`：当`shmaddr`不是NULL值时指定，表示函数将在地址处附加段，该地址由将`shmaddr`值四舍五入到页面大小的最近倍数计算得出；否则，用户必须确保`shmaddr`是页面对齐的，以便正确附加段。'
- en: '`SHM_RDONLY`: This is to specify that the segment will only be read if the
    user has the necessary read permissions. Otherwise, both read and write access
    for the segment is given (the process must have the respective permissions).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_RDONLY`：这是指定如果用户具有必要的读权限，则段将仅被读取。否则，为段提供读写访问权限（进程必须具有相应的权限）。'
- en: '`SHM_REMAP`: This is a Linux-specific flag that indicates that any existing
    mapping at the address specified by `shmaddr` be replaced with the new mapping.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_REMAP`：这是一个特定于Linux的标志，表示在由`shmaddr`指定的地址处的任何现有映射将被新映射替换。'
- en: Detaching shared memory
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离共享内存
- en: 'Likewise, to detach the shared memory from the process address space, `shmdt()`
    is invoked. As IPC shared memory regions are persistent in the kernel, they continue
    to exist even after the processes detach:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要将共享内存从进程地址空间分离出来，会调用`shmdt()`。由于IPC共享内存区域在内核中是持久的，它们在进程分离后仍然存在：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The segment at the address specified by `shmaddr` is detached from the address
    space of the calling process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由`shmaddr`指定的段从调用进程的地址空间中分离出来。
- en: Each of these interface operations invoke relevant system calls implemented
    in the `<ipc/shm.c>` source file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口操作中的每一个都调用了`<ipc/shm.c>`源文件中实现的相关系统调用。
- en: Data structures
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'Each shared memory segment is represented by a `struct shmid_kernel` descriptor.
    This structure contains all metadata relevant to the management of SysV shared
    memory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个共享内存段都由`struct shmid_kernel`描述符表示。该结构包含了与SysV共享内存管理相关的所有元数据：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For reliability and ease of management, the kernel''s IPC subsystem manages
    shared memory segments through a special file system called `shmfs`*.* This filesystem
    is not mounted on to the rootfs tree; its operations are only accessible through
    SysV shared memory system calls. The `*shm_file` pointer refers to the `struct
    file` object of `shmfs` that represents a shared memory block. When a process
    initiates an attach operation, the underlying system call invokes `do_mmap()`
    to create relevant mapping into the caller''s address space (through `struct vm_area_struct`)
    and steps into the `*shmfs-*`defined `shm_mmap()` operation to map corresponding
    shared memory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠性和便于管理，内核的IPC子系统通过一个名为`shmfs`的特殊文件系统管理共享内存段。这个文件系统没有挂载到rootfs树上；它的操作只能通过SysV共享内存系统调用来访问。`*shm_file`指针指向`shmfs`的`struct
    file`对象，表示一个共享内存块。当一个进程启动附加操作时，底层系统调用会调用`do_mmap()`来在调用者的地址空间中创建相关映射（通过`struct
    vm_area_struct`），并进入`*shmfs-*`定义的`shm_mmap()`操作来映射相应的共享内存：
- en: '![](img/00041.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: POSIX shared memory
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX共享内存
- en: The Linux kernel supports POSIX shared memory through a special filesystem called
    `tmpfs`*,* which is mounted on to `/dev/shm` of the `rootfs`*.* This implementation
    offers a distinct API which is consistent with the Unix file model, resulting
    in each shared memory allocation to be represented by a unique filename and inode.
    This interface is considered more flexible by application programmers since it
    allows standard POSIX file-mapping routines `mmap()` and `unmap()` for attaching
    and detaching memory segments into the caller process address space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核通过一个名为`tmpfs`的特殊文件系统支持POSIX共享内存，该文件系统挂载到`rootfs`的`/dev/shm`上。这种实现提供了一个与Unix文件模型一致的独特API，导致每个共享内存分配都由唯一的文件名和inode表示。这个接口被应用程序员认为更加灵活，因为它允许使用标准的POSIX文件映射例程`mmap()`和`unmap()`将内存段附加到调用进程的地址空间和分离出来。
- en: 'Following is a summarized description of interface routines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是接口例程的摘要描述：
- en: '| **API** | **Description** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `shm_open()` | Create and open a shared memory segment identified by a filename
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `shm_open()` | 创建并打开由文件名标识的共享内存段 |'
- en: '| `mmap()` | POSIX standard file mapping interface for attaching shared memory
    to caller''s address space |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `mmap()` | POSIX标准文件映射接口，用于将共享内存附加到调用者的地址空间 |'
- en: '| `sh_unlink()` | Destroy specified shared memory block |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `sh_unlink()` | 销毁指定的共享内存块 |'
- en: '| `unmap()` | Detach specified shared memory map from caller address space
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `unmap()` | 从调用者地址空间分离指定的共享内存映射 |'
- en: The underlying implementation is similar to that of SysV shared memory with
    the difference that the mapping implementation is handled by the `tmpfs` filesystem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 底层实现与SysV共享内存类似，不同之处在于映射实现由`tmpfs`文件系统处理。
- en: Although shared memory is the easiest way of sharing common data or resources,
    it dumps the burden of implementing synchronization on the processes, as a shared
    memory infrastructure does not provide any synchronization or protection mechanism
    for the data or resources in the shared memory region. An application designer
    must consider synchronization of shared memory access between contending processes
    to ensure reliability and validity of shared data, for instance, preventing a
    possible write by two processes on the same region at a time, restricting a reading
    process to wait until a write is completed by another process, and so on. Often,
    to synchronize such race conditions another IPC resource called semaphores is
    used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管共享内存是共享常用数据或资源的最简单方式，但它将实现同步的负担转嫁给了进程，因为共享内存基础设施不提供任何数据或资源的同步或保护机制。应用程序设计者必须考虑在竞争进程之间同步共享内存访问，以确保共享数据的可靠性和有效性，例如，防止两个进程同时在同一区域进行可能的写操作，限制读取进程等待直到另一个进程完成写操作等。通常，为了同步这种竞争条件，还会使用另一种IPC资源，称为信号量。
- en: Semaphores
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: '**Semaphores** are synchronization primitives provided by the IPC subsystem.
    They deliver a protective mechanism for shared data structures or resources against
    concurrent access by processes in a multithreaded environment. At its core, each
    semaphore is composed of an integer counter that can be atomically accessed by
    a caller process. Semaphore implementations provide two operations, one for waiting
    on a semaphore variable and another to signal the semaphore variable. In other
    words, waiting on the semaphore decreases the counter by 1 and signaling the semaphore
    increases the counter by 1\. Typically, when a process wants to access a shared
    resource, it tries to decrease the semaphore counter. This attempt is however
    handled by the kernel as it blocks the attempting process until the counter yields
    a positive value. Similarly, when a process relinquishes the resource, it increases
    the semaphore counter, which wakes up any process that is waiting for the resource.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是IPC子系统提供的同步原语。它们为多线程环境中的进程提供了对共享数据结构或资源的并发访问的保护机制。在其核心，每个信号量由一个可以被调用进程原子访问的整数计数器组成。信号量实现提供了两种操作，一种用于等待信号量变量，另一种用于发出信号量变量。换句话说，等待信号量会将计数器减1，发出信号量会将计数器加1。通常，当一个进程想要访问一个共享资源时，它会尝试减少信号量计数器。然而，内核会处理这个尝试，因为它会阻塞尝试的进程，直到计数器产生一个正值。类似地，当一个进程放弃资源时，它会增加信号量计数器，这会唤醒正在等待资源的任何进程。'
- en: '**Semaphore versions**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量版本**'
- en: Traditionally all `*nix` systems implement the System V semaphore mechanism;
    however, POSIX has its own implementation of semaphores aiming at portability
    and leveling a few clumsy issues which the System V version carries. Let’s begin
    by looking at System V semaphores.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上所有的 `*nix` 系统都实现了 System V 信号量机制；然而，POSIX 有自己的信号量实现，旨在实现可移植性并解决 System V
    版本存在的一些笨拙问题。让我们先来看看 System V 信号量。
- en: System V semaphores
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V 信号量
- en: 'Semaphores in System V are not just a single counter as you might think, but
    rather a set of counters. This implies that a semaphore set can contain single
    or multiple counters (0 to n) with an identical semaphore ID. Each counter in
    the set can protect a shared resource, and a single semaphore set can protect
    multiple resources. The system call that helps create this kind of semaphore is
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 System V 中，信号量不仅仅是一个单一的计数器，而是一组计数器。这意味着一个信号量集合可以包含单个或多个计数器（0 到 n）并具有相同的信号量
    ID。集合中的每个计数器可以保护一个共享资源，而单个信号量集合可以保护多个资源。用于创建这种类型信号量的系统调用如下：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`key` is used to identify the semaphore. If the key value is `IPC_PRIVATE`,
    a new set of semaphores is created.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` 用于标识信号量。如果键值为 `IPC_PRIVATE`，则创建一个新的信号量集合。'
- en: '`nsems` indicates the semaphore set with the number of counters needed in the
    set'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsems` 表示需要在集合中的信号量数量'
- en: '`semflg` dictates how the semaphore should be created. It can contain two values:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semflg` 指示应该如何创建信号量。它可以包含两个值：'
- en: '`IPC_CREATE:` If the key does not exist, it creates a new semaphore'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_CREATE:` 如果键不存在，则创建一个新的信号量'
- en: '`IPC_EXCL`: If the key exists, it throws an error and fails'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_EXCL:` 如果键存在，则抛出错误并失败'
- en: On success, the call returns the semaphore set identifier (a positive value).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，调用返回信号量集合标识符（一个正值）。
- en: 'A semaphore thus created contains uninitialized values and requires the initialization
    to be carried out using the `semctl()` function. After initialization, the semaphore
    set can be used by the processes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建的信号量包含未初始化的值，并需要使用 `semctl()` 函数进行初始化。初始化后，进程可以使用信号量集合：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Semop()` function lets the process initiate operations on the semaphore
    set. This function offers a facility unique to the SysV semaphore implementation
    called **undoable operations** through a special flag called `SEM_UNDO`. When
    this flag is set, the kernel allows a semaphore to be restored to a consistent
    state if a process aborts before completing the relevant shared data access operation.
    For instance, consider a case where one of the processes locks the semaphore and
    begins its access operations on shared data; during this time if the process aborts
    before completion of shared data access, the semaphore will be left in an inconsistent
    state, making it unavailable for other contending processes. However, if the process
    had acquired a lock on the semaphore by setting the `SEM_UNDO` flag with `semop()`,
    its termination would allow the kernel to revert the semaphore to a consistent
    state (unlocked state) making it available for other contending processes in wait.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Semop()` 函数允许进程对信号量集合进行操作。这个函数提供了一种独特的 SysV 信号量实现所特有的 **可撤销操作**，通过一个名为 `SEM_UNDO`
    的特殊标志。当设置了这个标志时，内核允许在进程在完成相关的共享数据访问操作之前中止时，将信号量恢复到一致的状态。例如，考虑这样一种情况：其中一个进程锁定了信号量并开始对共享数据进行访问操作；在此期间，如果进程在完成共享数据访问之前中止，那么信号量将处于不一致的状态，使其对其他竞争进程不可用。然而，如果进程通过在
    `semop()` 中设置 `SEM_UNDO` 标志来获取信号量的锁定，那么它的终止将允许内核将信号量恢复到一致的状态（解锁状态），使其对等待的其他竞争进程可用。'
- en: Data structures
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'Each SysV semaphore set is represented in the kernel by a descriptor of type
    `struct sem_array`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SysV 信号量集合在内核中由 `struct sem_array` 类型的描述符表示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each semaphore in the array is enumerated as an instance of `struct sem` defined
    in `<ipc/sem.c>`; the `*sem_base` pointer refers to the first semaphore object
    in the set. ;Each semaphore set contains a list of pending queue per process waiting;
    `pending_alter` is the head node for this pending queue of type `struct sem_queue`.
    Each semaphore set also contains per-semaphore undoable operations. `list_id`
    is a head node to a list of `struct sem_undo` instances; there is one instance
    in the list for each semaphore in the set. The following diagram sums up the semaphore
    set data structure and its lists:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个信号量都被列举为 `<ipc/sem.c>` 中定义的 `struct sem` 的实例；`*sem_base` 指针指向集合中的第一个信号量对象。每个信号量集合包含一个等待队列的挂起队列列表；`pending_alter`
    是这个挂起队列的头节点，类型为 `struct sem_queue`。每个信号量集合还包含每个信号量可撤销的操作。`list_id` 是指向 `struct
    sem_undo` 实例列表的头节点；列表中每个信号量都有一个实例。以下图表总结了信号量集合数据结构及其列表：
- en: '![](img/00042.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: POSIX semaphores
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX 信号量
- en: POSIX semaphore semantics are rather simple when compared to System V. Each
    semaphore is a simple counter that can never be less than zero. The implementation
    provides function interfaces for initialization, increment, and decrement operations.
    They can be used for synchronizing threads by allocating the semaphore instance
    in memory accessible to all the threads. They can also be used for synchronizing
    processes by placing the semaphore in shared memory. Linux implementation of POSIX
    semaphores is optimized to deliver better performance for non-contending synchronization
    scenarios.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 System V 相比，POSIX 信号量语义相对简单。每个信号量都是一个简单的计数器，永远不会小于零。实现提供了用于初始化、增加和减少操作的函数接口。它们可以通过在所有线程都可以访问的内存中分配信号量实例来用于同步线程。它们也可以通过将信号量放置在共享内存中来用于同步进程。Linux
    对 POSIX 信号量的实现经过优化，以提供更好的性能，用于非竞争同步场景。
- en: 'POSIX semaphores are available in two variants: named semaphores and unnamed
    semaphores. A named semaphore is identified by a filename and is suitable for
    use between unrelated processes. An unnamed semaphore is just a global instance
    of type `sem_t`; this form is generally preferred for use between threads. POSIX
    semaphore interface operations are part of the POSIX threads library implementation.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX信号量有两种变体：命名信号量和无名信号量。命名信号量由文件名标识，适用于不相关进程之间的使用。无名信号量只是`sem_t`类型的全局实例；一般情况下，这种形式更适合在线程之间使用。POSIX信号量接口操作是POSIX线程库实现的一部分。
- en: '| **Function interfaces** | **Description** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '**函数接口** | **描述**'
- en: '| `sem_open()` | Opens an existing named semaphore file or creates a new named
    semaphore and returns its descriptor |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '`sem_open()` | 打开现有的命名信号量文件或创建一个新的命名信号量并返回其描述符'
- en: '| `sem_init()` | Initializer routine for an unnamed semaphore |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '`sem_init()` | 无名信号量的初始化程序'
- en: '| `sem_post()` | Operation to increment semaphore |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '`sem_post()` | 增加信号量的操作'
- en: '| `sem_wait()` | Operation to decrement semaphore, blocks if invoked when semaphore
    value is zero |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`sem_wait()` | 减少信号量的操作，如果在信号量值为零时调用，则会阻塞'
- en: '| `sem_timedwait()` | Extends `sem_wait()` with a timeout parameter for bounded
    wait |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`sem_timedwait()` | 用有界等待的超时参数扩展`sem_wait()`'
- en: '| `sem_getvalue()` | Returns the current value of the semaphore counter |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`sem_getvalue()` | 返回信号量计数器的当前值'
- en: '| `sem_unlink()` | Removes a named semaphore identified with a file |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`sem_unlink()` | 通过文件标识符移除命名信号量'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched on various IPC mechanisms offered by the kernel.
    We explored the layout and relationship between various data structures for each
    mechanism, and also looked at both SysV and POSIX IPC mechanisms.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了内核提供的各种IPC机制。我们探讨了每种机制的各种数据结构的布局和关系，并且还研究了SysV和POSIX IPC机制。
- en: In the next chapter, we will take this discussion further into locking and kernel-synchronization
    mechanisms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步讨论锁定和内核同步机制。
