- en: Timers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: Timers give us  the ability to set up an artifact where the OS lets us know
    once the specified time has expired—is a ubiquitous application (and, indeed,
    kernel) feature. Of course, the timer is usually only useful if it is running
    in parallel with the application logic; this asynchronous notification behavior
    is achieved by different means, very often by having the kernel send the relevant
    process a signal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器使我们能够设置一个工件，当指定的时间到期时，操作系统会通知我们——这是一个普遍的应用程序（甚至是内核）特性。当然，计时器通常只有在与应用程序逻辑并行运行时才有用；这种异步通知行为是通过不同的方式实现的，很多时候是通过内核发送相关进程信号来实现的。
- en: In this chapter, we shall explore the available interfaces on Linux for setting
    up and working with timers. These interfaces fall into two broad categories—the
    older APIs (`alarm(2)`, `[get|set]itimer(2)`), and the shiny, newer POSIX APIs
    (`timer_create(2)`, `timer_[set|get]time(2)`, and so on*)*. Of course, as signals
    are quite heavily employed along with timers, we make use of the signal interfaces
    as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Linux上用于设置和使用计时器的可用接口。这些接口分为两大类——较旧的API（`alarm(2)`、`[get|set]itimer(2)`）和闪亮的新POSIX
    API（`timer_create(2)`、`timer_[set|get]time(2)`等）。当然，由于信号与计时器一起被广泛使用，我们也会使用信号接口。
- en: We would also like to point out that, due to the intrinsic dynamic nature of
    timers, statically seeing the output of our sample programs in the book will not
    suffice; as usual, we definitely urge the reader to clone the book's GitHub repository
    and try out the code themselves.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想指出，由于计时器的固有动态特性，静态地查看我们书中示例程序的输出是不够的；像往常一样，我们强烈建议读者克隆本书的GitHub存储库并自己尝试代码。
- en: In this chapter, the reader will learn to use the various timer interfaces (APIs)
    exposed by the Linux kernel. We begin with the older ones, which, though they
    have limitations are still very much used in system software, as the need arises.
    A simple **command-line interface** (**CLI**)- only digital clock program is written
    and analyzed using these APIs. Then we move the reader on to the more recent and
    powerful POSIX Timer API set. Two very interesting sample programs—a "how quickly
    can you react" game and a run-walk interval timer application—are shown and studied.
    We close with a brief mention of using timer APIs via the file abstraction, and
    what a watchdog timer is.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学习使用Linux内核提供的各种计时器接口（API）。我们首先介绍较旧的接口，尽管它们有一些限制，但在系统软件中仍然被广泛使用，因为需要。我们编写了一个简单的**命令行界面**（**CLI**）-仅数字时钟程序，并使用这些API进行分析。然后我们将读者引入更近期和功能强大的POSIX计时器API集。展示和研究了两个非常有趣的示例程序——一个“你有多快能反应”的游戏和一个跑步间隔计时器应用程序。最后简要提到了通过文件抽象使用计时器API以及看门狗计时器是什么。
- en: Older interfaces
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 较旧的接口
- en: 'As previously mentioned, the older interfaces include the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，较旧的接口包括以下内容：
- en: The `alarm(2)` system call
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alarm(2)`系统调用'
- en: The interval timer`[get|set]itimer(2)`system call APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔计时器`[get|set]itimer(2)`系统调用API
- en: Let's begin with the first of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从它们中的第一个开始。
- en: The good ol' alarm clock
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 老式的闹钟
- en: 'The `alarm(2)`system call allows a process to set up a simple timeout mechanism;
    its signature is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`alarm(2)`系统调用允许进程设置一个简单的超时机制；其签名如下：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is, indeed, quite self-explanatory. Let''s take a simple example: A process
    wants to set up a timer that will expire in three seconds from now, so `alarm(3)`
    is essentially the code to use to do this.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当不言自明的。让我们举一个简单的例子：一个进程想要设置一个在三秒后到期的计时器，所以`alarm(3)`基本上就是用来做这个的代码。
- en: What exactly happens in the aforementioned code? Three seconds after the alarm system
    call is issued—that is, after the timer has been armed—the kernel will send the
    signal `SIGALRM` to the process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中到底发生了什么？在发出警报系统调用后三秒钟，也就是在定时器被装备后，内核将向进程发送信号`SIGALRM`。
- en: 'The default action of `SIGALRM` (signal # 14 on x86) is to terminate the process.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGALRM`（在x86上是信号＃14）的默认操作是终止进程。'
- en: Thus, we expect the developer to catch the signal (via the `sigaction(2)` system
    call would be best, as discussed in depth in the preceding [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - II* ).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们期望开发人员捕获信号（最好通过`sigaction(2)`系统调用，如前面的[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中所深入讨论的那样）。
- en: If the parameter input to alarm is `0`, any pending `alarm(2)` will be canceled
    (Actually, this will happen in any case when the alarm API is invoked.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`alarm`的参数是`0`，则任何待处理的`alarm(2)`都将被取消（实际上，当调用`alarm`API时，无论如何都会发生这种情况）。
- en: Notice that the alarm API, unusually for a system call, returns an unsigned integer
    (thus `-1` cannot be returned, which is the usual failure case). Instead, it returns
    the number of seconds to any previous programmed timeout, or zero if none was
    pending.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`alarm`API不同寻常地返回一个无符号整数（因此不能返回`-1`，这是通常的失败情况）。相反，它返回任何先前编程的超时秒数，如果没有挂起的超时，则返回零。
- en: A simple program (`ch13/alarm1.c`) demonstrating the basic usage of `alarm(2)` follows;
    the parameter specifies the number of seconds to time out in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简单的程序（`ch13/alarm1.c`），演示了`alarm(2)`的基本用法；参数指定了超时的秒数。
- en: For readability, only the key parts of the source code are displayed in the
    following; to view the complete source code, build it, and run it, the entire
    tree is available for cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，以下仅显示源代码的关键部分；要查看完整的源代码、构建它并运行它，可以从GitHub克隆整个树：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'The signal trapping and timer arming code is shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 信号捕获和计时器装备代码如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens once the `SIGALRM` signal is dispatched to the process by the
    kernel; that is, once the timer times out? The signal handler runs, of course.
    Here it is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核向进程分发`SIGALRM`信号后会发生什么；也就是说，一旦定时器超时了？信号处理程序当然会运行。在这里：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s a quick build and test run:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速的构建和测试运行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now enhance the previous code (`ch13/alarm1.c`) to have the timeout continually
    repeat (the source file is `ch13/alarm2_rep.c`); the relevant code snippet (which
    has changed from the previous code) is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在增强了先前的代码（`ch13/alarm1.c`）以使超时持续重复（源文件是`ch13/alarm2_rep.c`）；已更改的相关代码片段如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Though it does not apply here, realize that calling `alarm(2)`automatically
    cancels any previously pending timeout. A quick trial run is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里不适用，但要意识到调用`alarm(2)`会自动取消任何先前挂起的超时。快速试运行如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The alarm now repeats (every second in the above example run). Also notice how
    we just kill the process with a keyboard *Ctrl *+ *C* (delivering the `SIGINT`,
    which, as we haven't trapped it, just terminates the foreground process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 警报现在重复（在上面的示例运行中，每秒一次）。还要注意我们如何用键盘*Ctrl*+*C*（发送`SIGINT`，因为我们没有捕获它，所以只终止前台进程）杀死进程。
- en: Alarm API – the downer
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alarm API - 令人沮丧
- en: 'Now that we have looked at using the (simplistic) `alarm(2)`API, it''s important
    to realize that it has several downsides:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过使用（简单的）`alarm(2)`API，重要的是要意识到它有一些缺点：
- en: A very coarse granularity timeout (a minimum of one second, which is a very
    long time on a modern processor!)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常粗糙的粒度超时（在现代处理器上是非常长的一秒！）
- en: Running more than a single timeout in parallel is not possible
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能同时运行多个超时
- en: It's not possible to query or modify the timeout value at a later point—attempting
    to do so will cancel it
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能在以后的时间点查询或修改超时值-尝试这样做将取消它
- en: Mixing the following APIs can result in problems/conflicts (in the following,
    the latter API may be internally implemented using the former)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合以下API可能会导致问题/冲突（在下面，后一个API可能是使用前一个API内部实现的）
- en: '`alarm(2)` and `setitimer(2)`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alarm(2)`和`setitimer(2)`'
- en: '`alarm(2)` and `sleep(3)`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alarm(2)`和`sleep(3)`'
- en: It's always possible that the timeout occurs later than expected (overrun)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是可能超时发生比预期晚（超时）
- en: 'As we progress through this chapter, we will find more powerful functions that
    can overcome most of these issues. (Well, to be fair, the poor `alarm(2)`does
    have an upside: for simplistic purposes, it''s really quick and easy to use!)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章中的进展，我们将发现更强大的函数可以克服大部分这些问题。（嗯，公平地说，可怜的`alarm(2)`确实有一个好处：对于简单的目的，它非常快速和容易使用！）
- en: Interval timers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间隔计时器
- en: 'The interval timer APIs allow a process to set up and query a timer that can
    be programmed to auto-recur at a fixed time interval. The relevant system calls
    are these:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔计时器API允许进程设置和查询可以按固定时间间隔自动重复的计时器。相关的系统调用如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Quite obviously, the `setitimer(2)` is used to set up a new timer; the `getitimer(2)` can
    be used to query it, and returns the time remaining.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`setitimer(2)`用于设置新的计时器；`getitimer(2)`可用于查询它，并返回剩余时间。
- en: 'The first parameter to both is `which`—it specifies the type of timer to use. Linux
    allows us to use three types of interval timer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两者的第一个参数都是`which`，它指定要使用的计时器类型。Linux允许我们使用三种间隔计时器类型：
- en: '`ITIMER_REAL`: Use this timer type to count down in real-time, which is also
    called wall clock time. Upon timer expiry, the kernel sends the signal `SIGALRM`
    to the calling process.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITIMER_REAL`：使用此计时器类型在实时中倒计时，也称为挂钟时间。计时器到期时，内核会向调用进程发送信号`SIGALRM`。'
- en: '`ITIMER_VIRTUAL`: Use this timer type to count down in virtual time; that is,
    the timer only counts down when the calling process (all threads) is running in
    user space on the CPU. Upon timer expiry, the kernel sends the signal `SIGVTALRM`
    to the calling process.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITIMER_VIRTUAL`：使用此计时器类型在虚拟时间中倒计时；也就是说，只有当调用进程（所有线程）在CPU上运行在用户空间时，计时器才会倒计时。计时器到期时，内核会向调用进程发送信号`SIGVTALRM`。'
- en: '`ITIMER_PROF`: Use this timer type to count down in virtual time too; this
    time, the timer  counts down when the calling process (all threads) is running
    in both user-space and/or kernel space on the CPU. Upon timer expiry, the kernel
    sends the signal `SIGPROF` to the calling process.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITIMER_PROF`：使用此计时器类型也在虚拟时间中倒计时；这时，当调用进程（所有线程）在CPU上运行在用户空间和/或内核空间时，计时器会倒计时。计时器到期时，内核会向调用进程发送信号`SIGPROF`。'
- en: Thus, to have a timer that should expire when a certain amount of time has expired,
    use the first one; one can use the remaining two types to profile a process's
    CPU usage. Only one timer of each of the preceding types can be used at a time
    (more on this is to follow).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使计时器在特定时间过期时到期，请使用第一个；可以使用剩下的两种类型来对进程的CPU使用情况进行分析。每种类型的计时器一次只能使用一个（后面将详细介绍）。
- en: 'The next parameter to examine is the `itimerval` data structure (and its internal `timeval` structure
    members; both are defined in the `time.h` header):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的下一个参数是`itimerval`数据结构（以及它的内部`timeval`结构成员；两者都在`time.h`头文件中定义）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (FYI, both the internal `time_t` and the `suseconds_t` typedefs translate to
    a long (integer) value.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，内部的`time_t`和`suseconds_t`typedefs都转换为长整型值。）
- en: 'As we can see, this—the second parameter to `setitimer(2)`, which is a pointer
    to struct `itimerval` called `new_value`—is where we specify the new timer''s
    expiration times, such as:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这是`setitimer(2)`的第二个参数，它是指向名为`new_value`的结构体`itimerval`的指针，用于指定新计时器的到期时间，例如：
- en: In the `it_value` structure member, place the initial timeout value. This value
    decreases as the timer runs down, and, at some point, will hit zero; at this point,
    the appropriate signal corresponding to the timer type will be delivered to the
    calling process.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`it_value`结构成员中，放置初始超时值。该值随着计时器的运行而减少，并且在某个时候将变为零；在这一点上，与计时器类型对应的适当信号将被传递给调用进程。
- en: Subsequent to the previous step, the `it_interval` structure member is checked.
    If it is non-zero, this value will be copied into the `it_value` structure, causing
    the timer to effectively auto-reset and run again for that amount of time; in
    other words, this is how the API fulfills the interval timer role.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上一步之后，将检查`it_interval`结构成员。如果它不为零，则该值将被复制到`it_value`结构中，导致定时器有效地自动重置并再次运行该时间量；换句话说，这就是API如何实现间隔定时器角色的方式。
- en: Also, clearly, the time expiry is expressed in seconds:microseconds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，明确指出，时间到期以秒:微秒表示。
- en: 'For example, if we wanted a repeating (interval) timeout every second, we need
    to initialize the structures as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要每秒重复（间隔）超时，我们需要将结构初始化如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (Error checking code is not shown in the previous code for clarity.) Precisely
    this is done in the simple digital clock demo program that follows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: （出于清晰起见，错误检查代码未在上述代码中显示。）这正是在接下来的简单数字时钟演示程序中完成的。
- en: 'A few special cases exist:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些特殊情况：
- en: To cancel (or disarm) a timer, set both fields of the `it_timer` structure to
    zero and invoke the `setitimer(2)` API.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要取消（或解除武装）定时器，请将`it_timer`结构的两个字段都设置为零，并调用`setitimer(2)`API。
- en: To create a single-shot timer—that is, one that expires exactly once—initialize
    both fields of the `it_interval` structure to zero, and then invoke the `setitimer(2)` API.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个单次定时器——即，到期后仅一次——将`it_interval`结构的两个字段都初始化为零，然后调用`setitimer(2)`API。
- en: If the third parameter to `setitimer(2`) is non-NULL, the previous timer value
    is returned here (as if the `getitmer(2)` API were invoked).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`setitimer(2)`的第三个参数为非NULL，则将在此处返回先前的定时器值（就好像调用了`getitmer(2)`API一样）。
- en: As is usual, the pair of system calls returns `0` on success and `-1` on failure
    (with `errno` set appropriately).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常一样，这对系统调用在成功时返回`0`，在失败时返回`-1`（并适当设置`errno`）。
- en: As there is one signal generated upon expiry of each type of timer, one can
    only have one instance of each timer type running concurrently within a given
    process. If we try and set up multiple timers of the same type (for example, `ITIMER_REAL`), it's
    always possible that multiple instances of the same signal (in this example, `SIGALRM`)
    will be delivered to the process—and to the same handler routine—simultaneously.
    As we learned in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II *, regular Unix signals cannot be queued, and signal instances might
    thus be dropped. In effect, it is best (and safest) to work concurrently with
    one of each type of timer in a given process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种类型的定时器到期时会生成一个信号，因此在给定进程中只能同时运行每种类型的定时器的一个实例。如果我们尝试设置多个相同类型的定时器（例如，`ITIMER_REAL`），则总是可能会将多个相同信号的实例（在本例中为`SIGALRM`）同时传递给进程——并且传递给相同的处理程序例程。正如我们在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中学到的那样，*信号-第一部分*和*信号-第二部分*，常规的Unix信号不能排队，因此信号实例可能会被丢弃。实际上，在给定进程中最好（也最安全）同时使用每种类型的定时器的一个实例。
- en: 'The following table contrasts the simple` alarm(2)` system call API that we
    saw earlier with the more powerful `[set|get]itimer(2)` interval timer APIs that
    we have just seen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下表对比了我们之前看到的简单`alarm(2)`系统调用API和我们刚刚看到的更强大的`[set|get]itimer(2)`间隔定时器API：
- en: '| **Feature** | **Simple timer** [`alarm(2)`] | **Interval timers** [`setitimer(2)`,
    `getitimer(2)`] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **简单定时器** [`alarm(2)`] | **间隔定时器** [`setitimer(2)`, `getitimer(2)`]
    |'
- en: '| Granularity (resolution) | Very coarse; 1 second | Fine granularity; in theory,
    1 microsecond (in practice, typically milliseconds prior to 2.6.16 HRT[1]) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 粒度（分辨率） | 非常粗糙；1秒 | 很好的粒度；理论上为1微秒（实际上，在2.6.16 HRT[1]之前通常为毫秒） |'
- en: '| Query time remaining | Not possible | Yes, with `getitimer(2)` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 查询剩余时间 | 不可能 | 是的，使用`getitimer(2)` |'
- en: '| Modify timeout | Not possible | Yes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 修改超时 | 不可能 | 是的 |'
- en: '| Cancel timeout | Yes | Yes |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 取消超时 | 是 | 是 |'
- en: '| Auto-repeating | No, but it can be set up manually | Yes |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 自动重复 | 不，但可以手动设置 | 是的 |'
- en: '| Multiple timers | Not possible | Yes, but at most three—one of each type
    (real, virtual, and profiling)—per process |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: 多个定时器 | 不可能 | 是的，但每个进程最多三个——每种类型一个（实时、虚拟和分析）|
- en: 'Table 1 : A quick comparison of the simple alarm(2)API and interval timers'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：简单`alarm(2)`API和间隔定时器的快速比较
- en: '[1] **High-resolution timers** (**HRT**); implemented in Linux 2.6.16 onward.
    See a link to a detailed paper on this in the *Further reading* section on the
    GitHub repository.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] **高分辨率定时器**（**HRT**）；从Linux 2.6.16开始实现。在GitHub存储库的*进一步阅读*部分中有一篇详细论文的链接。'
- en: What is knowledge without application? Let's try out the interval timer API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用的知识有什么用？让我们尝试一下间隔定时器API。
- en: A simple CLI digital clock
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的CLI数字时钟
- en: We humans are quite used to seeing a clock tick away, one second at a time.
    Why not write a quick C program that mimics a (very simplistic command-line) digital
    clock that must show us the correct date and time every single second! (Well,
    personally, I prefer seeing the old-fashioned analog clocks, but, hey, this book
    does not go into the closely held secret mantras to perform graphical drawing
    with X11.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类非常习惯看到时钟每秒滴答一次。为什么不编写一个快速的C程序，模拟一个（非常简单的命令行）数字时钟，必须每秒显示我们正确的日期和时间！（嗯，个人而言，我更喜欢看到老式的模拟时钟，但是，嘿，这本书并没有涉及执行图形绘图的密切保密的秘密口诀。）
- en: 'How we achieve this is quite simple, really: we set up an interval timer that
    times out every one second. The program (`ch13/intv_clksimple.c`) which demonstrates
    the basic usage of the quite powerful `setitimer(2)` API follows.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现这一点非常简单，实际上：我们设置一个每秒超时一次的间隔定时器。下面是演示相当强大的`setitimer(2)`API的基本用法的程序（`ch13/intv_clksimple.c`）。
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，以下仅显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆到这里：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'The signal trapping and set up of the single-second interval timer is shown
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 信号捕获和设置单秒间隔定时器如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the self-explanatory comment on why we typically do not use the `SA_RESTART`
    flag when working with signals that deliver timeouts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于为什么我们通常在处理传递超时的信号时不使用`SA_RESTART`标志的自解释注释。
- en: 'Setting up the interval timer is easy: we initialize the `itimerval` structure
    such that we set the seconds members—of the internal `timeval` structures—to `1`
    (we just leave the microseconds as zero), and issue the `setitimer(2)` system
    call. The timer is armed—it starts counting down. When a second has elapsed, the
    kernel will deliver the signal `SIGALRM` to the process (as the timer type is
    `ITIMER_REAL`). The signal handler routine `ticktock` will perform the task of
    obtaining and printing out the current timestamp (see its code as follows). The
    interval component being set to `1`, the timer will automatically and repeatedly
    fire every single second.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设置间隔定时器很容易：我们初始化`itimerval`结构，将其中的秒成员设置为`1`（微秒部分保持为零），然后发出`setitimer(2)`系统调用。定时器被装载——它开始倒计时。当一秒钟过去后，内核将向进程传递`SIGALRM`信号（因为定时器类型是`ITIMER_REAL`）。信号处理程序`ticktock`将执行获取并打印当前时间戳的任务（请参见其代码如下）。由于间隔组件被设置为`1`，定时器将自动重复每秒触发一次。
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous signal handler routine gets invoked once a second, every second
    (as, of course, the kernel delivers the signal `SIGALRM` to the process upon timer
    expiry). The job of this routine is clear: it must query and print the current
    date-time; that is, the timestamp.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信号处理程序例程每秒调用一次（当然，内核在定时器到期时向进程传递`SIGALRM`信号）。这个例程的工作很明确：它必须查询并打印当前日期时间；也就是时间戳。
- en: Obtaining the current time
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前时间
- en: 'Querying the current time is, at first glance, straightforward. Many programmers
    use the following API sequence to achieve it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查询当前时间乍一看似乎很简单。许多程序员使用以下API序列来实现它：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We do not. Why is this? Recall our discussion on the async-signal-safe (reentrant)
    functions in the first of [Chapters 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, (within the section *Reentrant Safety and Signaling*). Of
    the aforementioned three APIs, only the `time(2)` API is considered signal-safe;
    the other two are not (that is, they should not be used within a signal handler).
    The relevant man page (`signal-safety(7)`) confirms this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不这样做。为什么呢？回想一下我们在第11章《信号-第一部分》中对异步信号安全（可重入）函数的讨论（在“可重入安全性和信号”部分）。在前面提到的三个API中，只有`time(2)`
    API被认为是信号安全的；其他两个则不是（也就是说，它们不应该在信号处理程序中使用）。相关的man页面（`signal-safety(7)`）证实了这一点。
- en: Hence, we use documented async-signal-safe APIs-the `time(2)`, `clock_gettime(2)`
    and `ctime_r(3)`—to perform the role of obtaining the timestamp safely. A quick
    peek at them follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用文档化的异步信号安全API——`time(2)`、`clock_gettime(2)`和`ctime_r(3)`——来安全地获取时间戳的角色。以下是它们的快速查看。
- en: 'The `clock_gettime(2)` system call''s signature is this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock_gettime(2)`系统调用的签名如下：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first parameter is the clock source or clock type to use; the fact is that
    the Linux OS (and glibc) supports many different built-in types of clocks; among
    them are the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要使用的时钟源或时钟类型；事实上，Linux操作系统（和glibc）支持许多不同的内置时钟类型；其中包括以下几种：
- en: '`CLOCK_REALTIME`: A system-wide wall-clock clock (in real-time); use this to
    query the timestamp.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_REALTIME`：系统范围的挂钟时钟（实时）；使用它来查询时间戳。'
- en: '`CLOCK_MONOTONIC`: Monotonic clocks count in one direction (up, obviously;
    travelling backwards through time is a feature still being worked upon by mad
    (or are they?) scientists). It usually counts the time elapsed since the system
    boot.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_MONOTONIC`：单调时钟按一个方向计数（显然是向上；通过时间倒流是一项仍在被疯狂（或者是吗？）的科学家们研究的功能）。它通常计算自系统启动以来经过的时间。'
- en: '`CLOCK_BOOTTIME` (from Linux 2.6.39): This is pretty much the same as CLOCK_MONOTONIC,
    except that it takes into account time the system has been suspended.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_BOOTTIME`（从Linux 2.6.39开始）：这与`CLOCK_MONOTONIC`几乎相同，只是它考虑了系统暂停的时间。'
- en: '`CLOCK_PROCESS_CPUTIME_ID`: A measure of CPU time spent on CPU by all threads
    of a given process (via PID; use the `clock_getcpuclockid(3)` API to query it).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_PROCESS_CPUTIME_ID`：衡量给定进程的所有线程在CPU上花费的CPU时间（通过PID；使用`clock_getcpuclockid(3)`
    API来查询）。'
- en: '`CLOCK_THREAD_CPUTIME_ID`: A measure of CPU time spent on CPU by a specific
    thread (use the `pthread_getcpuclockid(3)` API to query it).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_THREAD_CPUTIME_ID`：衡量特定线程在CPU上花费的CPU时间（使用`pthread_getcpuclockid(3)`
    API来查询）。'
- en: There are more; please refer the man page on `clock_gettime(2)` for details.
    For our current purposes, `CLOCK_REALTIME` is the one we will go with.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多；请参考`clock_gettime(2)`的man页面以获取详细信息。对于我们当前的目的，`CLOCK_REALTIME`是我们要使用的时钟类型。
- en: 'The second parameter to `clock_gettime(2)`is a value-result style one; in effect,
    this is a return value. Upon a successful return, it will hold the timestamp in
    the `timeval` structure; the structure is defined in the `time.h` header, and
    holds the current timestamp in seconds and nanoseconds:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock_gettime(2)`的第二个参数是一个值-结果风格的参数；实际上，这是一个返回值。在成功返回时，它将保存`timeval`结构中的时间戳；该结构在`time.h`头文件中定义，并以秒和纳秒的形式保存当前时间戳：'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We shall be quite satisfied with the value in seconds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对秒数的值将会非常满意。
- en: 'But how exactly is this value in seconds and nanoseconds interpreted? It''s
    actually very common in the Unix universe: Unix systems store time as the number
    of seconds elapsed since January 1, 1970 midnight (00:00)—think of it as Unix''s
    birth! This time value is called time since the Epoch or Unix time. Okay, so it''s
    going to be a rather large number of seconds today, right? So how does one express
    it in a human-readable format? We''re glad you asked, as that''s precisely the
    job of the `ctime_r(3)`API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个秒和纳秒的值是如何解释的呢？在Unix宇宙中，这实际上非常常见：Unix系统将时间存储为自1970年1月1日午夜（00:00）以来经过的秒数——可以将其视为Unix的诞生！这个时间值被称为自纪元以来的时间或Unix时间。好吧，今天它将是一个相当大的秒数，对吧？那么如何以人类可读的格式表示它呢？我们很高兴你问，因为这正是`ctime_r(3)`API的工作：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter will be (a pointer to) the `time_t` member we got returned
    from  the `clock_gettime(2)` API; again, the second parameter is a value result-style
    return—on successful completion, it will hold the human-readable timestamp! Note
    that it's the application programmer's job to allocate memory for the buffer `buf` (and
    subsequently free it as required). In our code, we just use a statically allocated
    local buffer. (Of course, we perform error checking on all APIs.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数将是我们从`clock_gettime(2)`API返回的`time_t`成员的指针；再次，第二个参数是一个值结果式的返回——成功完成时，它将保存可读的时间戳！请注意，为缓冲区`buf`分配内存（并根据需要释放）是应用程序员的工作。在我们的代码中，我们只使用静态分配的本地缓冲区。（当然，我们对所有API执行错误检查。）
- en: Finally, depending on the `opt` value (passed by the user), we either use the
    (safe) `write(2)` system call or the (unsafe!) `printf(3)`/`fflush(3)` APIs to
    print out the current time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据用户传递的`opt`值，我们要么使用（安全的）`write(2)`系统调用，要么使用（不安全的！）`printf(3)`/`fflush(3)`API来打印当前时间。
- en: The code `printf("\r%s", tmstamp);` has the `printf(3)` using the `\r` format—this
    is the carriage return, which effectively brings the cursor back to the beginning
    of the same line. This gives the appearance of a clock constantly updating. This
    is nice, except for the fact that using `printf(3)`itself is signal-unsafe!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`printf("\r%s", tmstamp);`使用了`\r`格式的`printf(3)`——这是回车，它有效地将光标带回到同一行的开头。这给人一种不断更新的时钟的外观。这很好，除了使用`printf(3)`本身是不安全的！
- en: Trial runs
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试运行
- en: 'Here is a trial run, first with the signal-safe `write(2)`method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个试运行，首先使用信号安全的`write(2)`方法：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And now, here''s one with the signal-unsafe `printf(3)`/`fflush(3)`method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个使用信号不安全的`printf(3)`/`fflush(3)`方法的试运行：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It looks nicer, what with the timestamp being continually refreshed on the same
    line, but is unsafe. This book cannot show you, dear reader, the pleasant effect
    of the carriage return- style `printf("\r...")`. Do try it out on your Linux system
    to see this for yourself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好，时间戳不断刷新在同一行上，但是不安全。这本书无法向您展示，亲爱的读者，回车样式的`printf("\r...")`的愉快效果。在您的Linux系统上尝试一下，看看自己。
- en: We understand that using the `printf(3)` and `fflush(3)`APIs within a signal
    handler is bad programming practice—they are not async-signal safe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在信号处理程序中使用`printf(3)`和`fflush(3)`API是不好的编程实践——它们不是异步信号安全的。
- en: 'But what if the low-level design specification demands that we use exactly
    these APIs? Well, there''s always a way: why not redesign the program to use one
    of the synchronous blocking APIs to wait upon and catch signal(s) wherever appropriate
    (Remember, when trapping  fatal signals such as `SIGILL`, `SIGFPE`, `SIGSEGV`,
    and `SIGBUS`, it''s recommended to use the usual async `sigaction(2)` API): the
    `sigwait(3)`, `sigwaitinfo(2)`, `sigtimedwait(2)` or even the `signalfd(2)` API
    (that we covered in [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II*, section *Synchronously blocking for signals via the sigwait* APIs*).
    We leave this as an exercise for the reader.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果低级设计规范要求我们确切使用这些API呢？好吧，总是有办法：为什么不重新设计程序，使用其中一个同步阻塞API来等待和捕获信号（请记住，当捕获致命信号如`SIGILL`、`SIGFPE`、`SIGSEGV`和`SIGBUS`时，建议使用通常的异步`sigaction(2)`API）：`sigwait(3)`、`sigwaitinfo(2)`、`sigtimedwait(2)`甚至是`signalfd(2)`API（我们在[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中介绍过，*信号-第二部分*，*通过sigwait同步阻塞信号的API*）。我们把这留给读者作为练习。
- en: A word on using the profiling timers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于使用分析计时器的一些话
- en: 'We have explored, in some detail, the usage of the `ITIMER_REAL` timer type—which
    counts down in real-time. What about using the other two—the `ITIMER_VIRTUAL`
    and `ITIMER_PROF`—timers? Well, the code styling is very similar; there''s nothing
    new there. The catch that a developer who is new to this faces is this: the signal(s)
    may never seem to arrive at all!'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经比较详细地探讨了`ITIMER_REAL`计时器类型的使用——它按实时倒计时。那么，使用另外两种——`ITIMER_VIRTUAL`和`ITIMER_PROF`——计时器呢？嗯，代码风格非常相似；没有什么新东西。对于新手开发人员来说，面临的问题是：信号可能根本不会到达！
- en: 'Let''s take a simple code snippet using the `ITIMER_VIRTUAL` timer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`ITIMER_VIRTUAL`计时器的简单代码片段：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When run, no output appears—the timer is seemingly not working.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，没有输出出现——计时器似乎没有工作。
- en: 'That''s really not the case—it is working, but the catch is this: the process
    merely sleeps via the `pause(2)`. While sleeping, its not running on CPU; hence,
    the kernel has hardly decremented the (aforementioned, second-by-second) interval
    timer at all! Remember, both the `ITIMER_VIRTUAL` and `ITIMER_PROF` timers only
    decrement (or count down), when the process is on CPU. Thus, the one-second timer
    never actually expires, and the `SIGPROF` signal is never sent.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的不是这种情况——它正在工作，但问题在于：这个进程仅通过`pause(2)`来睡眠。在睡眠时，它不在CPU上运行；因此，内核几乎没有减少（前面提到的，每秒）间隔计时器！请记住，只有当进程在CPU上运行时，`ITIMER_VIRTUAL`和`ITIMER_PROF`计时器才会递减（或倒计时）。因此，一秒钟的计时器实际上从未到期，`SIGPROF`信号也从未发送。
- en: 'So, now, the way to solve the previous issue becomes obvious: let''s introduce
    some CPU processing into the program and reduce the timeout value. Our trusty `DELAY_LOOP_SILENT`macro
    (see source file `common.h`) has the process spin over some silly logic—the point
    being that it becomes CPU-intensive. Also, we have reduced the timer expiry to
    be expire for every 10 ms the process spends on the CPU:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在解决之前问题的方法变得明显：让我们在程序中引入一些CPU处理，并减少超时值。我们可靠的`DELAY_LOOP_SILENT`宏（参见源文件`common.h`）使进程在一些愚蠢的逻辑上旋转——重点是它变得CPU密集。此外，我们已经将定时器到期减少为每个进程在CPU上花费10毫秒：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time, upon running, we see this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，运行时，我们看到了这个：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The profiling timer is indeed working.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析定时器确实在工作。
- en: The newer POSIX (interval) timers mechanism
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新的POSIX（间隔）定时器机制
- en: 'Earlier in this chapter, we saw in *Table 1 : A quick comparison of the simple*
    *alarm(2) API and interval timers*, that, although the interval timer `[get|set]itimer(2)`
    APIs are superior to the simplistic `alarm(2)` API, they still lack important
    modern features. The modern POSIX (interval) timer mechanism addresses several
    shortcomings, some of which are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们在*表1：简单* *alarm(2) API和间隔定时器的快速比较*中看到，尽管间隔定时器`[get|set]itimer(2)`API优于简单的`alarm(2)`API，但它们仍然缺乏重要的现代功能。现代POSIX（间隔）定时器机制解决了一些缺点，其中一些如下：
- en: The resolution is improved a thousand-fold with the addition of nanosecond granularity timers
    (with the addition of an arch-independent HRT mechanism, which is integrated into
    2.6.16 Linux kernel onward).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加纳秒粒度定时器（通过在2.6.16 Linux内核中集成的与架构无关的HRT机制）来改善分辨率一千倍。
- en: A generic `sigevent(7)` mechanism—which is a way to handle asynchronous events
    such as timer expiry (our use case), AIO request completion, delivery of a message,
    and so on—to handle timer expiry. We are now not forced to tie timer expiry to
    the signaling mechanism.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种通用的`sigevent(7)`机制——这是一种处理异步事件的方式，例如定时器到期（我们的用例）、AIO请求完成、消息传递等——来处理定时器到期。我们现在不再被迫将定时器到期与信号机制绑定。
- en: Importantly, a process (or thread) can now set up and manage any number of timers.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，一个进程（或线程）现在可以设置和管理任意数量的定时器。
- en: 'Well, ultimately, there''s always an upper limit: in this case, it''s the resource
    limit `RLIMIT_SIGPENDING`. (More technically, the fact is that the OS allocates
    a queued real-time signal for every timer created, which is thus the limit.)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，总是有一个上限：在这种情况下，它是资源限制`RLIMIT_SIGPENDING`。（更技术上地说，事实是操作系统为每个创建的定时器分配了一个排队的实时信号，这就是限制。）
- en: These points are fleshed out as follows, so read on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观点将如下所述，继续阅读。
- en: Typical application workflow
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型的应用程序工作流程
- en: 'The design approach (and APIs used) to set up and use a modern POSIX timer
    follows; the sequence is typically in the order shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和使用现代POSIX定时器的设计方法（和使用的API）如下；顺序通常如下所示：
- en: Signal(s) setup.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号设置。
- en: Assuming the notification mechanism being used is a signal, first trap the signal(s) 
    via `sigaction(2)`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设正在使用的通知机制是信号，首先通过`sigaction(2)`捕获信号。
- en: Create and initialize the timer(s).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和初始化定时器。
- en: Decide on the clock type (or source) to use to measure the elapsed time.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用哪种时钟类型（或源）来测量经过的时间。
- en: Decide on the timer-expiry event-notification mechanism to be used by your application—typically,
    whether to use (the usual) signals or a (newly spawned) thread.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定应用程序使用的定时器到期事件通知机制——通常是使用（通常的）信号还是（新生成的）线程。
- en: The aforementioned decisions are implemented via the `timer_create(2)` system
    call; thereby it allows one to create a timer, and, of course, we can create multiple
    timers by invoking it multiple times.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述决策通过`timer_create(2)`系统调用实现；因此它允许创建一个定时器，当然，我们可以多次调用它来创建多个定时器。
- en: Arm (or disarm) a particular timer  using `timer_settime(2)`. To arm a timer
    means to effectively start it running—counting down; disarming a timer is the
    opposite—stopping it in its tracks.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_settime(2)`来装载（或解除装载）特定的定时器。装载定时器意味着有效地启动它运行——倒计时；解除装载定时器则相反——停止它。
- en: To query the time remaining (to expiration) in a particular timer (and its interval
    setting) use `timer_gettime(2)`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询特定定时器的剩余时间（到期时间）（及其间隔设置）使用`timer_gettime(2)`。
- en: Check the overrun count of a given timer using `timer_getoverrun(2)`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_getoverrun(2)`检查给定定时器的超时计数。
- en: Delete (and obviously disarm) a timer using `timer_delete(2)`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_delete(2)`删除（显然也是解除装载）定时器。
- en: Creating and using a POSIX (interval) timer
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用POSIX（间隔）定时器
- en: 'As seen previously, we use the powerful `timer_create(2)` system call to create
    a timer for the calling process (or thread, for that matter):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用强大的`timer_create(2)`系统调用为调用进程（或线程）创建定时器：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have to link with the **real time** (**rt**) library to make use of this
    API. The `librt`library implements the POSIX.1b Realtime Extensions to POSIX interfaces.
    Find a link to the `librt`man page in the *Further Reading *section on the GitHub
    repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须链接**实时**（**rt**）库来使用这个API。`librt`库实现了POSIX.1b对POSIX接口的实时扩展。在GitHub存储库的*进一步阅读*部分中找到`librt`man页面的链接。
- en: The first parameter passed to `timer_create(2)`informs the OS of the clock source to
    be used; we avoid repetition of the matter and refer the reader to the section
    *Obtaining the current time* covered earlier in the chapter, in which we enumerated
    several of the commonly used clock sources in Linux. (Also, as noted there, one
    can refer to the man page on `clock_gettime(2)` for additional details.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`timer_create(2)`的第一个参数通知操作系统要使用的时钟源；我们避免重复这个问题，并参考本章前面涵盖的*获取当前时间*部分，其中我们列举了Linux中常用的几种时钟源。（另外，正如在那里指出的，可以参考`clock_gettime(2)`的man页面获取更多细节。）
- en: 'The second parameter passed to `timer_create(2)`is interesting: it provides
    a generic way to specify the timer-expiry event-notification mechanism to be used
    by your application! To understand this, let''s take a look at the `sigevent` structure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`timer_create(2)`的第二个参数很有趣：它提供了一种通用的方式来指定应用程序使用的计时器到期事件通知机制！为了理解这一点，让我们来看看`sigevent`结构：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (Recall that we have already come across and used the `union sigval` mechanism
    to pass along a value to a signal handler in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - Part II*.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下，我们已经在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)中使用了`union
    sigval`机制，将一个值传递给信号处理程序。*信号-第一部分*和*信号-第二部分*。）
- en: 'Valid values for the `sigev_notify` member are enumerated in the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigev_notify`成员的有效值在以下枚举：'
- en: '| **Notification method** : `sigevent.sigev_notify` | **Meaning** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **通知方法**：`sigevent.sigev_notify` | **意义** |'
- en: '| `SIGEV_NONE` | Nothing done upon event arrival—a null notification |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_NONE` | 事件到达时不执行任何操作-空通知 |'
- en: '| `SIGEV_SIGNAL` | Notification by sending the process the signal specified
    in the `sigev_signo` member |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_SIGNAL` | 通过发送进程中`sigev_signo`成员中指定的信号来通知 |'
- en: '| `SIGEV_THREAD` | Notification by invoking (actually, spawning) a (new) thread
    whose function is `sigev_notify_function`, the parameter passed to it is `sigev_value`,
    and if `sigev_notify_attributes` is non-NULL it should be a `pthread_attr_t `structure
    for the new thread. (Readers, note that we shall cover multithreading in detail
    in subsequent chapters.) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_THREAD` | 通过调用（实际上是生成）一个（新的）线程，其函数为`sigev_notify_function`，传递给它的参数是`sigev_value`，如果`sigev_notify_attributes`不为NULL，则应该是新线程的`pthread_attr_t`结构。（读者们，请注意，我们将在后续章节中详细介绍多线程。）
    |'
- en: '| `SIGEV_THREAD_ID` | Linux-specific and used to specify a kernel thread that
    will run upon timer expiry; realistically, only threading libraries make use of
    this functionality. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_THREAD_ID` | 仅在Linux中使用，用于指定在计时器到期时将运行的内核线程；实际上，只有线程库才使用此功能。 |'
- en: 'Table 2 : Using the sigevent(7) mechanism'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：使用sigevent(7)机制
- en: In the first case, `SIGEV_NONE`, the timer can always be manually checked for
    expiry via the `timer_gettime(2)`API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`SIGEV_NONE`，可以始终通过`timer_gettime(2)`API手动检查计时器是否到期。
- en: 'The more interesting and common case is the second one, `SIGEV_SIGNAL`. Here,
    a signal is delivered to the process whose timer has expired; the process''s `sigaction(2)`
    handler''s `siginfo_t` data structure is populated appropriately; for our use
    case—that of using a POSIX timer—this is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣和常见的情况是第二种情况，`SIGEV_SIGNAL`。在这里，信号被传递给计时器已经到期的进程；进程的`sigaction(2)`处理程序的`siginfo_t`数据结构被适当地填充；对于我们的用例-使用POSIX计时器-如下：
- en: '`si_code` (or signal origin field) is set to the value `SI_TIMER` to denote
    that a POSIX timer has expired (look up the other possibilities within the man
    page on `sigaction`)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_code`（或信号来源字段）设置为值`SI_TIMER`，表示POSIX计时器已经到期（在`sigaction`的man页面中查找其他可能性）'
- en: '`si_signo` is set to the signal number (`sigev_signo`)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_signo`设置为信号编号（`sigev_signo`）'
- en: '`si_value` will be the value set in the union `sigev_value`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_value`将是`union sigev_value`中设置的值'
- en: For our purposes (in this chapter, at least), we shall only consider the case
    of setting the `sigevent` notification type to the value `SIGEV_SIGNAL` (and thus
    setting the signal to deliver in the `sigev_signo` member).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的（至少在本章中），我们只考虑将`sigevent`通知类型设置为值`SIGEV_SIGNAL`（因此设置要在`sigev_signo`成员中传递的信号）。
- en: The third parameter passed to `timer_create(2)`, `timer_t *timerid`, is a (now
    common) value result-style one; it is, in effect, the return ID of the newly created
    POSIX timer! Of course, the system call returns `-1` on failure (and `errno` is
    set accordingly), and `0` on success. The `timerid` is the handle to the timer—we
    shall typically pass it as a parameter in the subsequent POSIX timer APIs to specify
    a particular timer to act upon.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`timer_create(2)`的第三个参数，`timer_t *timerid`，是一个（现在常见的）值结果样式的参数；实际上，它是新创建的POSIX计时器的返回ID！当然，系统调用在失败时返回`-1`（并相应设置`errno`），成功时返回`0`。`timerid`是计时器的句柄-我们通常将其作为参数传递给后续的POSIX计时器API，以指定要操作的特定计时器。
- en: The arms race – arming and disarming a POSIX timer
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 军备竞赛-启动和停止POSIX计时器
- en: 'As mentioned previously, we use the `timer_settime(2)` system call to either
    arm (start) or disarm (stop) a timer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用`timer_settime(2)`系统调用来启动或停止计时器：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As one can have multiple concurrent POSIX timers running simultaneously, thus
    we need to specify exactly which timer we are referring to; this is done via the
    first parameter `timer_id`, which is the timer's ID, and the effective return
    of the previously seen `timer_create(2)` system call.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以同时运行多个并发的POSIX计时器，因此我们需要准确指定我们正在引用的计时器；这是通过第一个参数`timer_id`完成的，它是计时器的ID，并且是先前看到的`timer_create(2)`系统调用的有效返回。
- en: 'The important data structure employed here is the `itimerspec`; its definition
    is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的重要数据结构是`itimerspec`；其定义如下：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, it should be quite clear: within the third parameter, a pointer to the `itimerspec` structure
    called, `new_value`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显：在第三个参数中，指向名为`new_value`的`itimerspec`结构的指针：
- en: We can specify the time to the (theoretical) resolution to a single nanosecond!
    Note that the time is measured with respect to the clock source that was specified
    by the `timer_create(2`) API.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将时间指定到（理论上的）纳秒分辨率！请注意，时间是相对于由`timer_create(2)`API指定的时钟源来测量的。
- en: This reminds us, one can always query the clock resolution with the `clock_getres(2)` API.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这提醒我们，可以始终使用`clock_getres(2)`API查询时钟分辨率。
- en: 'With respect to initializing the `it_value`  (`timespec` structure):'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于初始化`it_value`（`timespec`结构）：
- en: Set it to a non-zero value to specify the initial timer-expiry value.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为非零值以指定初始计时器到期值。
- en: Set it to zero to specify that we are disarming (stopping) the timer.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为零以指定我们正在解除（停止）计时器。
- en: What if this structure is holding a positive value already? Then it's overwritten,
    and the timer is re-armed with the new values.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个结构已经保存了一个正值，那么它将被覆盖，并且定时器将使用新值重新启动。
- en: Not only that, but, by initializing the `it_interval` (timespec structure) to
    a non-zero value, we will set up a repeating - interval - timer (hence the name
    POSIX interval timer); the time interval being the value it is initialized to.
    The timer will continue to fire indefinitely, or until it's disarmed or deleted.
    If, instead, this structure is zeroed out, the timer becomes a one-shot timer
    (firing just once when the time specified in the it_value member elapses).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅如此，通过将`it_interval`（timespec结构）初始化为非零值，我们将设置一个重复的间隔定时器（因此称为POSIX间隔定时器）；时间间隔就是它初始化的值。定时器将持续无限期地触发，直到它被解除武装或删除。如果相反，这个结构被清零，定时器就变成了一次触发的定时器（当it_value成员中指定的时间过去时只触发一次）。
- en: 'In general, set the `flags` value to `0`—the man page on `timer_settime(2)` specifies
    an additional flag that could be used. Finally, the fourth parameter `old_value` (again,
    a pointer to struct `itimerspec`) works as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将`flags`值设置为`0`——`timer_settime(2)`的man页面指定了一个可以使用的附加标志。最后，第四个参数`old_value`（同样是指向`struct
    itimerspec`的指针）的工作如下：
- en: If `0`, it is simply ignored.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`0`，则会被简单地忽略。
- en: If non-zero, it is a means to query the time remaining to the expiry of the
    given timer.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果非零，则是查询到给定定时器到期的剩余时间的一种方法。
- en: The time to expiry will be returned in the `old_value->it_value` member (in
    seconds and nanoseconds), and the interval it was set will be returned in the `old_value->it_interval` member.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到期时间将在`old_value->it_value`成员中返回（以秒和纳秒为单位），设置的间隔将在`old_value->it_interval`成员中返回。
- en: As expected, the return value on success is `0` and is `-1` on failure (with `errno`
    being set appropriately).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的成功返回值为`0`，失败时为`-1`（并适当设置了`errno`）。
- en: Querying the timer
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询定时器
- en: 'A given POSIX timer can be queried at any point to fetch the time remaining
    to timer expiry via the `timer_gettime(2`) system call API; its signature is as
    follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以随时查询给定的POSIX定时器，以获取剩余时间到定时器到期的时间，使用`timer_gettime(2)`系统调用API；其签名如下：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Quite obviously, the first parameter passed to `timer_gettime(2)` is the ID
    of the particular timer to query, and the second parameter passed is the value
    result-style return—the time to expiry is returned in it (within the structure
    of type `itimerspec`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，传递给`timer_gettime(2)`的第一个参数是要查询的特定定时器的ID，传递的第二个参数是值结果样式返回——到期时间以它返回（在`itimerspec`类型的结构中）。
- en: As we know from preceding, the struct `itimerval` itself consists of two data
    structures of type `timespec`; the time remaining to timer expiry will be placed
    in the `curr_value->it_value` member. If this value is 0, it implies that the
    timer has been stopped (disarmed). If the value placed in the
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面所知道的，`struct itimerval`本身由两个`timespec`类型的数据结构组成；剩余时间到定时器到期将被放置在`curr_value->it_value`成员中。如果这个值为0，则意味着定时器已经停止（解除武装）。如果放置在
- en: '`curr_value->it_interval` member is positive, it indicates the interval at
    which the timer will repeatedly fire (after the first timeout); if 0, it implies
    the timer is a single-shot one (with no repeating timeouts).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`curr_value->it_interval`成员为正值时，表示定时器将重复触发的间隔（在第一次超时后）；如果为0，则意味着定时器是单次触发的（没有重复超时）。'
- en: Example code snippet showing the workflow
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码片段显示工作流程
- en: In the following, we display code snippets from our sample program `ch13/react.c`
    (see more on this rather interesting reaction time game app in the following section),
    which clearly illustrates the sequence of steps previously described.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们展示了来自我们的样本程序`ch13/react.c`的代码片段（在下一节中更多地了解这个相当有趣的反应时间游戏应用程序），它清楚地说明了先前描述的步骤序列。
- en: 'Signal(s) set up:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置信号：
- en: 'Assuming the notification mechanism being used is a signal, first trap the
    signal(s)  via `sigaction(2)` as follows:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设正在使用的通知机制是信号，首先通过`sigaction(2)`捕获信号如下：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create and initialize the timer(s):'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和初始化定时器：
- en: 'Decide on the clock type (or source) to use to measure the elapsed time:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用的时钟类型（或来源）来测量经过的时间：
- en: We use the real-time clock `CLOCK_REALTIME` the system-wide wall clock time,
    as our timer source.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用实时时钟`CLOCK_REALTIME`作为我们的定时器来源，系统范围的挂钟时间。
- en: Decide on the timer-expiry event-notification mechanism to be used by your application—typically,
    whether to use (the usual) signals or a (newly spawned) thread.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定应用程序使用的定时器到期事件通知机制——通常是使用（通常的）信号还是（新生成的）线程。
- en: We use signaling as the timer-expiry event-notification mechanism.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用信号作为定时器到期事件通知机制。
- en: 'The aforementioned decisions are implemented via the`timer_create(2)` system
    call, which allows one to create a timer; of course, we can create multiple timers
    by invoking it multiple times:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述决定是通过`timer_create(2)`系统调用实现的，它允许创建一个定时器；当然，我们可以多次调用它来创建多个定时器：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Arm (or disarm) a particular timer using the `timer_settime(2)` API. To arm
    a timer means to effectively start it running, or counting down; disarming a timer
    is the opposite—stopping it in its tracks:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_settime(2)`API来启动（或解除武装）特定的定时器。启动定时器意味着有效地开始计时或倒计时；解除武装定时器则相反——停止它的运行：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To query the time remaining (to expiration) in a particular timer (and its interval
    setting), use `timer_gettime(2)`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查询特定定时器的剩余时间（到期时间）和其间隔设置，请使用`timer_gettime(2)`
- en: This is not performed in this particular application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这个特定的应用程序中没有执行。
- en: Check the overrun count of a given timer using `timer_getoverrun(2)`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_getoverrun(2)`检查给定定时器的超时计数
- en: An explanation of what this API does, and why we might need it, is provided
    in the following section, *Figuring the overrun*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节“计算超时”中提供了此API的解释以及我们可能需要它的原因。
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Delete (and obviously disarm) a timer using `timer_delete(2)`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`timer_delete(2)`删除（显然解除武装）一个定时器
- en: This is not performed in this particular application (as the process exit will,
    of course, delete all timers associated with the process.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是这个特定应用程序中执行的（因为进程退出当然会删除与进程相关的所有定时器）。
- en: 'As the man page on `timer_create(2)` informs us, a few more points to note
    on POSIX (interval) timers are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`timer_create(2)`的man手册所告诉我们的，关于POSIX（间隔）定时器的一些要点如下：
- en: Upon `fork(2)`, all timers get auto-disarmed; in other words, timers are not
    going to continue towards expiry in the child process.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`fork(2)`之后，所有定时器都会自动解除武装；换句话说，定时器不会在子进程中继续到期。
- en: Upon `execve(2)`, all timers are deleted and will thus not be visible in the
    successor process.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`execve(2)`之后，所有定时器都被删除，因此在后继进程中将不可见。
- en: Something useful of note is that (from the Linux 3.10 kernel onward) the proc filesystem
    can be used to query the timer(s) a process owns; just lookup cat the pseudo-`file /proc/<pid>/timers` to
    see them (if they exist).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的一点是（从Linux 3.10内核开始），proc文件系统可以用来查询进程拥有的定时器；只需查找cat伪文件/proc/<pid>/timers以查看它们（如果存在）。
- en: From the Linux 4.10 kernel onward, POSIX timers are a kernel-configurable option
    (at kernel build time, they are enabled by default).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Linux 4.10内核开始，POSIX定时器是一个内核可配置的选项（在内核构建时，默认情况下启用）。
- en: As we have repeatedly mentioned, the man pages are a very precious and useful
    resource that is available to developers; again, the man page on `timer_create(2)` ([https://linux.die.net/man/2/timer_create](https://linux.die.net/man/2/timer_create))
    provides a nice example program; we urge the reader to refer to the man page,
    read it, build it and try the program out.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们反复提到的，man手册是开发人员可用的非常宝贵和有用的资源；再次，`timer_create(2)`的man手册提供了一个很好的示例程序；我们敦促读者参考man手册，阅读它，构建它并尝试运行程序。
- en: Figuring the overrun
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算超限
- en: Let's say we use signaling as the event-notification mechanism to tell us that
    a POSIX timer has expired, and let's say that the timer-expiry period is a very
    small amount of time (say, a few tens of microseconds); for example, 100 microseconds.
    This implies that every 100 microseconds the signal will be delivered to the target
    process!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用信号作为事件通知机制来告诉我们POSIX定时器已经到期，并且假设定时器到期时间非常短（比如几十微秒）；例如，100微秒。这意味着每100微秒信号将被传递给目标进程！
- en: In these circumstances, it's quite reasonable to expect that the process, being
    delivered the same ever-repeating signal at such a high rate, cannot possibly
    handle it. We also know from our knowledge on signaling that, in cases precisely
    like this, using a real-time signal would be far superior to using a regular Unix
    signal, as the OS has the ability to queue real-time signals but not regular signals—they
    (regular signals) will be dropped and only a single instance preserved.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以合理地期望进程以如此高的速率接收相同的重复信号，不可能处理它。我们也知道，从我们对信号的了解来看，在类似这样的情况下，使用实时信号要远远优于使用常规Unix信号，因为操作系统有能力排队实时信号，但不能排队常规信号——它们（常规信号）将被丢弃，只保留一个实例。
- en: 'So, we shall use a real-time signal (say, `SIGRTMIN`) to denote timer expiry;
    however, with a really tiny timer expiry (for example, as we said, 100 microseconds),
    even this technique will not suffice! The process will certainly be overrun by
    the rapid delivery of the same signal. For precisely these situations, one can
    retrieve the actual number of overruns that occurred between the timer expiry
    and the actual signal processing. How do we do this? There are two ways:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用实时信号（比如`SIGRTMIN`）来表示定时器到期；然而，即使使用一个非常小的定时器到期时间（例如，正如我们所说的100微秒），这种技术也不足以满足需求！进程肯定会被相同信号的快速传递所淹没。对于这些情况，我们可以获取定时器到期和实际信号处理之间发生的实际超限次数。我们该如何做到这一点？有两种方法：
- en: One is via the signal handler's `siginfo_t->_timer->si_overrun`  member (implying
    we specified the `SA_SIGINFO` flag when trapping the signal with sigaction)—this
    is the overrun count.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种是通过信号处理程序的`siginfo_t->_timer->si_overrun`成员（这意味着我们在使用sigaction捕获信号时指定了`SA_SIGINFO`标志）——这是超限计数。
- en: However, this method is Linux-specific (and non-portable). A simpler, portable
    method of obtaining the overrun count is by using the `timer_getoverrun(2)` system
    call. The downside here being that system calls have far more overhead than a
    memory lookup; as in life, when there's an upside, there's also a downside.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这种方法是特定于Linux的（不可移植）。获得超限计数的更简单、可移植的方法是使用`timer_getoverrun(2)`系统调用。这里的缺点是系统调用比内存查找的开销要大得多；就像生活中一样，有利的一面就有不利的一面。
- en: POSIX interval timers – example programs
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX间隔定时器-示例程序
- en: Programming is ultimately learned and understanding is deeply internalized by
    doing, not simply seeing or reading. Let's take our own advice and cut a couple
    of decent code examples, to illustrate using the POSIX (interval) timer APIs.
    (Of course, dear reader, it implies you do the same!)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 编程最终是通过实践来学习和理解的，而不仅仅是看或阅读。让我们听从自己的建议，编写一些体面的代码示例，以说明如何使用POSIX（间隔）定时器API。 （当然，亲爱的读者，这意味着你也要这样做！）
- en: The first sample program is a small CLI game of "how quickly can you react"?
    The second sample program is a simple implementation of a run-walk timer. Read
    on for the gory details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例程序是一个小型CLI游戏“你的反应有多快”？第二个示例程序是一个简单的跑步计时器的实现。继续阅读了解更多细节。
- en: The reaction – time game
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应-时间游戏
- en: We all understand that modern computers are fast! Of course, that's a very relative
    statement. How fast, exactly? That's an interesting question.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道现代计算机很快！当然，这是一个非常相对的说法。有多快？这是一个有趣的问题。
- en: How fast is fast?
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有多快？
- en: 'In [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*,
    in the section on the memory pyramid, we saw *Table 2: Memory Hierarchy Numbers.* Here,
    a representative look at the numbers was done—the typical access speeds for different
    kinds of memory technologies (for both the embedded and server space) are enumerated
    in the table.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中，*虚拟内存*，在内存金字塔部分，我们看到了*表2：内存层次结构数字*。这里，对数字进行了代表性的查看-不同类型的内存技术（嵌入式和服务器空间）的典型访问速度在表中列举。
- en: 'A quick recap gives us the following in terms of typical memory (and network)
    access speeds. Of course, these numbers are only indicative, and the very latest
    hardware might well have superior performance characteristics; here, the concept
    is what''s being focused upon:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾给出了典型内存（和网络）访问速度的以下内容。当然，这些数字仅供参考，最新的硬件可能具有更优越的性能特征；这里，重点是概念：
- en: '| **CPU registers** | **CPU caches** | **RAM** | **Flash** | **Disk** | **Network
    roundtrip** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **CPU寄存器** | **CPU缓存** | **RAM** | **Flash** | **磁盘** | **网络往返** |'
- en: '| 300 - 500 ps | 0.5 ns (L1) to 20 ns (L3) | 50–100 ns | 25–50 us | 5–10 ms
    | >= 100s of ms |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 300 - 500 ps | 0.5 ns（L1）至20 ns（L3）| 50-100 ns | 25-50 us | 5-10 ms | >=
    100s of ms |'
- en: 'Table 3 : Hardware memory speed summary table'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：硬件内存速度摘要表
- en: Most of these latency values are so tiny that we, as humans, cannot actually
    visualize them (see the information box on *average human reaction times* further
    on). So, that brings up the question. What minimally tiny numbers can we humans
    even hope to quite correctly visualize and relate to? The short answer is a few
    hundred milliseconds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些延迟值大多是如此微小，以至于我们作为人类实际上无法将它们可视化（请参阅稍后的*平均人类反应时间*信息框）。所以，这带来了一个问题。我们人类究竟能够希望相当正确地可视化和理解哪些微小的数字？简短的答案是几百毫秒。
- en: 'Why do we make such a statement? Well, if a computer program told you to react
    quick as you can and press a certain keyboard key combination immediately upon
    seeing a message, how long would it take? So, what we''re really attempting to
    test here is the human reaction time to a visual stimulus. Ah, that''s what we
    can empirically answer by writing this precise program: a reaction timer!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样说？嗯，如果一个计算机程序告诉你尽快做出反应并立即按下某个键盘组合键，需要多长时间？所以，我们真正想要测试的是人对视觉刺激的反应时间。啊，通过编写这个精确的程序，我们可以通过实验证明这一点：一个反应计时器！
- en: Do note that this simple visual stimulus reaction test is not considered to
    be scientific; we completely ignore important delay-inducing mechanisms such as
    the computer-system hardware and software itself. So don't beat yourself up on
    the results you get when you try it out!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个简单的视觉刺激反应测试并不被认为是科学的；我们完全忽略了重要的延迟产生机制，比如计算机系统硬件和软件本身。所以，当你尝试时，不要对结果感到沮丧！
- en: Our react game – how it works
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的反应游戏-它是如何工作的
- en: 'So, at a high level, here''s the step-by-step plan for the program (the actual
    code is shown in the following section; we suggest you first read this and then
    check out the code):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在高层次上，这是程序的逐步计划（实际代码显示在下一节；我们建议您先阅读此内容，然后再查看代码）：
- en: Create and initialize a simple alarm; program it to expire at a random time—anywhere
    between 1 and 5 seconds from the program's start
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并初始化一个简单的警报；将其设置为在程序启动后的1到5秒之间的任意时间过期
- en: 'The moment the alarm expires, do the following:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报过期的时刻，执行以下操作：
- en: Arm a POSIX (interval) timer (to the frequency specified in the first parameter).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置POSIX（间隔）计时器（到第一个参数指定的频率）。
- en: Display a message requesting the user to press *Ctrl *+ *C* on the keyboard
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一条消息，要求用户在键盘上按下*Ctrl *+ *C*。
- en: Take a timestamp (let's call it `tm_start`).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取时间戳（我们称之为`tm_start`）。
- en: When the user actually presses *^C* (*Ctrl *+ *C*; which we will know, simply,
    by trapping SIGINT via `sigaction(2)`), again, take a timestamp (let's call it `tm_end`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户实际按下*^C*（*Ctrl *+ *C*；我们将通过`sigaction(2)`捕获到），再次获取时间戳（我们称之为`tm_end`）。
- en: Calculate the user's reaction time (as `tm_end` - `tm_start`) and display it.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算用户的反应时间（作为`tm_end` - `tm_start`）并显示它。
- en: (Notice how the previous steps follow the *Typical application workflow* we
    described earlier in this chapter.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: （注意前面的步骤遵循我们在本章前面描述的*典型应用程序工作流程*。）
- en: Additionally, we ask the user to specify the interval timer's interval in milliseconds
    (the first parameter), and an optional verbose option as the second parameter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们要求用户指定间隔计时器的间隔时间（第一个参数），以及作为第二个参数的可选详细选项。
- en: 'Breaking it down further (in more detail), the initialization code performs
    the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分解（更详细地），初始化代码执行以下操作：
- en: 'Traps signals via `sigaction(2)`:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`sigaction(2)`捕获信号：
- en: '`SIGRTMIN`: We shall use signal notification to specify the timer expiration;
    this is the signal generated upon our POSIX interval timer''s expiry.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGRTMIN`：我们将使用信号通知来指定计时器到期；这是在我们的POSIX间隔计时器到期时生成的信号。'
- en: '`SIGINT`: The signal generated when the user reacts by pressing the *^C* keyboard
    key combination.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT`：用户按下*^C*键盘组合时生成的信号。'
- en: '`SIGALRM`: The signal generated when our initial random alarm expires'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGALRM`：我们的初始随机警报过期时生成的信号'
- en: 'Set up the POSIX interval timer:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置POSIX间隔计时器：
- en: Initialize the `sigevent` structure.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`sigevent`结构。
- en: Create the timer (with a real-time clock source) with `timer_create(2)`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计时器（使用实时时钟源）并用`timer_create(2)`。
- en: Initialize the `itimerspec` structure to the frequency value specified by the
    user (in ms)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`itimerspec`结构初始化为用户指定的频率值（以毫秒为单位）
- en: 'Then:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: 'Displays a message to the user:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示消息：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At any random time between 1 and 5 seconds the alarm expires
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在1到5秒之间的任意时间，警报会过期
- en: We enter the `SIGALRM` handler function
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进入`SIGALRM`处理程序函数
- en: It displays the `*** QUICK! Press ^C !!! *** `message
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示`*** 快！按^C键！***`消息
- en: It calls `timer_settime(2)` to arm the timer
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`timer_settime(2)`来设置计时器
- en: It takes the `tm_start` timestamp (with the `clock_gettime(2)` API)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取`tm_start`时间戳（使用`clock_gettime(2)`API）
- en: The POSIX interval timer now runs; it expires every `freq_ms` milliseconds (the
    value provided by the user); when running in verbose mode, we display a `**.**` for
    each timer expiry
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在POSIX间隔计时器正在运行；它每`freq_ms`毫秒到期一次（由用户提供的值）；在详细模式下运行时，我们为每个计时器到期显示一个`**.**`。
- en: 'The user, at some point, near or far, reacts and presses* Ctrl *+ *C*(*^C*);
    in the code for the signal handler for SIGINT, we do the following:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在某个时候，近或远，做出反应并按下*Ctrl*+*C*（^C）；在SIGINT的信号处理程序代码中，我们执行以下操作：
- en: Take the `tm_end` timestamp (with the `clock_gettime(2)` API)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取`tm_end`时间戳（使用`clock_gettime(2)`API）
- en: Calculate the delta (the reaction time!) via `tm_end` - `tm_start`, and display
    it
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`tm_end` - `tm_start`计算增量（反应时间！），并显示它
- en: Exit.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出。
- en: React – trial runs
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应 - 试验运行
- en: 'It is best to see the program in action; of course, the reader would do well
    (and enjoy this exercise a whole lot more!) to actually build and try it out for
    himself/herself:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是看到程序在运行中的情况；当然，读者最好（并且会更享受这个练习！）亲自构建并尝试一下：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We first run it with a 10 millisecond frequency and without verbosity:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以10毫秒的频率运行它，而且不显示详细信息：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After a random interval of between 1 and 5 seconds, this message appears and
    the user must react:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在1到5秒的随机间隔之后，出现这条消息，用户必须做出反应：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, with a 10 millisecond frequency and verbose mode on:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以10毫秒的频率和详细模式：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After a random interval of between 1 and 5 seconds, this message appears and
    the user must react:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在1到5秒的随机间隔之后，出现这条消息，用户必须做出反应：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the period character,`.`,appears rapidly, appearing once for every single
    expiry of our POSIX interval timer; that is, once every 10 ms in this run.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次POSIX间隔计时器到期时，句号字符`.`会迅速出现，也就是说，在这次运行中，每10毫秒出现一次。
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our previous sample runs, the user took 405 ms and 379 ms to react; as we
    mentioned, it's in the hundreds of milliseconds range. Take the challenge—how
    much better can you do?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的样本运行中，用户反应需要405毫秒和379毫秒；正如我们提到的，它在数百毫秒的范围内。接受挑战——你能做得更好吗？
- en: 'Research findings indicate the following numbers for average human reaction
    times:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 研究结果表明，人类平均反应时间如下：
- en: '| **Stimulus** | **Visual** | **Auditory** | **Touch** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **刺激** | **视觉** | **听觉** | **触觉** |'
- en: '| Average human reaction time | 250 ms | 170 ms | 150 ms |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 平均人类反应时间 | 250毫秒 | 170毫秒 | 150毫秒 |'
- en: Source: [https://backyardbrains.com/experiments/reactiontime](https://backyardbrains.com/experiments/reactiontime).We
    have become used to using phrases such as "in the blink of an eye" to mean really
    quickly. Interestingly, how long does it actually take to blink an eye? Research
    indicates that it takes an average of 300 to 400 ms!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://backyardbrains.com/experiments/reactiontime](https://backyardbrains.com/experiments/reactiontime)。我们已经习惯于使用短语，比如“眨眼之间”来表示非常快。有趣的是，眨眼实际上需要多长时间？研究表明，平均需要300到400毫秒！
- en: The react game – code view
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应游戏 - 代码视图
- en: 'Some key functionality aspects are shown as follows; first is the code that
    sets up the signal handler for `SIGRTMIN` and creates the POSIX interval (`ch13/react.c`):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键功能方面如下所示；首先是为`SIGRTMIN`设置信号处理程序并创建POSIX间隔的代码（`ch13/react.c`）：
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub, here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，以下仅显示源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆，链接在这里：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The surprise start is implemented as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 意外开始的实现如下：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s invoked as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它的调用如下：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The signal handler (the function `startoff`) and associated logic for the alarm
    (for `SIGALRM`) is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序（函数`startoff`）和与闹钟（`SIGALRM`）相关的逻辑如下：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Remember, while the user is lolling around, our POSIX interval timer continues
    to set and reset itself at the frequency specified by the user (as the first parameter
    passed, which we save in the variable `freq_ms`); so, every `freq_ms` milliseconds,
    our process will receive the signal `SIGRTMIN`. Here''s its signal handler routine:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当用户在四处游荡时，我们的POSIX间隔计时器会继续以用户指定的频率设置和重置自身（作为传递的第一个参数，我们将其保存在变量`freq_ms`中）；因此，每`freq_ms`毫秒，我们的进程将接收到信号`SIGRTMIN`。这是它的信号处理程序例程：
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the user does (finally!) press *^C,* the signal handler for SIGINT (the
    function `userpress`) is invoked:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户（最终！）按下*^C*时，将调用SIGINT的信号处理程序（函数`userpress`）：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The run:walk interval timer application
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行：步行间隔计时器应用程序
- en: This book's author is a self-confessed recreational runner. In my humble opinion,
    runners/joggers, especially when starting out (and frequently, even experienced
    ones), can benefit from a consistently followed run:walk pattern (the unit is
    minutes, typically).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的作者是一个自称业余跑步者。在我看来，跑步者/慢跑者，尤其是刚开始时（甚至经验丰富的人），可以从一致的跑步：步行模式中受益（单位通常是分钟）。
- en: The idea behind this is that running continuously is hard, especially for beginners.
    Often, coaches have the newbie runner follow a useful run:walk strategy; run for
    some given amount of time, then take a walk break for a given time period, then repeat—run
    again, walk again—indefinitely, or until your target distance (or time) goal is
    met.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的想法是，持续奔跑很难，尤其是对初学者来说。教练经常让新手跑步者遵循有用的跑步：步行策略；跑一段时间，然后休息一段时间，然后重复——再跑，再走——无限期地，或者直到达到目标距离（或时间）。
- en: For example, when a beginner runs distances of, say, 5 km or 10 km, (s)he might
    follow a consistent 5:2 run:walk pattern; that is, run for 5 minutes, walk for
    2 minutes, keep repeating this, until the run is done. (Ultra-runners, on the
    other hand, might prefer something akin to a 25:5 strategy.)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当初学者跑5公里或10公里时，可能会遵循一致的5:2跑步：步行模式；也就是说，跑步5分钟，步行2分钟，重复这个过程，直到跑步结束。（而超级长跑者可能更喜欢类似25:5的策略。）
- en: Why not write a run:walk timer application to help out both our budding and
    serious runners.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不编写一个跑步：步行计时器应用程序，以帮助我们的初学者和认真的跑步者。
- en: We shall do just that. First, though, from the viewpoint of understanding this
    program better, let's imagine the program is written and working—we shall give
    it a spin.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这样做。不过，从更好地理解这个程序的角度来看，让我们想象一下程序已经编写并且正在运行——我们将试一试。
- en: A few trial runs
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几次试运行
- en: 'When we simply run the program without passing any parameters, the help screen
    is displayed:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们简单地运行程序而不传递任何参数时，帮助屏幕会显示出来：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As can be seen, the program expects a minimum of two parameters:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，程序期望至少有两个参数：
- en: The time to run (in seconds) [required]
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跑步时间（以秒为单位）[必需]
- en: The time to walk (in seconds) [required]
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步行时间（以秒为单位）[必需]
- en: The verbosity level [optional]
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗长级别[可选]
- en: 'The optional third parameter, the verbosity level, allows the user to request
    more or less information as the program executes (always a useful way to instrument,
    and thus help debug, programs). We provide three possible verbosity levels:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第三个参数，冗长级别，允许用户在程序执行时请求更多或更少的信息（这总是一种有用的工具，因此有助于调试程序）。我们提供了三种可能的冗长级别：
- en: '`OFF`: Nothing besides the required matter is displayed (pass the third parameter
    0)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFF`：除了必需的内容之外，不显示任何内容（传递第三个参数0）'
- en: '`LOW`: The same as for level OFF, plus we use the period character `**.**` to
    show the elapse of time—every second, a `**.** `is printed to `stdout` [default]'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOW`：与关闭级别相同，另外我们使用句点字符`**.**`来显示时间流逝——每秒钟，`**.**`都会打印到`stdout`[默认]'
- en: '`HIGH`: The same as for level OFF, plus we show the internal data structure
    values, time to timer expiry, and so on (pass the third parameter 2)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIGH`：与关闭级别相同，另外我们显示内部数据结构值、计时器到期时间等（传递第三个参数2）'
- en: 'Let''s first try running at the default verbosity level (LOW), with the following
    spec:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试以默认的冗长级别（LOW）运行，使用以下规范：
- en: Run for 5 seconds
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行5秒
- en: Walk for 2 seconds
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步行2秒
- en: 'Okay, okay, we know, you''re fitter than that—you can run:walk for longer than
    5s:2s. Forgive us, but here''s the thing: for the purpose of the demo, we do not
    really want to wait until 5 minutes and then another 2 minutes have elapsed, just
    to see if it works, right? (When you''re using this app on your run, then please
    convert minutes to seconds and go for it!).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好吧，我们知道，你比那更健康——你可以跑步：步行超过5秒：2秒。原谅我们，但是这样的事情：为了演示的目的，我们并不真的想等到5分钟然后再过2分钟，只是为了看看它是否有效，对吧？（当您在跑步时使用这个应用程序时，请将分钟转换为秒并尝试！）。
- en: 'Enough said; let''s fire up the run:walk POSIX timer for a 5:2 run:walk interval:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说；让我们启动一个5:2的跑步：步行POSIX计时器：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Yes, it works; we break it off by typing *^C* (*Ctrl *+ *C)*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效；我们通过输入*^C*（*Ctrl*+*C*）来中断它。
- en: 'The preceding trial run was at the default verbosity level of `LOW`; now let''s
    rerun it with the same 5:2 run:walk interval, but with the verbosity level set
    to `HIGH` by passing `2` as the third parameter:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的试运行是在默认的冗长级别`LOW`；现在让我们以相同的5:2跑步：步行间隔重新运行它，但是将冗长级别设置为`HIGH`，通过传递`2`作为第三个参数：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The details are revealed; every second, the time remaining on our POSIX timer's
    expiry is shown (to the resolution of a millisecond). When the timer does expire,
    the OS delivers the real-time signal `SIGRTMIN` to the process; we enter the signal
    handler `its_time`, then we print out the signal information obtained from the struct
    `siginfo_t` pointer. We receive the signal number (34) and the pointer within
    the union `si->si_value`, which is the pointer to our application context data
    structure, so that we can access it without the use of globals (more on this later). (Of
    course, as noted several times, it's unsafe to use `printf(3)` and variants in
    a signal handler as they are signal-async-unsafe. We have done it here just as
    a demo; do not code like this for production use. A `Bzzzz!!!` message represents
    the buzz of the timer going off, of course; the program instructs the user to
    proceed with `RUN!` or `WALK!`, accordingly, and the number of seconds to do it
    for. The whole process repeats indefinitely.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 细节被揭示；每秒钟，我们的POSIX计时器到期的剩余时间被显示出来（以毫秒为分辨率）。当计时器到期时，操作系统向进程发送实时信号`SIGRTMIN`；我们进入信号处理程序`its_time`，然后我们打印出从`struct`
    `siginfo_t`指针获得的信号信息。我们接收到信号号码（34）和联合体`si->si_value`中的指针，这是指向我们的应用程序上下文数据结构的指针，因此我们可以在没有使用全局变量的情况下访问它（稍后会详细介绍）。（当然，正如多次注意到的那样，在信号处理程序中使用`printf(3)`和变体是不安全的。我们在这里只是为了演示；不要在生产中这样编码。`Bzzzz!!!`消息代表计时器响起的声音，当然；程序指示用户相应地进行`RUN!`或`WALK!`，以及进行的秒数。整个过程无限重复。
- en: The low – level design and code
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级设计和代码
- en: This simple program will allow you to set up the number of seconds to run and
    to walk. It will time out accordingly.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序将允许您设置跑步和步行的秒数。它将相应地计时。
- en: In this application, we use a simple one-shot POSIX timer to do the job. We
    set the timer to use signal notification as the timer expiry notification mechanism.
    We set up a signal handler for a RT signal (SIGRTMIN). Next, we initially set
    the POSIX timer to expire after the run period, then, when the signal does arrive
    in the signal handler, we reset (re-arm) the timer to expire after the walk period
    seconds. This essentially repeats forever, or until the user aborts the program
    by pressing *^C*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用一个简单的一次性POSIX计时器来完成工作。我们设置计时器使用信号通知作为计时器到期通知机制。我们为RT信号（SIGRTMIN）设置了一个信号处理程序。接下来，我们最初将POSIX计时器设置为在跑步期间到期，然后当信号在信号处理程序中到达时，我们重新设置（重新装载）计时器，使其在步行期间秒后到期。这基本上是无限重复的，或者直到用户通过按*^C*中止程序。
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub, here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，以下仅显示源代码的关键部分；要查看完整的源代码，构建并运行它，整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'Many real-world applications (indeed, any software) often requires several
    pieces of information—the state or application context—to be available to all
    functions at any given point in time; in other words, to be global. Ordinarily,
    one would just declare them as global (static) variables and proceed. We have
    a suggestion: why not encapsulate all of them into a single data structure? In
    fact, why not make it our own by typedef-ing a structure. Then we can allocate
    memory to it, initialize it, and just pass around its pointer in a manner that
    does not require it to be global. That would be efficient and elegant.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的应用程序（实际上，任何软件）通常需要几个信息片段 - 在任何给定时间点都可用于所有函数 - 即全局可用。通常，可以将它们声明为全局（静态）变量并继续。我们有一个建议：为什么不将它们全部封装到一个单一的数据结构中？事实上，为什么不通过typedef一个结构来使其成为我们自己的？然后我们可以为其分配内存，初始化它，并以一种不需要它成为全局的方式传递其指针。那将是高效而优雅的。
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our app, to keep things simple, we just statically allocate memory to (further,
    notice that it''s a local variable, not global):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，为了保持简单，我们只是静态分配内存给（此外，请注意它是一个局部变量，而不是全局变量）：
- en: '[PRE46]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The initialization work is carried out here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化工作在这里进行：
- en: '[PRE47]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, we do the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们执行以下操作：
- en: Trap the real-time signal (`SIGRTMIN`) (delivered upon timer expiry).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获实时信号（`SIGRTMIN`）（在定时器到期时传递）。
- en: 'Initialize our app context run:walk data structure:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化我们的应用上下文运行：步行数据结构：
- en: In particular, we set the type to run and the timeout value (seconds) to the
    time passed by the user in the first parameter.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是，将类型设置为运行，并将超时值（秒）设置为用户传递的第一个参数中的时间。
- en: The timer-expiry event-notification mechanism is selected as signaling via the `sigev_notify` member
    of our `sigevent` structure.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器到期事件通知机制被选择为通过`sigevent`结构的`sigev_notify`成员进行信号传递。
- en: It is useful to set the data passed along via the `sigev_value.sival_ptr` member
    as the pointer to our app context; this way, we can always gain access to it within
    the signal handler (eliminating the need to keep it global).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`sigev_value.sival_ptr`成员将传递的数据设置为指向我们应用上下文的指针是有用的；这样，我们可以在信号处理程序中始终访问它（消除了保持全局的需要）。
- en: Create the POSIX timer with the real-time clock source, and set it's ID to the `timerid` member
    of our app context runwalk structure
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实时时钟源创建POSIX定时器，并将其ID设置为我们应用上下文运行步行结构的`timerid`成员
- en: Arm—or start—the timer. (Recall, it's been initialized to expire in run seconds.)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装载 - 或启动 - 定时器。（回想一下，它已经初始化为在运行秒后到期。）
- en: 'In our preceding trial run, the run is set for 5 seconds, so, 5 seconds from
    the start, we shall asynchronously enter the signal handler for `SIGRTMIN`, `its_time`,
    as shown here:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的试运行中，运行设置为5秒，因此，从开始的5秒开始，我们将异步进入`SIGRTMIN`的信号处理程序`its_time`，如下所示：
- en: '[PRE48]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the signal handling code, we do the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号处理代码中，我们执行以下操作：
- en: (As mentioned previously) gain access to our app context data structure (by
    typecasting the `si->si_value.sival_ptr` to our (`sRunWalk *`) data type).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如前所述）访问我们的应用上下文数据结构（通过将`si->si_value.sival_ptr`强制转换为我们的（`sRunWalk *`）数据类型）。
- en: In HIGH verbose mode, we display more details (again, do not use `printf(3)`
    in production).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高度冗长的模式下，我们显示更多细节（再次，不要在生产中使用`printf(3)`）。
- en: 'Then, if the just-expired timer was the `RUN` one, we call our buzzer function `BUZZ `with
    the `WALK` message parameter, and, importantly:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果刚刚到期的定时器是`RUN`，我们调用我们的蜂鸣器函数`BUZZ`并传递`WALK`消息参数，而且，重要的是：
- en: Re-initialize the timeout value (seconds) to the duration for WALK (the second
    parameter passed by the user).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新初始化超时值（秒）为用户传递的第二个参数的持续时间。
- en: Toggle the type from RUN to WALK.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型从运行切换到步行。
- en: Re-arm the timer via the `timer_settime(2)` API.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`timer_settime(2)`API重新装载定时器。
- en: And vice versa when transiting from the just-expired WALK to RUN mode.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从刚刚到期的步行模式转换到运行模式时也是如此。
- en: This way, the process runs forever (or until the user terminates it via *^C*),
    continually timing out for the next run:walk interval.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，进程将永远运行（或直到用户通过*^C*终止它），不断地在下一个运行：步行间隔超时。
- en: Timer lookup via proc
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过proc查找定时器
- en: 'One more thing: interestingly, the Linux kernel allows us to peek deep inside
    the OS; this is (typically) achieved via the powerful Linux proc filesystem. In
    our current context, proc allows us to look up all the timers that a given process
    has. How is this done? By reading the pseudo-file `/proc/<PID>/timers`. Check
    it out. The screenshot below illustrates this being performed on the `runwalk_timer `process:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：有趣的是，Linux内核允许我们深入了解操作系统；这通常是通过强大的Linux proc文件系统实现的。在我们当前的上下文中，proc允许我们查找给定进程的所有定时器。这是如何做到的？通过读取伪文件`/proc/<PID>/timers`。看一看。下面的屏幕截图说明了这是如何在`runwalk_timer`进程上执行的。
- en: '![](img/ad7905d9-56a1-4f12-92c2-e77102b33333.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad7905d9-56a1-4f12-92c2-e77102b33333.png)'
- en: 'The terminal window on the left is where the `runwalk_timer` application runs;
    while it''s running, in the terminal window on the right, we lookup the proc filesystem''s
    pseudo-file `/proc/<PID>/timers`. The output clearly reveals the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的终端窗口是`runwalk_timer`应用程序运行的地方；当它正在运行时，在右侧的终端窗口中，我们查找proc文件系统的伪文件`/proc/<PID>/timers`。输出清楚地显示了以下内容：
- en: There's just one (POSIX) timer within the process (ID `0`).
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程中只有一个（POSIX）定时器（ID为`0`）。
- en: 'The timer-expiry event-notification mechanism is signaling, because we can
    see that `notify:signal/pid.<PID>` and signal: 34 are associated with this timer
    (signal: 34 is `SIGRTMIN`; use `kill -l` 34 to verify this).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '定时器到期事件通知机制是*信号*，因为我们可以看到`notify:signal/pid.<PID>`和signal: 34与该定时器相关联（signal:
    34是`SIGRTMIN`；使用`kill -l 34`来验证）。'
- en: The clock source associated with this timer is `ClockID 0`; that is, the real-time
    clock.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此定时器相关的时钟源是 `ClockID 0`；也就是实时时钟。
- en: A quick mention
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速提及
- en: 'To round off this chapter, we present a quick look at two interesting technologies:
    timers via the file abstraction model and watchdog timers. These sections are
    not covered in detail; we leave it to the interested reader to dig further.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们简要介绍了两种有趣的技术：通过文件抽象模型和看门狗定时器。这些部分没有详细介绍；我们留给感兴趣的读者进一步了解。
- en: Timers via file descriptors
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文件描述符使用定时器
- en: Do you recall a key philosophy of the Unix (and, thus, Linux) design that we
    covered in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System
    Architecture*, of this book? That is, everything is a process; if it's not a process,
    it's a file. The file abstraction is heavily used on Linux; here, too, with timers, we
    find that there is a way to represent and use timers via the file abstraction.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否还记得我们在本书的[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中介绍的Unix（因此也是Linux）设计的一个关键理念？也就是说，一切都是一个进程；如果不是进程，就是一个文件。文件抽象在Linux上被广泛使用；在这里，我们也发现可以通过文件抽象来表示和使用定时器。
- en: How is this done? The `timerfd_*` APIs provide the required abstraction. In
    this book, we shall not attempt to delve into the intricate details; rather, we
    would like the reader to become aware that one can use the file abstraction—reading
    a timer via the read(2) system call—if required.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何实现的？`timerfd_*` API提供了所需的抽象。在本书中，我们不打算深入研究复杂的细节；相反，我们希望读者意识到，如果需要，可以使用文件抽象—通过`read(2)`系统调用读取定时器。
- en: 'The following table quickly outlines the `timerfd_*` API set:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格快速概述了`timerfd_*` API集：
- en: '| **API** | **Purpose** | **Equivalent to the POSIX timer API** |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **目的** | **等同于POSIX定时器API** |'
- en: '| `timerfd_create(2)` | Create a POSIX timer; the return value on success is
    the file descriptor associated with this timer. | `timer_create(2)` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `timerfd_create(2)` | 创建一个POSIX定时器；成功时返回值是与该定时器关联的文件描述符。 | `timer_create(2)`
    |'
- en: '| `timerfd_settime(2)` | (Dis)arm a timer referred to by the first parameter `fd`.
    | `timer_settime(2)` |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `timerfd_settime(2)` | (解)装备由第一个参数`fd`引用的定时器。 | `timer_settime(2)` |'
- en: '| `timerfd_gettime(2)` | On successful completion, returns both the time to
    expiry and interval of the timer referred to by the first parameter `fd`. | `timer_gettime(2)`
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '`timerfd_gettime(2)` 在成功完成时，返回由第一个参数 `fd` 引用的定时器的到期时间和间隔。`timer_gettime(2)`'
- en: 'Table 4 : The timerfd_* APIs'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：`timerfd_*` API
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The real advantage to using file descriptors to represent various objects is
    that one can use a uniform, powerful set of APIs to operate upon them. In this
    particular case, we can monitor our file-based  timer(s) via the `read(2)`, `poll(2)`,
    `select(2)`, `epoll(7)`, and similar APIs.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件描述符表示各种对象的真正优势在于可以使用统一、强大的一组API对它们进行操作。在这种特殊情况下，我们可以通过`read(2)`、`poll(2)`、`select(2)`、`epoll(7)`和类似的API来监视基于文件的定时器。
- en: What if the process that created the fd-based timer forks or execs? Upon a `fork(2)`,
    the child process will inherit a copy of the file descriptor pertaining to any
    timer created in the parent via  the `timerfd_create(2)` API. Effectively, it
    shares the same timer as the parent process.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了基于fd的定时器的进程进行了fork或exec怎么办？在`fork(2)`时，子进程将继承父进程通过`timerfd_create(2)`API创建的任何定时器相关的文件描述符的副本。实际上，它与父进程共享相同的定时器。
- en: Upon an `execve(2)`, the timer(s) remain valid in the successor process and
    will continue expiring upon timeout; unless, upon creation, the TFD_CLOEXEC flag
    was specified.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execve(2)`时，定时器在继承的进程中仍然有效，并且将在超时时继续到期；除非在创建时指定了`TFD_CLOEXEC`标志。
- en: More detail (along with an example) can be found in the man page here: [https://linux.die.net/man/2/timerfd_create](https://linux.die.net/man/2/timerfd_create).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息（以及示例）可以在此处的man页面中找到：[https://linux.die.net/man/2/timerfd_create](https://linux.die.net/man/2/timerfd_create)。
- en: A quick note on watchdog timers
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于看门狗定时器的简要说明
- en: A watchdog is essentially a timer-based mechanism that is used to periodically
    detect if the system is in a healthy state, and if it is deemed not to be, to
    reboot it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗本质上是一种基于定时器的机制，用于定期检测系统是否处于健康状态，如果被认为不是，就重新启动它。
- en: This is achieved by setting up a (kernel) timer (with, say, a 60-second timeout).
    If all is well, a watchdog daemon process will consistently disarm the timer before
    it expires, and subsequently re-enable (arm) it; this is known as *petting the
    dog*. If the daemon does not disarm the watchdog timer (due to something having
    gone badly wrong), the watchdog is annoyed and reboots the system.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过设置（内核）定时器（比如，60秒超时）来实现的。如果一切正常，看门狗守护进程将在定时器到期之前一直解除定时器，并随后重新启用（装备）它；这被称为*抚摸狗*。如果守护进程不解除看门狗定时器（因为某些事情出了问题），看门狗会感到恼火并重新启动系统。
- en: A daemon is a system background process; more on daemons in [Appendix B](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf),
    *Daemon Processes*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是系统后台进程；有关守护进程的更多信息，请参阅[附录B](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf)，*守护进程*。
- en: A pure software watchdog implementation will not be protected against kernel
    bugs and faults; a hardware watchdog (which latches into the board-reset circuitry)
    will always be able to reboot the system as and when required.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 纯软件看门狗实现将无法防止内核错误和故障；硬件看门狗（它连接到板复位电路）将始终能够在需要时重新启动系统。
- en: Watchdog timers are very often used in embedded systems, especially deeply embedded
    ones (or those unreachable by a human for whatever reason); in a worst-case scenario,
    it can reboot, and hopefully move along with its designated tasks again. A famous
    example of a watchdog timer causing reboots is the Pathfinder robot, NASA sent
    to the Martian surface back in 1997 (yes, the one that encountered the priority
    inversion concurrency bug while on Mars. We shall explore this a little in [Chapter
    15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading with Pthreads
    Part II - Synchronization*, on multithreading and concurrency). And, yes, that's
    the very same Pathfinder robot that is given a role in the superb movie The Martian!
    More on this in the *Further reading* section on the GitHub repository.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗定时器在嵌入式系统中经常被使用，特别是在深度嵌入式系统中（或者由于某种原因无法被人类接触到的系统）；在最坏的情况下，它可以重新启动，并希望再次执行其指定的任务。一个著名的看门狗定时器导致重启的例子是NASA在1997年发送到火星表面的Pathfinder机器人（是的，就是在火星上遇到了优先级倒置并发错误的那个机器人。我们将在第15章《使用Pthreads进行多线程编程第二部分-同步》中稍微探讨一下这个问题，关于多线程和并发）。是的，这就是在优秀电影《火星救援》中扮演角色的Pathfinder机器人！关于这个问题，我们将在GitHub存储库的“进一步阅读”部分中详细介绍。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the reader has been taken through the various interfaces exposed
    by Linux with regard to creating and using timers. Setting up and managing timeouts
    is an essential component of many, if not most, systems applications. The older
    interfaces—the venerable `alarm(2)` API, followed by the `[s|g]etitimer(2)` system
    calls—were shown with example code. Then, we delved into the newer and better POSIX
    timers, including the advantages provided by them, and how to use them in a practical
    fashion. This was greatly aided with the help of two fairly elaborate sample programs—the
    react game and the run:walk timer application. Finally, the reader was introduced
    to the notion of using timers via file abstractions, and to the watchdog timer.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者已经了解了Linux在创建和使用定时器方面提供的各种接口。设置和管理超时是许多系统应用的重要组成部分，如果不是大多数系统应用的话。旧的接口——备受尊敬的`alarm(2)`API，以及`[s|g]etitimer(2)`系统调用——都有示例代码。然后，我们深入了解了更新更好的POSIX定时器，包括它们提供的优势以及如何在实际中使用它们。这在两个相当复杂的示例程序——react游戏和run:walk定时器应用程序的帮助下得到了很大的帮助。最后，读者被介绍了通过文件抽象使用定时器的概念，以及看门狗定时器。
- en: The next chapter is where we begin our long three-chapter journey on understanding
    and using the powerful multithreading framework on Linux.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是我们开始在Linux上理解和使用强大的多线程框架的漫长三章旅程的地方。
