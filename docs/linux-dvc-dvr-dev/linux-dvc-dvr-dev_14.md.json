["```\nusdhc@0219c000 { /* uSDHC4 */ \n   non-removable; \n   vmmc-supply = <&reg_3p3v>; \n   status = \"okay\"; \n   pinctrl-names = \"default\"; \n   pinctrl-0 = <&pinctrl_usdhc4_1>; \n}; \n\ngpio-keys { \n    compatible = \"gpio-keys\"; \n    pinctrl-names = \"default\"; \n    pinctrl-0 = <&pinctrl_io_foo &pinctrl_io_bar>; \n}; \n\niomuxc@020e0000 { \n    compatible = \"fsl,imx6q-iomuxc\"; \n    reg = <0x020e0000 0x4000>; \n\n    /* shared pinctrl settings */ \n    usdhc4 { /* first node describing the function */ \n        pinctrl_usdhc4_1: usdhc4grp-1 { /* second node */ \n            fsl,pins = < \n                MX6QDL_PAD_SD4_CMD__SD4_CMD    0x17059 \n                MX6QDL_PAD_SD4_CLK__SD4_CLK    0x10059 \n                MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059 \n                MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059 \n                MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059 \n                MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059 \n                MX6QDL_PAD_SD4_DAT4__SD4_DATA4 0x17059 \n                MX6QDL_PAD_SD4_DAT5__SD4_DATA5 0x17059 \n                MX6QDL_PAD_SD4_DAT6__SD4_DATA6 0x17059 \n                MX6QDL_PAD_SD4_DAT7__SD4_DATA7 0x17059 \n            >; \n        }; \n    }; \n    [...] \n    uart3 { \n        pinctrl_uart3_1: uart3grp-1 { \n            fsl,pins = < \n                MX6QDL_PAD_EIM_D24__UART3_TX_DATA 0x1b0b1 \n                MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1 \n            >; \n        }; \n    }; \n    // GPIOs (Inputs) \n   gpios { \n        pinctrl_io_foo: pinctrl_io_foo { \n            fsl,pins = < \n                MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09  0x1f059 \n                MX6QDL_PAD_DISP0_DAT13__GPIO5_IO07  0x1f059 \n            >; \n        }; \n        pinctrl_io_bar: pinctrl_io_bar { \n            fsl,pins = < \n                MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05  0x1f059 \n                MX6QDL_PAD_DISP0_DAT9__GPIO4_IO30   0x1f059 \n                MX6QDL_PAD_DISP0_DAT7__GPIO4_IO28   0x1f059 \n                MX6QDL_PAD_DISP0_DAT5__GPIO4_IO26   0x1f059 \n            >; \n        }; \n    }; \n}; \n```", "```\nMX6QDL_PAD_DISP0_DAT15__GPIO5_IO09  0x80000000 \n```", "```\nMX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1 \n```", "```\n#define MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05  0x19c 0x4b0 0x000 0x5 0x0 \n```", "```\nstruct pinctrl *p; \nstruct pinctrl_state *s; \nint ret; \n\np = pinctrl_get(dev); \nif (IS_ERR(p)) \n    return p; \n\ns = pinctrl_lookup_state(p, name); \nif (IS_ERR(s)) { \n    devm_pinctrl_put(p); \n    return ERR_PTR(PTR_ERR(s)); \n} \n\nret = pinctrl_select_state(p, s); \nif (ret < 0) { \n    devm_pinctrl_put(p); \n    return ERR_PTR(ret); \n} \n```", "```\nstatic struct pinctrl *pinctrl_get_select(struct device *dev, \n                             const char *name) \n```", "```\nstatic struct pinctrl * pinctrl_get_select_default( \n                                struct device *dev) \n{ \n   return pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT); \n} \n```", "```\ndcan1: d_can@481d0000 { \n    status = \"okay\"; \n    pinctrl-names = \"default\"; \n    pinctrl-0 = <&d_can1_pins>; \n}; \n```", "```\npinctrl = devm_pinctrl_get_select_default(&pdev->dev); \nif (IS_ERR(pinctrl)) \n    dev_warn(&pdev->dev,\"pins are not configured from the driver\\n\"); \n```", "```\n#include <linux/gpio.h> \n```", "```\nstatic int  gpio_request(unsigned gpio, const char *label) \n```", "```\nvoid gpio_free(unsigned int gpio) \n```", "```\nstatic bool gpio_is_valid(int number) \n```", "```\nstatic int  gpio_direction_input(unsigned gpio) \nstatic int  gpio_direction_output(unsigned gpio, int value) \n```", "```\nstatic  int  gpio_set_debounce(unsigned gpio, unsigned debounce) \n```", "```\nstatic int  gpio_get_value(unsigned gpio) \nvoid gpio_set_value(unsigned int gpio, int value); \n```", "```\nstatic int gpio_get_value_cansleep(unsigned gpio); \nvoid gpio_set_value_cansleep(unsigned gpio, int value); \n```", "```\nint gpio_to_irq(unsigned gpio);\n```", "```\nstatic irqreturn_t my_interrupt_handler(int irq, void *dev_id) \n{ \n    [...] \n    return IRQ_HANDLED; \n} \n\n[...] \nint gpio_int = of_get_gpio(np, 0); \nint irq_num = gpio_to_irq(gpio_int); \nint error = devm_request_threaded_irq(&client->dev, irq_num, \n                               NULL, my_interrupt_handler, \n                               IRQF_TRIGGER_RISING | IRQF_ONESHOT, \n                               input_dev->name, my_data_struct); \nif (error) { \n    dev_err(&client->dev, \"irq %d requested failed, %d\\n\", \n        client->irq, error); \n    return error; \n} \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/gpio.h>        /* For Legacy integer based GPIO */ \n#include <linux/interrupt.h>   /* For IRQ */ \n\nstatic unsigned int GPIO_LED_RED = 49; \nstatic unsigned int GPIO_BTN1 = 115; \nstatic unsigned int GPIO_BTN2 = 116; \nstatic unsigned int GPIO_LED_GREEN = 120; \nstatic unsigned int irq; \n\nstatic irq_handler_t btn1_pushed_irq_handler(unsigned int irq, \n                             void *dev_id, struct pt_regs *regs) \n{ \n    int state; \n\n    /* read BTN2 value and change the led state */ \n    state = gpio_get_value(GPIO_BTN2); \n    gpio_set_value(GPIO_LED_RED, state); \n    gpio_set_value(GPIO_LED_GREEN, state); \n\n    pr_info(\"GPIO_BTN1 interrupt: Interrupt! GPIO_BTN2 state is %d)\\n\", state); \n    return IRQ_HANDLED; \n} \n\nstatic int __init helloworld_init(void) \n{ \n    int retval; \n\n    /* \n     * One could have checked whether the GPIO is valid on the controller or not, \n     * using gpio_is_valid() function. \n     * Ex: \n     *  if (!gpio_is_valid(GPIO_LED_RED)) { \n     *       pr_infor(\"Invalid Red LED\\n\"); \n     *       return -ENODEV; \n     *   } \n     */ \n    gpio_request(GPIO_LED_GREEN, \"green-led\"); \n    gpio_request(GPIO_LED_RED, \"red-led\"); \n    gpio_request(GPIO_BTN1, \"button-1\"); \n    gpio_request(GPIO_BTN2, \"button-2\"); \n\n    /* \n     * Configure Button GPIOs as input \n     * \n     * After this, one can call gpio_set_debounce() \n     * only if the controller has the feature \n     * \n     * For example, to debounce a button with a delay of 200ms \n     *  gpio_set_debounce(GPIO_BTN1, 200); \n     */ \n    gpio_direction_input(GPIO_BTN1); \n    gpio_direction_input(GPIO_BTN2); \n\n    /* \n     * Set LED GPIOs as output, with their initial values set to 0 \n     */ \n    gpio_direction_output(GPIO_LED_RED, 0); \n    gpio_direction_output(GPIO_LED_GREEN, 0); \n\n    irq = gpio_to_irq(GPIO_BTN1); \n    retval = request_threaded_irq(irq, NULL,\\ \n                            btn1_pushed_irq_handler, \\ \n                            IRQF_TRIGGER_LOW | IRQF_ONESHOT, \\ \n                            \"device-name\", NULL); \n\n    pr_info(\"Hello world!\\n\"); \n    return 0; \n} \n\nstatic void __exit hellowolrd_exit(void) \n{ \n    free_irq(irq, NULL); \n    gpio_free(GPIO_LED_RED); \n    gpio_free(GPIO_LED_GREEN); \n    gpio_free(GPIO_BTN1); \n    gpio_free(GPIO_BTN2); \n\n    pr_info(\"End of the world\\n\"); \n} \n\nmodule_init(hellowolrd_init); \nmodule_exit(hellowolrd_exit); \n\nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\nstruct gpio_desc { \n   struct gpio_chip  *chip; \n   unsigned long flags; \n   const char *label; \n}; \n```", "```\n#include <linux/gpio/consumer.h> \n```", "```\n/* gpio suffixes used for ACPI and device tree lookup */ \nstatic const char * const gpio_suffixes[] = { \"gpios\", \"gpio\" }; \n```", "```\nstatic struct gpio_desc *of_find_gpio(struct device *dev, \n                                    const char *con_id, \n                                   unsigned int idx, \n                                   enum gpio_lookup_flags *flags) \n{ \n   char prop_name[32]; /* 32 is max size of property name */ \n   enum of_gpio_flags of_flags; \n   struct gpio_desc *desc; \n   unsigned int i; \n\n   for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) { \n         if (con_id) \n               snprintf(prop_name, sizeof(prop_name), \"%s-%s\", \n                       con_id, \n                      gpio_suffixes[i]); \n         else \n               snprintf(prop_name, sizeof(prop_name), \"%s\", \n                      gpio_suffixes[i]); \n\n         desc = of_get_named_gpiod_flags(dev->of_node, \n                                          prop_name, idx, \n                                 &of_flags); \n         if (!IS_ERR(desc) || (PTR_ERR(desc) == -EPROBE_DEFER)) \n               break; \n   } \n\n   if (IS_ERR(desc)) \n         return desc; \n\n   if (of_flags & OF_GPIO_ACTIVE_LOW) \n         *flags |= GPIO_ACTIVE_LOW; \n\n   return desc; \n} \n```", "```\nfoo_device { \n   compatible = \"acme,foo\"; \n   [...] \n   led-gpios = <&gpio 15 GPIO_ACTIVE_HIGH>, /* red */ \n               <&gpio 16 GPIO_ACTIVE_HIGH>, /* green */ \n               <&gpio 17 GPIO_ACTIVE_HIGH>; /* blue */ \n\n   power-gpios = <&gpio 1 GPIO_ACTIVE_LOW>; \n   reset-gpios = <&gpio 1 GPIO_ACTIVE_LOW>; \n}; \n```", "```\nstruct gpio_desc *gpiod_get_index(struct device *dev, \n                                 const char *con_id, \n                                 unsigned int idx, \n                                 enum gpiod_flags flags) \nstruct gpio_desc *gpiod_get(struct device *dev, \n                            const char *con_id, \n                            enum gpiod_flags flags) \n```", "```\nenum gpiod_flags { \n    GPIOD_ASIS = 0, \n    GPIOD_IN = GPIOD_FLAGS_BIT_DIR_SET, \n    GPIOD_OUT_LOW = GPIOD_FLAGS_BIT_DIR_SET | \n                    GPIOD_FLAGS_BIT_DIR_OUT, \n    GPIOD_OUT_HIGH = GPIOD_FLAGS_BIT_DIR_SET | \n                     GPIOD_FLAGS_BIT_DIR_OUT | \n                     GPIOD_FLAGS_BIT_DIR_VAL, \n}; \n```", "```\nstruct gpio_desc *red, *green, *blue, *power; \n\nred = gpiod_get_index(dev, \"led\", 0, GPIOD_OUT_HIGH); \ngreen = gpiod_get_index(dev, \"led\", 1, GPIOD_OUT_HIGH); \nblue = gpiod_get_index(dev, \"led\", 2, GPIOD_OUT_HIGH); \n\npower = gpiod_get(dev, \"power\", GPIOD_OUT_HIGH); \n```", "```\ngpiod_put(struct gpio_desc *desc); \n```", "```\ngpiod_put(blue); \ngpiod_put(red); \n```", "```\nint gpiod_direction_input(struct gpio_desc *desc); \nint gpiod_direction_output(struct gpio_desc *desc, int value); \n```", "```\nint gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce); \n```", "```\nint gpiod_cansleep(const struct gpio_desc *desc); \n\n/* Value get/set from sleeping context */ \nint gpiod_get_value_cansleep(const struct gpio_desc *desc); \nvoid gpiod_set_value_cansleep(struct gpio_desc *desc, int value); \n\n/* Value get/set from non-sleeping context */ \nint gpiod_get_value(const struct gpio_desc *desc); \nvoid gpiod_set_value(struct gpio_desc *desc, int value); \n```", "```\nint gpiod_to_irq(const struct gpio_desc *desc); \n```", "```\n/* Convert between the old gpio_ and new gpiod_ interfaces */ \nstruct gpio_desc *gpio_to_desc(unsigned gpio); \nint desc_to_gpio(const struct gpio_desc *desc); \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/platform_device.h>      /* For platform devices */ \n#include <linux/gpio/consumer.h>        /* For GPIO Descriptor */ \n#include <linux/interrupt.h>            /* For IRQ */ \n#include <linux/of.h>                   /* For DT*/ \n\n/* \n * Let us consider the below mapping in device tree: \n * \n *    foo_device { \n *       compatible = \"packt,gpio-descriptor-sample\"; \n *       led-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>, // red  \n *                   <&gpio2 16 GPIO_ACTIVE_HIGH>, // green  \n * \n *       btn1-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>; \n *       btn2-gpios = <&gpio2 31 GPIO_ACTIVE_LOW>; \n *   }; \n */ \n\nstatic struct gpio_desc *red, *green, *btn1, *btn2; \nstatic unsigned int irq; \n\nstatic irq_handler_t btn1_pushed_irq_handler(unsigned int irq, \n                              void *dev_id, struct pt_regs *regs) \n{ \n    int state; \n\n    /* read the button value and change the led state */ \n    state = gpiod_get_value(btn2); \n    gpiod_set_value(red, state); \n    gpiod_set_value(green, state); \n\n    pr_info(\"btn1 interrupt: Interrupt! btn2 state is %d)\\n\", \n              state); \n    return IRQ_HANDLED; \n} \n\nstatic const struct of_device_id gpiod_dt_ids[] = { \n    { .compatible = \"packt,gpio-descriptor-sample\", }, \n    { /* sentinel */ } \n}; \n\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n    int retval; \n    struct device *dev = &pdev->dev; \n\n    /* \n     * We use gpiod_get/gpiod_get_index() along with the flags \n     * in order to configure the GPIO direction and an initial \n     * value in a single function call. \n     * \n     * One could have used: \n     *  red = gpiod_get_index(dev, \"led\", 0); \n     *  gpiod_direction_output(red, 0); \n     */ \n    red = gpiod_get_index(dev, \"led\", 0, GPIOD_OUT_LOW); \n    green = gpiod_get_index(dev, \"led\", 1, GPIOD_OUT_LOW); \n\n    /* \n     * Configure GPIO Buttons as input \n     * \n     * After this, one can call gpiod_set_debounce() \n     * only if the controller has the feature \n     * For example, to debounce  a button with a delay of 200ms \n     *  gpiod_set_debounce(btn1, 200); \n     */ \n    btn1 = gpiod_get(dev, \"led\", 0, GPIOD_IN); \n    btn2 = gpiod_get(dev, \"led\", 1, GPIOD_IN); \n\n    irq = gpiod_to_irq(btn1); \n    retval = request_threaded_irq(irq, NULL,\\ \n                            btn1_pushed_irq_handler, \\ \n                            IRQF_TRIGGER_LOW | IRQF_ONESHOT, \\ \n                            \"gpio-descriptor-sample\", NULL); \n    pr_info(\"Hello! device probed!\\n\"); \n    return 0; \n} \n\nstatic void my_pdrv_remove(struct platform_device *pdev) \n{ \n    free_irq(irq, NULL); \n    gpiod_put(red); \n    gpiod_put(green); \n    gpiod_put(btn1); \n    gpiod_put(btn2); \n    pr_info(\"good bye reader!\\n\"); \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = my_pdrv_probe, \n    .remove     = my_pdrv_remove, \n    .driver     = { \n        .name     = \"gpio_descriptor_sample\", \n        .of_match_table = of_match_ptr(gpiod_dt_ids),   \n        .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\ngpio1: gpio1 { \n    gpio-controller; \n    #gpio-cells = <2>; \n}; \ngpio2: gpio2 { \n    gpio-controller; \n    #gpio-cells = <1>; \n}; \n[...] \n\ncs-gpios = <&gpio1 17 0>, \n           <&gpio2 2>; \n           <0>, /* holes are permitted, means no GPIO 2 */ \n           <&gpio1 17 0>; \n\nreset-gpios = <&gpio1 30 0>; \ncd-gpios = <&gpio2 10>; \n```", "```\n#include <linux/of_gpio.h> \n```", "```\nint of_get_named_gpio(struct device_node *np, \n                      const char *propname, int index) \nint of_get_named_gpio_count(struct device_node *np, \n                      const char* propname) \n```", "```\nint n_gpios = of_get_named_gpio_count(dev.of_node, \n                                    \"cs-gpios\"); /* return 4 */ \nint second_gpio = of_get_named_gpio(dev.of_node, \"cs-gpio\", 1); \nint rst_gpio = of_get_named_gpio(\"reset-gpio\", 0); \ngpio_request(second_gpio, \"my-gpio); \n```", "```\nint of_gpio_count(struct device_node *np) \nint of_get_gpio(struct device_node *np, int index) \n```", "```\nmy_node@addr { \n    compatible = \"[...]\"; \n\n    gpios = <&gpio1 2 0>, /* INT */ \n            <&gpio1 5 0>; /* RST */ \n    [...] \n}; \n```", "```\nstruct device_node *np = dev->of_node; \n\nif (!np) \n    return ERR_PTR(-ENOENT); \n\nint n_gpios = of_gpio_count(); /* Will return 2 */ \nint gpio_int = of_get_gpio(np, 0); \nif (!gpio_is_valid(gpio_int)) { \n    dev_err(dev, \"failed to get interrupt gpio\\n\"); \n    return ERR_PTR(-EINVAL); \n} \n\ngpio_rst = of_get_gpio(np, 1); \nif (!gpio_is_valid(pdata->gpio_rst)) { \n    dev_err(dev, \"failed to get reset gpio\\n\"); \n    return ERR_PTR(-EINVAL); \n} \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/platform_device.h>      /* For platform devices */ \n#include <linux/interrupt.h>            /* For IRQ */ \n#include <linux/gpio.h>        /* For Legacy integer based GPIO */ \n#include <linux/of_gpio.h>     /* For of_gpio* functions */ \n#include <linux/of.h>          /* For DT*/ \n\n/* \n * Let us consider the following node \n * \n *    foo_device { \n *       compatible = \"packt,gpio-legacy-sample\"; \n *       led-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>, // red  \n *                   <&gpio2 16 GPIO_ACTIVE_HIGH>, // green  \n * \n *       btn1-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>; \n *       btn2-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>; \n *   }; \n */ \n\nstatic unsigned int gpio_red, gpio_green, gpio_btn1, gpio_btn2; \nstatic unsigned int irq; \n\nstatic irq_handler_t btn1_pushed_irq_handler(unsigned int irq, void *dev_id, \n                            struct pt_regs *regs) \n{ \n    /* The content of this function remains unchanged */ \n    [...] \n} \n\nstatic const struct of_device_id gpio_dt_ids[] = { \n    { .compatible = \"packt,gpio-legacy-sample\", }, \n    { /* sentinel */ } \n}; \n\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n    int retval; \n    struct device_node *np = &pdev->dev.of_node; \n\n    if (!np) \n        return ERR_PTR(-ENOENT); \n\n    gpio_red = of_get_named_gpio(np, \"led\", 0); \n    gpio_green = of_get_named_gpio(np, \"led\", 1); \n    gpio_btn1 = of_get_named_gpio(np, \"btn1\", 0); \n    gpio_btn2 = of_get_named_gpio(np, \"btn2\", 0); \n\n    gpio_request(gpio_green, \"green-led\"); \n    gpio_request(gpio_red, \"red-led\"); \n    gpio_request(gpio_btn1, \"button-1\"); \n    gpio_request(gpio_btn2, \"button-2\"); \n\n    /* Code to configure GPIO and request IRQ remains unchanged */ \n    [...] \n    return 0; \n} \n\nstatic void my_pdrv_remove(struct platform_device *pdev) \n{ \n    /* The content of this function remains unchanged */ \n    [...] \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe  = my_pdrv_probe, \n    .remove = my_pdrv_remove, \n    .driver = { \n    .name   = \"gpio_legacy_sample\", \n            .of_match_table = of_match_ptr(gpio_dt_ids),   \n            .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \n\nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\ngpio4: gpio4 { \n    gpio-controller; \n    #gpio-cells = <2>; \n    interrupt-controller; \n    #interrupt-cells = <2>; \n}; \n\nmy_label: node@0 { \n    reg = <0>; \n    spi-max-frequency = <1000000>; \n    interrupt-parent = <&gpio4>; \n    interrupts = <29 IRQ_TYPE_LEVEL_LOW>; \n}; \n```", "```\nint platform_get_irq(struct platform_device *dev, unsigned int num); \n```", "```\nint gpio_export(unsigned gpio, bool direction_may_change); \n\nint gpiod_export(struct gpio_desc *desc, bool direction_may_change); \n```", "```\nvoid gpio_unexport(unsigned gpio); /* Integer-based interface */ \nvoid gpiod_unexport(struct gpio_desc *desc) /* Descriptor-based */ \n```", "```\nint gpio_export_link(struct device *dev, const char *name, \n                      unsigned gpio) \nint gpiod_export_link(struct device *dev, const char *name, \n                      struct gpio_desc *desc) \n```", "```\nstatic struct gpio_desc *red, *green, *btn1, *btn2; \n\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n    [...] \n    red = gpiod_get_index(dev, \"led\", 0, GPIOD_OUT_LOW); \n    green = gpiod_get_index(dev, \"led\", 1, GPIOD_OUT_LOW); \n\n    gpiod_export(&pdev->dev, \"Green_LED\", green); \n    gpiod_export(&pdev->dev, \"Red_LED\", red); \n\n       [...] \n    return 0; \n} \n```", "```\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n    [...] \n\n    gpio_red = of_get_named_gpio(np, \"led\", 0); \n    gpio_green = of_get_named_gpio(np, \"led\", 1); \n    [...] \n\n    int gpio_export_link(&pdev->dev, \"Green_LED\", gpio_green) \n    int gpio_export_link(&pdev->dev, \"Red_LED\", gpio_red) \n    return 0; \n} \n```"]