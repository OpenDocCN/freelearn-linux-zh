["```\nstruct v4l2_device {\n\u00a0\u00a0\u00a0\u00a0struct device *dev;\n\u00a0\u00a0\u00a0\u00a0struct media_device *mdev;\n\u00a0\u00a0\u00a0\u00a0struct list_head subdevs;\n\u00a0\u00a0\u00a0\u00a0spinlock_t lock;\n\u00a0\u00a0\u00a0\u00a0char name[V4L2_DEVICE_NAME_SIZE];\n\u00a0\u00a0\u00a0\u00a0void (*notify)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int notification, void *arg);\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *ctrl_handler;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_prio_state prio;\n\u00a0\u00a0\u00a0\u00a0struct kref ref;\n\u00a0\u00a0\u00a0\u00a0void (*release)(struct v4l2_device *v4l2_dev);\n};\n```", "```\nint v4l2_device_register(struct device *dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_device *v4l2_dev);\n```", "```\nv4l2_device_unregister(struct v4l2_device *v4l2_dev);\n```", "```\nstruct video_device\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\u00a0\u00a0\u00a0\u00a0struct media_entity entity;\n\u00a0\u00a0\u00a0\u00a0struct media_intf_devnode *intf_devnode;\n\u00a0\u00a0\u00a0\u00a0struct media_pipeline pipe;\n#endif\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_file_operations *fops;\n\u00a0\u00a0\u00a0\u00a0u32 device_caps;\n\u00a0\u00a0\u00a0\u00a0struct device dev; struct cdev *cdev;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_device *v4l2_dev;\n\u00a0\u00a0\u00a0\u00a0struct device *dev_parent;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *ctrl_handler;\n\u00a0\u00a0\u00a0\u00a0struct vb2_queue *queue;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_prio_state *prio;\n\u00a0\u00a0\u00a0\u00a0char name[32];\n\u00a0\u00a0\u00a0\u00a0enum vfl_devnode_type vfl_type;\n\u00a0\u00a0\u00a0\u00a0enum vfl_devnode_direction vfl_dir;\n\u00a0\u00a0\u00a0\u00a0int minor;\n\u00a0\u00a0\u00a0\u00a0u16 num;\n\u00a0\u00a0\u00a0\u00a0unsigned long flags; int index;\n\u00a0\u00a0\u00a0\u00a0spinlock_t fh_lock;\n\u00a0\u00a0\u00a0\u00a0struct list_head fh_list;\n\u00a0\u00a0\u00a0\u00a0void (*release)(struct video_device *vdev);\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_ioctl_ops *ioctl_ops;\n\u00a0\u00a0\u00a0\u00a0DECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);\n\u00a0\u00a0\u00a0\u00a0struct mutex *lock;\n};\n```", "```\nstruct video_device * vdev;\nvdev = video_device_alloc();\nif (!vdev)\n\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-ENOMEM);\nvdev->release = video_device_release;\n```", "```\nstruct my_struct {\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0struct video_device vdev;\n};\n[...]\nstruct my_struct *my_dev;\nstruct video_device *vdev;\nmy_dev =\tkzalloc(sizeof(struct my_struct), GFP_KERNEL);\nif (!my_dev)\n\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-ENOMEM);\nvdev = &my_vdev->vdev;\n/* Now work with vdev as our video_device struct */\nvdev->release = video_device_release_empty;\n[...]\n```", "```\nint video_register_device(struct video_device *vdev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0enum vfl_devnode_type type, int nr)\n```", "```\nvoid video_unregister_device(struct video_device *vdev)\n```", "```\nstruct v4l2_file_operations {\n\u00a0\u00a0\u00a0\u00a0struct module *owner;\n\u00a0\u00a0\u00a0\u00a0ssize_t (*read) (struct file *file, char user *buf,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t, loff_t *ppos);\n\u00a0\u00a0\u00a0\u00a0ssize_t (*write) (struct file *file, const char user *buf,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t, loff_t *ppos);\n\u00a0\u00a0\u00a0\u00a0poll_t (*poll) (struct file *file,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct poll_table_struct *);\n\u00a0\u00a0\u00a0\u00a0long (*unlocked_ioctl) (struct file *file,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\n\u00a0\u00a0\u00a0\u00a0\u00a0long (*compat_ioctl32) (struct file *file,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int cmd, unsigned long arg);\n#endif\n\u00a0\u00a0\u00a0\u00a0unsigned long (*get_unmapped_area) (struct file *file,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long, unsigned long,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long, unsigned long);\n\u00a0\u00a0\u00a0\u00a0int (*mmap) (struct file *file, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct vm_area_struct *vma);\n\u00a0\u00a0\u00a0\u00a0int (*open) (struct file *file);\n\u00a0\u00a0\u00a0\u00a0int (*release) (struct file *file);\n};\n```", "```\n    struct vb2_queue *q = container_of_myqueue_wrapper();\n    unsigned long off = vma->vm_pgoff << PAGE_SHIFT;\n    struct vb2_buffer *vb;\n    unsigned int buffer = 0, plane = 0;\n    for (i = 0; i < q->num_buffers; i++) {\n    \u00a0\u00a0\u00a0\u00a0struct vb2_buffer *buf = q->bufs[i];\n    \u00a0\u00a0\u00a0\u00a0/* The below assume we are on a single-planar system,\n    \u00a0\u00a0\u00a0\u00a0\u00a0* else we would have loop over each plane\n    \u00a0\u00a0\u00a0\u00a0\u00a0*/\n    \u00a0\u00a0\u00a0\u00a0if (buf->planes[0].m.offset == off)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0return i;\n    }\n    videobuf_queue_unlock(myqueue);\n    ```", "```\nint v4l2_fh_is_singular_file(struct file *filp)\nint v4l2_fh_is_singular(struct v4l2_fh *fh);\n```", "```\nstatic int foo_vdev_open(struct file *file)\n{\n\u00a0\u00a0\u00a0\u00a0struct mydev_state_struct *foo_dev = video_drvdata(file);\n\u00a0\u00a0\u00a0\u00a0int ret;\n[...]\n\u00a0\u00a0\u00a0\u00a0if (!v4l2_fh_is_singular_file(file))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto fh_rel;\n[...]\nfh_rel:\n\u00a0\u00a0\u00a0\u00a0if (ret)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v4l2_fh_release(file);\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\nstatic int foo_vdev_release(struct file *file)\n{\n\u00a0\u00a0\u00a0\u00a0struct mydev_state_struct *foo_dev = video_drvdata(file);\n\u00a0\u00a0\u00a0\u00a0bool fh_singular;\n\u00a0\u00a0\u00a0\u00a0int ret;\n[...]\n\u00a0\u00a0\u00a0\u00a0fh_singular = v4l2_fh_is_singular_file(file);\n\u00a0\u00a0\u00a0\u00a0ret = _vb2_fop_release(file, NULL);\n\u00a0\u00a0\u00a0\u00a0if (fh_singular)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* do something */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\nstatic const struct v4l2_file_operations foo_fops = {\n\u00a0\u00a0\u00a0\u00a0.owner = THIS_MODULE,\n\u00a0\u00a0\u00a0\u00a0.open = foo_vdev_open,\n\u00a0\u00a0\u00a0\u00a0.release = foo_vdev_release,\n\u00a0\u00a0\u00a0\u00a0.unlocked_ioctl = video_ioctl2,\n\u00a0\u00a0\u00a0\u00a0.poll = vb2_fop_poll,\n\u00a0\u00a0\u00a0\u00a0.mmap = vb2_fop_mmap,\n\u00a0\u00a0\u00a0\u00a0.read = vb2_fop_read,\n};\n```", "```\nstruct v4l2_ioctl_ops {\n\u00a0\u00a0\u00a0\u00a0/* VIDIOC_QUERYCAP handler */\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_querycap)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_capability *cap);\n\u00a0\u00a0\u00a0\u00a0/* Buffer handlers */\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_reqbufs)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_requestbuffers *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_querybuf)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_qbuf)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_expbuf)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_exportbuffer *e);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_dqbuf)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_create_bufs)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_create_buffers *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_prepare_buf)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer *b);\n\u00a0\u00a0\u00a0\u00a0int (*vidioc_overlay)(struct file *file, void *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int i);\n[...]\n};\n```", "```\nv4l2_disable_ioctl (vdev, cmd)\n```", "```\nstruct vb2_buffer {\n\u00a0\u00a0\u00a0\u00a0struct vb2_queue *vb2_queue;\n\u00a0\u00a0\u00a0\u00a0unsigned int index;\n\u00a0\u00a0\u00a0\u00a0unsigned int type;\n\u00a0\u00a0\u00a0\u00a0unsigned int memory;\n\u00a0\u00a0\u00a0\u00a0unsigned int num_planes;\n\u00a0\u00a0\u00a0\u00a0u64 timestamp;\n\u00a0\u00a0\u00a0\u00a0/* private: internal use only\n\u00a0\u00a0\u00a0\u00a0\u00a0*\n\u00a0\u00a0\u00a0\u00a0\u00a0* state: current buffer state; do not change\n\u00a0\u00a0\u00a0\u00a0\u00a0* queued_entry: entry on the queued buffers list, which\n\u00a0\u00a0\u00a0\u00a0\u00a0* holds all buffers queued from userspace\n\u00a0\u00a0\u00a0\u00a0\u00a0* done_entry: entry on the list that stores all buffers\n\u00a0\u00a0\u00a0\u00a0\u00a0* ready to be dequeued to userspace\n\u00a0\u00a0\u00a0\u00a0\u00a0* vb2_plane: per-plane information; do not change\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0enum vb2_buffer_state state;\n\u00a0\u00a0\u00a0\u00a0struct vb2_plane planes[VB2_MAX_PLANES];\n\u00a0\u00a0\u00a0\u00a0struct list_head queued_entry;\n\u00a0\u00a0\u00a0\u00a0struct list_head done_entry;\n[...]\n};\n```", "```\nstruct vb2_queue {\n\u00a0\u00a0\u00a0\u00a0unsigned int type;\n\u00a0\u00a0\u00a0\u00a0unsigned int io_modes;\n\u00a0\u00a0\u00a0\u00a0struct device *dev;\n\u00a0\u00a0\u00a0\u00a0struct mutex *lock;\n\u00a0\u00a0\u00a0\u00a0const struct vb2_ops *ops;\n\u00a0\u00a0\u00a0\u00a0const struct vb2_mem_ops *mem_ops;\n\u00a0\u00a0\u00a0\u00a0const struct vb2_buf_ops *buf_ops;\n\u00a0\u00a0\u00a0\u00a0u32 min_buffers_needed;\n\u00a0\u00a0\u00a0\u00a0gfp_t gfp_flags;\n\u00a0\u00a0\u00a0\u00a0void *drv_priv;\n\u00a0\u00a0\u00a0\u00a0struct vb2_buffer *bufs[VB2_MAX_FRAME];\n\u00a0\u00a0\u00a0\u00a0unsigned int num_buffers;\n\u00a0\u00a0\u00a0\u00a0/* Lots of private and debug stuff omitted */\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstruct vb2_ops {\n\u00a0\u00a0\u00a0\u00a0int (*queue_setup)(struct vb2_queue *q,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int *num_buffers, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int *num_planes,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int sizes[], \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device *alloc_devs[]);\n\u00a0\u00a0\u00a0\u00a0void (*wait_prepare)(struct vb2_queue *q);\n\u00a0\u00a0\u00a0\u00a0void (*wait_finish)(struct vb2_queue *q);\n\u00a0\u00a0\u00a0\u00a0int (*buf_init)(struct vb2_buffer *vb);\n\u00a0\u00a0\u00a0\u00a0int (*buf_prepare)(struct vb2_buffer *vb);\n\u00a0\u00a0\u00a0\u00a0void (*buf_finish)(struct vb2_buffer *vb);\n\u00a0\u00a0\u00a0\u00a0void (*buf_cleanup)(struct vb2_buffer *vb);\n\u00a0\u00a0\u00a0\u00a0int (*start_streaming)(struct vb2_queue *q, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int count);\n\u00a0\u00a0\u00a0\u00a0void (*stop_streaming)(struct vb2_queue *q);\n\u00a0\u00a0\u00a0\u00a0void (*buf_queue)(struct vb2_buffer *vb);\n};\n```", "```\n    /* Setup vb_queue minimum buffer requirements */\n    static int rcar_drif_queue_setup(struct vb2_queue *vq,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int *num_buffers,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int *num_planes,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int sizes[], \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device *alloc_devs[])\n    {\n    \u00a0\u00a0\u00a0\u00a0struct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\n    \u00a0\u00a0\u00a0\u00a0/* Need at least 16 buffers */\n    \u00a0\u00a0\u00a0\u00a0if (vq->num_buffers + *num_buffers < 16)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*num_buffers = 16 - vq->num_buffers;\n    \u00a0\u00a0\u00a0\u00a0*num_planes = 1;\n    \u00a0\u00a0\u00a0\u00a0sizes[0] = PAGE_ALIGN(sdr->fmt->buffersize);\n    \u00a0\u00a0\u00a0\u00a0rdrif_dbg(sdr, \"num_bufs %d sizes[0] %d\\n\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*num_buffers, sizes[0]);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```\n    struct dcmi_buf {\n    \u00a0\u00a0\u00a0struct vb2_v4l2_buffer vb;\n    \u00a0\u00a0\u00a0dma_addr_t paddr; /* the bus address of this buffer */\n    \u00a0\u00a0\u00a0size_t size;\n    \u00a0\u00a0\u00a0struct list_head list; /* list entry for tracking \u00a0\u00a0\u00a0buffers */\n    };\n    ```", "```\nint vb2_core_queue_init(struct vb2_queue *q)\n{\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* Sanity check\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0if (WARN_ON(!q) || WARN_ON(!q->ops) || \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON(!q->mem_ops) ||\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON(!q->type) || WARN_ON(!q->io_modes) ||\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON(!q->ops->queue_setup) || \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON(!q->ops->buf_queue))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n\u00a0\u00a0\u00a0\u00a0INIT_LIST_HEAD(&q->queued_list);\n\u00a0\u00a0\u00a0\u00a0INIT_LIST_HEAD(&q->done_list);\n\u00a0\u00a0\u00a0\u00a0spin_lock_init(&q->done_lock);\n\u00a0\u00a0\u00a0\u00a0mutex_init(&q->mmap_lock);\n\u00a0\u00a0\u00a0\u00a0init_waitqueue_head(&q->done_wq);\n\u00a0\u00a0\u00a0\u00a0q->memory = VB2_MEMORY_UNKNOWN;\n\u00a0\u00a0\u00a0\u00a0if (q->buf_struct_size == 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q->buf_struct_size = sizeof(struct vb2_buffer);\n\u00a0\u00a0\u00a0\u00a0if (q->bidirectional)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q->dma_dir = DMA_BIDIRECTIONAL;\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q->dma_dir = q->is_output ? DMA_TO_DEVICE : \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DMA_FROM_DEVICE;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nstruct v4l2_subdev {\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\u00a0\u00a0\u00a0\u00a0struct media_entity entity;\n#endif\n\u00a0\u00a0\u00a0\u00a0struct list_head list; \n\u00a0\u00a0\u00a0\u00a0struct module *owner;\n\u00a0\u00a0\u00a0\u00a0bool owner_v4l2_dev;\n\u00a0\u00a0\u00a0\u00a0u32 flags;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_device *v4l2_dev;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ops *ops;\n[...]\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *ctrl_handler;\n\u00a0\u00a0\u00a0\u00a0char name[V4L2_SUBDEV_NAME_SIZE];\n\u00a0\u00a0\u00a0\u00a0u32 grp_id; void *dev_priv;\n\u00a0\u00a0\u00a0\u00a0void *host_priv;\n\u00a0\u00a0\u00a0\u00a0struct video_device *devnode;\n\u00a0\u00a0\u00a0\u00a0struct device *dev;\n\u00a0\u00a0\u00a0\u00a0struct fwnode_handle *fwnode;\n\u00a0\u00a0\u00a0\u00a0struct device_node *of_node;\n\u00a0\u00a0\u00a0\u00a0struct list_head async_list;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_async_subdev *asd;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_async_notifier *notifier;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_async_notifier *subdev_notifier;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_subdev_platform_data *pdata;\n};\n```", "```\nstruct mychip_struct {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_subdev sd;\n[...]\n\u00a0\u00a0\u00a0\u00a0/* device speific fields*/\n[...]\n};\n```", "```\nvoid v4l2_subdev_init(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ops *ops)\nvoid v4l2_i2c_subdev_init(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ops *ops)\nvoid v4l2_spi_subdev_init(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct spi_device *spi,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ops *ops)\n```", "```\nv4l2_i2c_subdev_init(&mychip_struct->sd, client, subdev_ops);\n/*or*/\nv4l2_subdev_init(&mychip_struct->sd, subdev_ops);\n```", "```\nvoid v4l2_i2c_subdev_init(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ops *ops)\n{\n\u00a0\u00a0\u00a0v4l2_subdev_init(sd, ops);\n\u00a0\u00a0\u00a0sd->flags |= V4L2_SUBDEV_FL_IS_I2C;\n\u00a0\u00a0\u00a0/* the owner is the same as the i2c_client's driver owner */\n\u00a0\u00a0\u00a0sd->owner = client->dev.driver->owner;\n\u00a0\u00a0\u00a0sd->dev = &client->dev;\n\u00a0\u00a0\u00a0/* i2c_client and v4l2_subdev point to one another */\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0v4l2_set_subdevdata(sd, client);\n\u00a0\u00a0\u00a0i2c_set_clientdata(client, sd);\n\u00a0\u00a0\u00a0/* initialize name */\n\u00a0\u00a0\u00a0snprintf(sd->name, sizeof(sd->name),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"%s %d-%04x\", client->dev.driver->name,\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i2c_adapter_id(client->adapter), client->addr);\n}\n```", "```\nstruct v4l2_subdev_ops {\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_core_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*core;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_tuner_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*tuner;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_audio_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*audio;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_video_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*video;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_vbi_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*vbi;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_ir_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*ir;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_sensor_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*sensor;\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_subdev_pad_ops\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*pad;\n};\n```", "```\nstruct v4l2_subdev_core_ops {\n\u00a0\u00a0\u00a0\u00a0int (*log_status)(struct v4l2_subdev *sd);\n\u00a0\u00a0\u00a0\u00a0int (*load_fw)(struct v4l2_subdev *sd);\n\u00a0\u00a0\u00a0\u00a0long (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *arg);\n[...]\n#ifdef CONFIG_COMPAT\n\u00a0\u00a0\u00a0\u00a0long (*compat_ioctl32)(struct v4l2_subdev *sd, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int cmd, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long arg);\n#endif\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\u00a0\u00a0\u00a0int (*g_register)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_dbg_register *reg);\n\u00a0\u00a0\u00a0int (*s_register)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_dbg_register *reg);\n#endif\n\u00a0\u00a0\u00a0int (*s_power)(struct v4l2_subdev *sd, int on);\n\u00a0\u00a0\u00a0int (*interrupt_service_routine)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 status, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool *handled);\n\u00a0\u00a0\u00a0int (*subscribe_event)(struct v4l2_subdev *sd, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_fh *fh,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_event_subscription *sub);\n\u00a0\u00a0\u00a0int (*unsubscribe_event)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_fh *fh, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_event_subscription *sub);\n};\n```", "```\nstruct v4l2_subdev_video_ops {\n\u00a0\u00a0\u00a0\u00a0int (*querystd)(struct v4l2_subdev *sd, v4l2_std_id *std);\n[...]\n\u00a0\u00a0\u00a0\u00a0int (*s_stream)(struct v4l2_subdev *sd, int enable);\n\u00a0\u00a0\u00a0\u00a0int (*g_frame_interval)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_subdev_frame_interval *interval);\n\u00a0\u00a0\u00a0\u00a0int (*s_frame_interval)(struct v4l2_subdev *sd,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_subdev_frame_interval *interval);\n[...]\n};\n```", "```\nstruct v4l2_subdev_sensor_ops {\n\u00a0\u00a0\u00a0\u00a0int (*g_skip_top_lines)(struct v4l2_subdev *sd, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 *lines);\n\u00a0\u00a0\u00a0\u00a0int (*g_skip_frames)(struct v4l2_subdev *sd, u32 *frames);\n};\n```", "```\n#define OV5670_NUM_OF_SKIP_FRAMES\t2\nstatic int ov5670_get_skip_frames(struct v4l2_subdev *sd, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 *frames)\n{\n\u00a0\u00a0\u00a0\u00a0*frames = OV5670_NUM_OF_SKIP_FRAMES;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nerr = subdev->ops->video->s_stream(subdev, 1);\n```", "```\nerr = v4l2_subdev_call(subdev, video, s_stream, 1);\n```", "```\nv4l2_device_call_all(dev, 0, core, g_chip_ident, &chip);\n```", "```\nerr = v4l2_device_call_until_err(dev, 0, core, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_chip_ident, &chip);\n```", "```\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_subdev *sd)\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd)\nint v4l2_device_register_subdev_nodes(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v4l2_device *v4l2_dev)\n```", "```\nstruct v4l2_ctrl_handler {\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0struct mutex *lock;\n\u00a0\u00a0\u00a0\u00a0struct list_head ctrls;\n\u00a0\u00a0\u00a0\u00a0v4l2_ctrl_notify_fnc notify;\n\u00a0\u00a0\u00a0\u00a0void *notify_priv;\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstruct v4l2_ctrl {\n\u00a0\u00a0\u00a0\u00a0struct list_head node;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *handler;\n\u00a0\u00a0\u00a0\u00a0unsigned int is_private:1;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0const struct v4l2_ctrl_ops *ops;\n\u00a0\u00a0\u00a0\u00a0u32 id;\n\u00a0\u00a0\u00a0\u00a0const char *name;\n\u00a0\u00a0\u00a0\u00a0enum v4l2_ctrl_type type;\n\u00a0\u00a0\u00a0\u00a0s64 minimum, maximum, default_value;\n\u00a0\u00a0\u00a0\u00a0u64 step;\n\u00a0\u00a0\u00a0\u00a0unsigned long flags; [...]\n}\n```", "```\n#define V4L2_CID_BRIGHTNESS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+0)\n#define V4L2_CID_CONTRAST\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+1)\n#define V4L2_CID_SATURATION\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+2)\n#define V4L2_CID_HUE\t(V4L2_CID_BASE+3)\n#define V4L2_CID_AUTO_WHITE_BALANCE\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+12)\n#define V4L2_CID_DO_WHITE_BALANCE\u00a0\u00a0(V4L2_CID_BASE+13)\n#define V4L2_CID_RED_BALANCE (V4L2_CID_BASE+14)\n#define V4L2_CID_BLUE_BALANCE\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+15)\n#define V4L2_CID_GAMMA\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+16)\n#define V4L2_CID_EXPOSURE\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+17)\n#define V4L2_CID_AUTOGAIN\u00a0\u00a0\u00a0\u00a0(V4L2_CID_BASE+18)\n#define V4L2_CID_GAIN\u00a0\u00a0(V4L2_CID_BASE+19)\n#define V4L2_CID_HFLIP (V4L2_CID_BASE+20)\n#define V4L2_CID_VFLIP (V4L2_CID_BASE+21)\n[...]\n#define V4L2_CID_VBLANK\u00a0\u00a0(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 1) #define V4L2_CID_HBLANK\u00a0\u00a0(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 2) #define V4L2_CID_LINK_FREQ (V4L2_CID_IMAGE_PROC_CLASS_BASE + 1)\n```", "```\nv4l2_ctrl_handler_init(hdl, nr_of_controls_hint)\n```", "```\nstruct v4l2_ctrl *v4l2_ctrl_new_std(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *hdl,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct v4l2_ctrl_ops *ops,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 id, s64 min, s64 max, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u64 step, s64 def);\n```", "```\nstruct v4l2_ctrl_ops {\n\u00a0\u00a0\u00a0\u00a0int (*g_volatile_ctrl)(struct v4l2_ctrl *ctrl);\n\u00a0\u00a0\u00a0\u00a0int (*try_ctrl)(struct v4l2_ctrl *ctrl);\n\u00a0\u00a0\u00a0\u00a0int (*s_ctrl)(struct v4l2_ctrl *ctrl);\n};\n```", "```\nint v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl);\n```", "```\nstatic int ov7740_get_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\u00a0\u00a0\u00a0\u00a0struct ov7740 *ov7740 = container_of(ctrl->handler,\n\u00a0\u00a0\u00a0\u00a0struct ov7740, ctrl_handler);\n\u00a0\u00a0\u00a0\u00a0int ret;\n\u00a0\u00a0\u00a0\u00a0switch (ctrl->id) {\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_AUTOGAIN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_get_gain(ov7740, ctrl);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = -EINVAL;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\n```", "```\nstatic int ov7740_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\u00a0\u00a0\u00a0\u00a0struct ov7740 *ov7740 =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0container_of(ctrl->handler, struct ov7740, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ctrl_handler);\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *client = \u00a0\u00a0\u00a0\u00a0v4l2_get_subdevdata(&ov7740->subdev); \n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap = ov7740->regmap;\n\u00a0\u00a0\u00a0\u00a0int ret;\n\u00a0\u00a0\u00a0\u00a0u8 val = 0;\n[...]\n\u00a0\u00a0\u00a0\u00a0switch (ctrl->id) {\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_AUTO_WHITE_BALANCE:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_white_balance(ov7740, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_SATURATION:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_saturation(regmap, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_BRIGHTNESS:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_brightness(regmap, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_CONTRAST:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_contrast(regmap, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_VFLIP:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = regmap_update_bits(regmap, REG_REG0C,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REG0C_IMG_FLIP, val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_HFLIP:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = ctrl->val ? REG0C_IMG_MIRROR : 0x00;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = regmap_update_bits(regmap, REG_REG0C,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REG0C_IMG_MIRROR, val);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_AUTOGAIN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!ctrl->val)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ov7740_set_gain(regmap, ov7740->gain->val);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_autogain(regmap, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0case V4L2_CID_EXPOSURE_AUTO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (ctrl->val == V4L2_EXPOSURE_MANUAL)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ov7740_set_exp(regmap, ov7740->exposure->val);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = ov7740_set_autoexp(regmap, ctrl->val); break;\n\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = -EINVAL; break;\n\u00a0\u00a0\u00a0\u00a0}\n[...]\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\n```", "```\nstatic const struct v4l2_ctrl_ops ov7740_ctrl_ops = {\n\u00a0\u00a0\u00a0\u00a0.g_volatile_ctrl = ov7740_get_volatile_ctrl,\n\u00a0\u00a0\u00a0\u00a0.s_ctrl = ov7740_set_ctrl,\n};\n```", "```\nstatic int ov7740_init_controls(struct ov7740 *ov7740)\n{\n[...]\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl *auto_wb;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl *gain;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl *vflip;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl *auto_exposure;\n\u00a0\u00a0\u00a0\u00a0struct v4l2_ctrl_handler *ctrl_hdlr\n\u00a0\u00a0\u00a0\u00a0v4l2_ctrl_handler_init(ctrl_hdlr, 12);\n\u00a0\u00a0\u00a0\u00a0auto_wb = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_CID_AUTO_WHITE_BALANCE, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, 1, 1, 1);\n\u00a0\u00a0\u00a0\u00a0vflip = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_CID_VFLIP, 0, 1, 1, 0);\n\u00a0\u00a0\u00a0\u00a0gain = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_CID_GAIN, 0, 1023, 1, 500);\n\u00a0\u00a0\u00a0\u00a0/* let's mark this control as volatile*/\n\u00a0\u00a0\u00a0\u00a0gain->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\u00a0\u00a0\u00a0\u00a0contrast = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_CID_CONTRAST, 0, 127, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01, 0x20);\n\u00a0\u00a0\u00a0\u00a0ov7740->auto_exposure =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v4l2_ctrl_new_std_menu(ctrl_hdlr, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&ov7740_ctrl_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_CID_EXPOSURE_AUTO, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V4L2_EXPOSURE_MANUAL,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, V4L2_EXPOSURE_AUTO);\n[...]\n\u00a0\u00a0\u00a0\u00a0ov7740->subdev.ctrl_handler = ctrl_hdlr;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nret = v4l2_ctrl_handler_setup(ctrl_hdlr);\nif (ret) {\n\u00a0\u00a0\u00a0\u00a0dev_err(&client->dev, \"%s control init failed (%d)\\n\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__func__, ret);\n\u00a0\u00a0\u00a0goto error;\n}\n```"]