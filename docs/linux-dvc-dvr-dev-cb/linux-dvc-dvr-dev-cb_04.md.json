["```\n$ sudo apt install device-tree-compiler\n```", "```\n$ dtc -v\nVersion: DTC 1.4.5\n```", "```\n$ dtc -o simple_platform.dtb simple_platform.dts\n```", "```\n$ file simple_platform.dtb\nsimple_platform.dtb: Device Tree Blob version 17, size=1602, boot CPU=0, string block size=270, DT structure block size=1276\n```", "```\n$ diff -u simple_platform.dts simple_platform-reverted.dts | tail -29\n-      clks: clock@f00 {\n+      clock@f00 {\n           compatible = \"fsl,mpc5121-clock\";\n           reg = <0xf00 0x100>;\n-          #clock-cells = <1>;\n-          clocks = <&osc>;\n+          #clock-cells = <0x1>;\n+          clocks = <0x1>;\n           clock-names = \"osc\";\n+          phandle = <0x3>;\n       };\n```", "```\n\n-      serial0: serial@11100 {\n+      serial@11100 {\n           compatible = \"fsl,mpc5125-psc-uart\", \"fsl,mpc5125-psc\";\n           reg = <0x11100 0x100>;\n-          interrupt-parent = <&ipic>;\n-          interrupts = <40 0x8>;\n-          fsl,rx-fifo-size = <16>;\n-          fsl,tx-fifo-size = <16>;\n-          clocks = <&clks 47>, <&clks 34>;\n+          interrupt-parent = <0x2>;\n+          interrupts = <0x28 0x8>;\n+          fsl,rx-fifo-size = <0x10>;\n+          fsl,tx-fifo-size = <0x10>;\n+          clocks = <0x3 0x2f 0x3 0x22>;\n           clock-names = \"ipg\", \"mclk\";\n       };\n   };\n```", "```\n$ dtc -o simple_platform-reverted.dts simple_platform.dtb\n```", "```\n# dtc -I fs -o espressobin-reverted.dts /proc/device-tree/\n```", "```\n#define PATH_DEFAULT \"/\"\nstatic char *path = PATH_DEFAULT;\nmodule_param(path, charp, S_IRUSR | S_IWUSR);\nMODULE_PARM_DESC(path, \"a device tree pathname \" \\\n                       \"(default is \\\"\" PATH_DEFAULT \"\\\")\");\n```", "```\nstatic int __init get_dt_data_init(void)\n{\n    struct device_node *node, *child;\n    struct property *prop;\n\n    pr_info(\"path = \\\"%s\\\"\\n\", path);\n\n    /* Find node by its pathname */\n    node = of_find_node_by_path(path);\n    if (!node) {\n        pr_err(\"failed to find device-tree node \\\"%s\\\"\\n\", path);\n        return -ENODEV;\n    }\n    pr_info(\"device-tree node found!\\n\");\n```", "```\nstatic void print_main_prop(struct device_node *node)\n{\n    pr_info(\"+ node = %s\\n\", node->full_name);\n    print_property_u32(node, \"#address-cells\");\n    print_property_u32(node, \"#size-cells\");\n    print_property_u32(node, \"reg\");\n    print_property_string(node, \"name\");\n    print_property_string(node, \"compatible\");\n    print_property_string(node, \"status\");\n}\n```", "```\nstatic void print_property_u32(struct device_node *node, const char *name)\n{\n    u32 val32;\n    if (of_property_read_u32(node, name, &val32) == 0)\n        pr_info(\" \\%s = %d\\n\", name, val32); \n}\n\nstatic void print_property_string(struct device_node *node, const char *name)\n{\n    const char *str;\n    if (of_property_read_string(node, name, &str) == 0)\n        pr_info(\" \\%s = %s\\n\", name, str);\n}\n```", "```\n    pr_info(\"now move through all properties...\\n\");\n    for_each_property_of_node(node, prop)\n        pr_info(\"-> %s\\n\", prop->name);\n\n    /* Move through node's children... */\n    pr_info(\"Now move through children...\\n\");\n    for_each_child_of_node(node, child)\n        print_main_prop(child);\n\n    /* Force module unloading... */\n    return -EINVAL;\n    }\n```", "```\nstatic void print_main_prop(struct device_node *node)\n{\n    pr_info(\"+ node = %s\\n\", node->full_name);\n    print_property_u32(node, \"#address-cells\");\n    print_property_u32(node, \"#size-cells\");\n    print_property_u32(node, \"reg\");\n    print_property_string(node, \"name\");\n    print_property_string(node, \"compatible\");\n    print_property_string(node, \"status\");\n}\n```", "```\nstatic void print_property_u32(struct device_node *node, const char *name)\n{\n    u32 val32;\n    if (of_property_read_u32(node, name, &val32) == 0)\n        pr_info(\" \\%s = %d\\n\", name, val32);\n}\n\nstatic void print_property_string(struct device_node *node, const char *name)\n{\n    const char *str;\n    if (of_property_read_string(node, name, &str) == 0)\n        pr_info(\" \\%s = %s\\n\", name, str);\n}\n```", "```\n$ make KERNEL_DIR=../../../linux\nmake -C ../../../linux \\\n            ARCH=arm64 \\\n            CROSS_COMPILE=aarch64-linux-gnu- \\\n            SUBDIRS=/home/giometti/Projects/ldddc/github/chapter_4/get_dt_data modules\nmake[1]: Entering directory '/home/giometti/Projects/ldddc/linux'\n  CC [M] /home/giometti/Projects/ldddc/github/chapter_4/get_dt_data/get_dt_data.o\n  Building modules, stage 2.\n  MODPOST 1 modules\n  CC /home/giometti/Projects/ldddc/github/chapter_4/get_dt_data/get_dt_data.mod.o\n  LD [M] /home/giometti/Projects/ldddc/github/chapter_4/get_dt_data/get_dt_data.ko\nmake[1]: Leaving directory '/home/giometti/Projects/ldddc/linux'\n```", "```\n# modinfo get_dt_data.ko \nfilename: /root/get_dt_data.ko\nversion: 0.1\ndescription: Module to inspect device tree from the kernel\nauthor: Rodolfo Giometti\nlicense: GPL\nsrcversion: 6926CA8AD5E7F8B45C97CE6\ndepends: \nname: get_dt_data\nvermagic: 4.18.0 SMP preempt mod_unload aarch64\nparm: path:a device tree pathname (default is \"/\") (charp)\n```", "```\n# insmod get_dt_data.ko\n```", "```\nget_dt_data: path = \"/\"\nget_dt_data: device-tree node found!\n...\n```", "```\n...\nget_dt_data: now getting main properties...\nget_dt_data: + node = \nget_dt_data: #address-cells = 2\nget_dt_data: #size-cells = 2\nget_dt_data: name = \nget_dt_data: compatible = globalscale,espressobin\nget_dt_data: now move through all properties...\nget_dt_data: -> model\nget_dt_data: -> compatible\nget_dt_data: -> interrupt-parent\nget_dt_data: -> #address-cells\nget_dt_data: -> #size-cells\nget_dt_data: -> name\n...\n```", "```\n/ {\n    #address-cells = <0x2>;\n    model = \"Globalscale Marvell ESPRESSOBin Board\";\n    #size-cells = <0x2>;\n    interrupt-parent = <0x1>;\n    compatible = \"globalscale,espressobin\", \"marvell,armada3720\", \"marvell,armada3710\";\n```", "```\n...\nget_dt_data: Now move through children...\nget_dt_data: + node = aliases\nget_dt_data: name = aliases\nget_dt_data: + node = cpus\nget_dt_data: #address-cells = 1\nget_dt_data: #size-cells = 0\nget_dt_data: name = cpus\n...\nget_dt_data: + node = soc\nget_dt_data: #address-cells = 2\nget_dt_data: #size-cells = 2\nget_dt_data: name = soc\nget_dt_data: compatible = simple-bus\nget_dt_data: + node = chosen\nget_dt_data: name = chosen\nget_dt_data: + node = memory@0\nget_dt_data: reg = 0\nget_dt_data: name = memory\nget_dt_data: + node = regulator\nget_dt_data: name = regulator\nget_dt_data: compatible = regulator-gpio\n...\n```", "```\ninsmod: ERROR: could not insert module get_dt_data.ko: Invalid parameters\n```", "```\n# insmod get_dt_data.ko path=/cpus\n```", "```\nget_dt_data: path = \"/cpus\"\nget_dt_data: device-tree node found!\n```", "```\nget_dt_data: now getting main properties...\nget_dt_data: + node = cpus\nget_dt_data: #address-cells = 1\nget_dt_data: #size-cells = 0\nget_dt_data: name = cpus\n```", "```\nget_dt_data: now move through all properties...\nget_dt_data: -> #address-cells\nget_dt_data: -> #size-cells\nget_dt_data: -> name\nget_dt_data: Now move through children...\nget_dt_data: + node = cpu@0\nget_dt_data: reg = 0\nget_dt_data: name = cpu\nget_dt_data: compatible = arm,cortex-a53\nget_dt_data: + node = cpu@1\nget_dt_data: reg = 1\nget_dt_data: name = cpu\nget_dt_data: compatible = arm,cortex-a53\n```", "```\n# insmod get_dt_data.ko path=/soc/internal-regs@d0000000/i2c@11000\nget_dt_data: path = \"/soc/internal-regs@d0000000/i2c@11000\"\nget_dt_data: device-tree node found!\nget_dt_data: now getting main properties...\nget_dt_data: + node = i2c@11000\nget_dt_data: #address-cells = 1\nget_dt_data: #size-cells = 0\nget_dt_data: reg = 69632\nget_dt_data: name = i2c\nget_dt_data: compatible = marvell,armada-3700-i2c\nget_dt_data: status = disabled\nget_dt_data: now move through all properties...\n...\n```", "```\nchrdev {\n    compatible = \"ldddc,chrdev\";\n    #address-cells = <1>;\n    #size-cells = <0>;\n\n    chrdev@2 {\n        label = \"cdev-eeprom\";\n        reg = <2>;\n    };\n\n    chrdev@4 {\n        label = \"cdev-rom\";\n        reg = <4>;\n        read-only;\n    };\n};\n```", "```\nreg = <address1 length1 [address2 length2] [address3 length3] ... >\n```", "```\nstatic int __init chrdev_init(void)\n{\n    int ret;\n\n    /* Create the new class for the chrdev devices */\n    chrdev_class = class_create(THIS_MODULE, \"chrdev\");\n    if (!chrdev_class) {\n        pr_err(\"chrdev: failed to allocate class\\n\");\n        return -ENOMEM;\n    }\n\n    /* Allocate a region for character devices */\n    ret = alloc_chrdev_region(&chrdev_devt, 0, MAX_DEVICES, \"chrdev\");\n    if (ret < 0) {\n        pr_err(\"failed to allocate char device region\\n\");\n        goto remove_class;\n    }\n\n    pr_info(\"got major %d\\n\", MAJOR(chrdev_devt));\n\n    return 0;\n\nremove_class:\n    class_destroy(chrdev_class);\n\n    return ret;\n}\n```", "```\nstatic void __exit chrdev_exit(void)\n{\n    unregister_chrdev_region(chrdev_devt, MAX_DEVICES);\n    class_destroy(chrdev_class);\n}\n```", "```\n# insmod chrdev.ko \nchrdev: loading out-of-tree module taints kernel.\nchrdev:chrdev_init: got major 239\n```", "```\nint chrdev_device_register(const char *label, unsigned int id,\n                unsigned int read_only,\n                struct module *owner, struct device *parent) \n{\n    struct chrdev_device *chrdev;\n    dev_t devt;\n    int ret;\n\n    /* First check if we are allocating a valid device... */\n    if (id >= MAX_DEVICES) {\n        pr_err(\"invalid id %d\\n\", id);\n        return -EINVAL;\n    }\n    chrdev = &chrdev_array[id];\n\n    /* ... then check if we have not busy id */\n    if (chrdev->busy) {\n        pr_err(\"id %d\\n is busy\", id);\n        return -EBUSY; \n    }\n```", "```\n    /* Create the device and initialize its data */\n    cdev_init(&chrdev->cdev, &chrdev_fops);\n    chrdev->cdev.owner = owner;\n\n    devt = MKDEV(MAJOR(chrdev_devt), id);\n    ret = cdev_add(&chrdev->cdev, devt, 1); \n    if (ret) {\n        pr_err(\"failed to add char device %s at %d:%d\\n\",\n                label, MAJOR(chrdev_devt), id);\n        return ret;\n    }\n\n    chrdev->dev = device_create(chrdev_class, parent, devt, chrdev,\n                   \"%s@%d\", label, id);\n    if (IS_ERR(chrdev->dev)) {\n        pr_err(\"unable to create device %s\\n\", label); \n        ret = PTR_ERR(chrdev->dev);\n        goto del_cdev;\n    }\n```", "```\n  dev_set_drvdata(chrdev->dev, chrdev);\n\n /* Init the chrdev data */\n chrdev->id = id; \n chrdev->read_only = read_only;\n chrdev->busy = 1;\n strncpy(chrdev->label, label, NAME_LEN);\n memset(chrdev->buf, 0, BUF_LEN);\n\n dev_info(chrdev->dev, \"chrdev %s with id %d added\\n\", label, id);\n\n return 0;\n\ndel_cdev:\n cdev_del(&chrdev->cdev);\n\n return ret;\n}\nEXPORT_SYMBOL(chrdev_device_register);\n```", "```\n/* Main struct */\nstruct chrdev_device {\n    char label[NAME_LEN];\n    unsigned int busy : 1;\n    char buf[BUF_LEN];\n    int read_only;\n\n    unsigned int id; \n    struct module *owner;\n    struct cdev cdev;\n    struct device *dev;\n};\n```", "```\n# grep chrdev /proc/devices\n239 chrdev\n```", "```\n# mknod /dev/chrdev c 239 0\n# cat /dev/chrdev\ncat: /dev/chrdev: No such device or address\n```", "```\nstatic int chrdev_req_probe(struct platform_device *pdev)\n{\n    struct device *dev = &pdev->dev;\n    struct fwnode_handle *child;\n    struct module *owner = THIS_MODULE;\n    int count, ret;\n\n    /* If we are not registering a fixed chrdev device then get\n     * the number of chrdev devices from DTS\n     */\n    count = device_get_child_node_count(dev);\n    if (count == 0)\n        return -ENODEV;\n    if (count > MAX_DEVICES)\n        return -ENOMEM;\n```", "```\n device_for_each_child_node(dev, child) {\n        const char *label;\n        unsigned int id, ro;\n\n        /*\n         * Get device's properties\n         */\n\n        if (fwnode_property_present(child, \"reg\")) {\n            fwnode_property_read_u32(child, \"reg\", &id);\n        } else {\n...\n\n        }\n        ro = fwnode_property_present(child, \"read-only\");\n\n        /* Register the new chr device */\n        ret = chrdev_device_register(label, id, ro, owner, dev);\n        if (ret) { \n            dev_err(dev, \"unable to register\");\n        }\n    }\n\n    return 0;\n}\n```", "```\nstatic const struct of_device_id of_chrdev_req_match[] = {\n    {\n        .compatible = \"ldddc,chrdev\",\n    },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, of_chrdev_req_match);\n\nstatic struct platform_driver chrdev_req_driver = {\n    .probe = chrdev_req_probe,\n    .remove = chrdev_req_remove,\n    .driver = {\n        .name = \"chrdev-req\",\n        .of_match_table = of_chrdev_req_match,\n    },\n};\nmodule_platform_driver(chrdev_req_driver);\n```", "```\nstatic int chrdev_req_remove(struct platform_device *pdev)\n{\n    struct device *dev = &pdev->dev;\n    struct fwnode_handle *child;\n    int ret;\n\n    device_for_each_child_node(dev, child) {\n        const char *label; \n        int id;\n\n        /*\n         * Get device's properties\n         */\n\n        if (fwnode_property_present(child, \"reg\")) \n            fwnode_property_read_u32(child, \"reg\", &id);\n        else\n            BUG();\n        if (fwnode_property_present(child, \"label\"))\n            fwnode_property_read_string(child, \"label\", &label);\n        else\n            BUG();\n\n        /* Register the new chr device */\n        ret = chrdev_device_unregister(label, id);\n        if (ret)\n            dev_err(dev, \"unable to unregister\");\n    }\n\n    return 0;\n}\n```", "```\n\nint chrdev_device_unregister(const char *label, unsigned int id)\n{\n    struct chrdev_device *chrdev;\n\n    /* First check if we are deallocating a valid device... */\n    if (id >= MAX_DEVICES) {\n        pr_err(\"invalid id %d\\n\", id);\n        return -EINVAL;\n    }\n    chrdev = &chrdev_array[id];\n\n    /* ... then check if device is actualy allocated */\n    if (!chrdev->busy || strcmp(chrdev->label, label)) {\n        pr_err(\"id %d is not busy or label %s is not known\\n\",\n                        id, label);\n        return -EINVAL;\n    }\n```", "```\n    /* Deinit the chrdev data */\n    chrdev->id = 0;\n    chrdev->busy = 0;\n\n    dev_info(chrdev->dev, \"chrdev %s with id %d removed\\n\", label, id);\n\n    /* Dealocate the device */\n    device_destroy(chrdev_class, chrdev->dev->devt);\n    cdev_del(&chrdev->cdev);\n\n    return 0;\n}\nEXPORT_SYMBOL(chrdev_device_unregister);\n```", "```\n# udevadm monitor -k -p -s chrdev\nmonitor will print the received events for:\nKERNEL - the kernel uevent\n```", "```\n# insmod chrdev-req.ko \nchrdev cdev-eeprom@2: chrdev cdev-eeprom with id 2 added\nchrdev cdev-rom@4: chrdev cdev-rom with id 4 added\n```", "```\nKERNEL[14909.624343] add /devices/platform/chrdev/chrdev/cdev-eeprom@2 (chrdev)\nACTION=add\nDEVNAME=/dev/cdev-eeprom@2\nDEVPATH=/devices/platform/chrdev/chrdev/cdev-eeprom@2\nMAJOR=239\nMINOR=2\nSEQNUM=2297\nSUBSYSTEM=chrdev\n\nKERNEL[14909.631813] add /devices/platform/chrdev/chrdev/cdev-rom@4 (chrdev)\nACTION=add\nDEVNAME=/dev/cdev-rom@4\nDEVPATH=/devices/platform/chrdev/chrdev/cdev-rom@4\nMAJOR=239\nMINOR=4\nSEQNUM=2298\nSUBSYSTEM=chrdev\n```", "```\nCONFIG_FW_LOADER_USER_HELPER=y\nCONFIG_FW_LOADER_USER_HELPER_FALLBACK=y\n```", "```\nstatic const struct of_device_id of_chrdev_req_match[] = {\n    {\n        .compatible = \"ldddc,chrdev-fw_wait\",\n    },\n    {\n        .compatible = \"ldddc,chrdev-fw_nowait\",\n    },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, of_chrdev_req_match);\n\nstatic struct platform_driver chrdev_req_driver = {\n    .probe = chrdev_req_probe,\n    .remove = chrdev_req_remove,\n    .driver = {\n        .name = \"chrdev-fw\",\n        .of_match_table = of_chrdev_req_match,\n    },\n};\nmodule_platform_driver(chrdev_req_driver);\n```", "```\nstatic int chrdev_req_probe(struct platform_device *pdev)\n{\n    struct device *dev = &pdev->dev;\n    struct device_node *np = dev->of_node;\n    struct fwnode_handle *fwh = of_fwnode_handle(np);\n    struct module *owner = THIS_MODULE;\n    const char *file;\n    int ret = 0;\n\n    /* Read device properties */\n    if (fwnode_property_read_string(fwh, \"firmware\", &file)) {\n        dev_err(dev, \"unable to get property \\\"firmware\\\"!\");\n        return -EINVAL;\n    }\n\n    /* Load device firmware */\n    if (of_device_is_compatible(np, \"ldddc,chrdev-fw_wait\"))\n        ret = chrdev_load_fw_wait(dev, file);\n    else if (of_device_is_compatible(np, \"ldddc,chrdev-fw_nowait\"))\n        ret = chrdev_load_fw_nowait(dev, file);\n    if (ret)\n        return ret;\n```", "```\n    /* Register the new chr device */\n    ret = chrdev_device_register(\"chrdev-fw\", 0, 0, owner, dev);\n    if (ret) {\n        dev_err(dev, \"unable to register\");\n        return ret;\n    }\n\n    return 0;\n}\n```", "```\nstatic int chrdev_load_fw_wait(struct device *dev, const char *file)\n{\n    char fw_name[FIRMWARE_NLEN];\n    const struct firmware *fw;\n    int ret;\n\n    /* Compose firmware filename */\n    if (strlen(file) > (128 - 6 - sizeof(FIRMWARE_VER)))\n        return -EINVAL;\n    sprintf(fw_name, \"%s-%s.bin\", file, FIRMWARE_VER);\n\n    /* Do the firmware request */\n    ret = request_firmware(&fw, fw_name, dev);\n    if (ret) {\n        dev_err(dev, \"unable to load firmware\\n\");\n        return ret;\n    }\n```", "```\n    dump_data(fw->data, fw->size);\n\n    /* Firmware data has been read, now we can release it */\n    release_firmware(fw);\n\n    return 0;\n}\n```", "```\nstatic int chrdev_load_fw_nowait(struct device *dev, const char *file)\n{\n    char fw_name[FIRMWARE_NLEN];\n    int ret;\n\n    /* Compose firmware filename */\n    if (strlen(file) > (128 - 6 - sizeof(FIRMWARE_VER)))\n        return -EINVAL;\n    sprintf(fw_name, \"%s-%s.bin\", file, FIRMWARE_VER);\n\n    /* Do the firmware request */\n    ret = request_firmware_nowait(THIS_MODULE, false, fw_name, dev,\n            GFP_KERNEL, dev, chrdev_fw_cb);\n    if (ret) {\n        dev_err(dev,\n            \"unable to register call back for firmware loading\\n\");\n        return ret;\n    } \n\n    return 0;\n}\n```", "```\nstatic void chrdev_fw_cb(const struct firmware *fw, void *context)\n{\n    struct device *dev = context;\n\n    dev_info(dev, \"firmware callback executed!\\n\");\n    if (!fw) {\n        dev_err(dev, \"unable to load firmware\\n\");\n        return; \n    } \n\n    dump_data(fw->data, fw->size);\n\n    /* Firmware data has been read, now we can release it */\n    release_firmware(fw);\n}\n```", "```\n--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n@@ -41,6 +41,11 @@\n              3300000 0x0>;\n          enable-active-high;\n      };\n+\n+     chrdev {\n+         compatible = \"ldddc,chrdev-fw_wait\";\n+         firmware = \"chrdev-wait\";\n+     };\n };\n\n /* J9 */\n```", "```\n--- a/chapter_4/chrdev/Makefile\n+++ b/chapter_4/chrdev/Makefile\n@@ -6,7 +6,7 @@ ARCH ?= arm64\n CROSS_COMPILE ?= aarch64-linux-gnu-\n\n obj-m = chrdev.o\n-obj-m += chrdev-req.o\n+obj-m += chrdev-fw.o\n\n all: modules\n```", "```\n# insmod chrdev.ko \nchrdev: loading out-of-tree module taints kernel.\nchrdev:chrdev_init: got major 239\n# insmod chrdev-fw.ko \nchrdev-fw chrdev: Direct firmware load for chrdev-wait-1.0.0.bin \nfailed with error -2\nchrdev-fw chrdev: Falling back to syfs fallback for: chrdev-wait-1.0.0.bin\nchrdev-fw chrdev: unable to load firmware\nchrdev-fw: probe of chrdev failed with error -11\n```", "```\n# echo \"THIS IS A DUMMY FIRMWARE FOR CHRDEV DEVICE\" > \\\n /lib/firmware/chrdev-wait-1.0.0.bin\n```", "```\n# rmmod chrdev-fw \n# insmod chrdev-fw.ko \nchrdev_fw:dump_data: 54[T] 48[H] 49[I] 53[S] 20[ ] 49[I] 53[S] 20[ ] \nchrdev_fw:dump_data: 41[A] 20[ ] 44[D] 55[U] 4d[M] 4d[M] 59[Y] 20[ ] \nchrdev_fw:dump_data: 46[F] 49[I] 52[R] 4d[M] 57[W] 41[A] 52[R] 45[E] \nchrdev_fw:dump_data: 20[ ] 46[F] 4f[O] 52[R] 20[ ] 43[C] 48[H] 52[R] \nchrdev_fw:dump_data: 44[D] 45[E] 56[V] 20[ ] 44[D] 45[E] 56[V] 49[I] \nchrdev_fw:dump_data: 43[C] 45[E] 0a[-] \nchrdev chrdev-fw@0: chrdev chrdev-fw with id 0 added\n```", "```\n--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n@@ -41,6 +41,11 @@\n              3300000 0x0>;\n          enable-active-high;\n      };\n+\n+     chrdev {\n+         compatible = \"ldddc,chrdev-fw_nowait\";\n+         firmware = \"chrdev-nowait\";\n+     };\n };\n\n /* J9 */\n```", "```\n# insmod chrdev.ko \nchrdev: loading out-of-tree module taints kernel.\nchrdev:chrdev_init: got major 239\n# insmod chrdev-fw.ko \nchrdev-fw chrdev: Direct firmware load for chrdev-nowait-1.0.0.bin failed with error -2\nchrdev-fw chrdev: Falling back to syfs fallback for: chrdev-nowait-1.0.0.bin\nchrdev chrdev-fw@0: chrdev chrdev-fw with id 0 added\n```", "```\n# ls /sys/class/firmware/\nchrdev-nowait-1.0.0.bin  timeout\n```", "```\n# ls /sys/class/firmware/chrdev-nowait-1.0.0.bin\ndata  device  loading  power  subsystem  uevent\n```", "```\n# echo 1 > /sys/class/firmware/chrdev-nowait-1.0.0.bin/loading \n# echo \"THIS IS A DUMMY FIRMWARE\" > /sys/class/firmware/chrdev-nowait-1.0.0.bin/data \n# echo 0 > /sys/class/firmware/chrdev-nowait-1.0.0.bin/loading\nchrdev-fw chrdev: firmware callback executed!\nchrdev_fw:dump_data: 54[T] 48[H] 49[I] 53[S] 20[ ] 49[I] 53[S] 20[ ] \nchrdev_fw:dump_data: 41[A] 20[ ] 44[D] 55[U] 4d[M] 4d[M] 59[Y] 20[ ] \nchrdev_fw:dump_data: 46[F] 49[I] 52[R] 4d[M] 57[W] 41[A] 52[R] 45[E] \nchrdev_fw:dump_data: 0a[-] \n```", "```\n# ls /sys/bus/platform/drivers/mvebu-uart/\nd0012000.serial  uevent\n# ls /sys/bus/platform/drivers/mvebu-uart/d0012000.serial/tty/\nttyMV0\n```", "```\n# cat /sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-p\ninctrl/pinmux-pins \nPinmux settings per pin\nFormat: pin (name): mux_owner gpio_owner hog?\npin 0 (GPIO1-0): (MUX UNCLAIMED) (GPIO UNCLAIMED)\npin 1 (GPIO1-1): (MUX UNCLAIMED) (GPIO UNCLAIMED)\npin 2 (GPIO1-2): (MUX UNCLAIMED) (GPIO UNCLAIMED)\npin 3 (GPIO1-3): (MUX UNCLAIMED) GPIO1:479\npin 4 (GPIO1-4): (MUX UNCLAIMED) GPIO1:480\npin 5 (GPIO1-5): (MUX UNCLAIMED) (GPIO UNCLAIMED)\n...\npin 24 (GPIO1-24): (MUX UNCLAIMED) (GPIO UNCLAIMED)\npin 25 (GPIO1-25): d0012000.serial (GPIO UNCLAIMED) function uart group uart1\npin 26 (GPIO1-26): d0012000.serial (GPIO UNCLAIMED) function uart group uart1\npin 27 (GPIO1-27): (MUX UNCLAIMED) (GPIO UNCLAIMED)\n...\n```", "```\n--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n@@ -97,6 +97,13 @@\n    status = \"okay\";\n };\n\n+/* Exported on extension connector P9 at pins 24(UA2_TXD) and 26(UA2_RXD) */\n+&uart1 {\n+   pinctrl-names = \"default\";\n+   pinctrl-0 = <&uart2_pins>;\n+   status = \"okay\";\n+};\n+\n /*\n  * Connector J17 and J18 expose a number of different features. Some pins are\n  * multiplexed. This is the case for instance for the following features:\n```", "```\n    uart2_pins: uart2-pins {\n        groups = \"uart2\";\n        function = \"uart\";\n    };\n```", "```\n# ls /sys/bus/platform/drivers/mvebu-uart/\nd0012000.serial d0012200.serial uevent\n# ls /sys/bus/platform/drivers/mvebu-uart/d0012200.serial/tty/\nttyMV1\n```"]