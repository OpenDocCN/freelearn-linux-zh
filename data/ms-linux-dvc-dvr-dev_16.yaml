- en: '*Chapter 13*: Watchdog Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：看门狗设备驱动程序'
- en: A watchdog is a hardware (sometimes emulated by software) device intended to
    ensure the availability of a given system. It helps make sure that the system
    always reboots upon a critical hang, thus allowing to monitor the "normal" behavior
    of the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗是一种旨在确保给定系统可用性的硬件（有时由软件模拟）设备。它有助于确保系统在关键挂起时始终重新启动，从而允许监视系统的“正常”行为。
- en: 'Whether it is hardware-based or emulated by software, the watchdog is, most
    of the time, nothing but a timer initialized with a reasonable timeout that should
    be periodically refreshed by software running on the monitored system. If for
    any reason the software stops/fails at refreshing the timer (and has not explicitly
    shut it down) before it expires (it runs to timeout), this will trigger a (hardware)
    reset of the whole system (the computer, in our case). Such a mechanism can even
    help with recovering from a kernel panic. By the end of this chapter, you will
    be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是基于硬件还是由软件模拟，看门狗大多数情况下只是一个使用合理超时初始化的定时器，应该由受监视系统上运行的软件定期刷新。如果由于任何原因软件在超时之前停止/失败刷新定时器（并且没有明确关闭它），这将触发整个系统（在我们的情况下是计算机）的（硬件）复位。这种机制甚至可以帮助从内核恐慌中恢复。在本章结束时，您将能够做到以下事情：
- en: Read/understand an existing watchdog kernel driver and use what it exposes in
    user space.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读/理解现有的看门狗内核驱动程序，并在用户空间使用其提供的功能。
- en: Write new watchdog device drivers.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写新的看门狗设备驱动程序。
- en: Master some not-so-well-known concepts, such as *watchdog governor* and *pretimeout*.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握一些不太为人知的概念，如*看门狗管理器*和*预超时*。
- en: 'In this chapter, we will also address the concepts behind the Linux kernel
    watchdog subsystem with the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将讨论Linux内核看门狗子系统背后的概念，包括以下主题：
- en: Watchdog data structures and APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看门狗数据结构和API
- en: The watchdog user space interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看门狗用户空间接口
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start walking through this chapter, the following elements are required:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始阅读本章之前，需要以下元素：
- en: C programming skills
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C编程技能
- en: Basic electronics knowledge
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本电子知识
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获取
- en: Watchdog data structures and APIs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看门狗数据结构和API
- en: 'In this section, we will walk through the watchdog framework and learn how
    it works under the hood. The watchdog subsystem has a few data structures. The
    main one is `struct watchdog_device`, which is the Linux kernel representation
    of a watchdog device, containing all the information about it. It is defined in
    `include/linux/watchdog.h`, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究看门狗框架，并了解其在底层的工作原理。看门狗子系统有一些数据结构。主要的是`struct watchdog_device`，它是Linux内核对看门狗设备的表示，包含有关它的所有信息。它在`include/linux/watchdog.h`中定义如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are descriptions of the fields in this data structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此数据结构中字段的描述：
- en: '`id`: The watchdog''s ID allocated by the kernel during the device registration.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：内核在设备注册期间分配的看门狗ID。'
- en: '`parent`: Represents the parent for this device.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：表示此设备的父级。'
- en: '`info`: This `struct watchdog_info` structure pointer provides some additional
    information about the watchdog timer itself. This is the structure that is returned
    to the user when calling the `WDIOC_GETSUPPORT` ioctl on the watchdog char device
    in order to retrieve its capabilities. We will introduce this structure later
    in detail.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：此`struct watchdog_info`结构指针提供有关看门狗定时器本身的一些附加信息。这是在看门狗字符设备上调用`WDIOC_GETSUPPORT`
    ioctl以检索其功能时返回给用户的结构。我们稍后将详细介绍此结构。'
- en: '`ops`: A pointer to the list of watchdog operations. Once again, we will introduce
    this data structure later.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`：指向看门狗操作列表的指针。我们稍后将介绍这个数据结构。'
- en: '`gov`: A pointer to the watchdog pretimeout governor. A governor is nothing
    but a policy manager that reacts according to certain events or system parameters.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gov`：指向看门狗预超时管理器的指针。管理器只是根据某些事件或系统参数做出反应的策略管理器。'
- en: '`bootstatus`: The status of the watchdog device at boot. This is a bitmask
    of reasons that triggered the system reset. Possible values will be enumerated
    later when describing the `struct watchdog_info` structure.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstatus`：引导时看门狗设备的状态。这是触发系统复位的原因的位掩码。在描述`struct watchdog_info`结构时将枚举可能的值。'
- en: '`timeout`: This is the watchdog device''s timeout value in seconds.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：这是看门狗设备的超时值（以秒为单位）。'
- en: '`pretimeout`: The concept of *pretimeout* can be explained as an event that
    occurs sometime before the real timeout occurs, so if the system is in an unhealthy
    state, it triggers an interrupt before the real timeout reset. These interrupts
    are usually non-maskable ones (`pretimeout` field is actually the time interval
    (the number of seconds) before triggering the real timeout''s interrupt. This
    is not the number of seconds until the pretimeout. As an example, if you set the
    timeout to `60` seconds and the pretimeout to `10`, you''ll have the pretimeout
    event triggered in `50` seconds. Setting a pretimeout to `0` disables it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretimeout`：*预超时*的概念可以解释为在真正的超时发生之前的某个时间发生的事件，因此，如果系统处于不健康状态，它会在真正的超时复位之前触发中断。这些中断通常是不可屏蔽的（`pretimeout`字段实际上是触发真正超时中断之前的时间间隔（以秒为单位）。这不是直到预超时的秒数。例如，如果将超时设置为`60`秒，预超时设置为`10`，则预超时事件将在`50`秒触发。将预超时设置为`0`会禁用它。'
- en: '`min_timeout` and `max_timeout` are, respectively, the watchdog device''s minimum
    and maximum timeout values (in seconds). These are actually the lower and upper
    bounds for a valid timeout range. If the values are 0, then the framework will
    leave a check for the watchdog driver itself.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_timeout`和`max_timeout`分别是看门狗设备的最小和最大超时值（以秒为单位）。这实际上是一个有效超时范围的下限和上限。如果值为0，则框架将留下一个检查看门狗驱动程序本身。'
- en: '`wd_data`: A pointer to the watchdog core internal data. This field must be
    accessed via the `watchdog_set_drvdata()` and `watchdog_get_drvdata()` helpers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wd_data`：指向看门狗核心内部数据的指针。这个字段必须通过`watchdog_set_drvdata()`和`watchdog_get_drvdata()`助手来访问。'
- en: '`status` is a field that contains the device''s internal status bits. Possible
    values are listed here:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status` 是一个包含设备内部状态位的字段。可能的值在这里列出：'
- en: '--`WDOG_ACTIVE`: Tells whether the watchdog is running/active.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDOG_ACTIVE`：告诉看门狗是否正在运行/活动。
- en: '--`WDOG_NO_WAY_OUT`: Informs whether the `nowayout` feature is set. You can
    use `watchdog_set_nowayout()` to set the `nowayout` feature; its signature is
    `void watchdog_set_nowayout(struct watchdog_device *wdd, bool nowayout)`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDOG_NO_WAY_OUT`：通知是否设置了`nowayout`特性。您可以使用`watchdog_set_nowayout()`来设置`nowayout`特性；它的签名是`void
    watchdog_set_nowayout(struct watchdog_device *wdd, bool nowayout)`。
- en: '--`WDOG_STOP_ON_REBOOT`: Should be stopped on reboot.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDOG_STOP_ON_REBOOT`：应该在重启时停止。
- en: '--`WDOG_HW_RUNNING`: Informs that the hardware watchdog is running. You can
    use the `watchdog_hw_running()` helper to check whether this flag is set or not.
    However, you should set this flag on the success path of the watchdog''s start
    function (or in the probe function if for any reason you start it there or you
    discover that the watchdog is already started). You can use the `set_bit()` helper
    for this.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDOG_HW_RUNNING`：通知硬件看门狗正在运行。您可以使用`watchdog_hw_running()`助手来检查这个标志是否设置。但是，您应该在看门狗启动函数的成功路径上设置这个标志（或者在探测函数中，如果由于任何原因您在那里启动它或者发现看门狗已经启动）。您可以使用`set_bit()`助手来实现这一点。
- en: '--`WDOG_STOP_ON_UNREGISTER`: Specifies that the watchdog should be stopped
    on unregistration. You can use the `watchdog_stop_on_unregister()` helper to set
    this flag.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDOG_STOP_ON_UNREGISTER`：指定看门狗在注销时应该停止。您可以使用`watchdog_stop_on_unregister()`助手来设置这个标志。
- en: 'As we introduced it previously, let''s delve in detail into the `struct watchdog_info`
    structure, defined in `include/uapi/linux/watchdog.h`, actually, because it is
    part of the user space API:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前介绍的，让我们详细了解`struct watchdog_info`结构，在`include/uapi/linux/watchdog.h`中定义，实际上，因为它是用户空间API的一部分：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This structure is also the one returned to the user space on the success path
    of the `WDIOC_GETSUPPORT` ioctl. In this structure, the fields have the following
    meanings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构也是在`WDIOC_GETSUPPORT`ioctl的成功路径上返回给用户空间的。在这个结构中，字段的含义如下：
- en: '`options` represents the supported capabilities of the card/driver. It is a
    bitmask of the capabilities supported by the watchdog device/driver since some
    watchdog cards offer more than just a countdown. Some of these flags may also
    be set in the `watchdog_device.bootstatus` field in response to the `GET_BOOT_STATUS`
    ioctl. These flags are listed as follows, with dual explanations given where necessary:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options` 代表了卡片/驱动程序支持的能力。它是由看门狗设备/驱动程序支持的能力的位掩码，因为一些看门狗卡片提供的不仅仅是一个倒计时。这些标志中的一些也可以在`watchdog_device.bootstatus`字段中设置，以响应`GET_BOOT_STATUS`ioctl。这些标志如下列出，必要时给出双重解释：'
- en: --`WDIOF_SETTIMEOUT` means the watchdog device can have its timeout set. If
    this flag is set, then a `set_timeout` callback has to be defined.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_SETTIMEOUT`表示看门狗设备可以设置超时。如果设置了这个标志，那么必须定义一个`set_timeout`回调。
- en: --`WDIOF_MAGICCLOSE` means the driver supports the magic close char feature.
    As the closing of the watchdog char device file does not stop the watchdog, this
    feature means writing a *V* character (also called a magic character or magic
    *V*) sequence in this watchdog file will allow the next close to turn off the
    watchdog (if `nowayout` is not set).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_MAGICCLOSE`表示驱动程序支持魔术关闭字符功能。由于关闭看门狗字符设备文件不会停止看门狗，这个功能意味着在这个看门狗文件中写入一个*V*字符（也称为魔术字符或魔术*V*）序列将允许下一个关闭关闭看门狗（如果没有设置`nowayout`）。
- en: --`WDIOF_POWERUNDER` means the device can monitor/detect bad powers or power
    faults.. When set in `watchdog_device.bootstatus`, this flag means that it is
    the fact that the machine showed an under-voltage that triggered the reset.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_POWERUNDER`表示设备可以监视/检测不良电源或电源故障。当在`watchdog_device.bootstatus`中设置时，这个标志意味着机器显示了欠压触发了重置。
- en: --`WDIOF_POWEROVER`, on the other hand, means the device can monitor the operating
    voltage. When set in `watchdog_device.bootstatus`, it means the system reset may
    be due to an over-voltage status. Note that if one level is under and one over,
    both bits will be set.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: --另一方面，`WDIOF_POWEROVER`表示设备可以监视操作电压。当在`watchdog_device.bootstatus`中设置时，这意味着系统重置可能是由于过压状态。请注意，如果一个级别低于另一个级别，两个位都将被设置。
- en: --`WDIOF_OVERHEAT` means the watchdog device can monitor the chip/SoC temperature.
    When set in `watchdog_device.bootstatus`, it means the reason for the last machine
    reboot via the watchdog was due to exceeding the thermal limit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_OVERHEAT`表示看门狗设备可以监视芯片/SoC温度。当在`watchdog_device.bootstatus`中设置时，这意味着通过看门狗导致的上次机器重启的原因是超过了热限制。
- en: --`WDIOF_FANFAULT` informs us that this watchdog device can monitor the fan.
    When set, it means a system fan monitored by the watchdog card has failed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_FANFAULT`告诉我们这个看门狗设备可以监视风扇。当设置时，意味着看门狗卡监视的系统风扇已经失败。
- en: Some devices even have separate event inputs. If defined, electrical signals
    are present on these inputs, which also leads to a reset. This is the aim of `WDIOF_EXTERN1`
    and `WDIOF_EXTERN2`. When set in `watchdog_device.bootstatus`, it means the machine
    was last rebooted because of an external relay/source 1 or 2.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备甚至有单独的事件输入。如果定义了，这些输入上存在电信号，这也会导致重置。这就是`WDIOF_EXTERN1`和`WDIOF_EXTERN2`的目的。当在`watchdog_device.bootstatus`中设置时，这意味着机器上次重启是因为外部继电器/源1或2。
- en: --`WDIOF_PRETIMEOUT` means this watchdog device supports a pretimeout feature.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_PRETIMEOUT`表示这个看门狗设备支持预超时功能。
- en: --`WDIOF_KEEPALIVEPING` means this driver supports the `WDIOC_KEEPALIVE` ioctl
    (it can be pinged via an ioctl); otherwise, the ioctl will return `-EOPNOTSUPP`.
    When set in `watchdog_device.bootstatus`, this flag means the watchdog saw a keep-alive
    ping since it was last queried.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_KEEPALIVEPING`表示此驱动程序支持`WDIOC_KEEPALIVE` ioctl（可以通过ioctl进行ping）；否则，ioctl将返回`-EOPNOTSUPP`。当在`watchdog_device.bootstatus`中设置时，此标志表示自上次查询以来看门狗看到了一个保持活动的ping。
- en: '--`WDIOF_CARDRESET`: This is a special flag that may appear in `watchdog_device.bootstatus`
    only. It means the last reboot was caused by the watchdog itself (its timeout,
    actually).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: --`WDIOF_CARDRESET`：这是一个特殊标志，只能出现在`watchdog_device.bootstatus`中。它表示最后一次重启是由看门狗本身引起的（实际上是由它的超时引起的）。
- en: '`firmware_version` is the firmware version of the card.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firmware_version`是卡的固件版本。'
- en: '`identity` should be a string describing the device.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`应该是描述设备的字符串。'
- en: 'The other data structure without which nothing is possible is `struct watchdog_ops`,
    defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个没有这个结构就无法实现任何操作的是`struct watchdog_ops`，定义如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding structure contains the list of operations allowed on the watchdog
    device. Each operation''s meaning is presented in the following descriptions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构包含了在看门狗设备上允许的操作列表。每个操作的含义在以下描述中呈现：
- en: '`start` and `stop`: These are mandatory operations that, respectively, start
    and stop the watchdog.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`和`stop`：这些是强制操作，分别启动和停止看门狗。'
- en: A `ping` callback is used to send a keep-alive ping to the watchdog. This method
    is optional. If not defined, then the watchdog will be restarted via the `.start`
    operation, as it would mean that the watchdog does not have its own ping method.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`回调用于向看门狗发送保持活动的ping。这个方法是可选的。如果没有定义，那么看门狗将通过`.start`操作重新启动，因为这意味着看门狗没有自己的ping方法。'
- en: '`status` is an optional routine that returns the status of the watchdog device.
    If defined, its return value will be sent in response to a `WDIOC_GETBOOTSTATUS`
    ioctl.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`是一个可选的例程，返回看门狗设备的状态。如果定义了，其返回值将作为响应`WDIOC_GETBOOTSTATUS` ioctl发送。'
- en: '`set_timeout` is the callback to set the watchdog timeout value (in seconds).
    If defined, you should also set the `X` option flag; otherwise, any attempt to
    set the timeout will result in an `-EOPNOTSUPP` error.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_timeout`是设置看门狗超时值（以秒为单位）的回调。如果定义了，还应该设置`X`选项标志；否则，任何尝试设置超时都将导致`-EOPNOTSUPP`错误。'
- en: '`set_pretimeout` is the callback to set the pretimeout. If defined, you should
    also set the `WDIOF_PRETIMEOUT` option flag; otherwise, any attempt to set the
    pretimeout will result in an `-EOPNOTSUPP` error.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_pretimeout`是设置预超时的回调。如果定义了，还应该设置`WDIOF_PRETIMEOUT`选项标志；否则，任何尝试设置预超时都将导致`-EOPNOTSUPP`错误。'
- en: '`get_timeleft` is an optional operation that returns the number of seconds
    left before a reset.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_timeleft`是一个可选操作，返回重置前剩余的秒数。'
- en: '`restart`: This is actually the routine to restart the machine (not the watchdog
    device). If set, you may want to call `watchdog_set_restart_priority()` on the
    watchdog device in order to set the priority of this restart handler prior to
    registering the watchdog with the system.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：实际上是重新启动机器的例程（而不是看门狗设备）。如果设置了，您可能希望在注册看门狗设备之前调用`watchdog_set_restart_priority()`来设置此重启处理程序的优先级。'
- en: '`ioctl`: You should not implement this callback unless you have to – for example,
    if you need to handle extra/non-standard ioctl commands. If defined, this method
    will override the watchdog core default ioctl, unless it returns `-ENOIOCTLCMD`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl`：除非必须，否则不应该实现此回调函数，例如，如果您需要处理额外/非标准的ioctl命令。如果定义了此方法，它将覆盖看门狗核心默认的ioctl，除非它返回`-ENOIOCTLCMD`。'
- en: This structure contains the callback functions supported by the device according
    to its capabilities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含了设备支持的回调函数，根据其能力。
- en: Now that we are familiar with the data structures, we can switch to watchdog
    APIs and particularly see how to register and unregister such a device with the
    system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了数据结构，我们可以转向看门狗API，特别是看如何在系统中注册和注销这样一个设备。
- en: Registering/unregistering a watchdog device
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册/注销看门狗设备
- en: 'The watchdog framework provides two elementary functions to register/unregister
    watchdog devices with the system. These are `watchdog_register_device()` and `watchdog_unregister_device()`,
    and their respective prototypes are the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗框架提供了两个基本函数来在系统中注册/注销看门狗设备。这些函数分别是`watchdog_register_device()`和`watchdog_unregister_device()`，它们的原型如下：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding registration method returns zero on a success path or a negative
    *errno* code on failure. On the other hand, `watchdog_unregister_device()` performs
    the reverse operation. In order to no longer bother with unregistration, you can
    use the managed version of this function, `devm_watchdog_register_device`, whose
    prototype is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注册方法在成功路径上返回零，或者在失败时返回一个负的*errno*代码。另一方面，`watchdog_unregister_device()`执行相反的操作。为了不再烦恼注销，您可以使用此函数的托管版本`devm_watchdog_register_device`，其原型如下：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding managed version will automatically handle unregistration on driver
    detach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的托管版本将在驱动程序分离时自动处理注销。
- en: 'The registration method (whatever it is, managed or not) will check whether
    the `wdd->ops->restart` function is provided and will register this method as
    a restart handler. Thus, prior to registering the watchdog device with the system,
    the driver should set the restart priority using the `watchdog_set_restart_priority()`
    helper, knowing that the priority value of the restart handler should follow the
    following guidelines:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注册方法（无论是托管还是非托管）都将检查是否提供了`wdd->ops->restart`函数，并将此方法注册为重启处理程序。因此，在向系统注册看门狗设备之前，驱动程序应该使用`watchdog_set_restart_priority()`助手来设置重启优先级，知道重启处理程序的优先级值应遵循以下准则：
- en: '`0`: This is the lowest priority, which means using the watchdog''s restart
    function as a last resort; that is, when there is no other restart handler provided
    in the system.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这是最低优先级，意味着作为最后手段使用看门狗的重启功能；也就是说，在系统中没有提供其他重启处理程序时。'
- en: '`128`: This is the default priority, and means using this restart handler by
    default if no other handler is expected to be available and/or if a restart is
    sufficient to restart the entire system.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128`：这是默认优先级，意味着如果没有其他处理程序可用，或者如果重新启动足以重新启动整个系统，则默认使用此重新启动处理程序。'
- en: '`255`: This is the highest priority, preempting all other handlers.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255`：这是最高优先级，可以抢占所有其他处理程序。'
- en: 'The device registration should be done only after you have dealt with all the
    elements we have discussed; that is, after providing the valid `.info`, `.ops`,
    and timeout-related fields of the watchdog device. Prior to all this, memory space
    should be allocated for the `watchdog_device` structure. Wrapping this structure
    in a bigger and per-driver data structure is good practice, as shown in the following
    example, which is an excerpt from `drivers/watchdog/imx2_wdt.c`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设备注册应该在您处理了我们讨论的所有元素之后才能完成；也就是说，在为看门狗设备提供有效的`.info`、`.ops`和与超时相关的字段之后。在所有这些之前，应为`watchdog_device`结构分配内存空间。将此结构包装在更大的、每个驱动程序数据结构中是一个好的做法，如下面的示例所示，这是从`drivers/watchdog/imx2_wdt.c`中摘录的：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see how the watchdog device data structure is embedded in a bigger
    structure, `struct imx2_wdt_device`. Now comes the `probe` method, which initializes
    everything and sets the watchdog device in the bigger structure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到看门狗设备数据结构嵌入在一个更大的结构`struct imx2_wdt_device`中。现在是`probe`方法，它初始化所有内容并在更大的结构中设置看门狗设备：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Additionally, the bigger structure can be used in the `move` method to track
    the device state, and particularly the watchdog data structure embedded inside.
    This is what the preceding code excerpt highlights.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更大的结构可以在“move”方法中用于跟踪设备状态，特别是内嵌在其中的看门狗数据结构。这就是前面的代码摘录所突出的内容。
- en: So far, we have dealt with watchdog basics, walked through the base data structures,
    and described the main APIs. Now, we can learn about fancy features such as pretimeouts
    and governors in order to define the behavior of the system upon the watchdog
    event.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了看门狗的基础知识，走过了基本数据结构，并描述了主要的API。现在，我们可以了解一些高级功能，比如预超时和管理者，以定义系统在看门狗事件发生时的行为。
- en: Handling pretimeouts and governors
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理预超时和管理者
- en: The concept of *governor* appears in several subsystems in the Linux kernel
    (thermal governors, CPUFreq governors, and now watchdog governors). It is nothing
    but a driver that implements policy management (sometimes in the form of an algorithm)
    that reacts to some states/events of the system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，*管理者*的概念出现在几个子系统中（热管理管理者、CPU频率管理者，现在是看门狗管理者）。它只是一个实现策略管理（有时以算法的形式）的驱动程序，对系统的某些状态/事件做出反应。
- en: The way each subsystem implements its governor drivers may be different from
    other subsystems, but the main idea remains the same. Moreover, governors are
    identified by a unique name and the governor (policy manager) in use. They may
    be changed on the fly, most often from within the sysfs interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子系统实现其管理者驱动程序的方式可能与其他子系统不同，但主要思想仍然是相同的。此外，管理者由唯一名称和正在使用的管理者（策略管理器）标识。它们通常可以在sysfs接口内部进行动态更改。
- en: 'Now, back to watchdog pretimeouts and governors. Support for them can be added
    to the Linux kernel by enabling the `CONFIG_WATCHDOG_PRETIMEOUT_GOV` kernel config
    option. There are actually two watchdog governor drivers in the kernel: `drivers/watchdog/pretimeout_noop.c`
    and `drivers/watchdog/pretimeout_panic.c`. Their unique names are, respectively,
    `noop` and `panic`. Either can be used by default by enabling `CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP`
    or `CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_PANIC`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到看门狗预超时和管理者。可以通过启用`CONFIG_WATCHDOG_PRETIMEOUT_GOV`内核配置选项向Linux内核添加对它们的支持。实际上，内核中有两个看门狗管理者驱动程序：`drivers/watchdog/pretimeout_noop.c`和`drivers/watchdog/pretimeout_panic.c`。它们的唯一名称分别是`noop`和`panic`。可以通过启用`CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP`或`CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_PANIC`来默认使用其中任何一个。
- en: 'The main goal of this section is to deliver the pretimeout event to the watchdog
    governor that is currently active. This can be achieved by means of the `watchdog_notify_pretimeout()`
    interface, which has the following prototype:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要目标是将预超时事件传递给当前活动的看门狗管理者。这可以通过`watchdog_notify_pretimeout()`接口来实现，其原型如下：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we have discussed, some watchdog devices generate an IRQ in response to a
    pretimeout event. The main idea is to call `watchdog_notify_pretimeout()` from
    within this IRQ handler. Under the hood, this interface will internally find the
    watchdog governor (by looking for its name in the global list of watchdog governors
    registered with the system) and call its `.pretimeout` callback.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，一些看门狗设备在预超时事件发生时会生成一个中断请求。主要思想是在此中断处理程序中调用`watchdog_notify_pretimeout()`。在底层，此接口将在全局注册的看门狗管理者列表中查找其名称，并调用其`.pretimeout`回调。
- en: 'Just for your information, the following is what a watchdog governor structure
    looks like (you can find more information on watchdog governor drivers by looking
    at the source in `drivers/watchdog/pretimeout_noop.c` or `drivers/watchdog/pretimeout_panic.c`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了您的信息，以下是看门狗管理者结构的样子（您可以通过查看`drivers/watchdog/pretimeout_noop.c`或`drivers/watchdog/pretimeout_panic.c`中的源代码来了解更多关于看门狗管理者驱动程序的信息）：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Obviously, its fields have to be filled in by the underlying watchdog governor
    driver. For the real usage of a pretimeout notification, you can refer to the
    IRQ handler of the i.MX6 watchdog driver, defined in `drivers/watchdog/imx2_wdt.c`.
    An excerpt of this was shown earlier in the previous section. There, you will
    notice that `watchdog_notify_pretimeout()` gets called from within the watchdog
    (the pretimeout, actually) IRQ handler. Moreover, you will notice that the driver
    uses a different `watchdog_info` structure depending on whether there is a valid
    IRQ for the watchdog. If there is a valid one, the structure with the `WDIOF_PRETIMEOUT`
    flag set in `.options` is used, meaning that the device has a pretimeout feature.
    Otherwise, it uses the structure without the `WDIOF_PRETIMEOUT` flag set.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，其字段必须由底层看门狗管理器驱动程序填充。对于预超时通知的实际使用，您可以参考`drivers/watchdog/imx2_wdt.c`中定义的i.MX6看门狗驱动程序的IRQ处理程序。在前一节中已经显示了部分内容。在那里，您会注意到`watchdog_notify_pretimeout()`是从看门狗（实际上是预超时）IRQ处理程序中调用的。此外，您会注意到，驱动程序根据看门狗是否有有效的IRQ使用不同的`watchdog_info`结构。如果有有效的IRQ，将使用`.options`中设置了`WDIOF_PRETIMEOUT`标志的结构，这意味着设备具有预超时功能。否则，它将使用未设置`WDIOF_PRETIMEOUT`标志的结构。
- en: Now that we are familiar with the concept of governor and pretimeout, we can
    think about learning an alternative way of implementing watchdogs, such as GPIO-based
    ones.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了管理器和预超时的概念，我们可以考虑学习实现看门狗的另一种方法，例如基于GPIO的方法。
- en: GPIO-based watchdogs
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于GPIO的看门狗
- en: Sometimes, it may be better to use an external watchdog device instead of the
    one provided by the SoC itself, such as for power efficiency reasons, for example,
    as there are SoCs whose internal watchdog requires much more power than external
    ones. Most of the time, if not always, this kind of external watchdog device is
    controlled through a GPIO line and has the possibility to reset the system. It
    is pinged by toggling the GPIO line to which it is connected. This kind of configuration
    is used in UDOO QUAD (not checked on other UDOO variants).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用外部看门狗设备可能比使用SoC本身提供的看门狗更好，例如出于功耗效率的原因，因为有些SoC的内部看门狗需要比外部看门狗更多的功率。大多数情况下，这种外部看门狗设备是通过GPIO线控制的，并且具有重置系统的可能性。它通过切换连接的GPIO线来进行ping操作。这种配置在UDOO
    QUAD中使用（未在其他UDOO变体上进行检查）。
- en: The Linux kernel is able to handle this device by enabling the `CONFIG_GPIO_WATCHDOG
    config` option, which will pull the underlying driver, `drivers/watchdog/gpio_wdt.c`.
    If enabled, it will periodically *ping* the hardware connected to the GPIO line
    by toggling it from `1-to-0-to-1`. If that hardware does not receive its ping
    periodically, it will reset the system. You should use this instead of talking
    directly to the GPIOs using sysfs; it offers a better sysfs user space interface
    than the GPIO and it integrates with kernel frameworks better than your user space
    code could.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核能够通过启用`CONFIG_GPIO_WATCHDOG config`选项来处理此设备，这将拉取底层驱动程序`drivers/watchdog/gpio_wdt.c`。如果启用，它将定期通过切换连接到GPIO线的硬件来*ping*。如果该硬件未定期接收到ping，它将重置系统。您应该使用这个而不是直接使用sysfs与GPIO进行通信；它提供了比GPIO更好的sysfs用户空间接口，并且与内核框架集成得比您的用户空间代码更好。
- en: The support for this comes from the device tree only, and better documentation
    on its binding can be found in `Documentation/devicetree/bindings/watchdog/gpio-wdt.txt`,
    obviously from within the kernel sources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种支持仅来自设备树，有关其绑定的更好文档可以在`Documentation/devicetree/bindings/watchdog/gpio-wdt.txt`中找到，显然是在内核源代码中。
- en: 'The following is a binding example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个绑定示例：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `compatible` property must always be `linux,wdt-gpio`. `gpios` is a GPIO
    specifier that controls the watchdog device. `hw_algo` should be either `toggle`
    or `level`. The former means that either low-to-high or high-to-low transitions
    should be used to ping the external watchdog device, and that the watchdog is
    disabled when the GPIO line is left floating or connected to a three-state buffer.
    To achieve this, configuring the GPIO as input is sufficient. The second `algo`
    means that applying a signal level (high or low) is enough to ping the watchdog.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`compatible`属性必须始终为`linux,wdt-gpio`。`gpios`是控制看门狗设备的GPIO指定器。`hw_algo`应为`toggle`或`level`。前者意味着可以使用低至高或高至低的转换来ping外部看门狗设备，并且当GPIO线浮空或连接到三态缓冲器时，看门狗被禁用。为了实现这一点，将GPIO配置为输入就足够了。第二个`algo`意味着应用信号电平（高或低）就足以ping看门狗。'
- en: 'The way it works is the following: when user space code pings the watchdog
    through the `/dev/watchdog` device file, the underlying driver (`gpio_wdt.c`,
    actually) will either toggle the GPIO line (`1-0-1` if `hw_algo` is `toggle`)
    or assign a specific level (high or low if `hw_algo` is `level`) on that GPIO
    line. For example, the UDOO QUAD uses `APX823-31W5`, a GPIO-controlled watchdog,
    whose event output is connected to the i.MX6 PORB line (reset line, actually).
    Its schematic is available here: [http://udoo.org/download/files/schematics/UDOO_REV_D_schematics.pdf](http://udoo.org/download/files/schematics/UDOO_REV_D_schematics.pdf).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作方式如下：当用户空间代码通过`/dev/watchdog`设备文件ping看门狗时，底层驱动程序（实际上是`gpio_wdt.c`）将切换GPIO线（如果`hw_algo`是`toggle`，则为`1-0-1`）或在该GPIO线上分配特定电平（如果`hw_algo`是`level`，则为高或低）。例如，UDOO
    QUAD使用`APX823-31W5`，一个由GPIO控制的看门狗，其事件输出连接到i.MX6 PORB线（实际上是复位线）。其原理图在这里可用：[http://udoo.org/download/files/schematics/UDOO_REV_D_schematics.pdf](http://udoo.org/download/files/schematics/UDOO_REV_D_schematics.pdf)。
- en: Now, we are done with the watchdog on the kernel side. We went through the underlying
    data structure, dealt with its APIs, introduced the concept of pretimeouts, and
    even dealt with the GPIO-based watchdog alternative. In the next section, we will
    look into user space implementation, which is a kind of consumer of the watchdog
    services.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在内核端完成了看门狗。我们已经了解了底层数据结构，处理了其API，介绍了预超时的概念，甚至处理了基于GPIO的看门狗替代方案。在接下来的部分中，我们将研究用户空间实现，这是看门狗服务的一种消费者。
- en: The watchdog user space interface
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看门狗用户空间接口
- en: On Linux-based systems, the standard user space interface to the watchdog is
    the `/dev/watchdog` file, through which a daemon will notify the kernel watchdog
    driver that the user space is still alive. The watchdog starts right after the
    file is opened, and gets pinged by periodically writing into this file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Linux的系统上，看门狗的标准用户空间接口是`/dev/watchdog`文件，通过它，守护进程将通知内核看门狗驱动程序用户空间仍然活动。文件打开后，看门狗立即启动，并通过定期写入此文件进行ping。
- en: When the notification occurs, the underlying driver will notify the watchdog
    device, which will result in resetting its timeout; the watchdog will then wait
    for yet another `timeout` duration prior to resetting the system. However, if
    for any reason the user space does not perform the notification before the timeout
    is elapsed, the watchdog will reset the system (causing a reboot). This mechanism
    provides a way to enforce the system availability. Let's start with the basics,
    learning how to start and stop the watchdog.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当通知发生时，底层驱动程序将通知看门狗设备，这将导致重置其超时；然后看门狗将等待另一个`timeout`持续时间之后才重置系统。但是，如果由于任何原因用户空间在超时之前未执行通知，看门狗将重置系统（导致重新启动）。这种机制提供了一种强制系统可用性的方法。让我们从基础知识开始，学习如何启动和停止看门狗。
- en: Starting and stopping the watchdog
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止看门狗
- en: 'The watchdog is automatically started once you open the `/dev/watchdog` device
    file, as in the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打开`/dev/watchdog`设备文件，看门狗就会自动启动，如下例所示：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Only, closing the watchdog device file does not stop it. You will be surprised
    to face a system reset after closing the file. To properly stop the watchdog,
    you will first need to write the magic character *V* into the watchdog device
    file. This instructs the kernel to turn off the watchdog next time the device
    file is closed, as shown:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 只是关闭看门狗设备文件并不能停止它。关闭文件后，您将惊讶地发现系统重置。要正确停止看门狗，您首先需要向看门狗设备文件写入魔术字符*V*。这会指示内核在下次关闭设备文件时关闭看门狗，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you''ll need to close the watchdog device file in order to stop it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要关闭看门狗设备文件以停止它：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'There is an exception when stopping the watchdog by closing the file device:
    it is when the kernel''s `CONFIG_WATCHDOG_NOWAYOUT` config option is enabled.
    When this option is enabled, the watchdog cannot be stopped at all. Hence, you
    will need to service it all the time or it will reset the system. Moreover, the
    watchdog driver should have set the `WDIOF_MAGICCLOSE` flag in its option; otherwise,
    the magic close feature won''t work.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件设备以停止看门狗时有一个例外：即内核的`CONFIG_WATCHDOG_NOWAYOUT`配置选项启用时。启用此选项后，看门狗将无法停止。因此，您需要一直对其进行服务，否则它将重置系统。此外，看门狗驱动程序应该在其选项中设置`WDIOF_MAGICCLOSE`标志；否则，魔术关闭功能将无法工作。
- en: Now that we have seen how to start and stop the watchdog, it is time to learn
    how to refresh the device in order to prevent the system from suddenly rebooting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何启动和停止看门狗，现在是时候学习如何刷新设备以防止系统突然重新启动了。
- en: Pinging/kicking the watchdog – sending keep-alive pings
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ping/kick看门狗-发送保持活动的ping
- en: 'There are two ways to kick or feed the watchdog:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以踢或喂狗：
- en: 'Writing any character into `/dev/watchdog`: A write to the watchdog device
    file is defined as a keep-alive ping. It is recommended not to write a `V` character
    at all (as it has a particular meaning), even if it is in a string.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`/dev/watchdog`写入任何字符：向看门狗设备文件写入被定义为保持活动的ping。建议根本不要写入`V`字符（因为它具有特定含义），即使它在字符串中也是如此。
- en: 'Using the `WDIOC_KEEPALIVE` ioctl, `ioctl(fd, WDIOC_KEEPALIVE,` `0);`: The
    argument to the ioctl is ignored. The watchdog driver should have set the `WDIOF_KEEPALIVEPING`
    flag in its options prior to this ioctl so that it works.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`WDIOC_KEEPALIVE` ioctl，`ioctl(fd, WDIOC_KEEPALIVE,` `0);`：忽略ioctl的参数。看门狗驱动程序应该在此ioctl之前在其选项中设置`WDIOF_KEEPALIVEPING`标志，以便其工作。
- en: It is good practice to feed the watchdog every half of its timeout value. This
    means if its timeout is `30s`, you should feed it every `15s`. Now, let's learn
    about gathering some information on how the watchdog is ruling our system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 喂狗是一个好的做法，每半个超时值喂一次狗。这意味着如果超时是`30s`，您应该每`15s`喂一次。现在，让我们了解一些关于看门狗如何管理我们的系统的信息。
- en: Getting watchdog capabilities and identity
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取看门狗能力和身份
- en: Getting the watchdog capabilities and/or identity consists of grabbing the underlying
    `struct watchdog_info` structure associated with the watchdog. If you remember,
    this info structure is mandatory and is provided by the watchdog driver.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 获取看门狗能力和/或身份包括抓取与看门狗关联的底层`struct watchdog_info`结构。如果您记得的话，这个信息结构是强制性的，并由看门狗驱动程序提供。
- en: 'To achieve this, you need to use the `WDIOC_GETSUPPORT` ioctl. The following
    is an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您需要使用`WDIOC_GETSUPPORT` ioctl。以下是一个例子：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can go further by testing some fields in the capabilities, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测试一些功能来进一步了解其能力，如下所示：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can (or should I say "must") use this in order to check the watchdog features
    prior to performing certain actions on it. Now, we can go further and learn how
    to get and set more fancy watchdog properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以（或者我应该说"必须"）使用这个来在执行某些操作之前检查看门狗的功能。现在，我们可以进一步学习如何获取和设置更多花哨的看门狗属性。
- en: Setting and getting the timeout and pretimeout
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和获取超时和预超时
- en: Prior to setting/getting the timeout, the watchdog info should have the `WDIOF_SETTIMEOUT`
    flag set. There are drivers with which it is possible to modify the watchdog timeout
    on the fly using the `WDIOC_SETTIMEOUT` ioctl. These drivers must have the `WDIOF_SETTIMEOUT`
    flag set in their watchdog info structure and provide a `.set_timeout` callback.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置/获取超时之前，看门狗信息应该设置`WDIOF_SETTIMEOUT`标志。有一些驱动程序可以使用`WDIOC_SETTIMEOUT` ioctl动态修改看门狗超时时间。这些驱动程序必须在其看门狗信息结构中设置`WDIOF_SETTIMEOUT`标志，并提供`.set_timeout`回调。
- en: 'While the argument here is an integer representing the timeout value in seconds,
    the return value is the real timeout applied to the hardware device, as it may
    differ from the one requested in the ioctl due to hardware limitations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的参数是以秒为单位表示的超时值的整数，但返回值是应用于硬件设备的实际超时，因为由于硬件限制，它可能与ioctl中请求的超时不同：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When it comes to querying the current timeout, you should use the `WDIOC_GETTIMEOUT`
    ioctl, as in the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到查询当前超时时，您应该使用`WDIOC_GETTIMEOUT`ioctl，如下例所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, when it comes to the pretimeout, the watchdog driver should have set
    `WDIOF_PRETIMEOUT` in the options and provided a `.set_pretimeout` callback in
    its ops. You should then use `WDIOC_SETPRETIMEOUT` with the pretimeout value as
    a parameter:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当涉及到预超时时，看门狗驱动程序应该在选项中设置`WDIOF_PRETIMEOUT`，并在其操作中提供`.set_pretimeout`回调。然后，您应该使用`WDIOC_SETPRETIMEOUT`，并将预超时值作为参数：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the desired pretimeout value is either `0` or bigger than the current timeout,
    you will get an `-EINVAL` error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所需的预超时值为`0`或大于当前超时，则会收到`-EINVAL`错误。
- en: Now that we have seen how to get and set the timeout/pretimeout on the watchdog
    device, we can learn how to get the time left before the watchdog fires.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何获取和设置看门狗设备的超时/预超时，我们可以学习如何获取看门狗触发之前剩余的时间。
- en: Getting the time left
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取剩余时间
- en: 'The `WDIOC_GETTIMELEFT` ioctl allows checking how much time is left on the
    watchdog counter before a reset occurs. Moreover, the watchdog driver should support
    this feature by providing a `.get_timeleft()` callback; otherwise, you''ll have
    an `EOPNOTSUPP` error. The following is an example showing how to use this ioctl:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`WDIOC_GETTIMELEFT`ioctl允许检查看门狗计数器在发生重置之前剩余多少时间。此外，看门狗驱动程序应通过提供`.get_timeleft()`回调来支持此功能；否则，您将收到`EOPNOTSUPP`错误。以下是一个示例，显示如何使用此ioctl：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `timeleft` variable is filled on the return path of the ioctl.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeleft`变量在ioctl的返回路径上填充。'
- en: Once the watchdog fires, it triggers a reboot when it is configured to do so.
    In the next section, we will learn how to get the last reboot reason, in order
    to see whether the reboot was caused by the watchdog.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦看门狗触发，它会在配置为这样做时触发重启。在下一节中，我们将学习如何获取上次重启的原因，以查看重启是否是由看门狗引起的。
- en: Getting the (boot/reboot) status
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取（引导/重新引导）状态
- en: 'There are two ioctl commands to play with in this section. These are `WDIOC_GETSTATUS`
    and `WDIOC_GETBOOTSTATUS`. The way that these are handled depends on the driver
    implementation, and there are two types of driver implementations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中有两个ioctl命令可供使用。这些是`WDIOC_GETSTATUS`和`WDIOC_GETBOOTSTATUS`。这些的处理方式取决于驱动程序的实现，并且有两种类型的驱动程序实现：
- en: Old drivers that provide watchdog features through a miscellaneous device. These
    drivers do not use the generic watchdog framework interface and provide their
    own `file_ops` along with their own `.ioctl` ops. Moreover, these drivers only
    support `WDIOC_GETSTATUS`, while others may support both `WDIOC_GETSTATUS` and
    `WDIOC_GETBOOTSTATUS`. The difference between the two is that the former will
    return the raw content of the device's status register, while the latter is supposed
    to be a bit smarter as it parses the raw content and only returns the boot status
    flag. These drivers need to be migrated to the new generic watchdog framework.Note
    that some of those drivers supporting both commands may return the same value
    (the same `case` statement) for both ioctls, while others may return a different
    one (each command has its own `case` statement).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过杂项设备提供看门狗功能的旧驱动程序。这些驱动程序不使用通用看门狗框架接口，并提供自己的`file_ops`以及自己的`.ioctl`操作。此外，这些驱动程序仅支持`WDIOC_GETSTATUS`，而其他驱动程序可能同时支持`WDIOC_GETSTATUS`和`WDIOC_GETBOOTSTATUS`。两者之间的区别在于前者将返回设备状态寄存器的原始内容，而后者应该更智能，因为它解析原始内容并仅返回引导状态标志。这些驱动程序需要迁移到新的通用看门狗框架。请注意，一些支持两个命令的驱动程序可能会为两个ioctl返回相同的值（相同的`case`语句），而其他驱动程序可能会返回不同的值（每个命令都有自己的`case`语句）。
- en: New drivers use the generic watchdog framework. These drivers rely on the framework
    and do not care about `file_ops` anymore. Everything is done from within the `drivers/watchdog/watchdog_dev.c`
    file (you can have a look, especially at how the ioctl command is implemented).
    With these kinds of drivers, `WDIOC_GETSTATUS` and `WDIOC_GETBOOTSTATUS` are handled
    by the watchdog core separately. This section will deal with these drivers.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新驱动程序使用通用看门狗框架。这些驱动程序依赖于框架，不再关心`file_ops`。一切都是从`drivers/watchdog/watchdog_dev.c`文件中完成的（您可以查看，特别是如何实现ioctl命令）。对于这类驱动程序，`WDIOC_GETSTATUS`和`WDIOC_GETBOOTSTATUS`由看门狗核心分别处理。本节将处理这些驱动程序。
- en: 'Now, let''s focus on the generic implementation. For these drivers, `WDIOC_GETBOOTSTATUS`
    will return the value of the underlying `watchdog_device.bootstatus` field. For
    `WDIOC_GETSTATUS`, if the watchdog `.status` ops is provided, it will be called
    and its return value will be copied to the user; otherwise, the content of `watchdog_device.bootstatus`
    will be tweaked with an `AND` operation in order to clear (or flag) the bits that
    are not meaningful. The following code snippet shows how it is done in kernel
    space:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于通用实现。对于这些驱动程序，`WDIOC_GETBOOTSTATUS`将返回底层`watchdog_device.bootstatus`字段的值。对于`WDIOC_GETSTATUS`，如果提供了看门狗`.status`操作，将调用它，并将其返回值复制到用户;否则，将使用`AND`操作调整`watchdog_device.bootstatus`的内容，以清除（或标记）无意义的位。以下代码片段显示了在内核空间中如何完成这项工作：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code is a generic watchdog core function to get the watchdog
    status. It is actually a wrapper that is responsible for calling the underlying
    `ops.status` callback. Now, back to our user space usage. We can do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个用于获取看门狗状态的通用看门狗核心函数。实际上，它是一个负责调用底层`ops.status`回调的包装器。现在，回到我们的用户空间使用。我们可以这样做：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Obviously, we can proceed to individual flag checking as we did earlier in the
    *Getting watchdog capabilities and identity* section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以继续像在*获取看门狗功能和身份*部分中那样进行单独的标志检查。
- en: So far, we have written code to play with the watchdog device. The next section
    will show us how to deal with the watchdog from user space without writing code,
    essentially using the sysfs interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了与看门狗设备交互的代码。下一节将向我们展示如何在用户空间处理看门狗而无需编写代码，基本上使用sysfs接口。
- en: The watchdog sysfs interface
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看门狗sysfs接口
- en: 'The watchdog framework offers the possibility of managing watchdog devices
    from user space through the sysfs interface. This is possible if the `CONFIG_WATCHDOG_SYSFS`
    config option is enabled in the kernel, and the root directory is `/sys/class/watchdogX/`.
    `X` is the index of the watchdog device in the system. Each watchdog directory
    in sysfs has the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗框架提供了通过sysfs接口从用户空间管理看门狗设备的可能性。如果内核中启用了`CONFIG_WATCHDOG_SYSFS`配置选项，并且根目录是`/sys/class/watchdogX/`，则这是可能的。`X`是系统中看门狗设备的索引。sysfs中的每个看门狗目录都具有以下内容：
- en: '`nowayout`: Gives `1` if the device supports the `nowayout` feature, and `0`
    otherwise.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nowayout`：如果设备支持`nowayout`功能，则返回`1`，否则返回`0`。'
- en: '`status`: This is the sysfs equivalent of the `WDIOC_GETSTATUS` ioctl. This
    sysfs file reports the watchdog''s internal status bits.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：这是`WDIOC_GETSTATUS`ioctl的sysfs等效项。此sysfs文件报告了看门狗的内部状态位。'
- en: '`timeleft`: This is the sysfs equivalent of the `WDIOC_GETTIMELEFT` ioctl.
    This sysfs entry returns the time (the number of seconds, actually) left before
    the watchdog resets the system.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeleft`：这是`WDIOC_GETTIMELEFT`ioctl的sysfs等效项。此sysfs条目返回在看门狗重置系统之前剩余的时间（实际上是秒数）。'
- en: '`timeout`: Gives the current value of the timeout programmed.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：给出已编程超时的当前值。'
- en: '`identity`: Contains an identity string of the watchdog device.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`：包含看门狗设备的标识字符串。'
- en: '`bootstatus`: This is the sysfs equivalent of the `WDIOC_GETBOOTSTATUS` ioctl.
    This entry informs whether the system reset was caused by the watchdog device
    or not.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstatus`：这是`WDIOC_GETBOOTSTATUS`ioctl的sysfs等效项。此条目通知系统重置是否是由看门狗设备引起的。'
- en: '`state`: Gives the active/inactive status of the watchdog device.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：给出看门狗设备的活动/非活动状态。'
- en: Now that the preceding watchdog properties have been described, we can focus
    on pretimeout management from user space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的看门狗属性已经描述了，我们可以专注于来自用户空间的预超时管理。
- en: Handling a pretimeout event
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理预超时事件
- en: Setting the governor is done via sysfs. A governor is nothing but a policy manager
    that takes certain actions depending on some external (but input) parameters.
    There are thermal governors, CPUFreq governors, and now watchdog governors. Each
    governor is implemented in its own driver.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过sysfs设置管理器。管理器只是根据一些外部（但输入）参数采取某些操作的策略管理器。有热管理器、CPUFreq管理器，现在还有看门狗管理器。每个管理器都在自己的驱动程序中实现。
- en: 'You can check the available governors for a watchdog (let''s say `watchdog0`)
    using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查看门狗（比如`watchdog0`）的可用管理器：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can check whether pretimeout governors can be selected:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查是否可以选择预超时管理器：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To check the pretimeout value, you can simply do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查预超时值，您可以简单地执行以下操作：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we are familiar with using the watchdog sysfs interface from the user space.
    Though we are not in the kernel, we can leverage the whole framework, particularly
    playing with the watchdog parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了如何从用户空间使用看门狗sysfs接口。虽然我们不在内核中，但我们可以利用整个框架，特别是与看门狗参数交互。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed all aspects of watchdog devices: their APIs,
    the GPIO alternative, and how they help keep the system reliable. We saw how to
    start, how (when it is possible) to stop, and how to service the watchdog devices.
    Moreover, we introduced the concept of pretimeout and watchdog-dedicated governors.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了看门狗设备的所有方面：它们的API、GPIO替代方案以及它们如何帮助保持系统可靠。我们看到了如何启动，如何（在可能的情况下）停止，以及如何维护看门狗设备。此外，我们介绍了预超时和专用看门狗管理器的概念。
- en: In the next chapter, we will discuss some Linux kernel development and debugging
    tips, such as analyzing kernel panic messages and kernel tracing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些Linux内核开发和调试技巧，比如分析内核恐慌消息和内核跟踪。
