- en: Writing Your First Kernel Module - LKMs Part 1
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写您的第一个内核模块 - LKMs第1部分
- en: Welcome to your journey of learning about a fundamental aspect of Linux kernel
    development – the **Loadable Kernel Module** (**LKM**) framework – and how it
    is to be used by the *module user* or *module author*, who is typically a kernel
    or device driver programmer. This topic is rather vast and hence is split into
    two chapters – this one and the next.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到您学习Linux内核开发的基本方面-**可加载内核模块**（**LKM**）框架以及如何被*模块用户*或*模块作者*使用的旅程，他通常是内核或设备驱动程序员。这个主题相当广泛，因此分为两章-这一章和下一章。
- en: In this chapter, we'll begin by taking a quick look at the basics of the Linux
    kernel architecture, which will help us to understand the LKM framework. Then,
    we'll look into why kernel modules are useful and write our own simple *Hello,
    world* LKM, build and run it. We'll see how messages are written to the kernel
    log and understand and make use of the LKM Makefile. By the end of this chapter,
    you will have learned the basics of Linux kernel architecture and the LKM framework,
    applying it to write a simple yet complete piece of kernel code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先快速了解Linux内核架构的基础知识，这将帮助我们理解LKM框架。然后，我们将探讨为什么内核模块有用，并编写我们自己的简单的*Hello,
    world* LKM，构建并运行它。我们将看到消息是如何写入内核日志的，并理解并利用LKM Makefile。到本章结束时，您将已经学会了Linux内核架构和LKM框架的基础知识，并应用它来编写一个简单但完整的内核代码。
- en: 'In this chapter, we cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下内容：
- en: Understanding the kernel architecture – part I
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内核架构-第I部分
- en: Exploring LKMs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LKMs
- en: Writing our very first kernel module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个内核模块
- en: Common operations on kernel modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块的常见操作
- en: Understanding kernel logging and printk
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内核日志和printk
- en: Understanding the basics of a kernel module Makefile
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内核模块Makefile的基础知识
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you have already carefully followed [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),
    *Kernel Workspace Setup*, the technical prerequisites that follow will already
    be taken care of. (The chapter also mentions various useful open source tools
    and projects; I definitely recommend that you browse through it at least once.)
    For your convenience, we summarize some key points here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经仔细遵循了[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核工作空间设置*，随后的技术先决条件已经得到了满足。（该章还提到了各种有用的开源工具和项目；我强烈建议您至少浏览一次。）为了您的方便，我们在这里总结了一些关键点。
- en: 'To build and use a kernel module on a Linux distribution (or custom system),
    you need, at minimum, the following two components to be installed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux发行版（或自定义系统）上构建和使用内核模块，至少需要安装以下两个组件：
- en: '**A toolchain**: This includes the compiler, assembler, linker/loader, C library,
    and various other bits and pieces. If building for the local system, as we assume
    for now, then any modern Linux distribution will have a native toolchain pre-installed.
    If not, simply installing the `gcc` package for your distribution should be sufficient;
    on an Ubuntu- or Debian-based Linux system, use this:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具链**：这包括编译器、汇编器、链接器/加载器、C库和各种其他部分。如果为本地系统构建，正如我们现在假设的那样，那么任何现代Linux发行版都会预先安装本地工具链。如果没有，只需安装适用于您发行版的`gcc`软件包即可；在基于Ubuntu或Debian的Linux系统上，使用以下命令：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Kernel headers**: These headers will be used during compilation. In reality,
    you install a package geared to not only install the kernel headers but also other
    required bits and pieces (such as the kernel Makefile) onto the system. Again, any
    modern Linux distribution will/should have the kernel header pre-installed. If
    not (you can check using `dpkg(1)`, as shown here), simply install the package
    for your distribution; on an Ubuntu- or Debian-based Linux system, use this:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核头文件**：这些头文件将在编译过程中使用。实际上，您安装的软件包不仅安装内核头文件，还安装其他所需的部分（例如内核Makefile）到系统上。再次强调，任何现代Linux发行版都应该预先安装内核头文件。如果没有（您可以使用`dpkg(1)`进行检查，如下所示），只需安装适用于您发行版的软件包；在基于Ubuntu或Debian的Linux系统上，使用以下命令：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the second command using the `dpkg(1)` utility is simply used to verify
    that the `linux-headers` packages are indeed installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，使用`dpkg(1)`工具的第二个命令只是用来验证`linux-headers`软件包是否已经安装。
- en: This package may be named `kernel-headers-<ver#>` on some distributions. Also,
    for development directly on a Raspberry Pi, install the relevant kernel headers
    package named `raspberrypi-kernel-headers`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些发行版上，此软件包可能被命名为`kernel-headers-<ver#>`。此外，对于直接在树莓派上进行开发，安装名为`raspberrypi-kernel-headers`的相关内核头文件软件包。
- en: 'The entire source tree for this book is available in its GitHub repository
    at [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming),
    and the code for this chapter under the `ch4` directory. We definitely expect
    you to clone it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的整个源代码树可在其GitHub存储库中找到，网址为[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming)，本章的代码位于`ch4`目录下。我们期望您进行克隆：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code for this chapter is under its directory namesake, `chn` (where `n` is
    the chapter number; so here, it's under `ch4/`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于其目录名称下，`chn`（其中`n`是章节编号；所以在这里，它位于`ch4/`下）。
- en: Understanding kernel architecture – part 1
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内核架构-第1部分
- en: In this section, we begin to deepen our understanding of the kernel. More specifically,
    here we delve into what user and kernel spaces are and the major subsystems and
    various components that make up the Linux kernel. This information is dealt with
    at a higher level of abstraction for now and is deliberately kept brief. We shall
    delve a lot deeper into understanding the fabric of the kernel in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel
    Internals Essentials - Processes and Threads**.*
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开始加深对内核的理解。更具体地说，在这里，我们深入探讨了用户空间和内核空间以及构成Linux内核的主要子系统和各种组件。目前，这些信息在更高的抽象级别上处理，并且故意保持简洁。我们将在[第6章](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml)，*内核内部基础知识-进程和线程**.*中更深入地了解内核的结构。
- en: User space and kernel space
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户空间和内核空间
- en: Modern microprocessors support a minimum of two privilege levels. As a real-world
    example, the Intel/AMD x86[-64] family supports four privilege levels (they call
    them *ring levels*), and the ARM (32-bit) microprocessor family supports up to
    seven (ARM calls them *execution modes*; six are privileged and one is non-privileged).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代微处理器支持至少两个特权级别。以英特尔/AMD x86[-64]家族为例，支持四个特权级别（它们称之为*环级*），而ARM（32位）微处理器家族支持多达七个（ARM称之为*执行模式*；其中六个是特权的，一个是非特权的）。
- en: 'The key point here is that for security and stability on the platform, all
    modern operating systemsrunning on these processors will make use of (at least)
    two of the privilege levels (or modes):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是，为了平台的安全性和稳定性，所有运行在这些处理器上的现代操作系统都将使用（至少）两个特权级别（或模式）：
- en: '**User space**: For *applications* to run in *unprivileged user mode*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间**：*应用程序*在*非特权用户模式*下运行'
- en: '**Kernel space**: For the *kernel* (and all its components) to run in privileged
    mode – *kernel mode*'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核空间**：*内核*（及其所有组件）在特权模式下运行- *内核模式*'
- en: 'The following figure shows this basic architecture:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这种基本架构：
- en: '![](img/5d5b3064-6e8e-4b85-8ba3-26e71a262908.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5b3064-6e8e-4b85-8ba3-26e71a262908.png)'
- en: Figure 4.1 – Basic architecture – two privilege modes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1-基本架构-两个特权模式
- en: A few details on the Linux system architecture follow; do read on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是有关Linux系统架构的一些细节；请继续阅读。
- en: Library and system call APIs
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库和系统调用API
- en: 'User space applications often rely on **Application Programming Interfaces**(**APIs**) to
    perform their work. A *library* is essentially a collection or archive of APIs,
    allowing you to use a standardized, well-written, and well-tested interface (and
    leverage the usual benefits: not having to reinvent the wheel, portability, standardization,
    and so on). Linux systems have several libraries; even hundreds on enterprise-class
    systems is not uncommon. Of these, *all* usermode Linux applications (executables)
    are "auto-linked" into one important, always-used library: `glibc`* – the GNU
    standard C library*, as you shall learn. However, libraries are only ever available
    in user mode; the kernel does not have libraries (more on this in the following
    chapter).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间应用程序通常依赖于**应用程序编程接口**（**APIs**）来执行它们的工作。*库*本质上是API的集合或存档，允许您使用标准化、编写良好且经过充分测试的接口（并利用通常的好处：无需重新发明轮子、可移植性、标准化等）。Linux系统有几个库；即使在企业级系统上也不少见数百个。其中，*所有*用户模式Linux应用程序（可执行文件）都会被“自动链接”到一个重要的、始终使用的库中：`glibc`*
    - GNU标准C库*，正如您将会了解的那样。然而，库只能在用户模式下使用；内核没有库（在接下来的章节中会详细介绍）。
- en: Examples of library APIs are the well-known `printf(3)` (recall, from [Chapter
    1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel Workspace Setup*, the
    section of the man pages where this API can be found), `scanf(3)`, `strcmp(3)`,
    `malloc(3)`, and `free(3)`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 库API的示例是众所周知的`printf(3)`（回想一下，来自[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核工作空间设置*，可以找到此API的man页面部分），`scanf(3)`，`strcmp(3)`，`malloc(3)`和`free(3)`。
- en: 'Now, a key point: if user and kernel are separate address spaces and at differing
    privilege levels, how can a user process *access* the kernel? The short answer
    is *via system calls.* A **system call** is a special API, in the sense that it
    is the only legal (synchronous) way for user space processes to access the kernel.
    In other words, system calls are the only legal *entry point* into the kernel
    space. They have the ability to *switch* from non-privileged user mode to privileged
    kernel mode (more on this and the monolithic design in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel
    Internals Essentials – Processes and Threads*, under the *Process and interrupt
    contexts* section). Examples of system calls include `fork(2)`, `execve(2)`, `open(2)`,`read(2)`,
    `write(2)`, `socket(2)`, `accept(2)`, `chmod(2)`, and so on.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个关键点：如果用户和内核是分开的地址空间，并且处于不同的特权级别，用户进程如何能够*访问*内核呢？简短的答案是*通过系统调用*。**系统调用**是一种特殊的API，因为它是用户空间进程访问内核的唯一合法（同步）方式。换句话说，系统调用是进入内核空间的唯一合法*入口点*。它们有能力从非特权用户模式切换到特权内核模式（更多关于这一点和单片设计的内容请参阅[第6章](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml)，*内核内部要点-进程和线程*，在*进程和中断上下文*部分）。系统调用的示例包括`fork(2)`，`execve(2)`，`open(2)`，`read(2)`，`write(2)`，`socket(2)`，`accept(2)`，`chmod(2)`等。
- en: 'Look up all library and system call APIs in the man pages online:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在线查看所有库和系统调用API的man页面：
- en: '- Library APIs, man section 3: [https://linux.die.net/man/3/](https://linux.die.net/man/3/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '- 库API，man第3节：[https://linux.die.net/man/3/](https://linux.die.net/man/3/)'
- en: '- System call APIs, man section 2: [https://linux.die.net/man/2/](https://linux.die.net/man/2/)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '- 系统调用API，man第2节：[https://linux.die.net/man/2/](https://linux.die.net/man/2/)'
- en: The point being stressed here is that it's really only via system calls that
    user applications and the kernel communicate; that is the interface. In this book,
    we do not delve further into these details. If you are interested in knowing more,
    please refer to the book *Hands-On System Programming with Linux*, by Packt (specifically
    *Chapter 1, Linux System Architecture*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里强调的重点是，用户应用程序和内核之间实际上只能通过系统调用进行通信；这就是接口。在本书中，我们不会深入探讨这些细节。如果您对了解更多感兴趣，请参考Packt出版的书籍*《Linux系统编程实践》*，特别是*第1章，Linux系统架构*。
- en: Kernel space components
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核空间组件
- en: 'This book focuses entirely on the kernel space, of course. The Linux kernel
    today is a rather large and complex beast. Internally, it consists of a few major
    subsystems and several components. A broad enumeration of kernel subsystems and
    components yields the following list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本书完全专注于内核空间。今天的Linux内核是一个相当庞大和复杂的东西。在内部，它由几个主要子系统和几个组件组成。对内核子系统和组件的广泛枚举得到以下列表：
- en: '**Core kernel**: This code handles the typical core work of any modern operating
    system, including (user and kernel) process and thread creation/destruction, CPU
    scheduling, synchronization primitives, signaling, timers, interrupt handling,
    namespaces, cgroups, module support, crypto, and more.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心内核**：这段代码处理任何现代操作系统的典型核心工作，包括（用户和内核）进程和线程的创建/销毁，CPU调度，同步原语，信号，定时器，中断处理，命名空间，cgroups，模块支持，加密等等。'
- en: '**Memory Management (MM)**: This handles all memory-related work, including
    the setup and maintenance of kernel and process **Virtual Address Spaces** (**VASes**).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理（MM）**：这处理所有与内存相关的工作，包括设置和维护内核和进程**虚拟地址空间**（**VASes**）。'
- en: '**VFS (for filesystem support)**: The **Virtual Filesystem Switch** (**VFS**)
    is an abstraction layer over the actual filesystems implemented within the Linux
    kernel (for example, `ext[2|4]`, `vfat`, `reiserfs`, `ntfs`, `msdos`, `iso9660`,
    JFFS2, and UFS).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VFS（用于文件系统支持）**：**虚拟文件系统开关**（**VFS**）是Linux内核中实际文件系统的抽象层（例如，`ext[2|4]`，`vfat`，`reiserfs`，`ntfs`，`msdos`，`iso9660`，JFFS2和UFS）的实现。'
- en: '**Block IO**: The code paths implementing the actual file I/O, from the VFS
    right down to the block device driver and everything in between (really, quite
    a lot!), is encompassed here.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块IO**：实现实际文件I/O的代码路径，从VFS直到块设备驱动程序以及其中的所有内容（实际上，相当多！），都包含在这里。'
- en: '**Network protocol stack**: Linux is well known for its precise, to-the-letter-of-the-RFC,
    high-quality implementation of the well-known (and not-so-well-known) network
    protocols at all layers of the model, with TCP/IP being perhaps the most famous.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络协议栈**：Linux以其对模型各层的众所周知（和不那么众所周知）的网络协议的精确、高质量实现而闻名，TCP/IP可能是其中最著名的。'
- en: '**Inter-Process Communication (IPC) support**: The implementation of IPC mechanisms
    is done here; Linux supports message queues, shared memory, semaphores (both the
    older SysV and the newer POSIX ones), and other IPC mechanisms.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信（IPC）支持**：这里实现了IPC机制；Linux支持消息队列，共享内存，信号量（旧的SysV和新的POSIX），以及其他IPC机制。'
- en: '**Sound support**: All the code that implements audio is here, from the firmware
    to drivers and codecs.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声音支持**：这里包含了实现音频的所有代码，从固件到驱动程序和编解码器。'
- en: '**Virtualization support**: Linux has become extremely popular with large and
    small cloud providers alike, a big reason being its high-quality, low-footprint
    virtualization engine, **Kernel-based Virtual Machine** (**KVM**).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟化支持**：Linux已经成为大大小小的云提供商的极其受欢迎的选择，一个重要原因是其高质量、低占用的虚拟化引擎，**基于内核的虚拟机**（**KVM**）。'
- en: 'All this forms the major kernel subsystems; in addition, we have these:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些构成了主要的内核子系统；此外，我们还有这些：
- en: Arch-specific (meaning CPU-specific) code
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于体系结构（即特定于CPU）的代码
- en: Kernel initialization
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核初始化
- en: Security frameworks
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全框架
- en: Many types of device drivers
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多类型的设备驱动程序
- en: Recall that in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, the *A brief tour of the kernel source
    tree* section gave the kernel source tree (code) layout corresponding to the major
    subsystems and other components.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中，*从源代码构建5.x Linux内核
    - 第1部分*，*内核源代码树简要介绍*部分给出了与主要子系统和其他组件对应的内核源代码树（代码）布局。
- en: 'It is a well-known fact that the Linux kernel follows the **monolithic kernel
    architecture**. Essentially, a monolithic design is one in which *all* kernel
    components (that we mentioned in this section) live in and share the kernel address
    space (or kernel *segment*). This can be clearly seen in the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Linux内核遵循**单片内核架构**。基本上，单片设计是指*所有*内核组件（我们在本节中提到的）都存在并共享内核地址空间（或内核*段*）。这可以清楚地在下图中看到：
- en: '![](img/880b83aa-6e39-424c-84d5-a1904241bcac.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/880b83aa-6e39-424c-84d5-a1904241bcac.png)'
- en: Figure 4.2 – Linux kernel space - major subsystems and blocks
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - Linux内核空间 - 主要子系统和块
- en: Another fact you should be aware of is that these address spaces are of course *virtual*
    address spacesand not physical. The kernel will (leveraging hardware such as the
    MMU/TLB/caches) *map*, at the page granularity level, virtual pages to physical
    page frames. It does this by using a *master *kernel paging table to map kernel
    virtual pages to physical frames, and, for every single process that is alive,
    it maps the process's virtual pages to physical page frames via individual paging
    tables for each process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该知道的事实是，这些地址空间当然是*虚拟*地址空间，而不是物理地址空间。内核将（利用硬件，如MMU/TLB/高速缓存）*映射*，在页面粒度级别，虚拟页面到物理页面帧。它通过使用*主*内核分页表将内核虚拟页面映射到物理帧，并且对于每个存活的进程，它通过为每个进程使用单独的分页表将进程的虚拟页面映射到物理页面帧。
- en: More in-depth coverage of the essentials of the kernel and memory management
    architecture and internals awaits you in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml),
    *Kernel Internals Essentials – Processes and Threads *(and more chapters that
    follow).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml)中，*内核内部要点 - 进程和线程*（以及后续章节）中，等待您更深入地了解内核和内存管理架构和内部。
- en: Now that we have a basic understanding of the user and kernel spaces, let's
    move on and begin our journey into the LKM framework.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对用户空间和内核空间有了基本的了解，让我们继续并开始我们的LKM框架之旅。
- en: Exploring LKMs
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LKM
- en: Simply put, a kernel module is a means to provide kernel-level functionality
    without resorting to working within the kernel source tree.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，内核模块是一种提供内核级功能而不必在内核源代码树中工作的方法。
- en: 'Visualize a scenario where you have to add a support feature to the Linux kernel
    – perhaps a new device driver in order to use a certain hardware peripheral chip,
    a new filesystem, or a new I/O scheduler. One way to do this is pretty obvious:
    update the kernel source tree with the new code, build it, and test it.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情景，你必须向Linux内核添加支持功能 - 也许是为了使用某个硬件外围芯片而添加一个新的设备驱动程序，一个新的文件系统，或者一个新的I/O调度程序。一种明显的方法是：更新内核源代码树，构建并测试新代码。
- en: Though this may seem straightforward, it's actually a lot of work – every change
    in the code that we write, no matter how minor, will require us to rebuild the
    kernel image and then reboot the system in order to test it. There must be a cleaner,
    easier way; indeed there is – *the LKM framework*!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来很简单，实际上需要大量工作 - 我们编写的代码的每一次更改，无论多么微小，都需要我们重新构建内核映像，然后重新启动系统以进行测试。必须有一种更清洁、更简单的方法；事实上是有的
    - *LKM框架*！
- en: The LKM framework
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LKM框架
- en: The LKM framework is a means to compile a piece of kernel code *outside of *the
    kernel source tree, often referred to as "out-of-tree" code, keeping it independent
    from the kernel in a limited sense, and then insert it into or *plug it into* kernel
    memory, have it run and perform its job, and then remove it (or *unplug* it) from
    kernel memory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'LKM框架是一种在内核源树之外编译内核代码的方法，通常被称为“树外”代码，从某种程度上使其独立于内核，然后将其插入或*插入*到内核内存中，使其运行并执行其工作，然后将其（或*拔出*）从内核内存中移除。 '
- en: The kernel module's source code, typically consisting of one or more C source
    files, header files, and a Makefile, is built (via `make(1)`, of course) into
    a *kernel module*. The kernel module itself is merely a binary object file and
    not a binary executable. In Linux 2.4 and earlier, the kernel module's filename
    had a `.o` suffix; on modern 2.6 Linux and later, it instead has a `.ko` (**k**ernel
    **o**bject) suffix. Once built, you can insert this `.ko` file – the kernel module
    – into the live kernel at runtime, effectively making it a part of the kernel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块的源代码通常由一个或多个C源文件、头文件和一个Makefile组成，通过`make(1)`构建成一个*内核模块*。内核模块本身只是一个二进制对象文件，而不是一个二进制可执行文件。在Linux
    2.4及更早版本中，内核模块的文件名带有`.o`后缀；在现代的2.6 Linux及更高版本中，它的后缀是`.ko`（**k**ernel **o**bject）。构建完成后，你可以将这个`.ko`文件
    - 内核模块 - 插入到运行时的内核中，有效地使其成为内核的一部分。
- en: Note that not *all* kernel functionality can be provided via the LKM framework.
    Several core features, such as the core CPU scheduler code, memory manage the
    signaling, timer, interrupt management code paths, and so on, can only be developed
    within the kernel itself. Similarly, a kernel module is only allowed access to
    a subset of the full kernel API; more on this later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有内核功能都可以通过LKM框架提供。一些核心功能，如核心CPU调度器代码、内存管理、信号、定时器、中断管理代码路径等，只能在内核内部开发。同样，内核模块只允许访问完整内核API的子集；稍后会详细介绍。
- en: 'You might ask: how do I *insert* an object into the kernel? Let''s keep it
    simple – the answer is: via the `insmod(8)` utility. For now, let''s skip the
    details (these will be explained in the upcoming *Running the kernel module *section).
    The following figure provides an overview of first building and then inserting
    a kernel module into kernel memory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：我如何*插入*一个对象到内核中？让我们简单点 - 答案是：通过`insmod(8)`实用程序。现在，让我们跳过细节（这些将在即将到来的*运行内核模块*部分中解释）。以下图提供了首先构建，然后将内核模块插入内核内存的概述：
- en: '![](img/538b17b8-db71-480b-b991-8e396a816a0b.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/538b17b8-db71-480b-b991-8e396a816a0b.png)'
- en: Figure 4.3 – Building and then inserting a kernel module into kernel memory
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 构建然后将内核模块插入内核内存
- en: 'Worry not: the actual code for both the kernel module C source as well as its
    Makefile is dealt with in detail in an upcoming section; for now, we want to gain
    a conceptual understanding only.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心：内核模块的C源代码以及其Makefile的实际代码将在接下来的部分中详细介绍；现在，我们只想获得概念上的理解。
- en: The kernel module is loaded into and lives in kernel memory, that is, the kernel
    VAS (the bottom half of *Figure 4.3*) in an area of space allocated for it by
    the kernel. Make no mistake, *it is kernel code and runs with kernel privileges*.
    This way, you, the kernel (or driver) developer does not have to reconfigure,
    rebuild, and reboot the system each time. All you have to do is edit the code
    of the kernel module, rebuild it, remove the old copy from memory (if it exists),
    and insert the new version. It saves time, and it increases productivity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块被加载到内核内存中，并驻留在内核VAS（*图4.3*的下半部分）中，由内核为其分配的空间中。毫无疑问，*它是内核代码，并以内核特权运行*。这样，你作为内核（或驱动程序）开发人员就不必每次都重新配置、重建和重新启动系统。你只需要编辑内核模块的代码，重新构建它，从内存中删除旧版本（如果存在），然后插入新版本。这样可以节省时间，提高生产效率。
- en: 'One reason that kernel modules are advantageous is that they lend themselves
    to dynamic product configuration. For example, kernel modules can be designed
    to provide different features at differing price points; a script generating the
    final image for an embedded product could install a given set of kernel modules
    depending on the price the customer is willing to pay. Here''s another example
    of how this technology is leveraged in a *debug* or troubleshooting scenario:
    a kernel module could be used to dynamically generate diagnostics and debug logs
    on an existing product. Technologies such as kprobes and the like allow just this.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块有利的一个原因是它们适用于动态产品配置。例如，内核模块可以设计为在不同的价格点提供不同的功能；为嵌入式产品生成最终图像的脚本可以根据客户愿意支付的价格安装一组特定的内核模块。以下是另一个示例，说明了这项技术在*调试*或故障排除场景中的应用：内核模块可以用于在现有产品上动态生成诊断和调试日志。诸如kprobes之类的技术正是允许这样做的。
- en: In effect, the LKM framework gives us a means of dynamically extending kernel
    functionality by allowing us to insert and remove live code from kernel memory.
    This ability to plug in and unplug kernel functionality at our whim makes us realize
    that the Linux kernel is not purely monolithic, it is also *modular.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，LKM框架通过允许我们向内核内存中插入和移除实时代码的方式，为我们提供了一种动态扩展内核功能的手段。这种根据我们的意愿插入和拔出内核功能的能力使我们意识到Linux内核不仅是纯粹的单片式，它也是*模块化*的。
- en: Kernel modules within the kernel source tree
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核源树中的内核模块
- en: In fact, the kernel module object isn't completely unfamiliar to us. In [Chapter
    3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x Linux Kernel
    from Source - Part 2*, we built kernel modules as part of the kernel build process
    and had them installed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，内核模块对象对我们来说并不陌生。在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x
    Linux内核-第2部分*，我们在内核构建过程中构建了内核模块并将其安装。
- en: 'Recall that these kernel modules are part of the kernel source and have been
    configured as modules by selecting `M` in the tristate kernel menuconfig prompt.
    They get installed into directories under `/lib/modules/$(uname -r)/`. So, to
    see a little bit regarding the kernel modules installed under our currently running
    an Ubuntu 18.04.3 LTS guest kernel, we can do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些内核模块是内核源代码的一部分，并且通过在tristate内核menuconfig提示中选择`M`来配置为模块。它们被安装在`/lib/modules/$(uname
    -r)/`目录下。因此，要查看一下我们当前运行的Ubuntu 18.04.3 LTS客户机内核下安装的内核模块，我们可以这样做：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Okay, the folks at Canonical and elsewhere have been busy! Over five thousand
    kernel modules... Think about it – it makes sense: distributors cannot know in
    advance exactly what hardware peripherals a user will end up using (especially
    on generic computers like x86-based systems). Kernel modules serve as a convenient
    means to support huge amounts of hardware without insanely bloating the kernel
    image file (`bzImage` or `zImage`, for example).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Canonical和其他地方的人很忙！超过五千个内核模块...想想看-这是有道理的：发行商无法预先知道用户最终会使用什么硬件外围设备（特别是在像x86架构系统这样的通用计算机上）。内核模块作为一种方便的手段，可以支持大量硬件而不会使内核镜像文件（例如`bzImage`或`zImage`）变得非常臃肿。
- en: 'The installed kernel modules for our Ubuntu Linux system live within the `/lib/modules/$(uname
    -r)/kernel` directory, as seen here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Ubuntu Linux系统中安装的内核模块位于`/lib/modules/$(uname -r)/kernel`目录中，如下所示：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, looking at the top level of the `kernel/` directory under `/lib/modules/$(uname
    -r)` for the distro kernel (Ubuntu 18.04.3 LTS running the `5.0.0-36-generic`
    kernel), we see that there are many sub folders and literally a few thousand kernel
    modules packed within. By contrast, for the kernel we built (refer to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, for the details), there
    are much fewer. You will recall from our discussions in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*, that we deliberately used
    the `localmodconfig` target to keep the build small and fast. Thus, here, our
    custom 5.4.0 kernel has just some 60-odd kernel modules built against it***.***
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，查看`/lib/modules/$(uname -r)`下的发行版内核（Ubuntu 18.04.3 LTS运行`5.0.0-36-generic`内核）的`kernel/`目录的顶层，我们可以看到有许多子文件夹和成千上万的内核模块。相比之下，对于我们构建的内核（有关详细信息，请参阅[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)，*从源代码构建5.x
    Linux内核-第1部分*，和[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x Linux内核-第2部分*），数量要少得多。您会回忆起我们在[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中的讨论，*从源代码构建5.x
    Linux内核-第1部分*，我们故意使用了`localmodconfig`目标来保持构建的小巧和快速。因此，在这里，我们定制的5.4.0内核只构建了大约60个内核模块。
- en: 'One area that sees pretty heavy usage of kernel modules is that of *device
    drivers*. As an example, let''s look at a network device driver that is architected
    as a kernel module. You can find several (with familiar brands too!) under the
    distro kernel''s `kernel/drivers/net/ethernet` folder:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序是一个经常使用内核模块的领域。例如，让我们看一个作为内核模块架构的网络设备驱动程序。您可以在发行版内核的`kernel/drivers/net/ethernet`文件夹下找到几个（还有一些熟悉的品牌！）：
- en: '![](img/a3596e74-fd45-46b0-b1ed-c068d44daa3f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3596e74-fd45-46b0-b1ed-c068d44daa3f.png)'
- en: Figure 4.4 – Content of our distro kernel's ethernet network drivers (kernel
    modules)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4-我们发行版内核的以太网网络驱动程序（内核模块）的内容
- en: 'Popular on many Intel-based laptops is the Intel 1GbE **Network Interface Card**
    (**NIC**) ethernet adapter. The network device driver that drives it is called
    the `e1000` driver. Our x86-64 Ubuntu 18.04.3 guest (running on an x86-64 host
    laptop) shows that it indeed uses this driver:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于Intel的笔记本电脑上都使用Intel 1GbE **网络接口卡**（**NIC**）以太网适配器。驱动它的网络设备驱动程序称为`e1000`驱动程序。我们的x86-64
    Ubuntu 18.04.3客户机（在x86-64主机笔记本电脑上运行）显示它确实使用了这个驱动程序：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We shall cover the `lsmod(8)` (''list modules'') utility in more detail soon.
    More importantly for us, we can see that it''s a kernel module! How about obtaining
    some more information on this particular kernel module? That''s quite easily done
    by leveraging the `modinfo(8)` utility (for readability, we truncate its verbose
    output here):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将更详细地介绍`lsmod(8)`（'列出模块'）实用程序。对我们来说更重要的是，我们可以看到它是一个内核模块！如何获取有关这个特定内核模块的更多信息？通过利用`modinfo(8)`实用程序很容易实现（为了可读性，我们在这里截断了它的详细输出）：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `modinfo(8)` utility allows us to peek into a kernel module's binary image
    and extract some details regarding it; more on using `modinfo` in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`modinfo(8)`实用程序允许我们查看内核模块的二进制图像并提取有关它的一些详细信息；有关使用`modinfo`的更多信息将在下一节中介绍。'
- en: Another way to gain useful information on the system, including information
    on kernel modules that are currently loaded up, is via the `systool(1)` utility.
    For an installed kernel module (details on *installing* a kernel module follow
    in the next chapter in the *Auto-loading modules on system boot *section), doing
    `systool -m <module-name> -v` reveals information about it. Look up the `systool(1)`
    man page for usage details.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取系统有用信息的方法，包括有关当前加载的内核模块的信息，是通过`systool(1)`实用程序。对于已安装的内核模块（有关在下一章中*自动加载系统引导时安装*内核模块的详细信息），执行`systool
    -m <module-name> -v`可以显示有关它的信息。查阅`systool(1)`手册页以获取使用详细信息。
- en: The bottom line is that kernel modules have come to be *the* pragmatic way to
    build and distribute some types of kernel components, with *device drivers* being
    the most frequent use case for them. Other uses include but aren't limited to
    filesystems, network firewalls, packet sniffers, and custom kernel code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，内核模块已成为构建和分发某些类型的内核组件的*实用*方法，*设备驱动程序*是它们最常见的用例。其他用途包括但不限于文件系统、网络防火墙、数据包嗅探器和自定义内核代码。
- en: So, if you would like to learn how to write a Linux device driver, a filesystem,
    or a firewall, you must first learn how to write a kernel module, thus leveraging
    the kernel's powerful LKM framework. That's precisely what we will be doing next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想学习如何编写Linux设备驱动程序、文件系统或防火墙，您必须首先学习如何编写内核模块，从而利用内核强大的LKM框架。这正是我们接下来要做的事情。
- en: Writing our very first kernel module
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个内核模块
- en: When introducing a new programming language or topic, it has become a widely
    accepted computer programming tradition to mimic the original *K&R Hello, world *program
    as the very first piece of code. I'm happy to follow this venerated tradition
    to introduce the powerful LKM framework. In this section, you will learn the steps
    to code a simple LKM. We explain the code in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入新的编程语言或主题时，模仿原始的*K&R Hello, world*程序作为第一段代码已经成为一种被广泛接受的计算机编程传统。我很高兴遵循这一受尊敬的传统来介绍强大的LKM框架。在本节中，您将学习编写简单LKM的步骤。我们会详细解释代码。
- en: Introducing our Hello, world LKM C code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍我们的Hello, world LKM C代码
- en: 'Without further ado, here is some simple *Hello, world* C code, implemented
    to abide by the Linux kernel''s LKM framework:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，这里是一些简单的*Hello, world* C代码，实现了遵循Linux内核的LKM框架：
- en: 'For reasons of readability and space constraints, only the key parts of the
    source code are displayed here. To view the complete source code, build it, and
    run it, the entire source tree for this book is available in it''s GitHub repository
    here: [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming).
    We definitely expect you to clone it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可读性和空间限制的原因，这里只显示了源代码的关键部分。要查看完整的源代码，构建并运行它，本书的整个源树都可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming)。我们期望您能够克隆它：
- en: '`git clone https://github.com/PacktPublishing/Linux-Kernel-Programming.git`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/PacktPublishing/Linux-Kernel-Programming.git`'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can try out this simple *Hello, world* kernel module right away! Just `cd`
    to the correct source directory as shown here and get our helper `lkm` script
    to build and run it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以立即尝试这个简单的*Hello, world*内核模块！只需像这里显示的那样`cd`到正确的源目录，并获取我们的辅助`lkm`脚本来构建和运行它：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *hows and whys* are explained in a lot of detail shortly. Though tiny, the
    code of this, our very first kernel module, requires careful perusal and understanding.
    Do read on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何*和*为什么*很快会有详细的解释。尽管代码很小，但我们的第一个内核模块需要仔细阅读和理解。请继续阅读。'
- en: Breaking it down
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解
- en: The following subsections explain pretty much each line of the preceding *Hello,
    world* C code. Remember that although the program appears very small and trivial,
    there is a lot to be understood regarding it and the surrounding LKM framework.
    The rest of this chapter focuses on this and goes into great detail. I highly
    recommend that you take the time to read through and understand these fundamentals
    first. This will help you immensely in later, possibly difficult-to-debug situations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节解释了前面*Hello, world* C代码的几乎每一行。请记住，尽管程序看起来非常小和琐碎，但对于它和周围的LKM框架，有很多需要理解的地方。本章的其余部分将重点介绍这一点，并进行详细讨论。我强烈建议您花时间阅读和理解这些基础知识。这将在以后可能出现的难以调试的情况下对您有很大帮助。
- en: Kernel headers
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核头文件
- en: 'We use `#include` for a few header files. Unlike in user space ''C'' application
    development, these are *kernel headers* (as mentioned in the *Technical requirements *section).
    Recall from [Chapter 3](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 2*, that kernel modules were installed
    under a specific root-writeable branch. Let''s check it out again (here, we''re
    running on our guest x86_64 Ubuntu VM with the 5.0.0-36-generic distro kernel):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`#include`包含了一些头文件。与用户空间的'C'应用程序开发不同，这些是*内核头文件*（如*技术要求*部分所述）。请回顾[第3章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)，*从源代码构建5.x
    Linux内核 - 第2部分*，内核模块安装在特定的根可写分支下。让我们再次检查一下（这里，我们正在运行我们的客户x86_64 Ubuntu VM，使用的是5.0.0-36-generic发行版内核）。
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the symbolic or soft link named `build`. It points to the location of
    the kernel headers on the system. In the preceding code, it's under `/usr/src/linux-headers-5.0.0-36-generic/`!
    As you shall see, we will supply this information to the Makefile used to build
    our kernel module. (Also, some systems have a similar soft link called `source`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意名为`build`的符号链接或软链接。它指向系统上内核头文件的位置。在前面的代码中，它位于`/usr/src/linux-headers-5.0.0-36-generic/`下！正如您将看到的，我们将向用于构建内核模块的Makefile提供这些信息。（此外，一些系统有一个名为`source`的类似软链接）。
- en: The `kernel-headers` or `linux-headers` package unpacks a limited kernel source
    tree onto the system, typically under `/usr/src/...`. This code, however, isn't
    complete, hence our use of the phrase *limited* source tree. This is because the
    complete kernel source tree isn't required for the purpose of building modules
    – just the required components (the headers, the Makefiles, and so on) are what's
    packaged and extracted.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernel-headers`或`linux-headers`软件包将有限的内核源树解压到系统上，通常位于`/usr/src/...`下。然而，这段代码并不完整，因此我们使用了短语*有限*源树。这是因为构建模块并不需要完整的内核源树
    - 只需要打包和提取所需的组件（头文件，Makefile等）。'
- en: The first line of code in our *Hello, world* kernel module is `#include <linux/init.h>`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*Hello, world*内核模块中的第一行代码是`#include <linux/init.h>`。
- en: 'The compiler resolves this by searching for the previously mentioned kernel
    header file under `/lib/modules/$(uname -r)/build/include/`. Thus, by following
    the `build` soft link, we can see that it ultimately picks up this header file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过在`/lib/modules/$(uname -r)/build/include/`下搜索先前提到的内核头文件来解决这个问题。因此，通过跟随`build`软链接，我们可以看到它最终拾取了这个头文件：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The same follows for the other kernel headers included in the kernel module's
    source code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包含在内核模块源代码中的内核头文件也是如此。
- en: Module macros
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块宏
- en: 'Next, we have a few module macros of the form `MODULE_FOO()`; most are quite
    intuitive:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些形式为`MODULE_FOO()`的模块宏；大多数都很直观：
- en: '`MODULE_AUTHOR()`: Specifies the author(s) of the kernel module'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_AUTHOR()`: 指定内核模块的作者'
- en: '`MODULE_DESCRIPTION()`: Briefly describes the function of this LKM'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_DESCRIPTION()`: 简要描述此LKM的功能'
- en: '`MODULE_LICENSE()`: Specifies the license(s) under which this kernel module
    is released'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_LICENSE()`: 指定内核模块发布的许可证'
- en: '`MODULE_VERSION()`: Specifies the (local) version of the kernel module'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_VERSION()`: 指定内核模块的（本地）版本'
- en: In the absence of the source code, how will this information be conveyed to
    the end user (or customer)? Ah, the `modinfo(8)` utility does precisely that!
    These macros and their information might seem trivial, but they are important
    in projects and products. This information is relied upon, for example, by a vendor
    establishing the (open source) licenses that code is running under by using `grep` on
    the `modinfo` output on all installed kernel modules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有源代码的情况下，如何将这些信息传达给最终用户（或客户）？啊，`modinfo(8)`实用程序正是这样做的！这些宏及其信息可能看起来微不足道，但在项目和产品中非常重要。例如，供应商通过在所有已安装的内核模块上使用`grep`对`modinfo`输出来确定代码正在运行的（开源）许可证。
- en: Entry and exit points
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口和出口点
- en: 'Never forget, kernel modules are, after all, *kernel code running with kernel
    privileges*. It''s *not* an application and thus does not have it''s entry point
    as the familiar `main()`  function (that we know well and love). This, of course,
    begs the question: what are the entry and exit points of the kernel module? Notice,
    at the bottom of our simple kernel module, the following lines:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要忘记，内核模块毕竟是*以内核特权运行的内核代码*。它*不是*一个应用程序，因此没有像我们熟悉和喜爱的`main()`函数那样的入口点。这当然引出了一个问题：内核模块的入口和出口点是什么？请注意，在我们简单的内核模块底部，以下行：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `module_[init|exit]()` code is macros specifying the entry and exit points,
    respectively. The parameter to each is a function pointer. With modern C compilers,
    we can just specify the name of the function. Thus, in our code, the following
    applies:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`module_[init|exit]()`代码是分别指定入口和出口点的宏。每个参数都是一个函数指针。使用现代C编译器，我们可以只指定函数的名称。因此，在我们的代码中，以下内容适用：'
- en: The `helloworld_lkm_init()` function is the entry point.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helloworld_lkm_init()`函数是入口点。'
- en: The `helloworld_lkm_exit()` function is the exit point.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helloworld_lkm_exit()`函数是出口点。'
- en: You can almost think of these entry and exit points as a *constructor/destructor *pair
    for a kernel module. Technically, it's not the case, of course, as this isn't
    object-oriented C++ code, it's plain C. Nevertheless, it's a useful analogy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些入口和出口点几乎可以被认为是内核模块的*构造函数/析构函数*对。从技术上讲，当然不是这样，因为这不是面向对象的C++代码，而是普通的C。尽管如此，这是一个有用的类比。
- en: Return values
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: 'Notice the signature of the `init` and `exit` functions is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`init`和`exit`函数的签名如下：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a good coding practice, we have used the naming format for the functions
    as `<modulename>__[init|exit]()`, where `<modulename>` is replaced with the name
    of the kernel module. You will realize that this naming convention is just that
    - it's merely a convention that is, technically speaking, unnecessary, but it
    is intuitive and thus helpful. Clearly, neither routine receives any parameter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的编码实践，我们已经使用了函数的命名格式`<modulename>__[init|exit]()`，其中`<modulename>`被替换为内核模块的名称。您会意识到这种命名约定只是这样
    - 从技术上讲是不必要的，但它是直观的，因此有帮助。显然，这两个例程都不接收任何参数。
- en: Marking both functions with the `static` qualifier implies that they are private
    to this kernel module. That is what we want.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个函数标记为`static`限定符意味着它们对这个内核模块是私有的。这正是我们想要的。
- en: Now let's move along to the important convention that is followed for a kernel
    module's `init` function's return value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论内核模块的`init`函数返回值所遵循的重要约定。
- en: The 0/-E return convention
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 0/-E返回约定
- en: 'The kernel module''s `init`function is to return a value of type `int`; this
    is a key aspect. The Linux kernel has evolved a *style* or convention, if you
    will, with regard to returning values from it (meaning from the kernel space to
    the user space process). The LKM framework follows what is colloquially referred
    to as the `0/-E` convention:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块的`init`函数要返回一个类型为`int`的值；这是一个关键方面。Linux内核已经形成了一种*风格*或约定，如果你愿意的话，关于从中返回值的方式（从内核空间到用户空间进程）。LKM框架遵循了俗称的`0/-E`约定：
- en: Upon success, return integer value `0`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时，返回整数值`0`。
- en: Upon failure, return the negative of the value you would like the user space
    global uninitialized integer `errno` to be set to.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时，返回用户空间全局未初始化整数`errno`的负值。
- en: Be aware that `errno` is a global residing in a user process VAS within the uninitialized
    data segment. With very few exceptions, whenever a Linux system call fails, `-1` is
    returned and `errno` is set to a positive value, representing the failure code;
    this work is carried out by `glibc` "glue" code on the `syscall` return path.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`errno`是一个全局变量，驻留在用户进程VAS中的未初始化数据段中。除了很少的例外情况，每当Linux系统调用失败时，都会返回`-1`，并且`errno`被设置为一个正值，表示失败代码；这项工作是由`glibc`在`syscall`返回路径上的“粘合”代码完成的。
- en: Furthermore, the `errno` value is actually an index into a global table of English
    error messages (`const char * const sys_errlist[]`); this is really how routines
    such as `perror(3)`, `strerror[_r](3)` and the like can print out failure diagnostics.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`errno`值实际上是全局英文错误消息表的索引（`const char * const sys_errlist[]`）；这就是`perror(3)`、`strerror[_r](3)`等函数如何打印出失败诊断信息的真正原因。
- en: 'By the way, you can look up the **complete list of error codes** available
    to you from within these (kernel source tree) header files: `include/uapi/asm-generic/errno-base.h`
    and `include/uapi/asm-generic/errno.h`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您可以从这些（内核源树）头文件中查找可用的**错误代码完整列表**：`include/uapi/asm-generic/errno-base.h`
    和 `include/uapi/asm-generic/errno.h`。
- en: 'A quick example of how to return from a kernel module''s `init`function will
    help make this clear: say our kernel module''s `init`function is attempting to
    dynamically allocate some kernel memory (details on the `kmalloc()` API and so
    on will be covered in later chapters of course; please ignore it for now). Then,
    we could code it like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的例子可以帮助我们清楚地了解如何从内核模块的`init`函数返回：假设我们的内核模块的`init`函数正在尝试动态分配一些内核内存（有关`kmalloc()`API等的详细信息将在以后的章节中介绍；现在请忽略它）。然后，我们可以这样编写代码：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the memory allocation does fail (very unlikely, but hey, it can happen!),
    we do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存分配失败（很少见，但嘿，这是可能的！），我们会执行以下操作：
- en: 'First, we emit a warning `printk`. Actually, in this particular case – "out
    of memory" – it''s pedantic and unnecessary. The kernel will certainly emit sufficient
    diagnostic information if a kernel-space memory allocation ever fails! See this
    link for more details: [https://lkml.org/lkml/2014/6/10/382](https://lkml.org/lkml/2014/6/10/382);
    we do so here merely as it''s early in the discussion and for reader continuity.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们发出一个警告`printk`。实际上，在这种特殊情况下——"内存不足"——这是迂腐和不必要的。如果内核空间内存分配失败，内核肯定会发出足够的诊断信息！请参阅此链接以获取更多详细信息：[https://lkml.org/lkml/2014/6/10/382](https://lkml.org/lkml/2014/6/10/382)；我们之所以在这里这样做，只是因为讨论刚开始，为了读者的连贯性。
- en: 'Return the `-ENOMEM` value:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`-ENOMEM`值：
- en: The layer to which this value will be returned in user space is actually `glibc`;
    it has some "glue" code that multiplies this value by `-1` and sets the global
    integer `errno` to it.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户空间返回此值的层实际上是`glibc`；它有一些"粘合"代码，将此值乘以`-1`并将全局整数`errno`设置为它。
- en: Now, the `[f]init_module(2)` system call will return `-1`, indicating failure
    (this is because `insmod(8)` actually invokes this system call, as you will soon
    see).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，`[f]init_module(2)`系统调用将返回`-1`，表示失败（这是因为`insmod(8)`实际上调用了这个系统调用，您很快就会看到）。
- en: '`errno` will be set to `ENOMEM`, reflecting the fact that the kernel module
    insertion failed due to a failure to allocate memory.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errno`将被设置为`ENOMEM`，反映了由于内存分配失败而导致内核模块插入失败的事实。'
- en: Conversely, the framework *expects *the `init` function to return the value `0` upon
    success. In fact, in older kernel versions, failure to return `0` upon success
    would cause the kernel module to be abruptly unloaded from kernel memory. Nowadays,
    this removal of the kernel module does not happen but the kernel emits a warning
    message regarding the fact that a *suspicious* non-zero value has been returned.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，框架*期望*`init`函数在成功时返回值`0`。实际上，在旧的内核版本中，如果在成功时未返回`0`，内核模块将被突然从内核内存中卸载。如今，内核不会卸载内核模块，但会发出警告消息，指出已返回一个*可疑*的非零值。
- en: There's not much to be said for the cleanup routine. It receives no parameters
    and returns nothing (`void`). Its job is to perform any and all required cleanup
    before the kernel module is unloaded from kernel memory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 清理例程没有太多可说的。它不接收任何参数，也不返回任何内容（`void`）。它的工作是在内核模块从内核内存中卸载之前执行所有必需的清理。
- en: '*Not *including the `module_exit()` macro in your kernel module makes it impossible
    to ever unload it (notwithstanding a system shutdown or reboot, of course). Interesting...
    (I suggest you try this out as a small exercise!).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*不*在您的内核模块中包括`module_exit()`宏将使其不可能卸载（当然，除非系统关闭或重新启动）。有趣...（我建议您尝试这个小练习！）。'
- en: 'Of course, it''s never that simple: this behavior preventing the unload is
    guaranteed only if the kernel is built with the `CONFIG_MODULE_FORCE_UNLOAD` flag
    set to `Disabled` (the default).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事情永远不会那么简单：只有在内核构建时将`CONFIG_MODULE_FORCE_UNLOAD`标志设置为`Disabled`（默认情况下）时，才能保证这种阻止卸载的行为。
- en: The ERR_PTR and PTR_ERR macros
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ERR_PTR和PTR_ERR宏
- en: 'On the discussion of return values, you now understand that the kernel module''s
    `init` routine must return an integer. What if you wish to return a pointer instead?
    The `ERR_PTR()` inline function comes to our rescue, allowing us to return a pointer
    *disguised* as an integer simply by typecasting it as `void *`. It actually gets
    better: you can check for an error using the `IS_ERR()` inline function (which
    really just figures out whether the value is in the range [-1 to -4095]), *encodes*
    a negative error value into a pointer via the `ERR_PTR()` inline function, and
    *retrieves* this value from the pointer using the converse routine `PTR_ERR()`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回值的讨论中，您现在了解到内核模块的`init`例程必须返回一个整数。如果您希望返回一个指针呢？`ERR_PTR()`内联函数来帮助我们，允许我们返回一个指针，只需将其强制转换为`void
    *`即可。事实上，情况会更好：您可以使用`IS_ERR()`内联函数来检查错误（它实际上只是确定值是否在[-1到-4095]范围内），通过`ERR_PTR()`内联函数将负错误值编码为指针，并使用相反的例程`PTR_ERR()`从指针中检索此值。
- en: 'As a simple example, see the callee code given here. This time, we have the
    (sample) function `myfunc()` return a pointer (to a structure named `mystruct`)
    and not an integer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，看看这里给出的被调用者代码。这次，我们的（示例）函数`myfunc()`返回一个指针（指向一个名为`mystruct`的结构），而不是一个整数：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The caller code is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者代码如下：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'FYI, the inline `ERR_PTR()`, `PTR_ERR()`, and `IS_ERR()` functions all live
    within the (kernel header) `include/linux/err.h` file. The kernel documentation
    ([https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions](https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions))
    talks about kernel function return conventions. Also, you can find example usage
    for these functions under the `crypto/api-samples` code within the kernel source
    tree: [https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html](https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html)[.](https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，内联函数`ERR_PTR()`、`PTR_ERR()`和`IS_ERR()`都在（内核头文件）`include/linux/err.h`文件中。内核文档（[https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions](https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions)）讨论了内核函数的返回约定。此外，你可以在内核源代码树中的`crypto/api-samples`代码下找到这些函数的用法示例：[https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html](https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html)。
- en: The __init and __exit keywords
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: __init和__exit关键字
- en: 'A niggling leftover: what exactly are the `__init` and `__exit` macros we see
    within the preceding function signatures? These are merely memory optimization
    attributes inserted by the linker.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微小的遗留问题：在前面的函数签名中我们看到的`__init`和`__exit`宏到底是什么？这些只是链接器插入的内存优化属性。
- en: The `__init` macro defines an `init.text` section for code. Similarly, any data
    declared with the `__initdata` attribute goes into an `init.data` section. The
    whole point here is the code and data in the `init` function is used exactly once
    during initialization. Once it's invoked, it will never be called again; so, once
    called, it is then freed up (via `free_initmem()`).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init`宏为代码定义了一个`init.text`部分。同样，任何声明了`__initdata`属性的数据都会进入`init.data`部分。这里的重点是`init`函数中的代码和数据在初始化期间只使用一次。一旦被调用，它就再也不会被调用；所以一旦被调用，它就会被释放掉（通过`free_initmem()`）。'
- en: The deal is similar with the `__exit` macro, though, of course, this only makes
    sense with kernel modules. Once the `cleanup` function is called, all the memory
    is freed. If the code were instead part of the static kernel image (or if module
    support were disabled), this macro would have no effect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit`宏的情况类似，当然，这只对内核模块有意义。一旦调用`cleanup`函数，所有内存都会被释放。如果代码是静态内核映像的一部分（或者模块支持被禁用），这个宏就没有效果了。'
- en: 'Fine, but so far, we have still not explained some practicalities: how exactly
    can you get the kernel module object into kernel memory, have it execute, and
    then unload it, plus several other operations you might wish to perform. Let''s
    discuss these in the following section.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，但到目前为止，我们还没有解释一些实际问题：你到底如何将内核模块对象加载到内核内存中，让它执行，然后卸载它，以及你可能希望执行的其他一些操作。让我们在下一节讨论这些问题。
- en: Common operations on kernel modules
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块的常见操作
- en: Now let's delve into how exactly you can build, load, and unload a kernel module.
    Besides this, we'll also walk through the basics regarding the tremendously useful
    `printk()` kernel API, details on listing the currently loaded kernel modules
    with `lsmod(8)`, and a convenience script for automating some common tasks during
    kernel module development. So, let's begin!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入讨论一下你到底如何构建、加载和卸载内核模块。除此之外，我们还将介绍关于非常有用的`printk()`内核API、使用`lsmod(8)`列出当前加载的内核模块的基础知识，以及用于在内核模块开发过程中自动执行一些常见任务的便利脚本。所以，让我们开始吧！
- en: Building the kernel module
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建内核模块
- en: We definitely urge you to try out our simple *Hello, world *kernel module exercise
    (if you haven't already done so)! To do so, we assume you have cloned this book's
    GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming))
    already. If not, please do so now (refer to the *Technical requirements* section
    for details).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你尝试一下我们简单的*Hello, world*内核模块练习（如果你还没有这样做的话）！为此，我们假设你已经克隆了本书的GitHub存储库（[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming)）。如果还没有，请现在克隆（参考*技术要求*部分获取详细信息）。
- en: 'Here, we show step by step how exactly you can build and then insert our first
    kernel module into kernel memory. Again, a quick reminder: we have performed these
    steps on an x86-64 Linux guest VM (under Oracle VirtualBox 6.1) running the Ubuntu
    18.04.3 LTS distribution:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们逐步展示了你到底如何构建并将我们的第一个内核模块插入到内核内存中。再次提醒一下：我们在运行Ubuntu 18.04.3 LTS发行版的x86-64
    Linux虚拟机（在Oracle VirtualBox 6.1下）上执行了这些步骤。
- en: 'Change to this books'' source code chapter directory and sub-directory. Our
    very first kernel module lives in its own folder (as it should!) called `helloworld_lkm`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到本书源代码章节目录和子目录。我们的第一个内核模块位于自己的文件夹中（应该是这样！）叫做`helloworld_lkm`：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`<book-code-dir>` is, of course, the folder into which you cloned this book''s
    GitHub repository; here (see the screenshot,  Figure 4.5), you can see that it''s `/home/llkd/book_llkd/Linux-Kernel-Programming/`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`<book-code-dir>`当然是你克隆了本书的GitHub存储库的文件夹；在这里（见截图，图4.5），你可以看到它是`/home/llkd/book_llkd/Linux-Kernel-Programming/`。'
- en: 'Now verify the code base:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在验证代码库：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Build it with `make`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`make`进行构建：
- en: '![](img/bd85fe6e-cac7-4e9f-9d65-075cb8212f04.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd85fe6e-cac7-4e9f-9d65-075cb8212f04.png)'
- en: Figure 4.5 – Listing and building our very first *Hello, world *kernel module
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 列出并构建我们的第一个*Hello, world*内核模块
- en: The preceding screenshot shows that the kernel module has been successfully
    built. It's the `./helloworld_lkm.ko` file. (Also, note that we booted from, and
    thus have built the kernel module against, our custom 5.4.0 kernel, built in earlier
    chapters.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示内核模块已经成功构建。它是`./helloworld_lkm.ko`文件。（另外，注意我们是从我们之前章节中构建的自定义5.4.0内核引导的。）
- en: Running the kernel module
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行内核模块
- en: In order to have the kernel module run, you need to first load it into kernel
    memory space, of course. This is known as *inserting* the module into kernel memory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让内核模块运行，你需要首先将它加载到内核内存空间中。这被称为将模块*插入*到内核内存中。
- en: 'Getting the kernel module into the Linux kernel segment can be done in a few
    ways, which all ultimately boil down to invoking one of the `[f]init_module(2)` system
    calls. For convenience, several wrapper utilities exist that will do so (or you
    can always write one). We will use the  popular `insmod(8)` (read it as "**ins**ert **mod**ule") utility
    below; the parameter for `insmod` is the pathname to the kernel module to insert:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将内核模块放入Linux内核段可以通过几种方式完成，最终都归结为调用`[f]init_module(2)`系统调用之一。为了方便起见，存在几个包装实用程序将这样做（或者您总是可以编写一个）。我们将在下面使用流行的`insmod(8)`（读作“**ins**ert **mod**ule”）实用程序；`insmod`的参数是要插入的内核模块的路径名：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It fails! In fact, it should be pretty obvious why. Think about it: inserting
    code into the kernel is, in a very real sense, even superior to being *root* (superuser)
    on the system - again, I remind you: *it''s kernel code and will run with kernel
    privilege*. If any and every user is allowed to insert or remove kernel modules,
    hackers would have a field day! Deploying malicious code would become a fairly
    trivial affair. So, for security reasons, **only with root access can you insert
    or remove kernel modules**.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了！实际上，失败的原因应该是非常明显的。想一想：将代码插入内核在很大程度上甚至优于在系统上成为*root*（超级用户）- 再次提醒您：*它是内核代码，并且将以内核特权运行*。如果任何用户都被允许插入或删除内核模块，黑客将有一天的乐趣！部署恶意代码将变得相当简单。因此，出于安全原因，**只有具有root访问权限才能插入或删除内核模块**。
- en: Technically, being *root* implies that the process' (or thread's) **Real** and/or
    **Effective** **UID** (**RUID**/**EUID**) value is the special value *zero*. Not
    just that, but the modern kernel "sees" a thread as having certain **capabilities**(via
    the modern and superior POSIX Capabilities model); only a process/thread with
    the `CAP_SYS_MODULE` capability can (un)load kernel modules. We refer the reader
    to the man page on `capabilities(7)` for more details.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，作为*root*意味着进程（或线程）的**真实**和/或**有效** **UID**（**RUID**/**EUID**）值是特殊值*零*。不仅如此，而且现代内核通过现代和优越的POSIX
    Capabilities模型“看到”线程具有某些**capabilities**；只有具有`CAP_SYS_MODULE`能力的进程/线程才能（卸载）加载内核模块。我们建议读者查看`capabilities(7)`的手册页以获取更多详细信息。
- en: 'So, let''s again attempt to insert our kernel module into memory, this time
    with *root* privileges via `sudo(8)`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们再次尝试将我们的内核模块插入内存，这次使用`sudo(8)`的*root*权限：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now it works! As alluded to earlier, the `insmod(8)` utility works by invoking
    the `[f]init_module(2)` system call. When might the `insmod(8)` utility (in effect,
    internally the `[f]init_module(2)` system calls) *fail*?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以了！正如前面提到的，`insmod(8)`实用程序通过调用`[f]init_module(2)`系统调用来工作。`insmod(8)`实用程序（实际上是内部的`[f]init_module(2)`系统调用）*失败*的情况是什么时候？
- en: 'There are a few cases:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况：
- en: '**Permissions**: Not run as root or lack of the `CAP_SYS_MODULE` capability (`errno
    <- EPERM`).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：未以root身份运行或缺少`CAP_SYS_MODULE`能力（`errno <- EPERM`）。'
- en: The kernel tunable within the `proc` filesystem, ​`/proc/sys/kernel/modules_disabled`,
    is set to `1` (it defaults to `0`).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc`文件系统中的内核可调参数，`/proc/sys/kernel/modules_disabled`，被设置为`1`（默认为`0`）。'
- en: A kernel module with the same name is already in kernel memory (`errno <- EEXISTS`).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同名称的内核模块已经在内核内存中（`errno <- EEXISTS`）。
- en: Okay, all looks good. The `$?` result being `0` implies that the previous shell
    command was successful. That's great, but where is our *Hello, world* message?
    Read on!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切看起来都很好。`$?`的结果为`0`意味着上一个shell命令成功了。这很好，但是我们的*Hello, world*消息在哪里？继续阅读！
- en: A quick first look at the kernel printk()
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速查看内核printk()
- en: To emit a message, the user space C developer will often use the trusty `printf(3)`
    glibc API (or perhaps the `cout` when writing C++ code). However, it's important
    to understand that in kernel space, *there are no libraries*. Hence, we simply
    do *not* have access to the good old `printf()` API*.* Instead, it has essentially
    been re-implemented *within *the kernel as the `printk()` kernel API (curious
    as to where its code is? its here within the kernel source tree: `kernel/printk/printk.c:printk()`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出消息，用户空间的C开发人员通常会使用可靠的`printf(3)` glibc API（或者在编写C++代码时可能会使用`cout`）。但是，重要的是要理解，在内核空间中，*没有库*。因此，我们*无法*访问老式的`printf()`
    API*。相反，它在内核中基本上被重新实现为`printk()`内核API（想知道它的代码在哪里吗？它在内核源树中的这里：`kernel/printk/printk.c:printk()`）。
- en: 'Emitting a message via the `printk()` API is simple and very much similar to
    doing so with `printf(3)`. In our simple kernel module, here''s where the action
    occurs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`printk()` API发出消息非常简单，并且与使用`printf(3)`非常相似。在我们简单的内核模块中，这就是发生操作的地方：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Though very similar to `printf` at first glance, `printk` is really quite different.
    In terms of similarities, the API receives a format string as its parameter. The
    format string is pretty much identical to that of `printf`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看与`printf`非常相似，但`printk`实际上是非常不同的。在相似之处，API接收一个格式字符串作为其参数。格式字符串几乎与`printf`的格式字符串完全相同。
- en: 'But the similarities end there. The key difference between `printf` and `printk`
    is this: the user space `printf(3)` library API works by formatting a text string
    as requested and invoking the `write(2)` system call, which in turn actually performs
    a write to the `stdout` *device,* which, by default, is the Terminal window (or
    console device). The kernel `printk` API also formats its text string as requested,
    but its *output* *destination* differs. It writes to at least one place – the
    first one in the following list – and possibly to a few more:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但相似之处就到此为止。`printf`和`printk`之间的关键区别在于：用户空间的`printf(3)`库API通过根据请求格式化文本字符串并调用`write(2)`系统调用来工作，而后者实际上执行对`stdout`
    *设备*的写入，默认情况下是终端窗口（或控制台设备）。内核`printk` API也根据请求格式化其文本字符串，但其*输出* *目的地*不同。它至少写入一个地方-以下列表中的第一个-可能还会写入几个地方：
- en: A kernel log buffer in RAM (volatile)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM中的内核日志缓冲区（易失性）
- en: A log file, the kernel log file (non-volatile)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个日志文件，内核日志文件（非易失性）
- en: The console device
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台设备
- en: For now, we shall skip the inner details regarding the workings of `printk`.
    Also, please ignore the `KERN_INFO` token within the `printk` API; we shall cover
    all this soon enough.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将跳过关于`printk`工作原理的内部细节。另外，请忽略`printk` API中的`KERN_INFO`标记；我们很快会涵盖所有这些内容。
- en: 'When you emit a message via `printk`, it''s guaranteed that the output goes
    into a log buffer in kernel memory (RAM). This, in effect, constitutes the **kernel
    log**. It''s important to note that you will never see the `printk` output directly
    when working in graphical mode with an X server process running (the default environment
    when working on a typical Linux distro). So, the obvious question here is: how
    do you see the kernel log buffer content? There are a few ways. For now, let''s
    just make use of the quick and easy way.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过`printk`发出消息时，可以保证输出进入内核内存（RAM）中的日志缓冲区。这实际上构成了**内核日志**。重要的是要注意，在图形模式下使用X服务器进程运行时（在典型的Linux发行版上工作时的默认环境），您永远不会直接看到`printk`输出。因此，这里显而易见的问题是：您如何查看内核日志缓冲区内容？有几种方法。现在，让我们简单快速地使用一种方法。
- en: 'Use the `dmesg(1)` utility! By default, `dmesg` will dump the entire kernel
    log buffer content to stdout. Here, we look up the last two lines of the kernel
    log buffer with it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dmesg(1)`实用程序！默认情况下，`dmesg`将将整个内核日志缓冲区内容转储到标准输出。在这里，我们使用它查找内核日志缓冲区的最后两行：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There it is, finally: our *Hello, world* message!'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 终于找到了：我们的*Hello, world*消息！
- en: 'You can simply ignore the `loading out-of-tree module taints kernel.` message
    for now. For security reasons, most modern Linux distros will mark the kernel
    as *tainted *(literally, "contaminated" or "polluted") if a third party "out-of-tree"
    (or non-signed) kernel module is inserted. (Well, it''s really more of a pseudo-legal
    cover-up along the lines of: *"if something goes wrong from this point in time
    onward, we are not responsible, and so on..."*; you get the idea).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以简单地忽略`loading out-of-tree module taints kernel.`的消息。出于安全原因，大多数现代Linux发行版将内核标记为*污染*（字面上是"污染"或"污染"）如果插入了第三方"out-of-tree"（或非签名）内核模块。
    （嗯，这实际上更像是伪法律掩盖，类似于：“如果从这一点开始出了问题，我们不负责任等等...”；你懂的）。
- en: 'For a bit of variety, here is a screenshot of our *Hello, world* kernel module
    being inserted and removed (details follow) on an x86-64 CentOS 8 guest running
    the 5.4 Linux LTS kernel (that we custom-built as shown in detail in the first
    and second chapters):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有点变化，这里是我们在运行5.4 Linux LTS内核的x86-64 CentOS 8虚拟机上插入和移除*Hello, world*内核模块的屏幕截图（详细信息如下）：
- en: '![](img/8aed7347-fd0f-452d-9345-433a8952dfd0.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aed7347-fd0f-452d-9345-433a8952dfd0.png)'
- en: Figure 4.6 – Screenshot showing our working with the *Hello, world *kernel module
    on a CentOS 8 x86-64 guest
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 - 屏幕截图显示我们在CentOS 8 x86-64虚拟机上使用*Hello, world*内核模块
- en: Within the kernel log, as displayed by the `dmesg(1)` utility, the numbers in
    the leftmost column are a simple timestamp, in `[seconds.microseconds]` format,
    of time elapsed since system boot (it is not recommended to treat it as being
    perfectly accurate, though). By the way, this timestamp is a `Kconfig` variable
    – a kernel config option – named `CONFIG_PRINTK_TIME`; it can be overridden by
    the `printk.time` kernel parameter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在由`dmesg(1)`实用程序显示的内核日志中，最左边的列中的数字是一个简单的时间戳，格式为`[秒.微秒]`，表示自系统启动以来经过的时间（尽管不建议将其视为完全准确）。顺便说一句，这个时间戳是一个`Kconfig`变量
    - 一个内核配置选项 - 名为`CONFIG_PRINTK_TIME`；它可以被`printk.time`内核参数覆盖。
- en: Listing the live kernel modules
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出活动的内核模块
- en: 'Back to our kernel module: so far, we have built it, loaded it into the kernel,
    and verified that its entry point, the `helloworld_lkm_init()` function,  got
    invoked, thus executing the `printk` API. So now, what does it do? Well, nothing
    really; the kernel module merely (happily?) sits in kernel memory doing absolutely
    nothing. We can in fact easily look it up with the `lsmod(8)` utility:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的内核模块：到目前为止，我们已经构建了它，将它加载到内核中，并验证了它的入口点`helloworld_lkm_init()`函数被调用，从而执行了`printk`
    API。那么，它现在做什么？嗯，实际上什么都不做；内核模块只是（愉快地？）坐在内核内存中什么都不做。实际上，我们可以很容易地使用`lsmod(8)`实用程序查找它。
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`lsmod` shows all kernel modules currently residing (or *live*) in kernel memory,
    sorted in reverse chronological order. Its output is column formatted, with three
    columns and an optional fourth one. Let''s look at each column separately:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsmod`显示当前驻留在内核内存中（或*活动*）的所有内核模块，按时间顺序排列。它的输出是列格式化的，有三列和一个可选的第四列。让我们分别看看每一列：'
- en: The first column displays the *name* of the kernel module.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一列显示内核模块的*名称*。
- en: The second column is the (static) *size* in bytes that it's taking in the kernel.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二列是内核中占用的（静态）*大小*（以字节为单位）。
- en: The third column is the module *usage count*.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三列是模块的*使用计数*。
- en: The optional fourth column (and more that may follow) is explained in the next
    chapter (in the* Understanding module stacking *section. Also, on recent x86-64
    Linux kernels, a minimum of 16 KB of kernel memory seems to be taken up by a kernel
    module.)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的第四列（以及可能随后的更多内容）将在下一章中解释（在*理解模块堆叠*部分）。另外，在最近的x86-64 Linux内核上，似乎至少需要16 KB的内核内存来存储一个内核模块。
- en: 'So, great: by now you''ve successfully built, loaded and run your first kernel
    module into kernel memory and it basically works: what next? Well, nothing much
    really with this one! We simply learn how to unload it in the following section.
    There''s a lot more to come of course... keep going!'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，很好：到目前为止，您已经成功构建、加载并运行了您的第一个内核模块到内核内存中，并且基本上可以工作：接下来呢？嗯，实际上并没有太多！我们只是在下一节学习如何卸载它。当然还有更多要学的...继续吧！
- en: Unloading the module from kernel memory
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从内核内存中卸载模块
- en: 'To unload the kernel module, we use the convenience utility `rmmod(8)` (*remove
    module*):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载内核模块，我们使用方便的实用程序`rmmod(8)`（*删除模块*）：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The parameter to `rmmod(8)` is the *name *of the kernel module (as shown in
    the first column of `lsmod(8)`), not the pathname. Clearly, just as with `insmod(8)`,
    we need to run the `rmmod(8)` utility as the *root* user for it to succeed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmmod(8)` 的参数是内核模块的*名称*（如 `lsmod(8)` 的第一列中所示），而不是路径名。显然，就像 `insmod(8)` 一样，我们需要以
    *root* 用户身份运行 `rmmod(8)` 实用程序才能成功。'
- en: Here, we can also see that, because of our `rmmod`, the exit routine (or "destructor")
    `helloworld_lkm_exit()`functionof the kernel module got invoked. It in turn invoked
    `printk`*, *which emitted the *Goodbye, world *message (which we looked up with `dmesg`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以看到，由于我们的 `rmmod`，内核模块的退出例程（或 "析构函数"）`helloworld_lkm_exit()` 函数被调用。它反过来调用了
    `printk`，发出了 *Goodbye, world* 消息（我们用 `dmesg` 查找到）。
- en: 'When could `rmmod` (note that internally, it becomes the `delete_module(2)` system
    call) *fail*? Here are some cases:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmmod`（请注意，在内部，它变成了 `delete_module(2)` 系统调用）*失败* 的情况是什么时候？以下是一些情况：'
- en: '**Permissions**: If it is not run as root or there is a lack of the `CAP_SYS_MODULE`
    capability (`errno <- EPERM`).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：如果不以 root 用户身份运行，或者缺少 `CAP_SYS_MODULE` 能力（`errno <- EPERM`）。'
- en: If the kernel module's code and/or data is being used by another module (if
    a dependency exists; this is covered in detail in the next chapter's *Module stacking*
    section) or the module is currently in use by a process (or thread), then the
    module usage count will be positive and `rmmod` will fail (`errno <- EBUSY`).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果另一个模块正在使用内核模块的代码和/或数据（如果存在依赖关系；这在下一章的 *模块堆叠* 部分中有详细介绍），或者模块当前正在被进程（或线程）使用，则模块使用计数将为正，并且
    `rmmod` 将失败（`errno <- EBUSY`）。
- en: The kernel module did not specify an exit routine (or destructor) with the `module_exit()`
    macro *and* the `CONFIG_MODULE_FORCE_UNLOAD` kernel config option is disabled.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块没有使用 `module_exit()` 宏指定退出例程（或析构函数）*和* `CONFIG_MODULE_FORCE_UNLOAD` 内核配置选项被禁用。
- en: 'Several convenience utilities concerned with module management are nothing
    but symbolic (soft) links to the single `kmod(8)` utility (analogous to what the
    popular *busybox* utility does). The wrappers are `lsmod(8), rmmod(8)`, `insmod(8)`,
    `modinfo(8)`, `modprobe(8)`, and `depmod(8)`. Take a look at a few of them:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块管理相关的几个便利实用程序只是指向单个 `kmod(8)` 实用程序的符号（软）链接（类似于流行的 *busybox* 实用程序所做的）。这些包装器是
    `lsmod(8), rmmod(8)`, `insmod(8)`, `modinfo(8)`, `modprobe(8)`, 和 `depmod(8)`。让我们看看其中的一些：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the precise location of these utilities (`/bin`, `/sbin`, or `/usr/sbin`)
    can vary with the distribution.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些实用程序的确切位置（`/bin`，`/sbin`或`/usr/sbin`）可能会随着发行版的不同而有所变化。
- en: Our lkm convenience script
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的 lkm 便利脚本
- en: 'Let''s round off this *first kernel module* discussion with a simple yet useful
    custom Bash script called `lkm` that helps you out by automating the kernel module
    build, load, `dmesg`, and unload workflow. Here it is (the complete code is in
    the root of the book source tree):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个名为 `lkm` 的简单而有用的自定义 Bash 脚本来结束这个 *第一个内核模块* 的讨论，它可以通过自动化内核模块的构建、加载、`dmesg`
    和卸载工作流程来帮助你。这是它的内容（完整的代码在书籍源代码树的根目录中）：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Given the name of the kernel module as a parameter – without any extension
    part (such as `.c`) – the `lkm` script performs some validity checks, displays
    some version information, and then uses a wrapper `runcmd()` bash function to
    display the name of and run a given command, in effect getting the `clean/build/load/lsmod/dmesg`
    workflow done painlessly. Let''s try it out on our first kernel module:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 给定内核模块的名称作为参数 - 没有任何扩展部分（例如 `.c`）- `lkm` 脚本执行一些有效性检查，显示一些版本信息，然后使用包装器 `runcmd()` bash
    函数来显示并运行给定命令的名称，从而轻松完成 `clean/build/load/lsmod/dmesg` 工作流程。让我们在我们的第一个内核模块上试一试：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All done! Remember to unload the kernel module with `rmmod(8)`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 全部完成！记得使用 `rmmod(8)` 卸载内核模块。
- en: Congratulations! You have now learned how to write and try out a simple *Hello,
    world* kernel module. Much work remains, though, before you rest on your laurels;
    the next section delves into more key details regarding kernel logging and the
    versatile printk API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经学会了如何编写并尝试一个简单的 *Hello, world* 内核模块。不过，在你休息之前，还有很多工作要做；下一节将更详细地探讨有关内核日志记录和多功能
    printk API 的关键细节。
- en: Understanding kernel logging and printk
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内核日志和 printk
- en: There is still a lot to cover regarding the logging of kernel messages via the printk
    kernel API*.* This section delves into some of the details. It's important for
    a budding kernel developer like you to clearly understand these.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通过 printk 内核 API 记录内核消息仍有很多内容需要涵盖。本节深入探讨了一些细节。对于像你这样的新手内核开发人员来说，清楚地理解这些内容非常重要。
- en: In this section, we delve into more detail regarding kernel logging. We come
    to understand how exactly printk output is dealt with, looking at its pros and
    cons. We discuss the printk log levels, how modern systems log messages via the systemd journal,
    and how output can be directed to the console device. We round off this discussion
    with a note on rate-limiting printk and user-generated prints, generating printk's
    from user space and standardizing the printk output format.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地探讨内核日志记录。我们将了解到 printk 输出是如何处理的，以及其利弊。我们将讨论 printk 日志级别，现代系统如何通过 systemd 日志记录消息，以及如何将输出定向到控制台设备。我们将以限制
    printk 和用户生成的打印输出，从用户空间生成 printk，并标准化 printk 输出格式的注意来结束本讨论。
- en: 'We saw earlier, in the *A quick first look at the kernel* *printk* section, the
    essentials of using the kernel printk API''s functionality. Here, we explore a
    lot more with respect to the `printk()` API''s usage. In our simple kernel module,
    here''s the line of code that emits the "*Hello, world"* message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 *快速查看内核* *printk* 部分看到了使用内核 printk API 功能的基本知识。在这里，我们将更详细地探讨关于 `printk()`
    API 的使用。在我们简单的内核模块中，这是发出 "*Hello, world*" 消息的代码行：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, `printk`is similar to `printf` in terms of the *format string* and how
    that works – but the similarities end there. For emphasis, we repeat: a key difference
    between `printf` and `printk`is that `printf(3)` is a *user space library* API
    that works by invoking the `write(2)` system call, which writes to the *stdout
    device, *which by default is usually the Terminal window (or console device).
    The printk, on the other hand, is a *kernel space* API whose output instead goes
    to at least one place, the first one shown in the list below, and possibly to
    more places:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`printk`与`printf`类似，都涉及*格式字符串*以及其工作原理 - 但相似之处就到此为止。值得强调的是，`printf(3)`是一个*用户空间库*API，通过调用`write(2)`系统调用来工作，该系统调用写入*stdout设备*，默认情况下通常是终端窗口（或控制台设备）。而`printk`是一个*内核空间*API，其输出实际上会被发送到至少一个位置，如下列表中所示的第一个位置，可能还会发送到更多位置：
- en: A kernel log buffer (in RAM; volatile)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核日志缓冲区（在RAM中；易失性）
- en: A kernel log file (non-volatile)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核日志文件（非易失性）
- en: The console device
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台设备
- en: Let's examine the kernel log buffer in more detail.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查内核日志缓冲区。
- en: Using the kernel memory ring buffer
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内核内存环形缓冲区
- en: 'The kernel log buffer is simply a memory buffer within a kernel address space
    where the printk output is saved (logged). More technically, it''s the global
    `__log_buf[]` variable. Its definition in the kernel source is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 内核日志缓冲区只是内核地址空间中的一个内存缓冲区，用于保存（记录）`printk`的输出。更具体地说，它是全局变量`__log_buf[]`。在内核源代码中的定义如下：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's architected as a *ring buffer*; it has a finite size (`__LOG_BUF_LEN` bytes), and
    once it's full, it gets overwritten from byte zero. Hence, it's called a "ring"
    or circular, buffer). Here, we can see that the size is based on the `Kconfig`
    variable `CONFIG_LOG_BUF_SHIFT` (`1 << n` in C implies `2^n`). This value is shown
    and can be overridden as part of the kernel `(menu)config` here: `General Setup
    > Kernel log buffer size`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它被设计为一个*环形缓冲区*；它有一个有限的大小（`__LOG_BUF_LEN`字节），一旦满了，就会从第一个字节开始覆盖。因此，它被称为“环形”或循环缓冲区）。在这里，我们可以看到大小是基于`Kconfig`变量`CONFIG_LOG_BUF_SHIFT`（C中的`1
    << n`表示`2^n`）。这个值是显示的，并且可以作为内核`(菜单)配置`的一部分被覆盖：`常规设置 > 内核日志缓冲区大小`。
- en: It's an integer value with a range of `12 - 25` (we can always search `init/Kconfig` and
    see its spec), with a default value of `18`. So, the size of the log buffer =
    2^(18) = 256 KB. However, the actual runtime size is affected by other config
    directives as well, notably `LOG_CPU_MAX_BUF_SHIFT`, which makes the size a function
    of the number of CPUs on the system. Furthermore, the relevant `Kconfig` file
    says, *"Also this option is ignored when the log_buf_len kernel parameter is used
    as it forces an exact (power of two) size of the ring buffer." *So, that's interesting;
    we can often override defaults by passing a *kernel parameter* (via the bootloader)!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个整数值，范围为`12 - 25`（我们可以随时搜索`init/Kconfig`并查看其规范），默认值为`18`。因此，日志缓冲区的大小=2^(18)=256
    KB。但是，实际运行时的大小也受其他配置指令的影响，特别是`LOG_CPU_MAX_BUF_SHIFT`，它使大小成为系统上CPU数量的函数。此外，相关的`Kconfig`文件中说，*"当使用log_buf_len内核参数时，此选项将被忽略，因为它会强制使用环形缓冲区的确切（2的幂）大小。"*因此，这很有趣；我们经常可以通过传递*内核参数*（通过引导加载程序）来覆盖默认值！
- en: 'Kernel parameters are useful, many, and varied, and are well worth checking
    out. See the official documentation here: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html).
    A snippet from the Linux kernel documentation on the `log_buf_len` kernel parameter
    reveals the details:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 内核参数非常有用，种类繁多，值得一看。请参阅官方文档：[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)。来自Linux内核文档关于`log_buf_len`内核参数的片段揭示了细节：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Whatever the size of the kernel log buffer, two issues when dealing with the printk
    API become obvious:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 无论内核日志缓冲区的大小如何，处理 printk API 时会出现两个问题：
- en: Its messages are being logged in *volatile* memory (RAM); if the system crashes
    or power cycles in any manner, we will lose the precious kernel log (often eliminating
    our ability to debug).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的消息被记录在*易失性*内存（RAM）中；如果系统崩溃或以任何方式断电，我们将丢失宝贵的内核日志（通常会影响我们的调试能力）。
- en: The log buffer isn't very large by default, typically just 256 KB; voluminous
    prints will overwhelm the ring buffer, making it wrap around, thus losing information.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，日志缓冲区并不是很大，通常只有256 KB；大量的打印会使环形缓冲区不堪重负，导致信息丢失。
- en: How can we fix this? Read on...
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？继续阅读...
- en: Kernel logging and systemd's journalctl
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核日志和systemd的journalctl
- en: 'An obvious solution to the previously mentioned issues is to write (append)
    the kernel printk to a file. This is precisely how most modern Linux distributions
    are set up. The location of the log file varies with the distro: conventionally,
    the Red Hat-based ones write into the `/var/log/messages` file and the Debian-based
    ones into `/var/log/syslog`. Traditionally, the kernel printk would hook into
    the user space *system logger daemon* (`syslogd`)to perform file logging, thus
    automatically getting the benefit of more sophisticated features, such as log
    rotation, compression, and archival.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解决前面提到的问题的一个明显方法是将内核的`printk`写入（追加）到文件中。这正是大多数现代Linux发行版的设置方式。日志文件的位置因发行版而异：传统上，基于Red
    Hat的发行版会写入`/var/log/messages`文件，而基于Debian的发行版会写入`/var/log/syslog`。传统上，内核的`printk`会连接到用户空间的*系统日志守护程序*（`syslogd`）以执行文件记录，因此自动获得更复杂功能的好处，如日志轮换、压缩和归档。
- en: Over the past several years, though, system logging has been completely taken
    over by a useful and powerful new framework for system initialization called **systemd** (it replaces,
    or often works in addition to, the old SysV init framework). Indeed, systemd is
    now routinely used on even embedded Linux devices. Within the systemd framework,
    logging is performed by a daemon process called `systemd-journal`, and the `journalctl(1)`utility
    is the user interface to it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在过去的几年里，系统日志已经完全被一个称为**systemd**的有用而强大的系统初始化新框架所取代（它取代了旧的SysV init框架，或者通常与其一起工作）。事实上，即使是嵌入式Linux设备也经常使用systemd。在systemd框架内，日志记录由一个名为`systemd-journal`的守护进程执行，而`journalctl(1)`实用程序是其用户界面。
- en: The detailed coverage of systemd and its associated utilities is beyond the
    scope of this book. Please refer to the *Further reading* section of this chapter
    for links to (a lot) more on it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: systemd及其相关实用程序的详细覆盖范围超出了本书的范围。请参考本章的*进一步阅读*部分，了解更多相关内容。
- en: 'One key advantage of using the journal to retrieve and interpret logs is that **all
    logs** from applications, libraries, system daemons, the kernel, drivers, and
    so on are written (merged) here. This way, we can see a (reverse) chronological
    timeline of events without having to manually piece together different logs into
    a timeline. The man page on the `journalctl(1)`utility covers its various options
    in detail. Here, we present some (hopefully) convenient aliases based on this
    utility:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志记录来检索和解释日志的一个关键优势是，**所有**来自应用程序、库、系统守护进程、内核、驱动程序等的日志都会被写入（合并）在这里。这样，我们就可以看到一个（反向）时间线事件，而不必手动将不同的日志拼接成一个时间线。`journalctl(1)`实用程序的man页面详细介绍了它的各种选项。在这里，我们提供了一些（希望）基于这个实用程序的方便别名：
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the `-b` option `current boot` implies that the journal is displayed
    from the most recent system boot date at the present moment. A numbered listing
    of stored system (re)boots can be seen with `journalctl --list-boots`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`-b`选项`current boot`意味着日志是从当前系统启动日期显示的。可以使用`journalctl --list-boots`查看存储的系统（重新）启动的编号列表。
- en: 'We deliberately use the `--no-pager` option as it allows us to further filter
    the output with `[e]grep(1)`, `awk(1), sort(1)`, and so on, as required. A simple
    example of using `journalctl(1)` follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意使用`--no-pager`选项，因为它允许我们进一步使用`[e]grep(1)`、`awk(1)`、`sort(1)`等来过滤输出，根据需要。以下是使用`journalctl(1)`的一个简单示例：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice the default log format of the journal:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意日志的默认格式：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here `[source]` is `kernel` for kernel messages, or the name of the particular
    application or service that writes the message.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`[source]`是内核消息的内核，或者写入消息的特定应用程序或服务的名称。
- en: 'It''s useful to see a couple of usage examples from the man page on `journalctl(1)`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从`journalctl(1)`的man页面中看一些用法示例是有用的：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The non-volatile logging of kernel messages into files is very useful, of course.
    Note, though, that there exist circumstances, often dictated by hardware constraints,
    that might render it impossible. For example, a tiny, highly resource-constrained
    embedded Linux device might use a small internal flash chip as its storage medium.
    Now, not only is it small and all the space is pretty much used up by the apps,
    libraries, kernel, and bootloader, it is also a fact that flash-based chips have
    an effective limit on the number of erase-write cycles they can sustain before
    wearing out. Thus, writing to it a few million times might finish it off! So,
    sometimes, system designers deliberately and/or additionally use cheaper external
    flash memory such as (micro)SD/MMC cards (for non-critical data) to mitigate this
    impact, as they're easily replaceable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将内核消息非易失性地记录到文件中当然是非常有用的。但要注意，存在一些情况，通常由硬件限制所决定，可能会使这种记录变得不可能。例如，一个小型、高度资源受限的嵌入式Linux设备可能会使用小型内部闪存芯片作为存储介质。现在，它不仅很小，而且所有的空间几乎都被应用程序、库、内核和引导加载程序所使用，而且闪存芯片有一个有效的擦写周期限制，它们可以承受的擦写周期数量有限。因此，写入几百万次可能会使其报废！因此，有时系统设计人员故意和/或另外使用更便宜的外部闪存存储器，比如（微）SD/MMC卡（用于非关键数据），以减轻这种影响，因为它们很容易更换。
- en: Let's move on to understanding printk log levels.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续了解printk日志级别。
- en: Using printk log levels
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用printk日志级别
- en: 'To understand and use printk log levels, let''s begin by reproducing that single
    line of code – the first printk from our `helloworld_lkm` kernel module:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解和使用printk日志级别，让我们从我们的`helloworld_lkm`内核模块的第一个printk开始，重现那一行代码：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s now address the elephant in the room: what exactly does `KERN_INFO` mean?
    Firstly, be careful now: it''s *not* what your knee-jerk reaction says it is –
    a parameter. No! Notice that there is no comma character between it and the format
    string; just white space. `KERN_INFO` is merely one of **eight** **log levels**that
    a kernel printk gets logged at. A key thing to understand right away is that this
    log level is *not *a priority of any sort; its presence allows us *to filter messages*
    based on log level. The kernel defines eight possible log levels for printk; here
    they are:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决房间里的大象：`KERN_INFO`到底意味着什么？首先，现在要小心：它*不是*你的本能反应所说的参数。注意它和格式字符串之间没有逗号字符，只有空格。`KERN_INFO`只是内核printk记录的**八个**日志级别中的一个。立即要理解的一个关键点是，这个日志级别*不是*任何优先级；它的存在允许我们*根据日志级别过滤消息*。内核为printk定义了八个可能的日志级别；它们是：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, now we see that the `KERN_<FOO>` log levels are merely strings (`"0", "1",
    ..., "7"`) that get prefixed to the kernel message being emitted by printk; nothing
    more. This gives us the useful ability to filter messages based on log level.
    The comment on the right of each of them clearly shows the developer when to use
    which log level.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们看到`KERN_<FOO>`日志级别只是被添加到由printk发出的内核消息的字符串（"0"、"1"、...、"7"）；没有更多。这使我们有了根据日志级别过滤消息的有用能力。它们右侧的注释清楚地向开发人员显示了何时使用哪个日志级别。
- en: What's `KERN_SOH`? That's the ASCII **Start Of Header** (**SOH**) value `\001`.
    See the man page on `ascii(7)`; the `ascii(1)` utility dumps the ASCII table in
    various numerical bases. From here, we can clearly see that numeric `1` (or `\001`)
    is the `SOH` character, a convention that is followed here.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`KERN_SOH`是什么？那就是ASCII **报头开始**（**SOH**）值`\001`。查看`ascii(7)`的man页面；`ascii(1)`实用程序以各种数字基数转储ASCII表。从这里，我们可以清楚地看到数字`1`（或`\001`）是`SOH`字符，这里遵循的是一个约定。'
- en: 'Let''s quickly look at a couple of actual examples from within the Linux kernel
    source tree. When the kernel''s `hangcheck-timer`device driver (somewhat akin
    to a software watchdog) determines that a certain timer expiry (60 seconds by
    default) was delayed for over a certain threshold (by default, 180 seconds), it
    restarts the system! Here we show the relevant kernel code – the place where the
    `hangcheck-timer` driver emits printk in this regard:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下Linux内核源树中的一些实际示例。当内核的`hangcheck-timer`设备驱动程序（有点类似于软件看门狗）确定某个定时器到期（默认为60秒）被延迟超过一定阈值（默认为180秒）时，它会重新启动系统！在这里，我们展示了相关的内核代码
    - `hangcheck-timer`驱动程序在这方面发出`printk`的地方：
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Check out how the printk API was called with log level set to `KERN_CRIT`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`printk` API是如何调用的，日志级别设置为`KERN_CRIT`。
- en: 'On the other hand, squeaking out an informational message might be just what
    the doctor ordered: here, we see the generic parallel printer driver politely
    informing all concerned that the printer is on fire (rather understated, yes?):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，发出信息消息可能正是医生所开的处方：在这里，我们看到通用并行打印机驱动程序礼貌地通知所有相关方打印机着火了（相当低调，是吧？）
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You''d think a device being on fire will qualify the printk to be emitted at
    the "emergency" logging level... well, at least the `arch/x86/kernel/cpu/mce/p5.c:pentium_machine_check()` function
    adheres to this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为设备着火将使`printk`符合“紧急”日志级别...好吧，至少`arch/x86/kernel/cpu/mce/p5.c:pentium_machine_check()`函数遵循了这一点：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: (The `pr_<foo>()` convenience macros are covered next).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: （`pr_<foo>()`方便宏将在下面介绍）。
- en: '**An FAQ***:* if, within the `printk()`, the log level is *not* specified,
    what log level is the print emitted at? It''s `4` by default, that is, `KERN_WARNING` (the
    *Writing to the console* section reveals why exactly this is). Note, though, that
    you are expected to always specify a suitable log level when using printk.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题解答***：*如果在`printk()`中未指定日志级别，则打印将以什么日志级别发出？默认为`4`，即`KERN_WARNING`（*写入控制台*部分详细说明了为什么）。请注意，您应始终在使用`printk`时指定适当的日志级别。'
- en: There's an easy way to specify the kernel message log level. This is what we
    delve into next.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种简单的方法来指定内核消息日志级别。这是我们接下来要深入研究的内容。
- en: The pr_<foo> convenience macros
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pr_<foo>方便宏
- en: The convenience **`pr_<foo>()`** macros given here ease coding pain. The clunky
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的方便**`pr_<foo>()`**宏可以减轻编码痛苦。笨拙的
- en: '`printk(KERN_FOO "<format-str>");` is replaced with the elegant'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk(KERN_FOO "<format-str>");`被优雅地替换为'
- en: '`pr_foo("<format-str>");`, where `<foo>` is the log level; their use is encouraged:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`pr_foo("<format-str>");`，其中`<foo>`是日志级别；鼓励使用它们：'
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The kernel allows us to pass `loglevel=n` as a kernel command-line parameter,
    where `n` is an integer between `0` and `7`, corresponding to the eight log levels
    mentioned previously. As expected (as you shall soon learn), all printk instances
    with a log level less than that which was passed will be directed to the console
    device as well.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 内核允许我们将`loglevel=n`作为内核命令行参数传递，其中`n`是介于`0`和`7`之间的整数，对应于先前提到的八个日志级别。预期的是（很快您将会了解到），所有具有低于传递的日志级别的`printk`实例也将被定向到控制台设备。
- en: Writing a kernel message directly to the console device is at times very useful;
    the next section deals with the details on how we can achieve this.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将内核消息写入控制台设备有时非常有用；下一节将详细介绍如何实现这一点。
- en: Wiring to the console
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到控制台
- en: 'Recall that the printk output might go to up to three locations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`printk`输出可能会到达三个位置：
- en: The first being the kernel memory log buffer (always)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是内核内存日志缓冲区（始终）
- en: The second being non-volatile log files
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是非易失性日志文件
- en: 'The last one (that we''ll address here): the *console device*'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个（我们将在这里讨论）：*控制台设备*
- en: Traditionally, the console device is a pure kernel feature, the initial Terminal
    window that the superuser logs into (`/dev/console`) in a non-graphical environment.
    Interestingly, on Linux, we can define several consoles – a **teletype terminal**
    (**tty**) window (such as `/dev/console`), a text-mode VGA, a framebuffer, or
    even a serial port served over USB (this being common on embedded systems during
    development; see more on Linux consoles in the *Further reading *section of this
    chapter).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，控制台设备是一个纯内核功能，超级用户登录的初始终端窗口（`/dev/console`）在非图形环境中。有趣的是，在Linux上，我们可以定义几个控制台
    - 一个**电传打字机终端**（**tty**）窗口（如`/dev/console`），文本模式VGA，帧缓冲区，甚至是通过USB提供的串行端口（这在嵌入式系统开发中很常见；请参阅本章的*进一步阅读*部分中的有关Linux控制台的更多信息）。
- en: 'For example, when we connect a Raspberry Pi to an x86-64 laptop via a USB-to-RS232
    TTL UART (USB-to-serial) cable (see the *Further reading *section of this chapter
    for a blog article on this very useful accessory and how to set it up on the Raspberry
    Pi!) and then use `minicom(1)` (or `screen(1)`) to get a serial console, this
    is what shows up as the `tty`device – it''s the serial port:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们通过USB到RS232 TTL UART（USB到串行）电缆将树莓派连接到x86-64笔记本电脑时（请参阅本章的*进一步阅读*部分，了解有关这个非常有用的附件以及如何在树莓派上设置它的博客文章！），然后使用`minicom(1)`（或`screen(1)`）获取串行控制台时，这就是显示为`tty`设备的内容
    - 它是串行端口：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The point here is that the console is often the target of *important-enough*
    log messages, including those originating from deep within the kernel. Linux''s printk uses
    a `proc`-based mechanism for conditionally delivering its data to the console
    device. To understand this better, let''s first check out the relevant `proc`
    pseudo-file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是，控制台通常是*足够重要*的日志消息的目标，包括那些源自内核深处的消息。Linux的`printk`使用基于`proc`的机制有条件地将其数据传递到控制台设备。为了更好地理解这一点，让我们首先查看相关的`proc`伪文件：
- en: '[PRE41]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We interpret the preceding four numbers as printk log levels (with `0` being
    the highest and `7` the lowest in terms of "urgency"). The preceding four-integer
    sequence''s meaning is this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前面的四个数字解释为printk日志级别（`0`为最高，“紧急”级别为`7`为最低）。前面的四个整数序列的含义是这样的：
- en: The current (console) log level
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前（控制台）日志级别
- en: '*- The implication being that all messages less than this value will appear
    on the console device!*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 暗示着所有低于此值的消息将出现在控制台设备上！*'
- en: The default level for messages that lack an explicit log level
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏显式日志级别的消息的默认级别
- en: The minimum allowed log level
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的最低日志级别
- en: The boot-time default log level
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时的默认日志级别
- en: From this, we can see that log level `4` corresponds to `KERN_WARNING`. Thus,
    with the first number being `4` (indeed, the typical default on a Linux distro),* all
    printk instances lower than log level 4 will appear on the console device, *as
    well as being logged to a file, of course – in effect, all messages at the following
    log levels: `KERN_EMERG`,  `KERN_ALERT`,  `KERN_CRIT`, and `KERN_ERR`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，日志级别`4`对应于`KERN_WARNING`。因此，第一个数字为`4`（实际上是Linux发行版的典型默认值），*所有低于日志级别4的printk实例将出现在控制台设备上*，当然也会被记录到文件中-实际上，所有以下日志级别的消息：`KERN_EMERG`、`KERN_ALERT`、`KERN_CRIT`和`KERN_ERR`。
- en: Kernel messages at log level `0 [KERN_EMERG]` are *always *printed to the console,
    and indeed to all Terminal windows and the kernel log file, regardless of any
    settings.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别为`0 [KERN_EMERG]`的内核消息*总是*打印到控制台，确实打印到所有终端窗口和内核日志文件，而不受任何设置的影响。
- en: 'It''s worth noting that very often, when working on embedded Linux or any kernel
    development, you will work *on* the console device, as is the case with the Raspberry
    Pi example just given. Setting the `proc printk` pseudo-file''s first integer
    value to `8` will *guarantee that all printk instances appear directly on the
    console*, **thus making printk behave like a regular printf would!** Here, we
    show how the root user can easily set this up:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当在嵌入式Linux或任何内核开发中工作时，通常会在控制台设备上工作，就像刚才给出的树莓派示例一样。将`proc printk`伪文件的第一个整数值设置为`8`将*保证所有printk实例直接出现在控制台上*，**从而使printk的行为类似于常规的printf！**在这里，我们展示了root用户如何轻松设置这一点：
- en: '[PRE42]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: (Of course, this would have to be done as root.) This can be very convenient
    during development and test.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，这必须以root身份完成。）这在开发和测试过程中非常方便。
- en: 'On my Raspberry Pi, I keep a startup script that contains the following line:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的树莓派上，我保留了一个包含以下行的启动脚本：
- en: '`[ $(id -u) -eq 0 ] && echo "8 4 1 7" > /proc/sys/kernel/printk`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ $(id -u) -eq 0 ] && echo "8 4 1 7" > /proc/sys/kernel/printk`'
- en: Thus, when running it as root, this takes effect and all printk instances now
    directly appear on the `minicom(1)` console, just as `printf` would.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以root身份运行时，这将生效，所有printk实例现在直接出现在`minicom(1)`控制台上，就像`printf`一样。
- en: Talking about the versatile Raspberry Pi, the next section demonstrates running
    a kernel module on one.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到多功能的树莓派，下一节演示了在树莓派上运行内核模块。
- en: Writing output to the Raspberry Pi console
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将输出写入树莓派控制台
- en: 'On to our second kernel module! Here, we shall emit nine printk instances,
    one at each of the eight log levels, plus one via the `pr_devel()` macro (which
    is really nothing but the `KERN_DEBUG` log level). Let''s check out the relevant
    code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的第二个内核模块！在这里，我们将发出九个printk实例，每个实例都在八个日志级别中的一个，另外一个通过`pr_devel()`宏（实际上只是`KERN_DEBUG`日志级别）。让我们来看看相关的代码：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we will discuss the output when running the preceding `printk_loglvl`kernel
    module on a Raspberry Pi device. If you don't possess one or it's not handy, that's
    not a problem; please go ahead and try it out on an x86-64 guest VM.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论在树莓派设备上运行前述`printk_loglvl`内核模块时的输出。如果您没有或者不方便使用树莓派，那没问题；请继续在x86-64虚拟机上尝试。
- en: 'On the Raspberry Pi device (here I used the Raspberry Pi 3B+ model running
    the default Raspberry Pi OS), we log in and get ourselves a root shell via a simple `sudo
    -s`. We then build the kernel module. If you have installed the default Raspberry
    Pi image on the Raspberry Pi, all required development tools, kernel headers,
    and more will be pre-installed! Figure 4.7 is a screenshot of running our `printk_loglvl`
    kernel module on a Raspberry Pi board. Also, it''s important to realize that we''re
    running **on the console device** as we are using the aforementioned USB-to-serial
    cable over the `minicom(1)` Terminal emulator app (and *not* simply over an SSH
    connection):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派设备上（我在这里使用的是运行默认树莓派OS的树莓派3B+型号），我们登录并通过简单的`sudo -s`获取root shell。然后我们构建内核模块。如果您在树莓派上安装了默认的树莓派镜像，所有必需的开发工具、内核头文件等都将预先安装！图4.7是在树莓派板上运行我们的`printk_loglvl`内核模块的截图。另外，重要的是要意识到我们正在**控制台设备**上运行，因为我们正在使用前面提到的USB转串口电缆通过`minicom(1)`终端仿真器应用程序（而不是简单地通过SSH连接）：
- en: '![](img/ad3ab2f1-3279-4131-872f-49d290740d47.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad3ab2f1-3279-4131-872f-49d290740d47.png)'
- en: Figure 4.7 – The minicom Terminal emulator app window – the console – with the
    printk_loglvl kernel module output
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 - minicom终端仿真器应用程序窗口-控制台-带有printk_loglvl内核模块输出
- en: 'Notice something a bit different from the x86-64 environment: here, by default,
    the first integer in the output of `/proc/sys/kernel/printk` – the current console
    log level – is `3` (not `4`). Okay, so this implies that all kernel printk instances
    at log level *less than log level 3* will appear directly on the console device.
    Look at the screenshot: this is indeed the case! Furthermore, and as expected,
    the printk instanceat the "emergency" log level (`0`) always appears on the console,
    indeed on every open Terminal window.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从x86-64环境中注意到一些与之有点不同：在这里，默认情况下，“/proc/sys/kernel/printk”输出的第一个整数-当前控制台日志级别-是3（而不是4）。好吧，这意味着所有内核printk实例的日志级别低于日志级别3将直接出现在控制台设备上。看一下截图：情况确实如此！此外，正如预期的那样，“紧急”日志级别（`0`）的printk实例始终出现在控制台上，确实出现在每个打开的终端窗口上。
- en: 'Now for the interesting part: let''s set (as root, of course) the current console
    log level (remember, it''s the first integer in the output of `/proc/sys/kernel/printk`)
    to the value `8`. This way, all printk instances should appear directly on the
    console*.* We test precisely this here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分：让我们（当然是作为root）将当前控制台日志级别（记住，它是`/proc/sys/kernel/printk`输出中的第一个整数）设置为值`8`。这样，*所有的printk*实例应该直接出现在控制台上。我们在这里精确测试了这一点：
- en: '![](img/4140c171-54f0-4ebf-aca5-ebffc5db9963.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4140c171-54f0-4ebf-aca5-ebffc5db9963.png)'
- en: Figure 4.8 – The minicom Terminal – in effect, the console – window, with the
    console log level set to 8
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 - minicom终端 - 实际上是控制台 - 窗口，控制台日志级别设置为8
- en: Indeed, as expected, we see *all* the printk instances on the console device
    itself obviating the need to use `dmesg`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，正如预期的那样，我们在控制台设备上看到了*所有*的`printk`实例，无需使用`dmesg`。
- en: 'Hang on a moment, though: whatever happened to the `pr_debug()` and `pr_devel()` macros
    emitting a kernel message at log level `KERN_DEBUG` (that is, integer value `7`)?
    It has *not *appeared here, nor in the following `dmesg` output? We explain this
    shortly; please read on.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，等一下：`pr_debug()`和`pr_devel()`宏发出的内核消息在日志级别`KERN_DEBUG`（即整数值`7`）上发生了什么？它在这里*没有*出现，也没有在接下来的`dmesg`输出中出现？我们马上解释这一点，请继续阅读。
- en: 'With `dmesg(1)`, of course, all kernel messages – well, at least those still
    in the kernel log buffer in RAM – will be revealed. We see this to be the case
    here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过`dmesg(1)`，所有内核消息（至少是RAM中内核日志缓冲区中的消息）都会显示出来。我们在这里看到了这种情况：
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All printk's instances – except the `KERN_DEBUG` ones – are seen as we are looking
    at the kernel log via the `dmesg` utility. So, how do we get a debug message displayed?
    That's covered next.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`KERN_DEBUG`之外的所有`printk`实例都可以通过`dmesg`实用程序查看内核日志来看到。那么，如何显示调试消息呢？接下来会介绍。
- en: Enabling the pr_debug() kernel messages
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用pr_debug()内核消息
- en: 'Ah yes, `pr_debug()` turns out to be a bit of a special case: unless the `DEBUG` symbol is
    *defined* for the kernel module, a `printk`instance at log level `KERN_DEBUG` does
    not show up. We edit the kernel module''s Makefile to enable this. There are (at
    least) two ways to set this up:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 啊是的，`pr_debug()`原来是一个特殊情况：除非为内核模块*定义*了`DEBUG`符号，否则在日志级别`KERN_DEBUG`下的`printk`实例不会显示出来。我们编辑内核模块的Makefile以启用这一功能。至少有两种设置方法：
- en: 'Insert this line into the Makefile:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这行插入到Makefile中：
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Generically, it's `CFLAGS_<filename>.o  :=  -DDEBUG`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的是`CFLAGS_<filename>.o := -DDEBUG`。
- en: 'We could also just insert this statement into the Makefile:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以将这个语句插入到Makefile中：
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In our Makefile, we have deliberately kept the `-DDEBUG` commented out, to
    begin with. Now, to try it out, un-comment one of the following commented-out
    lines:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Makefile中，我们故意保持`-DDEBUG`注释掉，现在，为了尝试它，取消以下注释掉的行中的一个：
- en: '[PRE47]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once done, we remove the old stale kernel module from memory, rebuild it, and
    insert it using our `lkm`script. The output reveals that `pr_debug()`now does
    take effect:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们从内存中删除旧的过时内核模块，重新构建它，并使用我们的`lkm`脚本插入它。输出显示`pr_debug()`现在生效了：
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A partial screenshot (Figure 4.9) of the `lkm` script''s output clearly reveals
    the `dmesg` color-coding, with `KERN_ALERT / KERN_CRIT / KERN_ERR` background
    highlighted in red/in bold red typeface/in red foreground color, respectively,
    and `KERN_WARNING` in bold black typeface, helping us humans quickly spot important
    kernel messages:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`lkm`脚本输出的部分截图（图4.9）清楚地显示了`dmesg`的颜色编码，`KERN_ALERT / KERN_CRIT / KERN_ERR`的背景以红色/粗体红色字体/红色前景颜色突出显示，`KERN_WARNING`以粗体黑色字体显示，帮助我们人类快速发现重要的内核消息。'
- en: '![](img/76a8a54e-f3c7-4d0a-9c5f-764cc68d4686.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76a8a54e-f3c7-4d0a-9c5f-764cc68d4686.png)'
- en: Figure 4.9 – Partial screenshot of lkm script's output
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 - lkm脚本输出的部分截图
- en: Note that the behavior of `pr_debug()` is not identical when the dynamic debug feature
    (`CONFIG_DYNAMIC_DEBUG=y`) is enabled.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当启用动态调试功能（`CONFIG_DYNAMIC_DEBUG=y`）时，`pr_debug()`的行为并不相同。
- en: Device driver authors should note that for the purpose of emitting debug `printk`
    instances, they should avoid using `pr_debug()`. Instead, it is recommended that
    a device driver uses the `dev_dbg()` macro (additionally passing along a parameter
    to the device in question). Also, `pr_devel()` is meant to be used for kernel-internal
    debug `printk` instances whose output should never be visible in production systems.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序作者应该注意，为了发出调试`printk`实例，他们应该避免使用`pr_debug()`。相反，建议设备驱动程序使用`dev_dbg()`宏（另外传递给相关设备的参数）。此外，`pr_devel()`是用于内核内部调试`printk`实例的，其输出在生产系统中永远不应该可见。
- en: 'Now, back to the section on console output. So, for perhaps the purpose of
    kernel debugging (if nothing else), is there a guaranteed way to ensure that *all*
    printk instances are directed to the console*? *Yes, indeed – just pass the kernel
    (boot-time) parameter called `ignore_level`. For more details on this, do look
    up the description in the official kernel documentation: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html).
    Toggling the ignoring of the printk log level is also possible: as mentioned there,
    you can turn on the ignoring of printk log levels by doing this, thus allowing
    all printk''s to appear on the console device (and conversely, turn it off by
    echoing N into the same pseudo-file):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到控制台输出部分。因此，也许出于内核调试的目的（如果没有其他目的），有没有一种保证的方法可以确保*所有*的printk实例都被定向到控制台*？*是的，确实
    - 只需传递名为`ignore_level`的内核（启动时）参数。有关此更多详细信息，请查阅官方内核文档中的描述：[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)。忽略printk日志级别也是可能的：如上所述，您可以通过这样做打开忽略printk日志级别的功能，从而允许所有printk出现在控制台设备上（反之亦然，通过向同一伪文件中回显N来关闭它）：
- en: '[PRE49]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `dmesg(1)` utility can also be used to control the enabling/disabling of
    kernel messages to the console device, as well as the console logging level (that
    is, the level numerically below which messages will appear on the console) via
    various option switches (in particular, the `--console-level` option). I leave
    it to you to browse through the man page on `dmesg(1)` for the details.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: dmesg(1)实用程序也可以用于通过各种选项开关（特别是--console-level选项）控制启用/禁用内核消息到控制台设备，以及控制台日志级别（即在该级别以下的消息将出现在控制台上）。我让你浏览一下dmesg(1)的man页面以获取详细信息。
- en: 'The next segment deals with another very useful logging feature: rate-limiting.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分涉及另一个非常有用的日志记录功能：速率限制。
- en: Rate limiting the printk instances
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制printk实例的速率
- en: When we emit `printk` instances from a code path that is executed very often,
    the sheer amount of `printk` instances might quickly overflow the kernel log buffer
    (in RAM; remember that it's a circular buffer), thus overwriting what might well
    be key information. Besides that, ever-growing non-volatile log files that then
    repeat pretty much the same `printk` instances (almost) ad infinitum are not a
    great idea either and waste disk space, or worse, flash space. For example, think
    of a large-ish printk in an interrupt handler code path. What if the hardware
    interrupt is invoked at a frequency of, say, 100 Hz, that is, 100 times every
    single second!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从执行非常频繁的代码路径发出printk实例时，printk实例的数量可能会迅速超出内核日志缓冲区（在RAM中；请记住它是一个循环缓冲区），从而覆盖可能是关键信息。此外，不断增长的非易失性日志文件然后几乎无限地重复相同的printk实例也不是一个好主意，会浪费磁盘空间，或者更糟糕的是，闪存空间。例如，想象一下在中断处理程序代码路径中有一个大的printk。如果硬件中断以每秒100次的频率被调用，也就是每秒100次！
- en: 'To mitigate these issues, the kernel provides an interesting alternative: the *rate-limited *printk*.*
    The `printk_ratelimited()` macro has identical syntax to the regular printk; the
    key point is that it effectively *suppresses* regular prints when certain conditions
    are fulfilled. The kernel provides two control files named `printk_ratelimit`
    and `printk_ratelimit_burst` via the `proc` filesystem for this purpose. Here,
    we directly reproduce the `sysctl` documentation (from [https://www.kernel.org/doc/Documentation/sysctl/kernel.txt](https://www.kernel.org/doc/Documentation/sysctl/kernel.txt))
    that explains the precise meaning of these two (pseudo) files:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些问题，内核提供了一个有趣的替代方案：*速率限制*printk*。printk_ratelimited()宏的语法与常规printk相同；关键点是当满足某些条件时，它会有效地抑制常规打印。内核通过proc文件系统提供了两个控制文件，名为printk_ratelimit和printk_ratelimit_burst，用于此目的。在这里，我们直接复制了sysctl文档（来自https://www.kernel.org/doc/Documentation/sysctl/kernel.txt），该文档解释了这两个（伪）文件的确切含义：
- en: '[PRE50]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On our Ubuntu 18.04.3 LTS guest system, we find that their (default) values
    are as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Ubuntu 18.04.3 LTS客户系统上，我们发现它们（默认）的值如下：
- en: '[PRE51]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This implies that by default, up to 10 instances of the same message occurring
    within a 5-second time interval can make it through before rate limiting kicks
    in.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着默认情况下，在5秒的时间间隔内发生的相同消息最多可以通过10个实例，然后速率限制才会生效。
- en: The printk rate limiter, when it does suppress kernel `printk` instances, emits
    a helpful message mentioning exactly how many earlier printk callbacks were suppressed.
    As an example, we have a custom kernel module that makes use of the `Kprobes`framework
    to emit a `printk` instance prior to every call to `schedule()`, the kernel's
    core scheduling routine.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当printk速率限制器抑制内核printk实例时，会发出一条有用的消息，其中提到确切抑制了多少早期的printk回调。例如，我们有一个自定义内核模块，它利用Kprobes框架在每次调用schedule()之前发出一个printk实例，这是内核的核心调度例程。
- en: A **kprobe** is essentially an instrumentation framework often leveraged for
    production system troubleshooting; using it, you can specify a function that can
    be set to execute before or after a given kernel routine. The details are beyond
    the scope of this book.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Kprobe本质上是一个用于生产系统故障排除的仪器框架；使用它，您可以指定一个函数，该函数可以在给定内核例程之前或之后执行。细节超出了本书的范围。
- en: 'Now, as scheduling occurs often, a regular printk would cause the kernel log
    buffer to quickly overflow. Precisely this sort of situation warrants the use
    of the rate-limited printk. Here, we see some sample output from our example kernel
    module (we don''t show it''s code here) using the `printk_ratelimited()` API via
    a `kprobe` that sets up a *pre-handler* function called `handle_pre_schedule()`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于调度经常发生，常规的printk会导致内核日志缓冲区迅速溢出。正是这种情况需要使用速率限制的printk。在这里，我们看到了我们示例内核模块的一些示例输出（我们这里不显示它的代码），它使用了printk_ratelimited()
    API通过设置一个称为handle_pre_schedule()的*预处理程序*函数的kprobe来设置一个printk实例：
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A code-level example of using the rate-limited printk is seen in the interrupt
    handler code of the Linux kernel''s **Real-Time Clock** (**RTC**) driver here:
    `drivers/char/rtc.c`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核的实时时钟（RTC）驱动程序的中断处理程序代码中，可以看到使用速率限制printk的代码级示例，位置在drivers/char/rtc.c中：
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Don't mix up the `printk_ratelimited()` macro with the older (and now deprecated) `printk_ratelimit()` macro.
    Also, the actual rate-limiting code is in `lib/ratelimit.c:___ratelimit()`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆printk_ratelimited()宏和旧的（现在已弃用的）printk_ratelimit()宏。此外，实际的速率限制代码在lib/ratelimit.c:___ratelimit()中。
- en: 'Also, just as with the `pr_<foo>` macros we saw earlier, the kernel also provides
    the equivalent `pr_<foo>_ratelimited` macros for generating a kernel printk at
    log level `<foo>` with rate limiting enabled. Here''s a quick list of them:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像我们之前看到的pr_<foo>宏一样，内核还提供了相应的pr_<foo>_ratelimited宏，用于在启用速率限制时以日志级别<foo>生成内核printk。以下是它们的快速列表：
- en: '[PRE54]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Can we generate kernel-level messages from user space? Sounds interesting; that's
    our next sub-topic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否从用户空间生成内核级消息？听起来很有趣；这是我们的下一个子主题。
- en: Generating kernel messages from the user space
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户空间生成内核消息
- en: A popular debug technique that we programmers use is to sprinkle prints at various
    points in the code, often allowing us to narrow down the source of an issue. This
    is indeed a useful debugging technique and is called **instrumenting** the code.
    Kernel developers often use the venerable printk API for just this purpose.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序员经常使用的一种流行的调试技术是在代码的各个地方添加打印，这经常可以帮助我们缩小问题的来源。这确实是一种有用的调试技术，称为**instrumenting**代码。内核开发人员经常使用值得尊敬的printk
    API来实现这一目的。
- en: 'So, imagine you have written a kernel module and are in the process of debugging
    it (by adding several printk''s). Your kernel code now emits several printk instances,
    which, of course, you can see at runtime via `dmesg` or some other means. That''s
    fine, but what if, especially because you''re running some automated user space
    test script, you''d like to see the point at which the script initiated some action
    within our kernel module, by printing out a certain message. As a concrete example,
    say we want the log to look something like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想象一下，您已经编写了一个内核模块，并且正在调试它（通过添加几个printk）。您的内核代码现在发出了几个printk实例，当然，您可以在运行时通过`dmesg`或其他方式看到。这很好，但是，特别是因为您正在运行一些自动化的用户空间测试脚本，您可能希望通过打印某个特定消息来查看脚本在我们的内核模块中启动某个动作的位置。作为一个具体的例子，假设我们希望日志看起来像这样：
- en: '[PRE55]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can have our user space test script write a message into the kernel log
    buffer, just like a kernel printk would, by writing said message into the special
    `/dev/kmsg` device file:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户空间测试脚本可以像内核的printk一样，将消息写入内核日志缓冲区，通过写入特殊的`/dev/kmsg`设备文件：
- en: '[PRE56]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Well, hang on – doing so requires running with root access, of course. However,
    notice here that a simple `sudo(8)` before `echo` just doesn''t work:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，等一下 - 这样做当然需要以root访问权限运行。但是，请注意，这里简单的在`echo`之前加上`sudo(8)`是行不通的：
- en: '[PRE57]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The syntax used in the second attempt works, but it's just simpler to get yourself
    a root shell and carry out tasks such as this.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次尝试中使用的语法是有效的，但是更简单的方法是获取一个root shell并执行此类任务。
- en: 'One more thing: the `dmesg(1)` utility has several options designed to make
    the output more human-readable; we show some of them via our sample alias to `dmesg` here,
    after which we use it:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：`dmesg(1)`实用程序有几个选项，旨在使输出更易读；我们通过我们的`dmesg`的示例别名显示了其中一些选项，之后我们使用它。
- en: '[PRE58]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The message written to the kernel log via the special `/dev/kmsg` device file will
    be *printed* at the current default log level, typically, `4 : KERN_WARNING`.
    We can override this by actually prefixing the message with the required log level
    (as a number in string format). For example, to write from the user space into
    the kernel log at log level `6 : KERN_INFO`, use this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '通过特殊的`/dev/kmsg`设备文件写入内核日志的消息将以当前默认的日志级别打印，通常是`4 : KERN_WARNING`。我们可以通过实际在消息前加上所需的日志级别（作为字符串格式的数字）来覆盖这一点。例如，要在用户空间中以日志级别`6
    : KERN_INFO`写入内核日志，使用以下命令：'
- en: '[PRE59]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can see that our latter message is emitted at log level `6`, as specified
    within `echo`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们后来的消息是以日志级别`6`发出的，就像`echo`中指定的那样。
- en: There is really no way to distinguish between a user-generated kernel message
    and a kernel `printk()`*-*generated one; they look identical. So, of course, it
    could be as simple as inserting some special signature byte or string within the
    message, such as `@user@`, in order to help you distinguish these user-generated
    prints from the kernel ones.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 用户生成的内核消息和内核`printk()`生成的消息之间实际上没有办法区分；它们看起来是一样的。因此，当然，可以简单地在消息中插入一些特殊的签名字节或字符串，例如`@user@`，以帮助您区分这些用户生成的打印消息和内核消息。
- en: Standardizing printk output via the pr_fmt macro
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过pr_fmt宏标准化printk输出
- en: 'A last but important point regarding the kernel printk; pretty often, to give
    context to your `printk()` output (*where exactly did it occur?*), you might write
    the code like this, taking advantage of various gcc macros (like `__FILE__`, `__func__`,
    and `__LINE__`):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内核printk的最后一个但重要的一点；经常，为了给您的`printk()`输出提供上下文（*它到底发生在哪里？*），您可能会像这样编写代码，利用各种gcc宏（如`__FILE__`、`__func__`和`__LINE__`）。
- en: '[PRE60]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is fine; the problem is, if there are a lot of printk's in your project,
    it can be fairly painful to guarantee a standard printk format (for example, first
    displaying the module name followed by the function name and possibly the line
    number, as seen here) is always followed by everyone working on the project.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好；问题是，如果您的项目中有很多printk，要保证标准的printk格式（例如，首先显示模块名称，然后是函数名称，可能还有行号，就像这里看到的那样）总是由项目中的每个人遵循，这可能会相当痛苦。
- en: 'Enter the `pr_fmt` macro; defining this macro right at the beginning of your
    code (it must be even before the first `#include`), guarantees that every single
    subsequent printk in your code *will be prefixed with the format specified by
    this macro*. Lets take an example (we show a snippet of code from the next chapter;
    worry not, it''s really very simple, and serves as a template for your future
    kernel modules):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`pr_fmt`宏；在代码的开头定义这个宏（必须在第一个`#include`之前），可以保证代码中每个后续的printk都将以这个宏指定的格式为前缀。让我们举个例子（我们展示了下一章的代码片段；不用担心，它真的非常简单，可以作为您未来内核模块的模板）。
- en: '[PRE61]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `pr_fmt()` macro is highlighted in bold font; it uses the pre-defined `KBUILD_MODNAME`
    macro to substitute the name of your kernel module, and the gcc `__func__` specifier
    to display the name of the function we''re currently running! (You can even add
    a `%d` matched by the corresponding `__LINE__` macro to display the line number).
    So, bottom line: the `pr_info()` we emit in the `init` function of this LKM will
    display like this in the kernel log:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`pr_fmt()`宏以粗体字突出显示；它使用预定义的`KBUILD_MODNAME`宏来替换您的内核模块的名称，并使用gcc的`__func__`指定符来显示我们当前运行的函数的名称！（您甚至可以添加一个`%d`，与相应的`__LINE__`宏匹配，以显示行号）。因此，最重要的是：我们在这个LKM的`init`函数中发出的`pr_info()`将在内核日志中显示如下：'
- en: '[PRE62]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice how the LKM name and the function name are automatically prefixed. This
    is very useful and indeed very common; in the kernel, literally hundreds of source
    files begin with the `pr_fmt()`. (A quick search on the 5.4 kernel code base revealed
    over 2,000 instances of this macro in the code base! We too shall follow this
    convention, though not in all our demo kernel modules).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意LKM名称和函数名称是自动添加前缀的。这非常有用，而且非常常见；在内核中，成百上千的源文件以`pr_fmt()`开头。(在5.4内核代码库中快速搜索发现代码库中有超过2000个此宏的实例！我们也将遵循这个惯例，尽管并非所有的演示内核模块都是如此)。
- en: The `pr_fmt()` also takes effect on the recommended printk usage for driver
    authors - via the `dev_<foo>()` functions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`pr_fmt()`也影响了驱动程序作者推荐的printk使用方式 - 通过`dev_<foo>()`函数。'
- en: Portability and the printk format specifiers
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性和printk格式说明符
- en: There's a question to ponder regarding the versatile printk kernel API, how
    will you ensure that your printk output looks correct (is correctly formatted)
    and works equally well on any CPU regardless of bit width? The portability issue
    raises its head here; the good news is that getting familiar with the various
    format specifiers provided will help you a great deal in this regard, in effect
    allowing you to write arch-independent printks.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 关于多功能的printk内核API，有一个问题需要考虑，那就是如何确保你的printk输出在任何CPU上看起来正确（格式正确）并且同样适用，无论位宽如何？这里涉及到可移植性问题；好消息是，熟悉提供的各种格式说明符将在这方面帮助你很多，实际上可以让你编写与体系结构无关的printk。
- en: It's important to realize that the `size_t` - pronounced *size type* - is a `typedef` for
    an unsigned integer; similarly, `ssize_t` (*signed size type*) is a `typedef` for
    a signed integer.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到`size_t` - 发音为*size type* - 是无符号整数的`typedef`；同样，`ssize_t`（*signed size
    type*）是有符号整数的`typedef`。
- en: 'Here''s a few top-of-mind common printk format specifiers to keep in mind when
    writing portable code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的`printk`格式说明符，当编写可移植代码时要记住：
- en: 'For `size_t`, `ssize_t` (signed and unsigned) integers : use `%zd` and `%zu` respectively'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`size_t`，`ssize_t`（有符号和无符号）整数：分别使用`%zd`和`%zu`
- en: 'Kernel pointers: use `%pK` for security (hashed values), `%px` for actual pointers
    (don''t use this in production!), additionally, use `%pa` for physical addresses
    (must pass it by reference)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核指针：使用`%pK`进行安全处理（散列值），使用`%px`表示实际指针（在生产中不要使用！），另外，使用`%pa`表示物理地址（必须通过引用传递）
- en: Raw buffer as a string of hex characters : `%*ph` (where `*`  is replaced by
    the number of characters; use for buffers within 64 characters, use the `print_hex_dump_bytes()` routine
    for more); variations are available (see the kernel doc, link follows)
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始缓冲区作为十六进制字符的字符串：`%*ph`（其中`*`被字符的数量替换；用于64个字符以内的缓冲区，使用`print_hex_dump_bytes()`例程进行更多操作）；还有其他变体（请参阅内核文档，链接如下）
- en: IPv4 addresses with `%pI4`, IPv6 addresses with `%pI6` (variations too)
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`%pI4`表示IPv4地址，使用`%pI6`表示IPv6地址（也有变体）
- en: 'An exhaustive list of printk format specifiers, which to use when (with examples)
    is part of the official kernel documentation here: [https://www.kernel.org/doc/Documentation/printk-formats.txt](https://www.kernel.org/doc/Documentation/printk-formats.txt).
    The kernel also explicitly documents the fact that using the unadorned `%p` in
    a `printk()` statement can lead to security issues (link: [https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier](https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier)).
    I urge you to browse through it!'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: printk格式说明符的详尽列表，以及何时使用（附有示例）是官方内核文档的一部分：[https://www.kernel.org/doc/Documentation/printk-formats.txt](https://www.kernel.org/doc/Documentation/printk-formats.txt)。内核还明确记录了在`printk()`语句中使用未装饰的`%p`可能会导致安全问题（链接：[https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier](https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier)）。我建议你浏览一下！
- en: Okay! Let's move towards completing this chapter by learning the basics of how
    the Makefile for your kernel module builds the kernel.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！让我们通过学习内核模块的Makefile如何构建内核来完成本章的内容。
- en: Understanding the basics of a kernel module Makefile
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内核模块Makefile的基础知识。
- en: You will have noticed that we tend to follow a *one-kernel-module-per-directory*
    rule of sorts. Yes, that definitely helps keep things organized. So, let's take
    our second kernel module, the `ch4/printk_loglvl`one. To build it, we just `cd`
    to its folder, type `make`, and (fingers crossed!) voilà, it's done. We have the `printk_loglevel.ko`kernel
    module object freshly generated (which we can then `insmod(8)/rmmod(8)`). But
    how exactly did it get built when we typed `make`? Ah, explaining this is the
    purpose of this section.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们倾向于遵循一种*每个目录一个内核模块*的规则。是的，这确实有助于保持事情井然有序。因此，让我们来看看我们的第二个内核模块，`ch4/printk_loglvl`。要构建它，我们只需`cd`到它的文件夹，输入`make`，然后（祈祷！）完成。我们有了`printk_loglevel.ko`内核模块对象（然后我们可以使用`insmod(8)/rmmod(8)`）。但是当我们输入`make`时，它究竟是如何构建的呢？啊，解释这一点正是本节的目的。
- en: As this is our very first chapter that deals with the LKM framework and its
    corresponding Makefile, we will keep things nice and simple, especially with regard
    to the Makefile here. However, early in the following chapter, we shall introduce
    a more sophisticated, simply *better*Makefile (that is still quite simple to understand).
    We shall then use this better Makefile in all subsequent code; do look out for
    it and use it!
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们处理LKM框架及其相应Makefile的第一章，我们将保持事情简单，特别是在这里的Makefile方面。然而，在接下来的章节中，我们将介绍一个更复杂、更简单*更好*的Makefile（仍然很容易理解）。然后我们将在所有后续的代码中使用这个更好的Makefile；请留意并使用它！
- en: 'As you will know, the `make` command will by default look for a file named
    `Makefile` in the current directory; if it exists, it will parse it and execute
    command sequences as specified within it. Here''s our Makefile for the kernel
    module `printk_loglevel` project:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`make`命令默认会在当前目录中查找名为`Makefile`的文件；如果存在，它将解析并执行其中指定的命令序列。这是我们的内核模块`printk_loglevel`项目的`Makefile`：
- en: '[PRE63]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It should go without saying that the Unix Makefile syntax basically demands
    this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的`Makefile`语法基本上要求这样做：
- en: '[PRE64]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `rule(s)` instances are always prefixed with a `[Tab]` character, *not* white
    space.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`rule(s)`实例总是以`[Tab]`字符为前缀，而不是空格。'
- en: 'Let''s gather the basics regarding how this Makefile works. First off, a key
    point is this: the kernel''s `Kbuild` system (which we''ve been mentioning and
    using since [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*), primarily uses two variable strings
    of software to build, chained up within the two `obj-y` and `obj-m` variables.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下这个Makefile的基本工作原理。首先，一个关键点是：内核的`Kbuild`系统（我们自[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)以来一直在提及和使用，*从源代码构建5.x
    Linux内核-第1部分*），主要使用两个软件变量字符串进行构建，这两个变量字符串在两个`obj-y`和`obj-m`变量中链接起来。
- en: 'The `obj-y` string has the concatenated list of all objects to build and merge
    into the final kernel image files - the uncompressed `vmlinux`and the compressed
    (boot-able) `[b]zImage`images. Think about it – it makes sense: the `y` in `obj-y` stands
    for *Yes.* All kernel built-ins and `Kconfig` options that were set to `Y` during
    the kernel configuration process (or are `Y` by default) are chained together
    via this item, built, and ultimately woven into the final kernel image files by
    the `Kbuild` build system.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj-y`字符串包含要构建并*合并*到最终内核镜像文件中的所有对象的连接列表-未压缩的`vmlinux`和压缩（可引导）`[b]zImage`镜像。想一想-这是有道理的：`obj-y`中的`y`代表*Yes*。所有内核内置和`Kconfig`选项在内核配置过程中设置为`Y`（或默认为`Y`）的都通过此项链接在一起，构建，并最终通过`Kbuild`构建系统编织到最终的内核镜像文件中。'
- en: 'On the other hand, it''s now easy to see that the `obj-m` string is a concatenated
    list of all kernel objects to build *separately*, *as kernel modules*! This is
    precisely why our Makefile has this all-important line:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，现在很容易看到`obj-m`字符串是所有内核对象的连接列表，要*分别*构建为*内核模块*！这正是为什么我们的Makefile有这一重要行：
- en: '[PRE65]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In effect, it tells the `Kbuild` system to include our code; more correctly,
    it tells it to implicitly compile the `printk_loglvl.c` source code into the `printk_loglvl.o`binary
    object, and then add this object to the `obj-m` list. Next, the default rule for
    `make` being the `all` rule, it is processed:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它告诉`Kbuild`系统包括我们的代码；更正确地说，它告诉它隐式地将`printk_loglvl.c`源代码编译成`printk_loglvl.o`二进制对象，然后将此对象添加到`obj-m`列表中。接下来，由于`make`的默认规则是`all`规则，它被处理：
- en: '[PRE66]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The processing of this single statement is quite involved; here''s what transpires:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一语句的处理非常复杂；以下是发生的事情：
- en: The `-C` option switch to `make` has the `make` process *change directory* (via
    the `chdir(2)` system call) to the directory name that follows `-C`. Thus, it
    changes directory to the kernel `build` folder (which, as we covered earlier,
    is the location of the 'limited' kernel source tree that got installed via the
    `kernel-headers` package).
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-C`选项开关到`make`使`make`进程*更改目录*（通过`chdir(2)`系统调用）到跟在`-C`后面的目录名。因此，它会更改到内核`build`文件夹（正如我们之前介绍的，这是通过`kernel-headers`包安装的`有限`内核源树的位置）。'
- en: Once there, it *parses in* the content of the *kernel's top-level* Makefile –
    that is, the Makefile that resides there, in the root of this limited kernel source
    tree. This is a key point. This way, it's guaranteed that all kernel modules are
    tightly coupled to the kernel that they are being built against (more on this
    a bit later). This also guarantees that kernel modules are built with the exact
    same set of rules, that is, the compiler/linker configurations (the `CFLAGS` options,
    the compiler option switches, and so on), as the kernel image itself is. All this
    is required for binary compatibility.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到达那里，它就会*解析*内核*顶层*Makefile的内容-也就是说，位于这个有限内核源树根目录中的Makefile。这是一个关键点。这样可以保证所有内核模块与它们正在构建的内核紧密耦合（稍后会详细介绍）。这也保证了内核模块使用与内核镜像本身完全相同的一组规则构建，即编译器/链接器配置（`CFLAGS`选项，编译器选项开关等）。所有这些都是二进制兼容性所必需的。
- en: Next, you can see the initialization of the variable named `M`, and that the target specified
    is `modules`; hence, the `make` process now changes directory to that specified
    by the `M` variable, which you can see is set to `$(PWD)` – the very folder we
    started from (the present working directory; the `PWD := $(shell pwd)` in the
    Makefile initializes it to the correct value)!
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以看到变量`M`的初始化，指定的目标是`modules`；因此，`make`进程现在更改到由`M`变量指定的目录，您可以看到它设置为`$(PWD)`
    - 我们开始的文件夹（当前工作目录；Makefile中的`PWD := $(shell pwd)`将其初始化为正确的值）！
- en: 'So, interestingly, it''s a recursive build: the build process, having (very
    importantly) parsed the kernel top-level Makefile, now switches back to the kernel
    module''s directory and builds the module(s) therein.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这是一个递归构建：构建过程，非常重要的是，解析了内核顶层Makefile后，现在切换回内核模块的目录并构建其中的模块。
- en: 'Did you notice that when a kernel module is built, a fair number of intermediate
    working files are generated as well? Among them are `modules.order`, `<file>.mod.c`,
    `<file>.o`, `Module.symvers`,  `<file>.mod.o`,  `.<file>.o.cmd`, `.<file>.ko.cmd`,
    a folder called `.tmp_versions/`, and, of course, the kernel module binary object
    itself, `<file>.ko` – the whole point of the build exercise. Getting rid of all
    these objects, including the kernel module object itself, is easy: just perform
    `make clean`. The `clean` rule cleans it all up. (We shall delve into the `install` target
    in the following chapter.)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到，构建内核模块时，还会生成相当多的中间工作文件？其中包括`modules.order`、`<file>.mod.c`、`<file>.o`、`Module.symvers`、`<file>.mod.o`、`.<file>.o.cmd`、`.<file>.ko.cmd`、一个名为`.tmp_versions/`的文件夹，当然还有内核模块二进制对象本身，`<file>.ko`-整个构建过程的重点。摆脱所有这些对象，包括内核模块对象本身，很容易：只需执行`make
    clean`。`clean`规则会将所有这些清理干净。（我们将在下一章中深入探讨`install`目标。）
- en: 'You can look up what the `modules.order` and `modules.builtin` files (and other
    files) are meant for within the kernel documentation here: `Documentation/kbuild/kbuild.rst`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查找`modules.order`和`modules.builtin`文件（以及其他文件）的用途：`Documentation/kbuild/kbuild.rst`。
- en: Also as mentioned previously, we shall, in the following chapter, introduce
    and use a more sophisticated Makefile variant - **a 'better' Makefile**; it is
    designed to help you, the kernel module/driver developer, improve code quality
    by running targets related to kernel coding style checks, static analysis, simple
    packaging, and (a dummy target) for dynamic analysis.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如之前提到的，我们将在接下来的章节中介绍并使用一个更复杂的Makefile变体 - **一个更好的Makefile**；它旨在帮助您，内核模块/驱动程序开发人员，通过运行与内核编码风格检查、静态分析、简单打包以及（一个虚拟目标）相关的目标，提高代码质量。
- en: With that, we conclude this chapter. Well done – you are now well on your way
    to learning Linux kernel development!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们结束了。干得好 - 您现在已经在学习Linux内核开发的道路上取得了良好的进展！
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of Linux kernel architecture and the
    LKM framework. You learned what a kernel module is and why it's useful. We then
    wrote a simple yet complete kernel module, a very basic *Hello, world*. The material
    then delved further into how it works, along with how to load it, see the module
    listing, and unload it. Kernel logging with printk was covered in some detail,
    along with rate limiting printk, generating kernel messages from the user space,
    standardizing it's output format, and understanding the basics of the kernel module
    Makefile.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Linux内核架构和LKM框架的基础知识。您了解了什么是内核模块以及它的用途。然后，我们编写了一个简单但完整的内核模块，一个非常基本的*Hello,
    world*。然后，材料进一步深入探讨了它的工作原理，以及如何加载它，查看模块列表并卸载它。详细介绍了使用printk进行内核日志记录，以及限制printk的速率，从用户空间生成内核消息，标准化其输出格式，并了解内核模块Makefile的基础知识。
- en: That ends this chapter; I urge you to work on the sample code (via the book's
    GitHub repository), work on the *Questions*/assignments, and then proceed on to
    the next chapter, continuing our coverage of writing a Linux kernel module.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章；我敦促你去研究示例代码（通过本书的GitHub存储库），完成*问题*/作业，然后继续下一章，继续我们的Linux内核模块编写覆盖范围。
- en: Questions
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试对本章材料的了解：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。您会发现一些问题的答案在书的GitHub存储库中：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。
- en: Further reading
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a *Further reading* document in this book's GitHub repository. The *Further
    reading* document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您深入了解有用的材料，我们在本书的GitHub存储库中提供了一个相当详细的在线参考和链接列表（有时甚至包括书籍）的*进一步阅读*文档。*进一步阅读*文档在这里可用：[https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md)。
