["```\n#include <linux/videodev2.h>\n```", "```\nopen()\nint ioctl(int fd, VIDIOC_QUERYCAP, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_capability *argp)\nint ioctl(int fd, VIDIOC_S_FMT, struct v4l2_format *argp)\nint ioctl(int fd, VIDIOC_S_FMT, struct v4l2_format *argp)\n/* requesting N buffers */\nint ioctl(int fd, VIDIOC_REQBUFS, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct v4l2_requestbuffers *argp)\n/* queueing N buffers */\nint ioctl(int fd, VIDIOC_QBUF, struct v4l2_buffer *argp)\n/* start streaming */\nint ioctl(int fd, VIDIOC_STREAMON, const int *argp) \nread_loop: (for i=0; I < N; i++)\n\u00a0\u00a0\u00a0\u00a0/* Dequeue buffer i */\n\u00a0\u00a0\u00a0\u00a0int ioctl(int fd, VIDIOC_DQBUF, struct v4l2_buffer *argp)\n\u00a0\u00a0\u00a0\u00a0process_buffer(i)\n\u00a0\u00a0\u00a0\u00a0/* Requeue buffer i */\n\u00a0\u00a0\u00a0\u00a0int ioctl(int fd, VIDIOC_QBUF, struct v4l2_buffer *argp)\nend_loop\n\u00a0\u00a0\u00a0\u00a0releases_memories()\n\u00a0\u00a0\u00a0\u00a0close()\n```", "```\nstatic int xioctl(int fh, int request, void *arg)\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int r;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0do {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = ioctl(fh, request, arg);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} while (-1 == r && EINTR == errno);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return r;\n}\n```", "```\nstatic const char *dev_name = \"/dev/video0\";\nfd = open (dev_name, O_RDWR);\nif (fd == -1) {\n\u00a0\u00a0\u00a0\u00a0perror(\"Failed to open capture device\\n\");\n\u00a0\u00a0\u00a0\u00a0return -1;\n}\n```", "```\nclose (fd);\n```", "```\n/* Values for 'capabilities' field */\n#define V4L2_CAP_VIDEO_CAPTURE 0x00000001 /*video capture device*/ #define V4L2_CAP_VIDEO_OUTPUT 0x00000002\u00a0\u00a0/*video output device*/ #define V4L2_CAP_VIDEO_OVERLAY 0x00000004 /*Can do video overlay*/ [...] /* VBI device skipped */\n/* video capture device that supports multiplanar formats */#define V4L2_CAP_VIDEO_CAPTURE_MPLANE\t0x00001000\n/* video output device that supports multiplanar formats */ #define V4L2_CAP_VIDEO_OUTPUT_MPLANE\t0x00002000\n/* mem-to-mem device that supports multiplanar formats */#define V4L2_CAP_VIDEO_M2M_MPLANE\t0x00004000\n/* Is a video mem-to-mem device */#define V4L2_CAP_VIDEO_M2M\t0x00008000\n[...] /* radio, tunner and sdr devices skipped */\n#define V4L2_CAP_READWRITE\t0x01000000 /*read/write systemcalls */ #define V4L2_CAP_ASYNCIO\t0x02000000\t/* async I/O */\n#define V4L2_CAP_STREAMING\t0x04000000\t/* streaming I/O ioctls */ #define V4L2_CAP_TOUCH\t0x10000000\t/* Is a touch device */\n```", "```\n#include <linux/videodev2.h>\n[...]\nstruct v4l2_capability cap;\nmemset(&cap, 0, sizeof(cap));\nif (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {\n\u00a0\u00a0\u00a0\u00a0if (EINVAL == errno) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"%s is no V4L2 device\\n\", dev_name);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(EXIT_FAILURE);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit(\"VIDIOC_QUERYCAP\" \n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```\nif (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"%s is not a video capture device\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n\u00a0\u00a0\u00a0\u00a0exit(EXIT_FAILURE);\n}\nif (!(cap.capabilities & V4L2_CAP_READWRITE))\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"%s does not support read i/o\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n/* Check whether USERPTR and/or MMAP method are supported */\nif (!(cap.capabilities & V4L2_CAP_STREAMING))\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"%s does not support streaming i/o\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n/* Check whether driver support read/write i/o */\nif (!(cap.capabilities & V4L2_CAP_READWRITE))\n\u00a0\u00a0\u00a0\u00a0fprintf (stderr, \"%s does not support read i/o\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n```", "```\n#define CLEAR(x) memset(&(x), 0, sizeof(x))\n```", "```\nstruct v4l2_format {\n u32 type;\n union {\n\u00a0\u00a0struct v4l2_pix_format pix; /* V4L2_BUF_TYPE_VIDEO_CAPTURE */\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0struct v4l2_pix_format_mplane pix_mp; /* _CAPTURE_MPLANE */\n\u00a0\u00a0struct v4l2_window win;\t /* V4L2_BUF_TYPE_VIDEO_OVERLAY */\n\u00a0\u00a0struct v4l2_vbi_format vbi; /* V4L2_BUF_TYPE_VBI_CAPTURE */\n\u00a0\u00a0struct v4l2_sliced_vbi_format sliced;/*_SLICED_VBI_CAPTURE */ \n\u00a0\u00a0struct v4l2_sdr_format sdr;\u00a0\u00a0\u00a0/* V4L2_BUF_TYPE_SDR_CAPTURE */\n\u00a0\u00a0struct v4l2_meta_format meta;/* V4L2_BUF_TYPE_META_CAPTURE */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0} fmt;\n};\n```", "```\nstruct v4l2_format fmt;\nCLEAR(fmt);\n/* Get the current format */\nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nif (ioctl(fd, VIDIOC_G_FMT, &fmt)) {\n\u00a0\u00a0\u00a0\u00a0printf(\"Getting format failed\\n\");\n\u00a0\u00a0\u00a0\u00a0exit(2);\n}\n```", "```\n#define WIDTH\t1920\n#define HEIGHT\t1080\n#define PIXFMT\tV4L2_PIX_FMT_YUV420\n/* Changing required properties and set the format */ fmt.fmt.pix.width = WIDTH;\nfmt.fmt.pix.height = HEIGHT;\nfmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2u;\nfmt.fmt.pix.sizeimage = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height; \nfmt.fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\nfmt.fmt.pix.field = V4L2_FIELD_ANY;\nfmt.fmt.pix.pixelformat = PIXFMT;\nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nif (xioctl(fd, VIDIOC_S_FMT, &fmt)) {\n\u00a0\u00a0\u00a0\u00a0printf(\"Setting format failed\\n\");\n\u00a0\u00a0\u00a0\u00a0exit(2);\n}\n```", "```\nif (fmt.fmt.pix.pixelformat != PIXFMT)\n\u00a0\u00a0\u00a0printf(\"Driver didn't accept our format. Can't proceed.\\n\");\n/* because VIDIOC_S_FMT may change width and height */\nif ((fmt.fmt.pix.width != WIDTH) || \u00a0\u00a0\u00a0\u00a0(fmt.fmt.pix.height != HEIGHT))\u00a0\u00a0\u00a0\u00a0\u00a0\n fprintf(stderr, \"Warning: driver is sending image at %dx%d\\n\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fmt.fmt.pix.width, fmt.fmt.pix.height);\n```", "```\n#define FRAMERATE 30\nstruct v4l2_streamparm parm;\nint error;\nCLEAR(parm);\nparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n/* first query streaming parameters */\nerror = xioctl(fd, VIDIOC_G_PARM, &parm);\nif (!error) {\n\u00a0\u00a0\u00a0\u00a0/* Now determine if the FPS selection is supported */\n\u00a0\u00a0\u00a0\u00a0if (parm.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* yes we can */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CLEAR(parm);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.parm.capture.capturemode = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.parm.capture.timeperframe.numerator = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.parm.capture.timeperframe.denominator = FRAMERATE;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error = xioctl(fd, VIDIOC_S_PARM, &parm);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (error)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"Unable to set the FPS\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* once again, driver may have changed our requested \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* framerate */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (FRAMERATE != \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.parm.capture.timeperframe.denominator)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf (\"fps coerced ......: from %d to %d\\n\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FRAMERATE,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parm.parm.capture.timeperframe.denominator);\n```", "```\n#define BUF_COUNT 4\nstruct v4l2_requestbuffers req; CLEAR (req);\nreq.count\t= BUF_COUNT;\nreq.type\t= V4L2_BUF_TYPE_VIDEO_CAPTURE;\nreq.memory\t= V4L2_MEMORY_USERPTR;\nif (-1 == xioctl (fd, VIDIOC_REQBUFS, &req)) {\n\u00a0\u00a0\u00a0\u00a0if (EINVAL == errno)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"%s does not support user pointer i/o\\n\", \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(\"VIDIOC_REQBUFS failed \\n\");\n}\n```", "```\nstruct buffer_addr {\n\u00a0\u00a0\u00a0\u00a0void\u00a0\u00a0*start;\n\u00a0\u00a0\u00a0\u00a0size_t length;\n};\nstruct buffer_addr *buf_addr;\nint i;\nbuf_addr = calloc(BUF_COUNT, sizeof (*buffer_addr));\nif (!buf_addr) {\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"Out of memory\\n\");\n\u00a0\u00a0\u00a0\u00a0exit (EXIT_FAILURE);\n}\nfor (i = 0; i < BUF_COUNT; ++i) {\n\u00a0\u00a0\u00a0\u00a0buf_addr[i].length = buffer_size;\n\u00a0\u00a0\u00a0\u00a0buf_addr[i].start = malloc(buffer_size);\n\u00a0\u00a0\u00a0\u00a0if (!buf_addr[i].start) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"Out of memory\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(EXIT_FAILURE);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```\n#define BUF_COUNT_MIN 3\nstruct v4l2_requestbuffers req; CLEAR (req);\nreq.count\t= BUF_COUNT;\nreq.type\t= V4L2_BUF_TYPE_VIDEO_CAPTURE;\nreq.memory\t= V4L2_MEMORY_MMAP;\nif (-1 == xioctl (fd, VIDIOC_REQBUFS, &req)) {\n\u00a0\u00a0\u00a0\u00a0if (EINVAL == errno)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"%s does not support memory mapping\\n\", \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fprintf(\"VIDIOC_REQBUFS failed \\n\");\n}\n/* driver may have granted less than the number of buffers we\n * requested let's then make sure it is not less than the\n * minimum we can deal with\n */\nif (req.count < BUF_COUNT_MIN) {\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"Insufficient buffer memory on %s\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name);\n\u00a0\u00a0\u00a0\u00a0exit (EXIT_FAILURE);\n}\n```", "```\nstruct buffer_addr {\n\u00a0\u00a0\u00a0\u00a0void *start;\n\u00a0\u00a0\u00a0\u00a0size_t length;\n};\nstruct buffer_addr *buf_addr;\nbuf_addr = calloc(BUF_COUNT, sizeof (*buffer_addr));\nif (!buf_addr) {\n\u00a0\u00a0\u00a0\u00a0fprintf (stderr, \"Out of memory\\n\");\n\u00a0\u00a0\u00a0\u00a0exit (EXIT_FAILURE);\n}\nfor (i = 0; i < req.count; ++i) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer buf;\n\u00a0\u00a0\u00a0\u00a0CLEAR (buf);\n\u00a0\u00a0\u00a0\u00a0buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0buf.memory = V4L2_MEMORY_MMAP; buf.index\t= i;\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl (fd, VIDIOC_QUERYBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit(\"VIDIOC_QUERYBUF\");\n\u00a0\u00a0\u00a0\u00a0buf_addr[i].length = buf.length;\n\u00a0\u00a0\u00a0\u00a0buf_addr[i].start =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mmap (NULL /* start anywhere */, buf.length,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PROT_READ | PROT_WRITE /* required */,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MAP_SHARED /* recommended */, fd, buf.m.offset);\n\u00a0\u00a0\u00a0\u00a0if (MAP_FAILED == buf_addr[i].start)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit(\"mmap\");\n}\n```", "```\n/* V4L2 DMABuf export */\nstruct v4l2_requestbuffers req;\nCLEAR (req);\nreq.count = BUF_COUNT;\nreq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nreq.memory = V4L2_MEMORY_DMABUF;\nif (-1 == xioctl(fd, VIDIOC_REQBUFS, &req))\n\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_QUERYBUFS\");\n```", "```\nint outdev_dmabuf_fd[BUF_COUNT] = {-1};\nint i;\nfor (i = 0; i < req.count; i++) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_exportbuffer expbuf;\n\u00a0\u00a0\u00a0\u00a0CLEAR (expbuf);\n\u00a0\u00a0\u00a0\u00a0expbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\u00a0\u00a0\u00a0\u00a0expbuf.index = i;\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl(fd, VIDIOC_EXPBUF, &expbuf)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_EXPBUF\");\n\u00a0\u00a0\u00a0\u00a0outdev_dmabuf_fd[i] = expbuf.fd;\n}\n```", "```\nstruct buffer_addr {\n\u00a0\u00a0\u00a0\u00a0void *start;\n\u00a0\u00a0\u00a0\u00a0size_t length;\n};\nstruct buffer_addr *buf_addr;\nbuf_addr = calloc(1, sizeof(*buf_addr));\nif (!buf_addr) {\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"Out of memory\\n\");\n\u00a0\u00a0\u00a0\u00a0exit(EXIT_FAILURE);\n}\nbuf_addr[0].length = buffer_size;\nbuf_addr[0].start = malloc(buffer_size);\nif (!buf_addr[0].start) {\n\u00a0\u00a0\u00a0\u00a0fprintf(stderr, \"Out of memory\\n\");\n\u00a0\u00a0\u00a0\u00a0exit(EXIT_FAILURE);\n}\n```", "```\n/* Prime buffers */\nfor (i = 0; i < BUF_COUNT; ++i) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer buf;\n\u00a0\u00a0\u00a0\u00a0CLEAR(buf);\n\u00a0\u00a0\u00a0\u00a0buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0buf.memory = V4L2_MEMORY_USERPTR; buf.index = i;\n\u00a0\u00a0\u00a0\u00a0buf.m.userptr = (unsigned long)buf_addr[i].start;\n\u00a0\u00a0\u00a0\u00a0buf.length = buf_addr[i].length;\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit(\"VIDIOC_QBUF\");\n}\n```", "```\n/* Prime buffers */\nfor (i = 0; i < BUF_COUNT; ++i) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer buf; CLEAR (buf);\n\u00a0\u00a0\u00a0\u00a0buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0buf.memory = V4L2_MEMORY_MMAP;\n\u00a0\u00a0\u00a0\u00a0buf.index = i;\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl (fd, VIDIOC_QBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_QBUF\");\n}\n```", "```\n/* Prime buffers */\nfor (i = 0; i < BUF_COUNT; ++i) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer buf; CLEAR (buf);\n\u00a0\u00a0\u00a0\u00a0buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0buf.memory = V4L2_MEMORY_DMABUF; buf.index\t= i;\n\u00a0\u00a0\u00a0\u00a0buf.m.fd = outdev_dmabuf_fd[i];\n\u00a0\u00a0\u00a0\u00a0/* enqueue the dmabuf to capture device */\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl (fd, VIDIOC_QBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_QBUF\");\n}\n```", "```\n/* Start streaming */\nint ret;\nint a = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nret = xioctl(capt.fd, VIDIOC_STREAMON, &a);\nif (ret < 0) {\n\u00a0\u00a0\u00a0\u00a0perror(\"VIDIOC_STREAMON\\n\");\n\u00a0\u00a0\u00a0\u00a0return -1;\n}\n```", "```\nstruct v4l2_buffer buf;\nCLEAR (buf);\nbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nbuf.memory = V4L2_MEMORY_MMAP;\nif (-1 == xioctl (fd, VIDIOC_DQBUF, &buf)) {\n\u00a0\u00a0\u00a0\u00a0switch (errno) {\n\u00a0\u00a0\u00a0\u00a0case EAGAIN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0\u00a0\u00a0case EIO:\n\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_DQBUF\");\n\u00a0\u00a0\u00a0\u00a0}\n}\n/* make sure the returned index is coherent with the number\n * of buffers allocated  */\nassert (buf.index < BUF_COUNT);\n/* We use buf.index to point to the correct entry in our  * buf_addr  */ \nprocess_image(buf_addr[buf.index].start);\n/* Queue back this buffer again, after processing is done */\nif (-1 == xioctl (fd, VIDIOC_QBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_QBUF\");\n```", "```\n#define MAXLOOPCOUNT 200\n/* Start the loop of capture */\nfor (i = 0; i < MAXLOOPCOUNT; i++) {\n\u00a0\u00a0\u00a0\u00a0struct v4l2_buffer buf;\n\u00a0\u00a0\u00a0\u00a0CLEAR (buf);\n\u00a0\u00a0\u00a0\u00a0buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\u00a0\u00a0\u00a0\u00a0buf.memory = V4L2_MEMORY_MMAP;\n\u00a0\u00a0\u00a0\u00a0if (-1 == xioctl (fd, VIDIOC_DQBUF, &buf)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0/* Queue back this buffer again, after processing is done */\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nstruct v4l2_buffer buf; int i;\nCLEAR (buf);\nbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\nbuf.memory = V4L2_MEMORY_USERPTR;\n/* Dequeue a captured buffer */\nif (-1 == xioctl (fd, VIDIOC_DQBUF, &buf)) {\n\u00a0\u00a0\u00a0\u00a0switch (errno) {\n\u00a0\u00a0\u00a0\u00a0case EAGAIN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0\u00a0\u00a0case EIO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_DQBUF\");\n\u00a0\u00a0\u00a0\u00a0}\n}\n/*\n * We may need the index to which corresponds this buffer\n * in our buf_addr array. This is done by matching address\n * returned by the dequeue ioctl with the one stored in our\n * array  */\nfor (i = 0; i < BUF_COUNT; ++i)\n\u00a0\u00a0\u00a0\u00a0if (buf.m.userptr == (unsigned long)buf_addr[i].start &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0buf.length == buf_addr[i].length)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n/* the corresponding index is used for sanity checks only */ \nassert (i < BUF_COUNT);\nprocess_image ((void *)buf.m.userptr);\n/* requeue the buffer */\nif (-1 == xioctl (fd, VIDIOC_QBUF, &buf))\n\u00a0\u00a0\u00a0\u00a0errno_exit (\"VIDIOC_QBUF\");\n```", "```\nif (-1 == read (fd, buffers[0].start, buffers[0].length)) {\n\u00a0\u00a0\u00a0\u00a0switch (errno) {\n\u00a0\u00a0\u00a0\u00a0case EAGAIN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0\u00a0\u00a0case EIO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errno_exit (\"read\");\n\u00a0\u00a0\u00a0\u00a0}\n}\nprocess_image (buffers[0].start);\n```", "```\n# v4l2-ctl --list-devices\nIntegrated Camera: Integrated C (usb-0000:00:14.0-8):\n\t/dev/video0\n\t/dev/video1\n```", "```\n# v4l2-ctl -d /dev/video0 -D\nDriver Info (not using libv4l2):\n\tDriver name\u00a0\u00a0\u00a0: uvcvideo\n\tCard type\u00a0\u00a0\u00a0\u00a0\u00a0: Integrated Camera: Integrated C\n\tBus info\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: usb-0000:00:14.0-8\n\tDriver version: 5.4.60\n\tCapabilities\u00a0\u00a0: 0x84A00001\n\t\tVideo Capture\n\t\tMetadata Capture\n\t\tStreaming\n\t\tExtended Pix Format\n\t\tDevice Capabilities\n\tDevice Caps\u00a0\u00a0\u00a0: 0x04200001\n\t\tVideo Capture\n\t\tStreaming\n\t\tExtended Pix Format\n```", "```\n# v4l2-ctl -L\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0brightness 0x00980900 (int)\u00a0\u00a0: min=0 max=255 step=1 default=128 value=128\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contrast 0x00980901 (int)\u00a0\u00a0\u00a0\u00a0: min=0 max=255 step=1 default=32 value=32\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saturation 0x00980902 (int)\u00a0\u00a0: min=0 max=100 step=1 default=64 value=64\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hue 0x00980903 (int)\u00a0\u00a0\u00a0\u00a0: min=-180 max=180 step=1 default=0 value=0\n white_balance_temperature_auto 0x0098090c (bool)\u00a0\u00a0\u00a0: default=1 value=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gamma 0x00980910 (int)\u00a0\u00a0: min=90 max=150 step=1 default=120 value=120\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0power_line_frequency 0x00980918 (menu)\u00a0\u00a0\u00a0: min=0 max=2 default=1 value=1\n\t\t\t\t0: Disabled\n\t\t\t\t1: 50 Hz\n\t\t\t\t2: 60 Hz\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0white_balance_temperature 0x0098091a (int)\u00a0\u00a0: min=2800 max=6500 step=1 default=4600 value=4600 flags=inactive\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sharpness 0x0098091b (int)\u00a0\u00a0\u00a0\u00a0: min=0 max=7 step=1 default=3 value=3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0backlight_compensation 0x0098091c (int)\u00a0\u00a0\u00a0\u00a0: min=0 max=2 step=1 default=1 value=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exposure_auto 0x009a0901 (menu)\u00a0\u00a0\u00a0: min=0 max=3 default=3 value=3\n\t\t\t\t1: Manual Mode\n\t\t\t\t3: Aperture Priority Mode\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exposure_absolute 0x009a0902 (int)\u00a0\u00a0\u00a0\u00a0: min=5 max=1250 step=1 default=157 value=157 flags=inactive\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exposure_auto_priority 0x009a0903 (bool)\u00a0\u00a0\u00a0: default=0 value=1\njma@labcsmart:~$\n```", "```\n# v4l2-ctl --set-ctrl brightness=192\n```", "```\n# v4l2-ctl -L\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0brightness 0x00980900 (int)\u00a0\u00a0\u00a0\u00a0: min=0 max=255 step=1 default=128 value=192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n```", "```\n# v4l2-ctl --get-ctrl brightness \nbrightness: 192\n```", "```\n# v4l2-ctl --list-formats-ext\nioctl: VIDIOC_ENUM_FMT\n\tIndex\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: 0\n\tType\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Video Capture\n\tPixel Format: 'MJPG' (compressed)\n\tName\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Motion-JPEG\n\t\tSize: Discrete 1280x720\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 960x540\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 848x480\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 640x480\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 640x360\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 424x240\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 352x288\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 320x240\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 320x180\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\tIndex\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: 1\n\tType\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Video Capture\n\tPixel Format: 'YUYV'\n\tName\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: YUYV 4:2:2\n\t\tSize: Discrete 1280x720\n\t\t\tInterval: Discrete 0.100s (10.000 fps)\n\t\tSize: Discrete 960x540\n\t\t\tInterval: Discrete 0.067s (15.000 fps)\n\t\tSize: Discrete 848x480\n\t\t\tInterval: Discrete 0.050s (20.000 fps)\n\t\tSize: Discrete 640x480\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 640x360\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 424x240\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 352x288\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 320x240\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n\t\tSize: Discrete 320x180\n\t\t\tInterval: Discrete 0.033s (30.000 fps)\n```", "```\n# v4l2-ctl --set-parm=30\nFrame rate set to 30.000 fps\n#\n```", "```\n# v4l2-ctl --set-fmt-video=width=640,height=480,\u00a0\u00a0pixelformat=MJPG\n```", "```\n# v4l2-ctl --set-parm=<framerate numerator>\n```", "```\n# v4l2-ctl --set-fmt-video=width=320,height=240,\u00a0\u00a0pixelformat=MJPG \\\n\u00a0\u00a0\u00a0--stream-mmap --stream-count=1 --stream-to=grab-320x240.mjpg\n```", "```\n# v4l2-ctl --set-fmt-video=width=320,height=240,\u00a0\u00a0pixelformat=YUYV \\\n\u00a0\u00a0--stream-mmap --stream-count=1 --stream-to=grab-320x240-yuyv.raw\n```", "```\n# ffmpeg -f rawvideo -s 320x240 -pix_fmt yuyv422 \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-i grab-320x240-yuyv.raw grab-320x240.png\n```", "```\n# ls -hl grab-320x240.mjpg\n-rw-r--r-- 1 root root 8,0K oct.\u00a0\u00a021 20:26 grab-320x240.mjpg\n# ls -hl grab-320x240-yuyv.raw \n-rw-r--r-- 1 root root 150K oct.\u00a0\u00a021 20:26 grab-320x240-yuyv.raw\n```", "```\n# gst-typefind-1.0 grab-320x240.mjpg \ngrab-320x240.mjpg - image/jpeg, width=(int)320, height=(int)240, sof-marker=(int)0\n# gst-typefind-1.0 grab-320x240-yuyv.raw \ngrab-320x240-yuyv.raw - FAILED: Could not determine type of stream.\n```", "```\n# echo 0x3 > /sys/module/videobuf2_v4l2/parameters/debug\n# echo 0x3 > /sys/module/videobuf2_common/parameters/debug\n```", "```\n# dmesg\n[831707.512821] videobuf2_common: __setup_offsets: buffer 0, plane 0 offset 0x00000000\n[831707.512915] videobuf2_common: __setup_offsets: buffer 1, plane 0 offset 0x00097000\n[831707.513003] videobuf2_common: __setup_offsets: buffer 2, plane 0 offset 0x0012e000\n[831707.513118] videobuf2_common: __setup_offsets: buffer 3, plane 0 offset 0x001c5000\n[831707.513119] videobuf2_common: __vb2_queue_alloc: allocated 4 buffers, 1 plane(s) each\n[831707.513169] videobuf2_common: vb2_mmap: buffer 0, plane 0 successfully mapped\n[831707.513176] videobuf2_common: vb2_core_qbuf: qbuf of buffer 0 succeeded\n[831707.513205] videobuf2_common: vb2_mmap: buffer 1, plane 0 successfully mapped\n[831707.513208] videobuf2_common: vb2_core_qbuf: qbuf of buffer 1 succeeded\n[...]\n```", "```\n$ echo 0x3 > /sys/class/video4linux/video0/dev_debug\n```", "```\n$ dmesg\n[833211.742260] video0: VIDIOC_QUERYCAP: driver=uvcvideo, card=Integrated Camera: Integrated C, bus=usb-0000:00:14.0-8, version=0x0005043c, capabilities=0x84a00001, device_caps=0x04200001\n[833211.742275] video0: VIDIOC_QUERY_EXT_CTRL: id=0x980900, type=1, name=Brightness, min/max=0/255, step=1, default=128, flags=0x00000000, elem_size=4, elems=1, nr_of_dims=0, dims=0,0,0,0\n[...]\n[833211.742318] video0: VIDIOC_QUERY_EXT_CTRL: id=0x98090c, type=2, name=White Balance Temperature, Auto, min/max=0/1, step=1, default=1, flags=0x00000000, elem_size=4, elems=1, nr_of_dims=0, dims=0,0,0,0\n[833211.742365] video0: VIDIOC_QUERY_EXT_CTRL: id=0x98091c, type=1, name=Backlight Compensation, min/max=0/2, step=1, default=1, flags=0x00000000, elem_size=4, elems=1, nr_of_dims=0, dims=0,0,0,0\n[833211.742376] video0: VIDIOC_QUERY_EXT_CTRL: id=0x9a0901, type=3, name=Exposure, Auto, min/max=0/3, step=1, default=3, flags=0x00000000, elem_size=4, elems=1, nr_of_dims=0, dims=0,0,0,0\n[...]\n[833211.756641] videobuf2_common: vb2_mmap: buffer 1, plane 0 successfully mapped\n[833211.756646] videobuf2_common: vb2_core_qbuf: qbuf of buffer 1 succeeded\n[833211.756649] video0: VIDIOC_QUERYBUF: 00:00:00.00000000 index=2, type=vid-cap, request_fd=0, flags=0x00012000, field=any, sequence=0, memory=mmap, bytesused=0, offset/userptr=0x12e000, length=614989\n[833211.756657] timecode=00:00:00 type=0, flags=0x00000000, frames=0, userbits=0x00000000\n[833211.756698] videobuf2_common: vb2_mmap: buffer 2, plane 0 successfully mapped\n[833211.756704] videobuf2_common: vb2_core_qbuf: qbuf of buffer 2 succeeded\n[833211.756706] video0: VIDIOC_QUERYBUF: 00:00:00.00000000 index=3, type=vid-cap, request_fd=0, flags=0x00012000, field=any, sequence=0, memory=mmap, bytesused=0, offset/userptr=0x1c5000, length=614989\n[833211.756714] timecode=00:00:00 type=0, flags=0x00000000, frames=0, userbits=0x00000000\n[833211.756751] videobuf2_common: vb2_mmap: buffer 3, plane 0 successfully mapped\n[833211.756755] videobuf2_common: vb2_core_qbuf: qbuf of buffer 3 succeeded\n[833212.967229] videobuf2_common: vb2_core_streamon: successful\n[833212.967234] video0: VIDIOC_STREAMON: type=vid-cap\n```", "```\n# v4l2-compliance\nv4l2-compliance SHA\u00a0\u00a0\u00a0: not available\nDriver Info:\n\tDriver name\u00a0\u00a0\u00a0: uvcvideo\n\tCard type\u00a0\u00a0\u00a0\u00a0\u00a0: Integrated Camera: Integrated C\n\tBus info\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: usb-0000:00:14.0-8\n\tDriver version: 5.4.60\n\tCapabilities\u00a0\u00a0: 0x84A00001\n\t\tVideo Capture\n\t\tMetadata Capture\n\t\tStreaming\n\t\tExtended Pix Format\n\t\tDevice Capabilities\n\tDevice Caps\u00a0\u00a0\u00a0: 0x04200001\n\t\tVideo Capture\n\t\tStreaming\n\t\tExtended Pix Format\nCompliance test for device /dev/video0 (not using libv4l2):\nRequired ioctls:\n\ttest VIDIOC_QUERYCAP: OK\nAllow for multiple opens:\n\ttest second video open: OK\n\ttest VIDIOC_QUERYCAP: OK\n\ttest VIDIOC_G/S_PRIORITY: OK\n\ttest for unlimited opens: OK\nDebug ioctls:\n\ttest VIDIOC_DBG_G/S_REGISTER: OK (Not Supported)\n\ttest VIDIOC_LOG_STATUS: OK (Not Supported)\n[]\nOutput ioctls:\n\ttest VIDIOC_G/S_MODULATOR: OK (Not Supported)\n\ttest VIDIOC_G/S_FREQUENCY: OK (Not Supported)\n[...]\nTest input 0:\n\tControl ioctls:\n\t\tfail: v4l2-test-controls.cpp(214): missing control class for class 00980000\n\t\tfail: v4l2-test-controls.cpp(251): missing control class for class 009a0000\n\t\ttest VIDIOC_QUERY_EXT_CTRL/QUERYMENU: FAIL\n\t\ttest VIDIOC_QUERYCTRL: OK\n\t\tfail: v4l2-test-controls.cpp(437): s_ctrl returned an error (84)\n\t\ttest VIDIOC_G/S_CTRL: FAIL\n\t\tfail: v4l2-test-controls.cpp(675): s_ext_ctrls returned an error (\n```"]