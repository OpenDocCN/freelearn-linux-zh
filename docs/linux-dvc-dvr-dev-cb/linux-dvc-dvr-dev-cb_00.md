# 前言

内核设备驱动程序开发是复杂操作系统中最重要的部分之一，而 Linux 就是这样的操作系统。设备驱动程序对于在工业、家庭或医疗应用等真实环境中使用计算机的开发人员非常重要。事实上，即使 Linux 现在得到了广泛的支持，每天仍然会创建新的外围设备，这些设备需要驱动程序才能在 GNU/Linux 机器上得到有效使用。

本书将介绍实现完整字符驱动程序（通常称为*char driver*）的方法，通过介绍在内核和用户空间之间交换数据的所有必要技术，实现与外围设备中断的进程同步，访问 I/O 内存映射到（内部或外部）设备，并在内核中高效地管理时间。

本书中提供的所有代码都与 Linux 4.18+版本兼容（即最新的 5.x 内核）。这些代码可以在 Marvell ESPRESSObin 上进行测试，该设备具有内置的 ARM 64 位 CPU，但也可以在任何其他类似的 GNU/Linux 嵌入式设备上使用。通过这种方式，读者可以验证他们所读内容是否被正确理解。

# 本书的读者对象

如果您想了解如何在 Linux 机器上实现完整的字符驱动程序，或者想了解几种内核机制的工作原理（例如工作队列、完成和内核定时器等），以更好地理解通用驱动程序的工作原理，那么本书适合您。

如果您需要了解如何编写自定义内核模块以及如何向其传递参数，或者如何读取和更好地管理内核消息，甚至如何向内核源代码添加自定义代码，那么本书就是为您而写的。

如果您需要更好地理解设备树，如何修改它，甚至如何编写新的设备树以满足您的需求，并学习如何管理新的设备驱动程序，那么您也会从本书中受益。

# 本书涵盖内容

第一章，*安装开发系统*，介绍了如何在 Ubuntu 18.04.1 LTS 上安装完整的开发系统，以及基于 Marvell ESPRESSObin 板的完整测试系统。本章还将介绍如何使用串行控制台，如何从头开始重新编译内核，并教授一些进行交叉编译和软件仿真的技巧。

第二章，*内核深度剖析*，讨论了如何创建自定义内核模块，以及如何读取和管理内核消息。这些技能对于帮助开发人员理解内核内部发生的事情非常有用。

第三章，*使用字符驱动程序*，探讨了如何实现一个非常简单的字符驱动程序，以及如何在其与用户空间之间交换数据。本章最后提出了一些例子，以突出*一切皆文件*的抽象与设备驱动程序之间的关系。

第四章，*使用设备树*，介绍了设备树。读者将学习如何阅读和理解它，如何编写自定义设备树，然后如何编译它以获得可以传递给内核的二进制形式。本章以使用 Armada 3720、i.Mx 7Dual 和 SAMA5D3 CPU 为例，介绍了下载固件（在外围设备内）以及如何使用 Pin MUX 工具配置 CPU 引脚的部分。

第五章，*管理中断和并发*，介绍了如何在 Linux 内核中管理中断和并发。它展示了如何安装中断处理程序，如何推迟工作到以后的时间，以及如何管理内核定时器。在本章末尾，读者将学习如何等待事件（如等待某些数据被读取）以及如何保护他们的数据免受竞争条件的影响。

第六章，*杂项内核内部*，讨论如何在内核内部动态分配内存，以及如何使用几个有用的辅助函数来进行一些日常编程操作（如字符串操作、列表和哈希表操作）。本章还将介绍如何进行 I/O 内存访问，以及如何在内核内部安全地花费时间以创建明确定义的繁忙循环延迟。

第七章，*高级字符驱动程序操作*，介绍了字符驱动程序上所有可用的高级操作：`ioctl()`、`mmap()`、`lseek()`、`poll()`/`select()`系统调用的实现，以及通过`SIGIO`信号进行异步 I/O。

附录 A，*附加信息：使用字符驱动程序*，这包含了第三章的附加信息。

附录 B，*附加信息：使用设备树*，这包含了第四章的附加信息。

附录 C，*附加信息：管理中断和并发*，这包含了第五章的附加信息。

附录 D，*附加信息：杂项内核内部*，这包含了第六章的附加信息。

附录 E，*附加信息：高级字符驱动程序操作*，这包含了第七章的附加信息。

# 为了充分利用本书

+   您应该对非图形文本编辑器（如`vi`、`emacs`或`nano`）有一些了解。您不能直接连接 LCD 显示器、键盘和鼠标到嵌入式套件上进行对文本文件的小修改，因此您应该对这些工具有一定的了解，以便远程进行这些修改。

+   您应该知道如何管理 Ubuntu 系统，或者至少是一个通用的基于 GNU/Linux 的系统。我的主机 PC 运行在 Ubuntu 18.04.1 LTS 上，但您也可以使用更新的 Ubuntu LTS 版本，或者带有一些修改的基于 Debian 的系统。您也可以使用其他 GNU/Linux 发行版，但这将需要您付出一些努力，主要是关于安装交叉编译工具、库依赖和软件包管理。

本书不涵盖 Windows、macOS 等外部系统，因为您不应该使用低技术的系统来开发高技术系统的代码！

+   熟悉 C 编程语言、C 编译器的工作原理以及如何管理 makefile 都是强制性要求。

# 下载示例代码文件

您可以从您在[www.packt.com](http://www.packt.com)的账户中下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packt.com/support](http://www.packt.com/support)并注册，文件将直接通过电子邮件发送给您。

您可以按照以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)登录或注册。

1.  选择“支持”选项卡。

1.  单击“代码下载和勘误”。

1.  在搜索框中输入书名，然后按照屏幕上的说明操作。

下载文件后，请确保使用以下最新版本的解压缩或提取文件夹：

+   Windows 系统使用 WinRAR/7-Zip

+   Mac 系统使用 Zipeg/iZip/UnRarX

+   7-Zip/PeaZip for Linux

该书的代码包托管在 GitHub 上，网址为[`github.com/giometti/linux_device_driver_development_cookbook`](https://github.com/giometti/linux_device_driver_development_cookbook)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Linux-Device-Driver-Development-Cookbook`](https://github.com/PacktPublishing/Linux-Device-Driver-Development-Cookbook)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还有来自我们丰富的书籍和视频目录的其他代码包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

# 下载彩色图像

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图像。您可以在此处下载：[`www.packtpub.com/sites/default/files/downloads/9781838558802_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/9781838558802_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

文本文件夹名称、文件名、文件扩展名、路径名、虚拟 URL 和用户输入中的代码词显示如下："要获取前面的内核消息，我们可以使用`dmesg`和`tail -f /var/log/kern.log`命令。"

代码块设置如下：

```
#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("Hello World!\n");

    return 0;
}
```

您应该注意，本书中的大多数代码都采用 4 个空格缩进，而本书提供的文件中的示例代码使用 8 个空格缩进。因此，前面的代码将如下所示：

```
#include <stdio.h>

int main(int argc, char *argv[])
{
        printf("Hello World!\n");

        return 0;
}
```

显然，它们在实践中是完全等效的！

本书中使用的嵌入式套件的任何命令行输入或输出均按以下方式呈现：

```
# make CFLAGS="-Wall -O2" helloworld
cc -Wall -O2 helloworld.c -o helloworld
```

命令以粗体显示，而它们的输出以普通文本显示。您还应该注意，由于空间限制，提示字符串已被删除；实际上，在您的终端上，完整的提示应该如下所示：

```
root@espressobin:~# make CFLAGS="-Wall -O2" helloworld
cc -Wall -O2 helloworld.c -o helloworld
```

还要注意，由于书中的空间限制，您可能会遇到非常长的命令行，如下所示：

```
$ make CFLAGS="-Wall -O2" \
 CC=aarch64-linux-gnu-gcc \
 chrdev_test
aarch64-linux-gnu-gcc -Wall -O2 chrdev_test.c -o chrdev_test
```

否则，我不得不打破命令行。但是，在一些特殊情况下，您可能会发现以下格式的输出行（特别是内核消息）：

```
[ 526.318674] mem_alloc:mem_alloc_init: kmalloc(..., GFP_KERNEL) =ffff80007982f
000
[ 526.325210] mem_alloc:mem_alloc_init: kmalloc(..., GFP_ATOMIC) =ffff80007982f
000
```

不幸的是，这些行不能在印刷书籍中轻松重现，但您应该将它们视为单行。

在我的主机计算机上，作为非特权用户给出的任何命令行输入或输出均按以下方式编写：

```
$ tail -f /var/log/kern.log
```

当我需要以特权用户（root）的身份在我的主机计算机上给出命令时，命令行输入或输出将如下所示：

```
# insmod mem_alloc.ko
```

您应该注意，所有特权命令也可以由普通用户使用`sudo`命令以以下格式执行：

```
$ sudo <command>
```

因此，前面的命令可以由普通用户执行，如下所示：

```
$ sudo /insmod mem_alloc.ko
```

# 内核和日志消息

在几个 GNU/Linux 发行版上，内核消息通常具有以下形式：

```
[ 3.421397] mvneta d0030000.ethernet eth0: Using random mac address 3e:a1:6b:
f5:c3:2f
```

这是本书中的一行非常长的行，因此我们从每行的起始字符开始删除字符，直到真正的信息开始。因此，在上面的示例中，输出行将如下报告：

```
mvneta d0030000.ethernet eth0: Using random mac address 3e:a1:6b:f5:c3:2f
```

但是，正如前面所说，如果行仍然太长，它将被打破。

在终端中，长输出或重复或不太重要的行通过用三个点`...`替换来删除，如下所示：

```
output begin
output line 1
output line 2
...
output line 10
output end
```

当三个点位于行尾时，这意味着输出会继续，但出于空间原因，我决定将其截断。

# 文件修改

当您需要修改文本文件时，我将使用*统一上下文差异*格式，因为这是一种非常高效和紧凑的表示文本修改的方式。可以通过使用带有`-u`选项参数的`diff`命令或在`git`存储库中使用`git diff`命令来获得此格式。

作为一个简单的例子，让我们考虑`file1.old`中的以下文本：

```
This is first line
This is the second line
This is the third line
...
...
This is the last line
```

假设我们需要修改第三行，如下摘录所示：

```
This is first line
This is the second line
This is the new third line modified by me
...
...
This is the last line
```

您可以轻松理解，每次对文件进行简单修改都报告整个文件是不必要且占用空间；但是，通过使用*统一上下文差异*格式，前述修改可以写成如下形式：

```
$ diff -u file1.old file1.new
--- file1.old 2019-05-18 14:49:04.354377460 +0100
+++ file1.new 2019-05-18 14:51:57.450373836 +0100
@@ -1,6 +1,6 @@
 This is first line
 This is the second line
-This is the third line
+This is the new third line modified by me
 ...
 ...
 This is the last line
```

现在，修改非常清晰，并以紧凑的形式编写！它以两行标题开始，原始文件前面有`---`，新文件前面有`+++`。然后，它遵循一个或多个变更块，其中包含文件中的行差异。前面的示例只有一个块，其中未更改的行前面有一个空格字符，而要添加的行前面有一个`+`字符，要删除的行前面有一个`-`字符。

尽管出于空间原因，本书中大多数补丁的缩进都减少了，以适应印刷页面的宽度；但是，它们仍然是完全可读的。对于完整的补丁，您应该参考 GitHub 上提供的文件或 Packt 网站上的文件。

# 串行和网络连接

在本书中，我主要会使用两种不同类型的连接与嵌入式套件进行交互：串行控制台和 SSH 终端以及以太网连接。

串行控制台，通过 USB 连接实现，主要用于从命令行管理系统。它主要用于监视系统，特别是控制内核消息。

SSH 终端与串行控制台非常相似，即使不完全相同（例如，内核消息不会自动显示在终端上），但它可以像串行控制台一样用于从命令行给出命令和编辑文件。

在章节中，我将使用串行控制台上的终端或通过 SSH 连接来提供实现本书中所有原型所需的大部分命令和配置设置。

要从主机 PC 访问串行控制台，可以使用`minicon`命令，如下所示：

```
$ minicom -o -D /dev/ttyUSB0
```

但是，在第一章，*安装开发系统*中，这些方面都有解释，您不必担心。还要注意，在某些系统上，您可能需要 root 权限才能访问`/dev/ttyUSB0`设备。在这种情况下，您可以通过使用`sudo`命令或更好地通过使用以下命令将系统用户正确添加到正确的组来解决此问题：

```
$ sudo adduser $LOGNAME dialout
```

然后注销并重新登录，您应该能够无问题地访问串行设备。

要访问 SSH 终端，您可以使用以太网连接。它主要用于从主机 PC 或互联网下载文件，并且可以通过将以太网电缆连接到嵌入式套件的以太网端口，然后根据读者的 LAN 设置相应地配置端口来建立连接（请参阅第一章，*安装开发系统*中的所有说明）。

# 其他约定

**粗体**：表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词会以这种方式出现在文本中。例如："从管理面板中选择系统信息"。

警告或重要说明会以这种方式出现。

提示和技巧会以这种方式出现。

# 章节

在本书中，您会经常看到几个标题（*准备就绪*，*如何做*，*它是如何工作的*，*还有更多*，和*另请参阅*）。

为了清晰地说明如何完成一个配方，使用以下各节：

# 准备就绪

本节告诉您在配方中可以期待什么，并描述如何设置配方所需的任何软件或任何预备设置。

# 如何做...

本节包含完成配方所需的步骤。

# 它是如何工作的...

本节通常包括对前一节中发生的事情的详细解释。

# 还有更多…

本节包括有关食谱的额外信息，以使您对食谱更加了解。

# 另请参阅

本节提供有关食谱的其他有用信息的链接。

# 联系我们

我们的读者反馈总是受欢迎的。

**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并发送电子邮件至 `customercare@packtpub.com`。

**勘误**: 尽管我们已经尽一切努力确保内容的准确性，但错误确实会发生。如果您在本书中发现错误，我们将不胜感激您向我们报告。请访问 [www.packt.com/submit-errata](http://www.packt.com/submit-errata)，选择您的书，点击勘误提交表格链接，并输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何形式的非法副本，我们将不胜感激您向我们提供位置地址或网站名称。请通过 `copyright@packt.com` 与我们联系，并提供材料链接。

**如果您有兴趣成为作者**：如果您在某个专题上有专业知识，并且有兴趣撰写或为一本书做出贡献，请访问 [authors.packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下评论。阅读并使用本书后，为什么不在购买书籍的网站上留下评论呢？潜在的读者可以看到并使用您的客观意见来做出购买决定，我们在 Packt 可以了解您对我们产品的看法，我们的作者可以看到您对他们书籍的反馈。谢谢！

有关 Packt 的更多信息，请访问 [packt.com](http://www.packt.com/)。
